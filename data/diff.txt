44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,79 @@
+package depends.deptypes;
+
+import java.util.ArrayList;
+
+public class DependencyType {
+	
+    // struct->method
+    public static final String RELATION_RECEIVED_BY = "Received by";
+    public static final String RELATION_RECEIVE = "Receive";
+
+    //structType/aliasType->interface
+    public static final String RELATION_IMPLEMENT = "Implement";
+    public static final String RELATION_IMPLEMENTED_BY = "Implemented by";
+
+    //file->package
+    public static final String RELATION_IMPORT = "Import";
+
+    //function-function; function->method; method->function; method->method
+    public static final String RELATION_CALL = "Call";
+
+    //function/method->var
+    public static final String RELATION_PARAMETER = "Parameter";
+
+    //function/method->var
+    public static final String RELATION_RETURN = "Return";
+
+    //function/method->OperandVar
+    public static final String RELATION_SET = "Set";
+
+    //function/method->OperandVar
+    public static final String RELATION_USE = "Use";
+
+    //class->class in python
+    //struct-> struct , interface->interface in golang
+    public static final String RELATION_INHERIT = "Inherit";
+    
+	public static final String RELATION_DEFINE = "Define";
+
+    //struct1->struct2, interface1->interface2
+    //public static final String RELATION_INHERIT = "Embed";
+    //public static final String RELATION_INHERITED_BY = "Embeded by";
+
+	public static final ArrayList<String> resolveMask(String depMask) {
+        ArrayList<String> depedencyTypes = new ArrayList<String>();
+        for(int i = 0; i < depMask.toCharArray().length; i++) {
+            if(depMask.toCharArray()[i] == '1') {
+                if(i == 0) {
+                    depedencyTypes.add(RELATION_IMPORT);
+                }
+                else if (i == 1) {
+                    depedencyTypes.add(RELATION_INHERIT);
+                }
+                else if (i == 2) {
+                    depedencyTypes.add(RELATION_IMPLEMENT);
+                }
+                else if (i == 3) {
+                    depedencyTypes.add(RELATION_RECEIVE);
+                }
+                else if (i == 4) {
+                    depedencyTypes.add(RELATION_CALL);
+                }
+                else if (i == 5) {
+                    depedencyTypes.add(RELATION_SET);
+                }
+                else if (i == 6) {
+                    depedencyTypes.add(RELATION_USE);
+                }
+                else if (i == 7) {
+                    depedencyTypes.add(RELATION_PARAMETER);
+                }
+                else if (i == 8) {
+                    depedencyTypes.add(RELATION_RETURN);
+                }
+            }
+        }
+        return depedencyTypes;
+    }
+
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,114 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+
+import depends.entity.repo.EntityRepo;
+import depends.entity.types.VarEntity;
+
+public class Entity {
+    protected String fullName = "";
+	protected int id=-1;
+    protected int parentId=-1;
+    
+    public Entity(String fullName, int parentId, Integer id) {
+		this.setFullName(fullName);
+		this.setParentId(parentId);
+		this.setId(id);
+		vars = new ArrayList<>();
+	}
+
+	public void setFileId(int fileId) {
+	}
+
+	public String getFullName() {
+		return fullName;
+	}
+
+	public void setFullName(String fullName) {
+		this.fullName = fullName;
+	}
+
+
+    protected ArrayList<Integer> childrenIds = new ArrayList<>();
+    protected ArrayList<Relation> relations = new ArrayList<>();
+    protected ArrayList<VarEntity> vars;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public int getParentId() {
+        return parentId;
+    }
+
+    public void setParentId(int parentId) {
+        this.parentId = parentId;
+    }
+
+    public void addRelation(Relation relation) {
+        relations.add(relation);
+    }
+
+    public void addRelations(ArrayList<Relation> relations) {
+        this.relations.addAll(relations);
+    }
+
+    public ArrayList<Relation> getRelations() {
+        return relations;
+    }
+
+    public void addChildId(Integer id) {
+        childrenIds.add(id);
+    }
+
+    public void addChildrenIds(ArrayList<Integer> ids) {
+        childrenIds.addAll(ids);
+    }
+
+    public ArrayList<Integer> getChildrenIds() {
+        return childrenIds;
+    }
+
+    @Override
+    public String toString() {
+        String str = "";
+        str += "\n(";
+        str += ("name:" + fullName + ',');
+        str += ("id:" + id + ',');
+        str += ("parentId:" + parentId + ",");
+        str += ("childrenIds:" + childrenIds + ",");
+        str += ("relations:" + relations);
+        str += ")\n";
+        return str;
+    }
+
+	public Set<String> resolveBinding(EntityRepo registry) {
+		Set<String> unsolved = new HashSet<>();
+		for (Relation relation:this.relations) {
+			if (relation.getToId()<0) {
+				String fullName = relation.getToFullName();
+				Entity rhs = registry.getEntity(fullName);
+				if (rhs!=null) {
+					relation.refreshToId(rhs.getId());
+				}else {
+					unsolved.add(fullName);
+				}
+			}
+		}
+		return unsolved;
+	}
+
+	public void addVar(VarEntity var) {
+		this.vars.add(var);
+	}
+
+	public ArrayList<VarEntity> getVars() {
+		return this.vars;
+	}
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,32 @@
+package depends.entity;
+
+public class Relation {
+	private String type;
+	private Integer toId = -1;
+	private String toFullName;
+	public Relation(String type, String rhsFullName) {
+		this.type = type;
+		this.toFullName = rhsFullName;
+	}
+	public Relation(String type, Integer fileId) {
+		this.type = type;
+		this.toId = fileId;
+	}
+	public String getType() {
+		return type;
+	}
+	public Integer getToId() {
+		return toId;
+	}
+	public String getToFullName() {
+		return toFullName;
+	}
+	public void refreshToId(int rhs) {
+		this.toId  = rhs;
+	}
+	@Override
+	public String toString() {
+		return "Relation[" + type + "]-->" + toId + "(" + toFullName + ")";
+	}
+	
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,99 @@
+package depends.entity.repo;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.entity.Relation;
+import depends.entity.types.PackageEntity;
+
+public class EntityRepo {
+	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
+	public HashMap<Integer, Entity> allEntieisById = new HashMap<>();
+	private int nextAvaliableIndex;
+	
+	
+	public EntityRepo() {
+		nextAvaliableIndex = 0;
+	}
+	public Entity getEntity(String entityName) {
+		return allEntieisByName.get(entityName);
+	}
+	public Entity getEntity(Integer entityId) {
+		return allEntieisById.get(entityId);
+	}
+	
+	public void add(Entity entity) {
+		if (!entity.getFullName().isEmpty())
+			allEntieisByName.put(entity.getFullName(),entity);
+		allEntieisById.put(entity.getId(), entity);
+	}
+	
+	public void updateEntityNameIndex(String oldName, String newName, Entity entity) {
+		if (oldName.isEmpty()) {
+			allEntieisByName.put(newName, entity);
+			return;
+		}
+		if (entity==null) return;
+		allEntieisByName.remove(oldName);
+		allEntieisByName.put(newName, entity);
+	}
+	
+	public Collection<Entity> getEntities() {
+		return allEntieisById.values();
+	}
+	public Integer getCurrentIndex() {
+		return nextAvaliableIndex++;
+	}
+
+	public int getAncestorOfType(int entityId, @SuppressWarnings("rawtypes") Class classType) throws EntityNotExistsException, NoRequestedTypeOfAncestorExistsException {
+		Entity e = this.getEntity(entityId);
+		if (e==null) throw new EntityNotExistsException(entityId);
+		while (!e.getClass().equals(classType)) {
+			e = this.getEntity(e.getParentId());
+			if (e==null) break;
+		}
+		if (e==null) throw new NoRequestedTypeOfAncestorExistsException(entityId,classType);
+		return e.getId();
+	}
+	
+	public Set<String> resolveAllBindings() {
+    	HashSet<String> unsolved = new HashSet<>();
+        for (Entity entity:allEntieisByName.values()) {
+        	Set<String> u = entity.resolveBinding(this);
+			unsolved.addAll(u);
+        }
+		return unsolved;		
+
+	}
+
+	/**
+	 * note: import package.* means that it depends on all files of the package. it is not a suggested practices;
+	 * so we expends the import relations to all files under the package
+	 */
+	public void expendsPackageImports() {
+        for (Entity entity:allEntieisByName.values()) {
+        	ArrayList<Relation> expendedRelations = new ArrayList<>();
+        	for (Relation r:entity.getRelations()) {
+        		if (!r.getType().equals(DependencyType.RELATION_IMPORT))continue;
+        		if (r.getToId()<0) continue;
+        		if (!(this.getEntity(r.getToId()) instanceof PackageEntity)) continue;
+        		Entity pkg = this.getEntity(r.getToId());
+        		for (Integer fileId: pkg.getChildrenIds()) {
+        			expendedRelations.add(new Relation(DependencyType.RELATION_IMPORT,fileId));
+        		}
+        	}
+        	entity.addRelations(expendedRelations);
+        }
+	}
+	
+	public void addRelation(int theEntityId, String entityFullName, String relationType) {
+	        getEntity(theEntityId).addRelation(new Relation(relationType,entityFullName));
+	}
+
+
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,10 @@
+package depends.entity.types;
+
+import java.util.UUID;
+import depends.entity.Entity;
+
+public class AnonymousBlock extends Entity{
+    public AnonymousBlock( int parentId, Integer id) {
+    	super(UUID.randomUUID().toString(),  parentId, id);
+	}
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,21 @@
+package depends.entity.types;
+
+import java.util.HashMap;
+
+import depends.entity.Entity;
+
+public class FileEntity extends Entity{
+	HashMap<String,String> importedNames = new HashMap<>();
+	public FileEntity(String fullName, int fileId) {
+		super(fullName, -1,fileId);
+	}
+	public void addImport(String importedTypeOrPackage) {
+		String lastName = importedTypeOrPackage;
+        if (lastName.indexOf(".") > 0)
+        	lastName = lastName.substring(lastName.lastIndexOf(".")+1);
+        importedNames.put(lastName, importedTypeOrPackage);
+	}
+	public String getImport(String lastName) {
+		return importedNames.get(lastName);
+	}
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,9 @@
+package depends.entity.types;
+
+import depends.entity.Entity;
+
+public class FunctionEntity extends Entity{
+	public FunctionEntity(String fullName, int parentId, Integer id) {
+		super(fullName, parentId,id);
+	}
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,11 @@
+package depends.entity.types;
+
+import depends.entity.Entity;
+
+public class TypeEntity extends Entity{
+
+	public TypeEntity(String fullName,  int parentId, Integer id) {
+		super(fullName,parentId,id);
+	}
+ 
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,14 @@
+package depends.entity.types;
+
+import depends.entity.Entity;
+
+public class VarEntity extends Entity {
+
+	private String type;
+
+	public VarEntity(String fullName,  String type, int parentId, int id) {
+		super(fullName,  parentId,id);
+		this.type = type;
+	}
+    
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,124 @@
+package depends.extractor;
+
+import java.util.Stack;
+
+import depends.entity.Entity;
+import depends.entity.repo.EntityRepo;
+import depends.entity.types.FileEntity;
+import depends.entity.types.FunctionEntity;
+import depends.entity.types.PackageEntity;
+import depends.entity.types.TypeEntity;
+import depends.entity.types.VarEntity;
+
+public class HandlerContext{
+	private EntityRepo entityRepo;
+	private FileEntity currentFileEntity;
+	private String currentPackageName = "";
+	Stack<Entity> entityStack = new Stack<Entity>();
+	
+	public HandlerContext(EntityRepo entityRepo) {
+		this.entityRepo = entityRepo;
+	}
+	public FileEntity newFileEntity(String fileName) {
+		currentFileEntity = new FileEntity(fileName,entityRepo.getCurrentIndex());
+		return currentFileEntity;
+	}
+
+	public Entity newPackageEntity(String packageName) {
+		this.currentPackageName = packageName;
+		Entity pkgEntity = entityRepo.getEntity(packageName);
+		if (pkgEntity ==null) {
+			pkgEntity = new PackageEntity(packageName,-1,
+				entityRepo.getCurrentIndex());
+		}
+		currentFileEntity.setParentId(pkgEntity.getId());
+		pkgEntity.addChildId(currentFileEntity.getId());
+		return pkgEntity;
+	}
+	
+	private String resolveTypeNameDefinition(String name) {
+		if (name.isEmpty()) return "";
+		String prefix = "";
+		for (int i=entityStack.size()-1;i>=0;i--) {
+			Entity t = entityStack.get(i);
+			if(! t.getFullName().isEmpty() &&
+					!(t.getFullName().startsWith("<Anony>"))) {
+				prefix = t.getFullName();
+				break;
+			}
+		}
+		if (prefix.isEmpty()) {
+			if (currentPackageName.length()>0)
+				return currentPackageName + "." + name;
+			return name;
+		}else {
+			return  prefix + "." + name;
+		}
+	}
+	
+	public Entity newClassInterface(String classOrInterfaceName) {
+		Entity currentTypeEntity = new TypeEntity(resolveTypeNameDefinition(classOrInterfaceName),
+				currentFileEntity.getId(),
+				entityRepo.getCurrentIndex());
+        entityRepo.add(currentTypeEntity);
+        entityStack.push(currentTypeEntity);
+		return currentTypeEntity;
+	}
+	
+	public void popEntity() {
+		entityStack.pop();
+	}
+	
+	public void newImport(String importedTypeOrPackage) {
+		currentFileEntity.addImport(importedTypeOrPackage);
+	}
+	
+	//TODO: should be refined
+	public FileEntity currentFile() {
+		return currentFileEntity;
+	}
+	
+	public String resolveTypeNameRef(String typeName) {
+		//if it is a full name like "java.io.Exception"
+		if (typeName.indexOf('.')>0) return typeName;
+		
+		//if it is a singleName like "JavaHandler"
+		// TODO: we still cannot handle on demand import like 
+		// import package.name.*;
+		if (currentFile().getImport(typeName)!=null)
+			typeName = currentFile().getImport(typeName);
+		else
+			typeName = (currentPackageName.isEmpty()? "":".") + typeName;
+		return typeName;
+	}
+	public Entity newFunctionEntity(String methodName) {
+		Entity currentFunctionEntity = new FunctionEntity(resolveTypeNameDefinition(methodName),
+				currentType().getId(),
+				entityRepo.getCurrentIndex());
+        entityStack.push(currentFunctionEntity);
+		return currentFunctionEntity;
+	}
+	public Entity currentType() {
+		for (int i=entityStack.size()-1;i>=0;i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof TypeEntity)
+				return t;
+		}
+		return null;
+	}
+	public Entity currentFunction() {
+		for (int i=entityStack.size()-1;i>=0;i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof FunctionEntity)
+				return t;
+		}
+		return null;
+	}
+	public void addVar(String type, String varName) {
+		VarEntity varEntity = new VarEntity(varName, type, lastContainer().getId(), entityRepo.getCurrentIndex());
+		lastContainer().addVar(varEntity);
+	}
+	public Entity lastContainer() {
+		return entityStack.peek();
+	}
+}
\ No newline at end of file

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,58 @@
+package depends.extractor.java.context;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import depends.javaextractor.Java9Parser.FormalParameterContext;
+import depends.javaextractor.Java9Parser.FormalParameterListContext;
+
+public class FormalParameterListContextHelper {
+	
+	FormalParameterListContext context;
+	List<String> parameterTypes;
+	
+	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext) {
+		this.context = formalParameterListContext;
+		parameterTypes = new ArrayList<>();
+	}
+	/**
+	 * 
+	 * formalParameterList
+	 * :	formalParameters ',' lastFormalParameter
+	 * |	lastFormalParameter
+	 * |	receiverParameter
+	 * @param context
+	 * @return
+	 */
+	public Collection<String> extractParameterTypeList() {
+		if (context != null) {
+			System.out.println(context.getText());
+			if (context.formalParameters() != null) {
+				System.out.println(context.formalParameters().getText());
+				for (FormalParameterContext p : context.formalParameters().formalParameter()) {
+					// Primitive type will be ignored
+					addParameterType( new UnannTypeContextHelper().calculateType(p.unannType()));
+				}
+			}
+			if (context.lastFormalParameter() != null) {
+				if (context.lastFormalParameter().formalParameter() != null) {
+					// Primitive type will be ignored
+					addParameterType( new UnannTypeContextHelper().calculateType(
+							context.lastFormalParameter().formalParameter().unannType()));
+				}
+				if (context.lastFormalParameter().unannType() != null) {
+					addParameterType( new UnannTypeContextHelper().calculateType( context.lastFormalParameter().unannType()));
+				}
+			}
+			if (context.receiverParameter() != null) {
+				addParameterType( new UnannTypeContextHelper().calculateType(context.receiverParameter().unannType()));
+			}
+		}
+		return parameterTypes;
+	}
+	private void addParameterType(String type) {
+		if (type!=null)
+			this.parameterTypes.add(type);
+	}
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,41 @@
+package depends.format.json;
+
+
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.util.Map;
+
+@XmlRootElement(name = "cell")
+public class JCellObject {
+    private int src;
+    private int dest;
+    private Map<String, Float> values;
+
+    public int getSrc() {
+        return src;
+    }
+
+    @XmlAttribute(name = "src")
+    public void setSrc(int src) {
+        this.src = src;
+    }
+
+    public int getDest() {
+        return dest;
+    }
+
+    @XmlAttribute(name = "dest")
+    public void setDest(int dest) {
+        this.dest = dest;
+    }
+
+    public void setValues(Map<String, Float> values) {
+        this.values = values;
+    }
+
+    @XmlElement
+    public Map<String, Float> getValues() {
+        return values;
+    }
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,50 @@
+package depends.format.json;
+
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.util.ArrayList;
+
+@XmlRootElement(name = "matrix")
+public class JDepObject {
+    private String schemaVersion;
+    private String name;
+    private ArrayList<String> variables;
+    private ArrayList<JCellObject> cells;
+
+    public String getName() {
+        return name;
+    }
+
+    @XmlAttribute(name = "name")
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getSchemaVersion() {
+        return schemaVersion;
+    }
+
+    @XmlAttribute(name = "schema-version")
+    public void setSchemaVersion(String schemaVersion) {
+        this.schemaVersion = schemaVersion;
+    }
+
+    public ArrayList<String> getVariables() {
+        return variables;
+    }
+
+    @XmlElement
+    public void setVariables(ArrayList<String> variables) {
+        this.variables = variables;
+    }
+
+    public ArrayList<JCellObject> getCells() {
+        return cells;
+    }
+
+    @XmlElement
+    public void setCells(ArrayList<JCellObject> cells) {
+        this.cells = cells;
+    }
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,57 @@
+package depends.format.matrix;
+
+import java.util.ArrayList;
+
+import depends.entity.Entity;
+import depends.entity.Relation;
+import depends.entity.repo.EntityRepo;
+import depends.entity.types.FileEntity;
+import depends.util.Tuple;
+
+public class FileDependencyGenerator {
+	/**
+	 * Build the dependency matrix (without re-mapping file id)
+	 * @param entityRepo which contains entities and relations
+	 * @return the generated dependency matrix
+	 */
+	public DependencyMatrix build(EntityRepo entityRepo) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix();
+        ArrayList<String> files = new ArrayList<String>();
+		for (Entity entity:entityRepo.getEntities()) {
+        	if (entity instanceof FileEntity){
+        		files.add( entity.getFullName());
+        	}
+        	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity.getId());
+        	if (fileEntityFrom==-1) continue;
+        	for (Relation relation:entity.getRelations()) {
+        		if (relation.getToId()>=0) {
+        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getToId());
+        			if (fileEntityTo==-1) continue;
+        			dependencyMatrix.addDependency(relation.getType(), new Tuple<Integer, Integer>(fileEntityFrom,fileEntityTo));
+        		}
+        	}
+        }
+		dependencyMatrix.setNodes(files);
+		return dependencyMatrix;
+	}
+
+	/**
+	 * Build the dependency matrix (re-mapped all dependencies with 0-based values 
+	 * to align with node indexes)
+	 * @param entityRepo which contains entities and relations
+	 * @return the generated dependency matrix
+	 */
+	public DependencyMatrix buildWithRemap(EntityRepo repo) {
+		DependencyMatrix r = build(repo);
+		r.remapIds(repo);
+		return r;
+	}
+
+	private int getFileEntityIdNoException(EntityRepo entityRepo, Integer entityId){
+		try {
+			return entityRepo.getAncestorOfType(entityId, FileEntity.class);
+		} catch (Exception e) {
+			return -1;
+		} 
+	}
+	}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,21 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.repo.EntityRepo;
+
+public class JavaInternalClassTest {
+	@Test
+	public void test_parameter() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/InternalClass.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        assertNotNull(repo.getEntity("a.InternalClass.Internal"));
+	}
+
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,21 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.repo.EntityRepo;
+
+public class JavaParameterParserTest {
+	@Test
+	public void test_parameter() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/FunctionParameters.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        assertEquals(3,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+	}
+
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,22 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.Entity;
+import depends.entity.repo.EntityRepo;
+
+public class JavaVarResolveTest {
+	@Test
+	public void test_field_var_should_be_parsed() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/FieldVar.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        Entity classEntity = repo.getEntity("FieddVar");
+        assertEquals(3,classEntity.getVars().size()); 
+	}
+}

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,5 @@
+
+public class FieddVar {
+	String a;
+	public String b,c;
+}
\ No newline at end of file

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,13 @@
+public class FunctionParameters {
+	public void func_without_parameter() {
+	}
+	public void function_with_one_parameter(Integer a) {
+		
+	}
+	public void function_with_two_parameter(Integer a, String b) {
+		
+	}
+	public void function_with_parameters_same_type(Integer a, String b, Integer c) {
+		
+	}
+}
\ No newline at end of file

44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,6 @@
+package a;
+public class InternalClass {
+	class Internal{
+		
+	}
+}
\ No newline at end of file

14facfd0e7b0248bb22972b90c8c4aa519401f5c
@@ -6,15 +6,23 @@ import java.util.List;
 
 import depends.javaextractor.Java9Parser.FormalParameterContext;
 import depends.javaextractor.Java9Parser.FormalParameterListContext;
+import depends.javaextractor.Java9Parser.IdentifierContext;
+import depends.javaextractor.Java9Parser.UnannTypeContext;
+import depends.javaextractor.Java9Parser.VariableDeclaratorIdContext;
+import depends.util.Tuple;
 
 public class FormalParameterListContextHelper {
 	
 	FormalParameterListContext context;
 	List<String> parameterTypes;
+	List<Tuple<String, String>> varList;
 	
 	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext) {
 		this.context = formalParameterListContext;
 		parameterTypes = new ArrayList<>();
+		varList = new ArrayList<>();
+		if (formalParameterListContext!=null)
+			extractParameterTypeList();
 	}
 	/**
 	 * 
@@ -25,34 +33,58 @@ public class FormalParameterListContextHelper {
 	 * @param context
 	 * @return
 	 */
-	public Collection<String> extractParameterTypeList() {
+	public void extractParameterTypeList() {
 		if (context != null) {
 			System.out.println(context.getText());
 			if (context.formalParameters() != null) {
 				System.out.println(context.formalParameters().getText());
 				for (FormalParameterContext p : context.formalParameters().formalParameter()) {
-					// Primitive type will be ignored
-					addParameterType( new UnannTypeContextHelper().calculateType(p.unannType()));
+					foundParameterDefintion(p.unannType(),p.variableDeclaratorId());
 				}
 			}
+			/**
+			 * lastFormalParameter:
+			 *   	variableModifier* unannType annotation* '...' variableDeclaratorId
+		     *     |formalParameter
+			 */
 			if (context.lastFormalParameter() != null) {
 				if (context.lastFormalParameter().formalParameter() != null) {
-					// Primitive type will be ignored
-					addParameterType( new UnannTypeContextHelper().calculateType(
-							context.lastFormalParameter().formalParameter().unannType()));
+					foundParameterDefintion(context.lastFormalParameter().formalParameter().unannType(),
+							context.lastFormalParameter().formalParameter().variableDeclaratorId());
 				}
+				
 				if (context.lastFormalParameter().unannType() != null) {
-					addParameterType( new UnannTypeContextHelper().calculateType( context.lastFormalParameter().unannType()));
+					foundParameterDefintion(context.lastFormalParameter().unannType(),
+							context.lastFormalParameter().variableDeclaratorId());
 				}
 			}
+			/**
+			 * receiverParameter :	annotation* unannType (identifier '.')? 'this'
+			 */
 			if (context.receiverParameter() != null) {
-				addParameterType( new UnannTypeContextHelper().calculateType(context.receiverParameter().unannType()));
+				UnannTypeContext unannType =  context.receiverParameter().unannType();
+				String type =  new UnannTypeContextHelper().calculateType(unannType);
+				if (type!=null)
+					this.parameterTypes.add(type);
+				IdentifierContext var = context.receiverParameter().identifier();
+				if (var!=null)
+					varList.add(new Tuple<String, String>(type,var.Identifier().getText()));		
 			}
 		}
+		return;
+	}
+	public Collection<String> getParameterTypeList(){
 		return parameterTypes;
 	}
-	private void addParameterType(String type) {
+	public Collection<Tuple<String, String>> getVarList(){
+		return varList;
+	}
+	
+	private void foundParameterDefintion(UnannTypeContext unannType, VariableDeclaratorIdContext variableDeclaratorId) {
+		String type =  new UnannTypeContextHelper().calculateType(unannType);
 		if (type!=null)
 			this.parameterTypes.add(type);
+		String var = variableDeclaratorId.identifier().getText();
+		varList.add(new Tuple<String, String>(type,var));		
 	}
 }

14facfd0e7b0248bb22972b90c8c4aa519401f5c
@@ -16,7 +16,17 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/FieldVar.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        Entity classEntity = repo.getEntity("FieddVar");
+        Entity classEntity = repo.getEntity("FieldVar");
         assertEquals(3,classEntity.getVars().size()); 
 	}
+	
+	@Test
+	public void test_local_var_should_be_parsed() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/LocalVar.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        assertEquals(1,repo.getEntity("LocalVar").getVars().size());
+        assertEquals(2,repo.getEntity("LocalVar.foo").getVars().size());
+	}
 }

14facfd0e7b0248bb22972b90c8c4aa519401f5c
@@ -1,5 +1,5 @@
 
-public class FieddVar {
+public class FieldVar {
 	String a;
 	public String b,c;
 }
\ No newline at end of file

14facfd0e7b0248bb22972b90c8c4aa519401f5c
@@ -0,0 +1,7 @@
+
+public class LocalVar {
+	String a;
+	void foo(String b) {
+		String a;
+	}
+}
\ No newline at end of file

6f31e63fc02cae9f5e8d76e0abd9df882f8d1fac
@@ -10,5 +10,9 @@ public class VarEntity extends Entity {
 		super(fullName,  parentId,id);
 		this.type = type;
 	}
+
+	public String getType() {
+		return type;
+	}
     
 }

6f31e63fc02cae9f5e8d76e0abd9df882f8d1fac
@@ -121,4 +121,15 @@ public class HandlerContext{
 	public Entity lastContainer() {
 		return entityStack.peek();
 	}
+	public String inferType(String varName) {
+		for (int i=entityStack.size()-1;i>=0;i--) {
+			Entity t = entityStack.get(i);
+			for (VarEntity var:t.getVars()) {
+				if (var.getFullName().equals(varName)){
+					return var.getType();
+				}
+			}
+		}
+		return null;
+	}
 }
\ No newline at end of file

6f31e63fc02cae9f5e8d76e0abd9df882f8d1fac
@@ -29,4 +29,14 @@ public class JavaVarResolveTest {
         assertEquals(1,repo.getEntity("LocalVar").getVars().size());
         assertEquals(2,repo.getEntity("LocalVar.foo").getVars().size());
 	}
+	
+	@Test
+	public void test_local_var_type_could_be_inferred() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/LocalVarInferExample.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        assertEquals(2,repo.getEntity("LocalVarInferExample.setExample").getVars().size());
+        
+	}
 }

09b25f297b78ccabaca1b67fcf9f92e43b2f03ee
@@ -0,0 +1,14 @@
+
+public class LocalVarInferExample {
+	String a;
+	void setExample(String b) {
+		Integer x;
+		x=1; //Set x
+		b="2"; //Set b
+		x=b.length(); //Set x
+		x++; //Set x
+		++x; //Set x
+		x--; //Set x
+		--x; //Set x
+	}
+}
\ No newline at end of file

99b712c4bfd3d17fb8d037a1b32c613cd446f68d
@@ -88,7 +88,7 @@ public class HandlerContext{
 		if (currentFile().getImport(typeName)!=null)
 			typeName = currentFile().getImport(typeName);
 		else
-			typeName = (currentPackageName.isEmpty()? "":".") + typeName;
+			typeName = currentPackageName + (currentPackageName.isEmpty()? "":".") + typeName;
 		return typeName;
 	}
 	public Entity newFunctionEntity(String methodName) {
@@ -132,4 +132,14 @@ public class HandlerContext{
 		}
 		return null;
 	}
+	public String inferType(String fromType, String varName) {
+		Entity type = entityRepo.getEntity(fromType);
+		if (type==null) return null;
+		if (!(type instanceof TypeEntity)) return null;
+		for (VarEntity var:type.getVars()) {
+			if (var.getFullName().equals(varName))
+				return var.getType();
+		}
+		return null;
+	}
 }
\ No newline at end of file

99b712c4bfd3d17fb8d037a1b32c613cd446f68d
@@ -35,9 +35,7 @@ public class FormalParameterListContextHelper {
 	 */
 	public void extractParameterTypeList() {
 		if (context != null) {
-			System.out.println(context.getText());
 			if (context.formalParameters() != null) {
-				System.out.println(context.formalParameters().getText());
 				for (FormalParameterContext p : context.formalParameters().formalParameter()) {
 					foundParameterDefintion(p.unannType(),p.variableDeclaratorId());
 				}

99b712c4bfd3d17fb8d037a1b32c613cd446f68d
@@ -36,7 +36,18 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/LocalVarInferExample.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        assertEquals(2,repo.getEntity("LocalVarInferExample.setExample").getVars().size());
+        //7 set included
+        assertEquals(11,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
         
 	}
+	
+	@Test
+	public void test_field_access_could_be_inferred() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/FieldAccessInferExample.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        assertEquals(11,repo.getEntity("test.FieldAccessInferExample.setExample").getRelations().size());
+	}
+	
 }

c5e3729e2b973bdc3f53e1d5844e7dff3c1e497d
@@ -37,7 +37,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         //7 set included
-        assertEquals(11,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(9,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
         
 	}
 	
@@ -47,7 +47,7 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/FieldAccessInferExample.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        assertEquals(11,repo.getEntity("test.FieldAccessInferExample.setExample").getRelations().size());
+        assertEquals(13,repo.getEntity("test.FieldAccessInferExample.setExample").getRelations().size());
 	}
 	
 }

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -5,6 +5,7 @@ import java.util.HashSet;
 import java.util.Set;
 
 import depends.entity.repo.EntityRepo;
+import depends.entity.types.FunctionEntity;
 import depends.entity.types.VarEntity;
 
 public class Entity {
@@ -17,6 +18,7 @@ public class Entity {
 		this.setParentId(parentId);
 		this.setId(id);
 		vars = new ArrayList<>();
+		functions = new ArrayList<>();
 	}
 
 	public void setFileId(int fileId) {
@@ -34,6 +36,7 @@ public class Entity {
     protected ArrayList<Integer> childrenIds = new ArrayList<>();
     protected ArrayList<Relation> relations = new ArrayList<>();
     protected ArrayList<VarEntity> vars;
+    protected ArrayList<FunctionEntity> functions;
 
     public int getId() {
         return id;
@@ -111,4 +114,12 @@ public class Entity {
 	public ArrayList<VarEntity> getVars() {
 		return this.vars;
 	}
+
+	public void addFunction(FunctionEntity functionEntity) {
+		this.functions.add(functionEntity);
+	}
+	
+	public ArrayList<FunctionEntity> getFunctions() {
+		return this.functions;
+	}
 }

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -3,7 +3,24 @@ package depends.entity.types;
 import depends.entity.Entity;
 
 public class FunctionEntity extends Entity{
-	public FunctionEntity(String fullName, int parentId, Integer id) {
+	private String returnType;
+	private String shortName;
+	public String getShortName() {
+		return shortName;
+	}
+
+	public String getReturnType() {
+		return returnType;
+	}
+
+	public void setReturnType(String returnType) {
+		this.returnType = returnType;
+	}
+
+	public FunctionEntity(String fullName, int parentId, Integer id, String resultType, String shortName) {
 		super(fullName, parentId,id);
+		this.returnType = resultType;
+		this.shortName = shortName;
 	}
+
 }

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -18,9 +18,11 @@ public class HandlerContext{
 	
 	public HandlerContext(EntityRepo entityRepo) {
 		this.entityRepo = entityRepo;
+		entityStack = new Stack<Entity>();
 	}
 	public FileEntity newFileEntity(String fileName) {
 		currentFileEntity = new FileEntity(fileName,entityRepo.getCurrentIndex());
+        entityStack.push(currentFileEntity);
 		return currentFileEntity;
 	}
 
@@ -41,6 +43,7 @@ public class HandlerContext{
 		String prefix = "";
 		for (int i=entityStack.size()-1;i>=0;i--) {
 			Entity t = entityStack.get(i);
+			if (t instanceof FileEntity) continue; //file name should be bypass. use package name instead 
 			if(! t.getFullName().isEmpty() &&
 					!(t.getFullName().startsWith("<Anony>"))) {
 				prefix = t.getFullName();
@@ -73,11 +76,6 @@ public class HandlerContext{
 		currentFileEntity.addImport(importedTypeOrPackage);
 	}
 	
-	//TODO: should be refined
-	public FileEntity currentFile() {
-		return currentFileEntity;
-	}
-	
 	public String resolveTypeNameRef(String typeName) {
 		//if it is a full name like "java.io.Exception"
 		if (typeName.indexOf('.')>0) return typeName;
@@ -91,10 +89,12 @@ public class HandlerContext{
 			typeName = currentPackageName + (currentPackageName.isEmpty()? "":".") + typeName;
 		return typeName;
 	}
-	public Entity newFunctionEntity(String methodName) {
-		Entity currentFunctionEntity = new FunctionEntity(resolveTypeNameDefinition(methodName),
+	public Entity newFunctionEntity(String methodName, String resultType) {
+		//TODO: should process parameter types to distinguish the overload functions for short name;
+		FunctionEntity currentFunctionEntity = new FunctionEntity(resolveTypeNameDefinition(methodName),
 				currentType().getId(),
-				entityRepo.getCurrentIndex());
+				entityRepo.getCurrentIndex(),resultType,methodName);
+		currentType().addFunction(currentFunctionEntity);
         entityStack.push(currentFunctionEntity);
 		return currentFunctionEntity;
 	}
@@ -114,6 +114,24 @@ public class HandlerContext{
 		}
 		return null;
 	}
+	
+	public FileEntity currentFile() {
+		return currentFileEntity;
+	}
+	
+	public Entity latestValidContainer() {
+		for (int i=entityStack.size()-1;i>=0;i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof FunctionEntity)
+				return t;
+			if (t instanceof TypeEntity)
+				return t;
+			if (t instanceof FileEntity)
+				return t;
+		}
+		return null;
+	}
+	
 	public void addVar(String type, String varName) {
 		VarEntity varEntity = new VarEntity(varName, type, lastContainer().getId(), entityRepo.getCurrentIndex());
 		lastContainer().addVar(varEntity);
@@ -132,7 +150,7 @@ public class HandlerContext{
 		}
 		return null;
 	}
-	public String inferType(String fromType, String varName) {
+	public String inferVarType(String fromType, String varName) {
 		Entity type = entityRepo.getEntity(fromType);
 		if (type==null) return null;
 		if (!(type instanceof TypeEntity)) return null;
@@ -142,4 +160,18 @@ public class HandlerContext{
 		}
 		return null;
 	}
+
+	public String inferFunctionType(String fromType, String varName) {
+		Entity type = entityRepo.getEntity(fromType);
+		if (type==null) return null;
+		if (!(type instanceof TypeEntity)) return null;
+		TypeEntity typeEntity = (TypeEntity)type;
+		
+		for (FunctionEntity var:typeEntity.getFunctions()) {
+			if (var.getShortName().equals(varName))
+				return var.getReturnType();
+		}
+		return null;
+	}
+
 }
\ No newline at end of file

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -0,0 +1,71 @@
+package depends.extractor.java.context;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+import org.antlr.v4.runtime.RuleContext;
+
+import depends.extractor.java.JavaHandler;
+import depends.javaextractor.JavaParser.AnnotationContext;
+
+public class AnnotationProcessor {
+	private JavaHandler handler;
+
+	public AnnotationProcessor(JavaHandler handler) {
+		this.handler = handler;
+	}
+	/**
+	 * for any elements who with modifiers like 'public/static/... @Annotation‘，
+	 * process annotations as "USE"
+	 * 
+	 * @param ctx
+	 * @param class1
+	 */
+	
+	private boolean containsMethod(RuleContext ctx,String methodName) {
+		try {
+			Method m = ctx.getClass().getMethod(methodName);
+			if (m!=null) return true;
+		} catch (Exception e) {
+			return false;
+		}
+		return true;
+	}
+	private Method getMethod(RuleContext ctx, String methodName) {
+		try {
+			Method m = ctx.getClass().getMethod(methodName);
+			if (m!=null) return m;
+		} catch (Exception e) {
+			return null;
+		}
+		return null;	
+	}
+	
+	public void processAnnotationModifier(RuleContext ctx, String methodName) {
+		while (true) {
+			if (ctx == null)
+				break;
+			if (containsMethod(ctx,methodName))
+				break;
+			ctx = ctx.parent;
+		}
+		if (ctx==null)return;
+			
+		Method m = getMethod(ctx,methodName);
+		if (m==null) return;
+		try {
+			@SuppressWarnings("unchecked")
+			List<?> modifiers = (List<?>) m.invoke(ctx);
+			for (Object modifier : modifiers) {
+				Method annotationMethod = modifier.getClass().getMethod("annotation");
+				AnnotationContext annotation = (AnnotationContext) (annotationMethod.invoke(modifier));
+				if (annotation == null)
+					return;
+				String name = QualitiedNameContextHelper.getName(annotation.qualifiedName());
+				handler.foundAnnotationInUse(name);
+			}
+		} catch (Exception e) {
+			return;
+		}
+	}
+}

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -0,0 +1,170 @@
+package depends.extractor.java.context;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.antlr.v4.runtime.RuleContext;
+
+import depends.deptypes.DependencyType;
+import depends.extractor.GenericHandler;
+import depends.javaextractor.JavaParser.ExpressionContext;
+import depends.javaextractor.JavaParser.PrimaryContext;
+import depends.util.Tuple;
+
+public class ExpressionUsage {
+	class Expression {
+		String text; //for debug purpose
+		String returnType; //the type we care
+		String identifier;        //the varName, or method name, etc.
+		boolean isSet = false; //is a set relation from right to leftHand
+		boolean isDot = false; //is a dot expression, will decuce variable tfype left to right
+		boolean isCall = false;
+		
+		List<Tuple<String, String>> relations = new ArrayList<>();
+
+		@Override
+		public String toString() {
+			StringBuilder s = new StringBuilder();
+			s.append("[").append(text).append("]").append("\n")
+					.append("set=").append(isSet).append("\n")
+					.append("dot=").append(isDot).append("\n")
+					.append("isCall=").append(isCall).append("\n")
+					.append("type=").append(returnType).append("\n")
+					.append("var=").append(identifier).append("\n");
+			
+			for (Tuple<String, String> item : relations) {
+				s.append(item.y).append("->").append(item.x).append(",");
+			}
+			return s.toString();
+		}
+	}
+
+	GenericHandler handler;
+	HashMap<RuleContext, Expression> data;
+
+	public ExpressionUsage(GenericHandler handler) {
+		this.handler = handler;
+		data = new HashMap<>();
+	}
+
+	public void foundExpression(ExpressionContext ctx) {
+		System.out.println("enter "+ctx.getText());
+		if (ctx.creator()!=null)
+			System.out.println("creator:"+ctx.creator().getText());
+		Expression d = new Expression();
+		d.text = ctx.getText();
+		Tuple<String, String> nodeInfo = getExpressionType(ctx);
+		if (nodeInfo!=null) {
+			d.returnType = nodeInfo.x;
+			d.identifier = nodeInfo.y;
+		}
+		if (d.identifier==null && ctx.IDENTIFIER()!=null)
+			d.identifier = ctx.IDENTIFIER().getText();
+		else if (d.identifier==null && ctx.methodCall()!=null)
+			d.identifier = ctx.methodCall().IDENTIFIER().getText();
+		else if (d.identifier==null && (ctx.NEW()!=null && ctx.creator()!=null)){
+			d.identifier = ctx.creator().createdName().IDENTIFIER(0).getText();
+		}
+		d.isDot = isDot(ctx);
+		d.isSet = isSet(ctx);
+		d.isCall = ctx.methodCall()==null?false:true;
+		data.put(ctx, d);
+		updateParentType(ctx,d.returnType);
+	}
+
+	public void commitAllExpressionUsage() {
+		for (RuleContext item : data.keySet()) {
+			Expression value = data.get(item);
+			if (value.isSet) {
+				handler.addRelation(value.returnType, DependencyType.RELATION_SET);
+			}
+			System.out.println(value);
+		}
+		data.clear();
+	}
+
+	public Tuple<String, String> getExpressionType(ExpressionContext ctx) {
+		Tuple<String, String> primaryInfo = getPrimaryType(ctx.primary());
+		if (primaryInfo!=null) return primaryInfo;
+		if (ctx.typeType()!=null && ctx.expression()!=null) {
+			return new Tuple<String,String>(ctx.typeType().getText(),"");
+		}
+		if (ctx.NEW()!=null & ctx.creator()!=null) {
+			return new Tuple<String,String>(ctx.creator().createdName().IDENTIFIER(0).getText(),"");
+		}
+		return null;
+	}
+	
+	private boolean isDot(ExpressionContext ctx) {
+		if (ctx.bop!=null)
+			if (ctx.bop.getText().equals(".")) return true;
+		return false;
+	}
+	public boolean isSet(ExpressionContext ctx) {
+		if (ctx.bop != null) {
+			if (OpHelper.isAssigment(ctx.bop.getText())) {
+				return true;
+			}
+		}
+		if (ctx.prefix != null) {
+			if (OpHelper.isIncrementalDecremental(ctx.prefix.getText())) {
+				return true;
+			}
+		}
+		if (ctx.postfix != null) {
+			if (OpHelper.isIncrementalDecremental(ctx.postfix.getText())) {
+				return true;
+			}
+		}
+		return false;
+	}
+	
+//  primary
+//    : '(' expression ')'
+//    | THIS
+//    | SUPER
+//    | literal
+//    | IDENTIFIER
+//    | typeTypeOrVoid '.' CLASS
+//    | nonWildcardTypeArguments (explicitGenericInvocationSuffix | THIS arguments) //Just USE relation
+//    
+	private Tuple<String, String> getPrimaryType(PrimaryContext ctx) {
+		String type =null;
+		String varName = "";
+		if (ctx==null) return null;
+		if (ctx.expression()!=null) return null;
+		if (ctx.literal()!=null) {
+			type = "Built-in";
+			varName = ctx.literal().getText();
+		}else if (ctx.IDENTIFIER()!=null) {
+			varName = ctx.IDENTIFIER().getText();
+			type = handler.context().inferType(varName);
+		}else if (ctx.typeTypeOrVoid()!=null) {
+			type = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
+		}
+		return new Tuple<String, String> (type,varName);
+	}
+
+	private RuleContext findParentInStack(RuleContext ctx) {
+		if (ctx==null) return null;
+		if (data.containsKey(ctx.parent)) return ctx.parent;
+		return findParentInStack(ctx.parent);
+	}
+	private void updateParentType(RuleContext ctx, String type) {
+		if (type==null ) return;
+		RuleContext parent = findParentInStack(ctx);
+		if (parent==null) return;
+		System.out.println(parent.getText());
+		Expression d = data.get(parent);
+		if (d==null) return;
+		if (d.returnType!=null) return;
+		if (d.isDot && (!d.isCall))
+			d.returnType = handler.context().inferVarType(handler.context().resolveTypeNameRef(type), d.identifier);
+		else if (d.isDot && d.isCall)
+			d.returnType = handler.context().inferFunctionType(handler.context().resolveTypeNameRef(type),d.identifier);
+		else
+			d.returnType = type;
+		updateParentType(parent,d.returnType);
+	}
+}

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -4,85 +4,85 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import depends.javaextractor.Java9Parser.FormalParameterContext;
-import depends.javaextractor.Java9Parser.FormalParameterListContext;
-import depends.javaextractor.Java9Parser.IdentifierContext;
-import depends.javaextractor.Java9Parser.UnannTypeContext;
-import depends.javaextractor.Java9Parser.VariableDeclaratorIdContext;
+import org.antlr.v4.runtime.tree.TerminalNode;
+
+import depends.javaextractor.JavaParser.FormalParameterContext;
+import depends.javaextractor.JavaParser.FormalParameterListContext;
+import depends.javaextractor.JavaParser.FormalParametersContext;
+import depends.javaextractor.JavaParser.LastFormalParameterContext;
+import depends.javaextractor.JavaParser.TypeTypeContext;
+import depends.javaextractor.JavaParser.VariableModifierContext;
 import depends.util.Tuple;
 
 public class FormalParameterListContextHelper {
-	
+
+	private FormalParametersContext formalParameters;
 	FormalParameterListContext context;
+
 	List<String> parameterTypes;
 	List<Tuple<String, String>> varList;
+	private List<String> annotations;
+
+	public FormalParameterListContextHelper(FormalParametersContext formalParameters) {
+		this.formalParameters = formalParameters;
+		this.context = this.formalParameters.formalParameterList();
+		parameterTypes = new ArrayList<>();
+		varList = new ArrayList<>();
+		annotations = new ArrayList<>();
+		if (context!=null)
+			extractParameterTypeList();
+	}
+
+	public Collection<String> getParameterTypeList(){
+		return parameterTypes;
+	}
+	public Collection<Tuple<String, String>> getVarList(){
+		return varList;
+	}
+
 	
 	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext) {
 		this.context = formalParameterListContext;
 		parameterTypes = new ArrayList<>();
 		varList = new ArrayList<>();
-		if (formalParameterListContext!=null)
+		annotations = new ArrayList<>();
+		if (context!=null)
 			extractParameterTypeList();
 	}
-	/**
-	 * 
-	 * formalParameterList
-	 * :	formalParameters ',' lastFormalParameter
-	 * |	lastFormalParameter
-	 * |	receiverParameter
-	 * @param context
-	 * @return
-	 */
+
+
 	public void extractParameterTypeList() {
 		if (context != null) {
-			if (context.formalParameters() != null) {
-				for (FormalParameterContext p : context.formalParameters().formalParameter()) {
-					foundParameterDefintion(p.unannType(),p.variableDeclaratorId());
+			if (context.formalParameter() != null) {
+				for (FormalParameterContext p : context.formalParameter()) {
+					foundParameterDefintion(p.typeType(),p.variableDeclaratorId().IDENTIFIER(),p.variableModifier());
 				}
-			}
-			/**
-			 * lastFormalParameter:
-			 *   	variableModifier* unannType annotation* '...' variableDeclaratorId
-		     *     |formalParameter
-			 */
-			if (context.lastFormalParameter() != null) {
-				if (context.lastFormalParameter().formalParameter() != null) {
-					foundParameterDefintion(context.lastFormalParameter().formalParameter().unannType(),
-							context.lastFormalParameter().formalParameter().variableDeclaratorId());
-				}
-				
-				if (context.lastFormalParameter().unannType() != null) {
-					foundParameterDefintion(context.lastFormalParameter().unannType(),
-							context.lastFormalParameter().variableDeclaratorId());
+				if (context.lastFormalParameter()!=null) {
+					LastFormalParameterContext p = context.lastFormalParameter();
+					foundParameterDefintion(p.typeType(),p.variableDeclaratorId().IDENTIFIER(),p.variableModifier());
 				}
 			}
-			/**
-			 * receiverParameter :	annotation* unannType (identifier '.')? 'this'
-			 */
-			if (context.receiverParameter() != null) {
-				UnannTypeContext unannType =  context.receiverParameter().unannType();
-				String type =  new UnannTypeContextHelper().calculateType(unannType);
-				if (type!=null)
-					this.parameterTypes.add(type);
-				IdentifierContext var = context.receiverParameter().identifier();
-				if (var!=null)
-					varList.add(new Tuple<String, String>(type,var.Identifier().getText()));		
-			}
 		}
 		return;
 	}
-	public Collection<String> getParameterTypeList(){
-		return parameterTypes;
-	}
-	public Collection<Tuple<String, String>> getVarList(){
-		return varList;
-	}
-	
-	private void foundParameterDefintion(UnannTypeContext unannType, VariableDeclaratorIdContext variableDeclaratorId) {
-		String type =  new UnannTypeContextHelper().calculateType(unannType);
+
+	private void foundParameterDefintion(TypeTypeContext typeType, TerminalNode identifier, List<VariableModifierContext> variableModifier) {
+		String type = ClassTypeContextHelper.getClassName(typeType);
 		if (type!=null)
 			this.parameterTypes.add(type);
-		String var = variableDeclaratorId.identifier().getText();
-		varList.add(new Tuple<String, String>(type,var));		
+		String var = identifier.getText();
+		varList.add(new Tuple<String, String>(type,var));	
+
+		for ( VariableModifierContext modifier:variableModifier) {
+			if (modifier.annotation()!=null) {
+				this.annotations.add(QualitiedNameContextHelper.getName(modifier.annotation().qualifiedName()));
+			}
+		}
+
+	}
+
+	public List<String> getAnnotations() {
+		return annotations;
 	}
+
 }

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -0,0 +1,16 @@
+package depends.extractor.java.context;
+
+import java.util.List;
+
+import org.antlr.v4.runtime.tree.TerminalNode;
+
+public class IdentifierContextHelper {
+	public static String getName(List<TerminalNode> identifiers) {
+		String r = "";
+		for (TerminalNode id:identifiers) {
+			String dot = r.isEmpty()?"":".";
+			r = r + dot + id.getText();
+		}
+		return r;
+	}
+}

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -0,0 +1,38 @@
+package depends.extractor.java.context;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.javaextractor.JavaParser.ConstantDeclaratorContext;
+import depends.javaextractor.JavaParser.VariableDeclaratorContext;
+import depends.javaextractor.JavaParser.VariableDeclaratorIdContext;
+import depends.javaextractor.JavaParser.VariableDeclaratorsContext;
+
+public class VariableDeclaratorsContextHelper {
+
+	public static List<String> getVariables(VariableDeclaratorsContext variableDeclarators) {
+		List<String> vars = new ArrayList<>();
+		if (variableDeclarators==null) return vars; 
+		for (VariableDeclaratorContext vContext:variableDeclarators.variableDeclarator()) {
+			vars.add(vContext.variableDeclaratorId().IDENTIFIER().getText());
+		}
+		return vars;
+	}
+
+	public static List<String> getVariables(List<ConstantDeclaratorContext> constantDeclarator) {
+		List<String> vars = new ArrayList<>();
+		if (constantDeclarator==null) return vars; 
+		for (ConstantDeclaratorContext vContext:constantDeclarator) {
+			vars.add(vContext.IDENTIFIER().getText());
+		}
+		return vars;
+	}
+
+	public static List<String> getVariable(VariableDeclaratorIdContext variableDeclaratorIdContext) {
+		List<String> vars = new ArrayList<>();
+		if (variableDeclaratorIdContext==null) return vars; 
+		vars.add(variableDeclaratorIdContext.IDENTIFIER().getText());
+		return vars;
+	}
+
+}

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -36,8 +36,8 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/LocalVarInferExample.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        //7 set included
-        assertEquals(9,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        //8 set included
+        assertEquals(10,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
         
 	}
 	

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -1,12 +1,12 @@
 
-public class LocalVarInferExample {
+@Autowired public class LocalVarInferExample {
 	String a;
-	void setExample(String b) {
-		Integer x;
+	void setExample(String b) { //param
+		Integer x; //define
 		x=1; //Set x
 		b="2"; //Set b
 		x=b.length(); //Set x
-		x++; //Set x
+		(x=b)+=1; //Set x
 		++x; //Set x
 		x--; //Set x
 		--x; //Set x

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -30,16 +30,27 @@ public class DependencyType {
     //function/method->OperandVar
     public static final String RELATION_USE = "Use";
 
-    //class->class in python
-    //struct-> struct , interface->interface in golang
     public static final String RELATION_INHERIT = "Inherit";
     
 	public static final String RELATION_DEFINE = "Define";
 
-    //struct1->struct2, interface1->interface2
-    //public static final String RELATION_INHERIT = "Embed";
-    //public static final String RELATION_INHERITED_BY = "Embeded by";
+    public static final String RELATION_EMBED = "Embed";
+    public static final String RELATION_EMBED_BY = "Embeded by";
 
+    /**
+     * Mask of dependencies.
+     * 0 - IMPORT
+     * 1 - INHERIT
+     * 2 - IMPLEMENT
+     * 3 - RECEIVE
+     * 4 - CALL
+     * 5 - SET
+     * 6 - USE
+     * 7 - PARAMETER
+     * 8 - RETURN 
+     * @param depMask
+     * @return
+     */
 	public static final ArrayList<String> resolveMask(String depMask) {
         ArrayList<String> depedencyTypes = new ArrayList<String>();
         for(int i = 0; i < depMask.toCharArray().length; i++) {

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -0,0 +1,73 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import depends.entity.types.FunctionEntity;
+import depends.entity.types.VarEntity;
+import depends.extractor.HandlerContext;
+
+public abstract class ContainerEntity extends Entity {
+
+    ArrayList<VarEntity> vars;
+    ArrayList<FunctionEntity> functions;
+	HashMap<Integer, Expression> expressions;
+
+	public ContainerEntity(String fullName, int parentId, Integer id) {
+		super(fullName, parentId, id);
+		vars = new ArrayList<>();
+		functions = new ArrayList<>();
+		expressions = new HashMap<>();
+	}
+	
+	public void addVar(VarEntity var) {
+		this.vars.add(var);
+	}
+
+	public ArrayList<VarEntity> getVars() {
+		return this.vars;
+	}
+
+	public void addFunction(FunctionEntity functionEntity) {
+		this.functions.add(functionEntity);
+	}
+	
+	public ArrayList<FunctionEntity> getFunctions() {
+		return this.functions;
+	}
+
+	public HashMap<Integer, Expression> expressions() {
+		return expressions;
+	}
+
+	public void addExpression(Expression expression) {
+		expressions.put(expression.id, expression);
+	}
+
+	/**
+	 * Recursively update all types of parent after obtain the child type <br>
+	 * In AST, the parent type is determined by child. <br>
+	 * e.g : <br>
+	 *       (i=1)++
+	 *       i is an integer, i=1 is also an integer (determined by i)
+	 *       (i=1)++ is an integer (determined by i=1)
+	 * @param ctx
+	 * @param type
+	 */
+	public void updateParentReturnType(Integer id, String type, HandlerContext context) {
+		if (type==null ) return;
+		Expression thisExpression = expressions.get(id);
+		if (thisExpression==null) return;
+		Expression d = expressions.get(thisExpression.parentId);
+		if (d==null) return;
+		if (d.returnType!=null) return;
+		if (d.isDot && (!d.isCall))
+			d.returnType = context.inferVarType(context.resolveTypeNameRef(type), d.identifier);
+		else if (d.isDot && d.isCall)
+			d.returnType = context.inferFunctionType(context.resolveTypeNameRef(type),d.identifier);
+		else
+			d.returnType = type;
+		updateParentReturnType(d.id,d.returnType,context);
+	}
+
+}

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -8,17 +8,19 @@ import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.VarEntity;
 
-public class Entity {
-    protected String fullName = "";
+public abstract class Entity {
 	protected int id=-1;
-    protected int parentId=-1;
+	protected String fullName = "";
+
+	protected int parentId=-1;
+    protected ArrayList<Integer> childrenIds = new ArrayList<>();
+    
+    protected ArrayList<Relation> relations = new ArrayList<>();
     
     public Entity(String fullName, int parentId, Integer id) {
-		this.setFullName(fullName);
+		this.fullName = fullName;
 		this.setParentId(parentId);
 		this.setId(id);
-		vars = new ArrayList<>();
-		functions = new ArrayList<>();
 	}
 
 	public void setFileId(int fileId) {
@@ -28,15 +30,7 @@ public class Entity {
 		return fullName;
 	}
 
-	public void setFullName(String fullName) {
-		this.fullName = fullName;
-	}
-
 
-    protected ArrayList<Integer> childrenIds = new ArrayList<>();
-    protected ArrayList<Relation> relations = new ArrayList<>();
-    protected ArrayList<VarEntity> vars;
-    protected ArrayList<FunctionEntity> functions;
 
     public int getId() {
         return id;
@@ -70,10 +64,6 @@ public class Entity {
         childrenIds.add(id);
     }
 
-    public void addChildrenIds(ArrayList<Integer> ids) {
-        childrenIds.addAll(ids);
-    }
-
     public ArrayList<Integer> getChildrenIds() {
         return childrenIds;
     }
@@ -106,20 +96,4 @@ public class Entity {
 		}
 		return unsolved;
 	}
-
-	public void addVar(VarEntity var) {
-		this.vars.add(var);
-	}
-
-	public ArrayList<VarEntity> getVars() {
-		return this.vars;
-	}
-
-	public void addFunction(FunctionEntity functionEntity) {
-		this.functions.add(functionEntity);
-	}
-	
-	public ArrayList<FunctionEntity> getFunctions() {
-		return this.functions;
-	}
 }

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -0,0 +1,38 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.util.Tuple;
+
+public class Expression {
+	public Integer id;
+	public Integer parentId;
+	
+	public String text; // for debug purpose
+	public String returnType; // the type we care
+	public String identifier; // the varName, or method name, etc.
+	public boolean isSet = false; // is a set relation from right to leftHand
+	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
+	public boolean isCall = false;
+	List<Tuple<String, String>> relations = new ArrayList<>();
+
+	public Expression(Integer id, Integer parentId) {
+		this.id = id;
+		this.parentId = parentId;
+		
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder s = new StringBuilder();
+		s.append("[").append(text).append("]").append("\n")
+			.append("returnType=").append(returnType).append("\n")
+			.append("var=").append(identifier).append("\n");
+
+		for (Tuple<String, String> item : relations) {
+			s.append(item.y).append("->").append(item.x).append(",");
+		}
+		return s.toString();
+	}
+}
\ No newline at end of file

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -1,9 +1,10 @@
 package depends.entity.types;
 
 import java.util.UUID;
-import depends.entity.Entity;
 
-public class AnonymousBlock extends Entity{
+import depends.entity.ContainerEntity;
+
+public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock( int parentId, Integer id) {
     	super(UUID.randomUUID().toString(),  parentId, id);
 	}

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -2,9 +2,9 @@ package depends.entity.types;
 
 import java.util.HashMap;
 
-import depends.entity.Entity;
+import depends.entity.ContainerEntity;
 
-public class FileEntity extends Entity{
+public class FileEntity extends ContainerEntity{
 	HashMap<String,String> importedNames = new HashMap<>();
 	public FileEntity(String fullName, int fileId) {
 		super(fullName, -1,fileId);

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -1,8 +1,8 @@
 package depends.entity.types;
 
-import depends.entity.Entity;
+import depends.entity.ContainerEntity;
 
-public class FunctionEntity extends Entity{
+public class FunctionEntity extends ContainerEntity{
 	private String returnType;
 	private String shortName;
 	public String getShortName() {

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -1,8 +1,8 @@
 package depends.entity.types;
 
-import depends.entity.Entity;
+import depends.entity.ContainerEntity;
 
-public class TypeEntity extends Entity{
+public class TypeEntity extends ContainerEntity{
 
 	public TypeEntity(String fullName,  int parentId, Integer id) {
 		super(fullName,parentId,id);

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -2,7 +2,9 @@ package depends.extractor;
 
 import java.util.Stack;
 
+import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.Expression;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.FunctionEntity;
@@ -98,11 +100,11 @@ public class HandlerContext{
         entityStack.push(currentFunctionEntity);
 		return currentFunctionEntity;
 	}
-	public Entity currentType() {
+	public TypeEntity currentType() {
 		for (int i=entityStack.size()-1;i>=0;i--) {
 			Entity t = entityStack.get(i);
 			if (t instanceof TypeEntity)
-				return t;
+				return (TypeEntity)t;
 		}
 		return null;
 	}
@@ -136,27 +138,38 @@ public class HandlerContext{
 		VarEntity varEntity = new VarEntity(varName, type, lastContainer().getId(), entityRepo.getCurrentIndex());
 		lastContainer().addVar(varEntity);
 	}
-	public Entity lastContainer() {
-		return entityStack.peek();
+	public ContainerEntity lastContainer() {
+		for (int i=entityStack.size()-1;i>=0;i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof ContainerEntity)
+				return (ContainerEntity)t;
+		}
+		return null;
 	}
+	
 	public String inferType(String varName) {
 		for (int i=entityStack.size()-1;i>=0;i--) {
 			Entity t = entityStack.get(i);
-			for (VarEntity var:t.getVars()) {
-				if (var.getFullName().equals(varName)){
-					return var.getType();
+			if (t instanceof ContainerEntity) {
+				for (VarEntity var:((ContainerEntity)t).getVars()) {
+					if (var.getFullName().equals(varName)){
+						return var.getType();
+					}
 				}
 			}
 		}
 		return null;
 	}
+	
 	public String inferVarType(String fromType, String varName) {
 		Entity type = entityRepo.getEntity(fromType);
 		if (type==null) return null;
 		if (!(type instanceof TypeEntity)) return null;
-		for (VarEntity var:type.getVars()) {
-			if (var.getFullName().equals(varName))
-				return var.getType();
+		if (type instanceof ContainerEntity) {
+			for (VarEntity var:((ContainerEntity)type).getVars()) {
+				if (var.getFullName().equals(varName))
+					return var.getType();
+			}
 		}
 		return null;
 	}
@@ -173,5 +186,8 @@ public class HandlerContext{
 		}
 		return null;
 	}
-
+	public void addExpression(Expression d) {
+		// TODO Auto-generated method stub
+		
+	}
 }
\ No newline at end of file

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -1,59 +1,30 @@
 package depends.extractor.java.context;
 
-import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.List;
+import java.util.UUID;
 
 import org.antlr.v4.runtime.RuleContext;
 
 import depends.deptypes.DependencyType;
+import depends.entity.ContainerEntity;
+import depends.entity.Expression;
+import depends.entity.repo.EntityRepo;
 import depends.extractor.GenericHandler;
 import depends.javaextractor.JavaParser.ExpressionContext;
 import depends.javaextractor.JavaParser.PrimaryContext;
 import depends.util.Tuple;
 
 public class ExpressionUsage {
-	class Expression {
-		String text; //for debug purpose
-		String returnType; //the type we care
-		String identifier;        //the varName, or method name, etc.
-		boolean isSet = false; //is a set relation from right to leftHand
-		boolean isDot = false; //is a dot expression, will decuce variable tfype left to right
-		boolean isCall = false;
-		
-		List<Tuple<String, String>> relations = new ArrayList<>();
-
-		@Override
-		public String toString() {
-			StringBuilder s = new StringBuilder();
-			s.append("[").append(text).append("]").append("\n")
-					.append("set=").append(isSet).append("\n")
-					.append("dot=").append(isDot).append("\n")
-					.append("isCall=").append(isCall).append("\n")
-					.append("type=").append(returnType).append("\n")
-					.append("var=").append(identifier).append("\n");
-			
-			for (Tuple<String, String> item : relations) {
-				s.append(item.y).append("->").append(item.x).append(",");
-			}
-			return s.toString();
-		}
-	}
-
 	GenericHandler handler;
-	HashMap<RuleContext, Expression> data;
-
 	public ExpressionUsage(GenericHandler handler) {
 		this.handler = handler;
-		data = new HashMap<>();
 	}
 
 	public void foundExpression(ExpressionContext ctx) {
-		System.out.println("enter "+ctx.getText());
-		if (ctx.creator()!=null)
-			System.out.println("creator:"+ctx.creator().getText());
-		Expression d = new Expression();
-		d.text = ctx.getText();
+		RuleContext parent = findParentInStack(ctx);
+		Expression d = new Expression(ctx.hashCode(),parent==null?null:parent.hashCode());
+		handler.context().lastContainer().addExpression(d);
+		d.text = ctx.getText(); //for debug purpose. no actual effect
 		Tuple<String, String> nodeInfo = getExpressionType(ctx);
 		if (nodeInfo!=null) {
 			d.returnType = nodeInfo.x;
@@ -61,29 +32,30 @@ public class ExpressionUsage {
 		}
 		if (d.identifier==null && ctx.IDENTIFIER()!=null)
 			d.identifier = ctx.IDENTIFIER().getText();
-		else if (d.identifier==null && ctx.methodCall()!=null)
-			d.identifier = ctx.methodCall().IDENTIFIER().getText();
+		else if (d.identifier==null && ctx.methodCall()!=null) {
+			if (ctx.methodCall().THIS()!=null) {
+				d.identifier = "this";
+			}else if (ctx.methodCall().SUPER()!=null) {
+				d.identifier = "super";
+			}else {
+				d.identifier = ctx.methodCall().IDENTIFIER().getText();
+			}
+		}
 		else if (d.identifier==null && (ctx.NEW()!=null && ctx.creator()!=null)){
 			d.identifier = ctx.creator().createdName().IDENTIFIER(0).getText();
 		}
 		d.isDot = isDot(ctx);
 		d.isSet = isSet(ctx);
 		d.isCall = ctx.methodCall()==null?false:true;
-		data.put(ctx, d);
-		updateParentType(ctx,d.returnType);
-	}
-
-	public void commitAllExpressionUsage() {
-		for (RuleContext item : data.keySet()) {
-			Expression value = data.get(item);
-			if (value.isSet) {
-				handler.addRelation(value.returnType, DependencyType.RELATION_SET);
-			}
-			System.out.println(value);
-		}
-		data.clear();
+		handler.context().lastContainer().updateParentReturnType(d.id,d.returnType,handler.context());
 	}
 
+	/**
+	 * To determine the return type of the expression, 
+	 * @param ctx
+	 * @return Tuple.x -> expression type
+	 *         Tuple.y -> var name (if has)
+	 */
 	public Tuple<String, String> getExpressionType(ExpressionContext ctx) {
 		Tuple<String, String> primaryInfo = getPrimaryType(ctx.primary());
 		if (primaryInfo!=null) return primaryInfo;
@@ -133,38 +105,42 @@ public class ExpressionUsage {
 		String type =null;
 		String varName = "";
 		if (ctx==null) return null;
-		if (ctx.expression()!=null) return null;
+		//1. we only handle leaf node. if there is still expression,
+		//   the type will be determined by child node in the expression
+		if (ctx.expression()!=null) return null; 
 		if (ctx.literal()!=null) {
+		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
 			type = "Built-in";
 			varName = ctx.literal().getText();
 		}else if (ctx.IDENTIFIER()!=null) {
+		//2. if it is a var name, dertermine the type based on context.
 			varName = ctx.IDENTIFIER().getText();
 			type = handler.context().inferType(varName);
 		}else if (ctx.typeTypeOrVoid()!=null) {
+		//3. if given type directly
 			type = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
+		}else if (ctx.THIS()!=null){
+			varName = "this";
+			//TODO: deduce this type
+		}else if (ctx.SUPER()!=null){
+			varName = "super";
+			//TODO: deduce super type
+		}else {
+			System.out.println("TODO: .g4, line 533: nonWildcardTypeArguments (explicitGenericInvocationSuffix | THIS arguments)");
+			System.out.println(ctx.getText());
 		}
 		return new Tuple<String, String> (type,varName);
 	}
 
+
+
 	private RuleContext findParentInStack(RuleContext ctx) {
 		if (ctx==null) return null;
-		if (data.containsKey(ctx.parent)) return ctx.parent;
+		if (ctx.parent==null) return null;
+		if (handler.context().lastContainer()==null) {
+			return null;
+		}
+		if (handler.context().lastContainer().expressions().containsKey(ctx.parent.hashCode())) return ctx.parent;
 		return findParentInStack(ctx.parent);
 	}
-	private void updateParentType(RuleContext ctx, String type) {
-		if (type==null ) return;
-		RuleContext parent = findParentInStack(ctx);
-		if (parent==null) return;
-		System.out.println(parent.getText());
-		Expression d = data.get(parent);
-		if (d==null) return;
-		if (d.returnType!=null) return;
-		if (d.isDot && (!d.isCall))
-			d.returnType = handler.context().inferVarType(handler.context().resolveTypeNameRef(type), d.identifier);
-		else if (d.isDot && d.isCall)
-			d.returnType = handler.context().inferFunctionType(handler.context().resolveTypeNameRef(type),d.identifier);
-		else
-			d.returnType = type;
-		updateParentType(parent,d.returnType);
-	}
 }

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -8,6 +8,8 @@ import org.junit.Test;
 
 import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
+import depends.entity.types.FunctionEntity;
+import depends.entity.types.TypeEntity;
 
 public class JavaVarResolveTest {
 	@Test
@@ -17,7 +19,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         Entity classEntity = repo.getEntity("FieldVar");
-        assertEquals(3,classEntity.getVars().size()); 
+        assertEquals(3,((TypeEntity)classEntity).getVars().size()); 
 	}
 	
 	@Test
@@ -26,8 +28,8 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/LocalVar.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        assertEquals(1,repo.getEntity("LocalVar").getVars().size());
-        assertEquals(2,repo.getEntity("LocalVar.foo").getVars().size());
+        assertEquals(1,((TypeEntity)repo.getEntity("LocalVar")).getVars().size());
+        assertEquals(2,((FunctionEntity)repo.getEntity("LocalVar.foo")).getVars().size());
 	}
 	
 	@Test
@@ -44,10 +46,10 @@ public class JavaVarResolveTest {
 	@Test
 	public void test_field_access_could_be_inferred() throws IOException {
 		EntityRepo repo = new EntityRepo();
-        String src = "./src/test/resources/java-code-examples/FieldAccessInferExample.java";
+        String src = "./src/test/resources/java-code-examples/ComplexExpressionExample.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        assertEquals(13,repo.getEntity("test.FieldAccessInferExample.setExample").getRelations().size());
+        assertEquals(13,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 }

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -8,7 +8,7 @@ class ClassA{
 	int foo();
 }
 
-public class FieldAccessInferExample {
+public class ComplexExpressionExample {
 	void setExample(ClassA a) { 	      //parameter a(1)
 		(new ClassA()).x.m = 3;      //set (newA) x, m (2)
 		a.x.m = 1;                        //set m (1), use a, x? or set a,x?

010ee718f84bebb1e36a87b70e07069d5ccf6b6e
@@ -13,10 +13,9 @@ import depends.entity.types.PackageEntity;
 
 public class EntityRepo {
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
-	public HashMap<Integer, Entity> allEntieisById = new HashMap<>();
+	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
 	
-	
 	public EntityRepo() {
 		nextAvaliableIndex = 0;
 	}
@@ -24,13 +23,13 @@ public class EntityRepo {
 		return allEntieisByName.get(entityName);
 	}
 	public Entity getEntity(Integer entityId) {
-		return allEntieisById.get(entityId);
+		return allEntitiesById.get(entityId);
 	}
 	
 	public void add(Entity entity) {
 		if (!entity.getFullName().isEmpty())
 			allEntieisByName.put(entity.getFullName(),entity);
-		allEntieisById.put(entity.getId(), entity);
+		allEntitiesById.put(entity.getId(), entity);
 	}
 	
 	public void updateEntityNameIndex(String oldName, String newName, Entity entity) {
@@ -44,9 +43,9 @@ public class EntityRepo {
 	}
 	
 	public Collection<Entity> getEntities() {
-		return allEntieisById.values();
+		return allEntitiesById.values();
 	}
-	public Integer getCurrentIndex() {
+	public Integer generateId() {
 		return nextAvaliableIndex++;
 	}
 
@@ -63,7 +62,7 @@ public class EntityRepo {
 	
 	public Set<String> resolveAllBindings() {
     	HashSet<String> unsolved = new HashSet<>();
-        for (Entity entity:allEntieisByName.values()) {
+        for (Entity entity:allEntitiesById.values()) {
         	Set<String> u = entity.resolveBinding(this);
 			unsolved.addAll(u);
         }

010ee718f84bebb1e36a87b70e07069d5ccf6b6e
@@ -4,7 +4,6 @@ import java.util.Stack;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.Expression;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.FunctionEntity;
@@ -23,7 +22,7 @@ public class HandlerContext{
 		entityStack = new Stack<Entity>();
 	}
 	public FileEntity newFileEntity(String fileName) {
-		currentFileEntity = new FileEntity(fileName,entityRepo.getCurrentIndex());
+		currentFileEntity = new FileEntity(fileName,entityRepo.generateId());
         entityStack.push(currentFileEntity);
 		return currentFileEntity;
 	}
@@ -33,7 +32,7 @@ public class HandlerContext{
 		Entity pkgEntity = entityRepo.getEntity(packageName);
 		if (pkgEntity ==null) {
 			pkgEntity = new PackageEntity(packageName,-1,
-				entityRepo.getCurrentIndex());
+				entityRepo.generateId());
 		}
 		currentFileEntity.setParentId(pkgEntity.getId());
 		pkgEntity.addChildId(currentFileEntity.getId());
@@ -64,7 +63,7 @@ public class HandlerContext{
 	public Entity newClassInterface(String classOrInterfaceName) {
 		Entity currentTypeEntity = new TypeEntity(resolveTypeNameDefinition(classOrInterfaceName),
 				currentFileEntity.getId(),
-				entityRepo.getCurrentIndex());
+				entityRepo.generateId());
         entityRepo.add(currentTypeEntity);
         entityStack.push(currentTypeEntity);
 		return currentTypeEntity;
@@ -95,7 +94,7 @@ public class HandlerContext{
 		//TODO: should process parameter types to distinguish the overload functions for short name;
 		FunctionEntity currentFunctionEntity = new FunctionEntity(resolveTypeNameDefinition(methodName),
 				currentType().getId(),
-				entityRepo.getCurrentIndex(),resultType,methodName);
+				entityRepo.generateId(),resultType,methodName);
 		currentType().addFunction(currentFunctionEntity);
         entityStack.push(currentFunctionEntity);
 		return currentFunctionEntity;
@@ -135,7 +134,7 @@ public class HandlerContext{
 	}
 	
 	public void addVar(String type, String varName) {
-		VarEntity varEntity = new VarEntity(varName, type, lastContainer().getId(), entityRepo.getCurrentIndex());
+		VarEntity varEntity = new VarEntity(varName, type, lastContainer().getId(), entityRepo.generateId());
 		lastContainer().addVar(varEntity);
 	}
 	public ContainerEntity lastContainer() {
@@ -147,7 +146,7 @@ public class HandlerContext{
 		return null;
 	}
 	
-	public String inferType(String varName) {
+	public String inferVarType(String varName) {
 		for (int i=entityStack.size()-1;i>=0;i--) {
 			Entity t = entityStack.get(i);
 			if (t instanceof ContainerEntity) {
@@ -186,8 +185,4 @@ public class HandlerContext{
 		}
 		return null;
 	}
-	public void addExpression(Expression d) {
-		// TODO Auto-generated method stub
-		
-	}
 }
\ No newline at end of file

010ee718f84bebb1e36a87b70e07069d5ccf6b6e
@@ -1,14 +1,8 @@
 package depends.extractor.java.context;
 
-import java.util.HashMap;
-import java.util.UUID;
-
 import org.antlr.v4.runtime.RuleContext;
 
-import depends.deptypes.DependencyType;
-import depends.entity.ContainerEntity;
 import depends.entity.Expression;
-import depends.entity.repo.EntityRepo;
 import depends.extractor.GenericHandler;
 import depends.javaextractor.JavaParser.ExpressionContext;
 import depends.javaextractor.JavaParser.PrimaryContext;
@@ -115,7 +109,7 @@ public class ExpressionUsage {
 		}else if (ctx.IDENTIFIER()!=null) {
 		//2. if it is a var name, dertermine the type based on context.
 			varName = ctx.IDENTIFIER().getText();
-			type = handler.context().inferType(varName);
+			type = handler.context().inferVarType(varName);
 		}else if (ctx.typeTypeOrVoid()!=null) {
 		//3. if given type directly
 			type = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -0,0 +1,12 @@
+package depends.entity;
+
+import depends.entity.types.FunctionEntity;
+import depends.entity.types.VarEntity;
+
+public interface BindingResolver {
+
+	FunctionEntity resolveFunctionBindings(Entity theContainer, String varName);
+
+	VarEntity resolveVarBindings(Entity theContainer, String varName);
+
+}

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -1,23 +1,42 @@
 package depends.entity;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 
+import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
+import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
-import depends.extractor.HandlerContext;
 
 public abstract class ContainerEntity extends Entity {
 
     ArrayList<VarEntity> vars;
     ArrayList<FunctionEntity> functions;
-	HashMap<Integer, Expression> expressions;
 
-	public ContainerEntity(String fullName, int parentId, Integer id) {
-		super(fullName, parentId, id);
+    HashMap<Integer, Expression> expressions;
+    Collection<String> typeParameters;      //Generic type parameters like <T>, <String>, <? extends Object>
+	Collection<String> annotations = new ArrayList<>();
+    Collection<TypeEntity> resolvedTypeParameters= new ArrayList<>();
+    Collection<TypeEntity> resolvedAnnotations= new ArrayList<>();
+    
+	public void addAnnotation(String name) {
+		this.annotations.add(name);
+	}
+	
+
+
+	public ContainerEntity(String rawName, Entity parent, Integer id) {
+		super(rawName, parent, id);
 		vars = new ArrayList<>();
 		functions = new ArrayList<>();
 		expressions = new HashMap<>();
+		typeParameters = new ArrayList<>();
+	}
+	
+	public void addTypeParameter(String typeName) {
+		this.typeParameters.add(typeName);
 	}
 	
 	public void addVar(VarEntity var) {
@@ -32,6 +51,7 @@ public abstract class ContainerEntity extends Entity {
 		this.functions.add(functionEntity);
 	}
 	
+
 	public ArrayList<FunctionEntity> getFunctions() {
 		return this.functions;
 	}
@@ -54,20 +74,45 @@ public abstract class ContainerEntity extends Entity {
 	 * @param ctx
 	 * @param type
 	 */
-	public void updateParentReturnType(Integer id, String type, HandlerContext context) {
+	public void updateParentReturnType(Integer expressionId, TypeEntity type, EntityRepo bindingResolver) {
 		if (type==null ) return;
-		Expression thisExpression = expressions.get(id);
+		Expression thisExpression = expressions.get(expressionId);
 		if (thisExpression==null) return;
-		Expression d = expressions.get(thisExpression.parentId);
-		if (d==null) return;
-		if (d.returnType!=null) return;
-		if (d.isDot && (!d.isCall))
-			d.returnType = context.inferVarType(context.resolveTypeNameRef(type), d.identifier);
-		else if (d.isDot && d.isCall)
-			d.returnType = context.inferFunctionType(context.resolveTypeNameRef(type),d.identifier);
+		Expression parentExpression = expressions.get(thisExpression.parentId);
+		if (parentExpression==null) return;
+		if (parentExpression.returnType!=null) return;
+		if (parentExpression.isDot && (!parentExpression.isCall)){
+			VarEntity returnType = bindingResolver.resolveVarBindings(type, parentExpression.identifier);
+			if (returnType!=null)
+				parentExpression.returnType = returnType.getType();
+		}
+		else if (parentExpression.isDot && parentExpression.isCall){
+			FunctionEntity returnType = bindingResolver.resolveFunctionBindings(type,parentExpression.identifier);
+			if (returnType!=null)
+				parentExpression.returnType = returnType.getReturnType();			
+		}
 		else
-			d.returnType = type;
-		updateParentReturnType(d.id,d.returnType,context);
+			parentExpression.returnType = type;
+		updateParentReturnType(parentExpression.id,parentExpression.returnType,bindingResolver);
+	}
+
+	public Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer,Collection<String> identifiers) {
+		ArrayList<TypeEntity> r = new ArrayList<>();
+
+		for (String typeParameter:identifiers) {
+			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter);
+			if (typeEntity!=null)
+				r.add(typeEntity);
+		}
+		return r;
+	}
+
+	public  void inferLocalLevelTypes(TypeInfer typeInferer){
+		resolvedTypeParameters= identiferToTypes(typeInferer,typeParameters);
+		resolvedAnnotations= identiferToTypes(typeInferer,annotations);
+		for (VarEntity var:this.vars) {
+			var.inferLocalLevelTypes(typeInferer);
+		}
 	}
 
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -2,35 +2,54 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 
 import depends.entity.repo.EntityRepo;
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.VarEntity;
 
 public abstract class Entity {
-	protected int id=-1;
-	protected String fullName = "";
-
-	protected int parentId=-1;
-    protected ArrayList<Integer> childrenIds = new ArrayList<>();
-    
-    protected ArrayList<Relation> relations = new ArrayList<>();
-    
-    public Entity(String fullName, int parentId, Integer id) {
-		this.fullName = fullName;
-		this.setParentId(parentId);
+	int id=-1;
+	String qualifiedName = null;
+	String rawName = "";
+	Entity parent;
+	ArrayList<Entity> children = new ArrayList<>();
+    ArrayList<Relation> relations = new ArrayList<>();
+
+	
+    public Entity(String rawName, Entity parent, Integer id) {
+		this.qualifiedName = null;
+		this.rawName = rawName;
+		this.parent = parent;
 		this.setId(id);
+		deduceQualifiedName();
 	}
 
-	public void setFileId(int fileId) {
-	}
+	private void deduceQualifiedName() {
+		if (this.rawName.contains(".")) {
+			this.qualifiedName = this.rawName;
+			return; //already qualified
+		}
+		if (parent==null) {
+			this.qualifiedName = this.rawName;
+			return;
+		}
+		if (parent.getQualifiedName()==null) {
+			this.qualifiedName = this.rawName;
+			return;
+		}
+		if (parent.getQualifiedName().isEmpty()) {
+			this.qualifiedName = rawName;
+			return;
+		}
+		this.qualifiedName= parent.getQualifiedName()+"." + rawName;
 
-	public String getFullName() {
-		return fullName;
 	}
 
 
+	public String getRawName() {
+		return rawName;
+	}
+
 
     public int getId() {
         return id;
@@ -40,14 +59,6 @@ public abstract class Entity {
         this.id = id;
     }
 
-    public int getParentId() {
-        return parentId;
-    }
-
-    public void setParentId(int parentId) {
-        this.parentId = parentId;
-    }
-
     public void addRelation(Relation relation) {
         relations.add(relation);
     }
@@ -60,25 +71,8 @@ public abstract class Entity {
         return relations;
     }
 
-    public void addChildId(Integer id) {
-        childrenIds.add(id);
-    }
-
-    public ArrayList<Integer> getChildrenIds() {
-        return childrenIds;
-    }
-
-    @Override
-    public String toString() {
-        String str = "";
-        str += "\n(";
-        str += ("name:" + fullName + ',');
-        str += ("id:" + id + ',');
-        str += ("parentId:" + parentId + ",");
-        str += ("childrenIds:" + childrenIds + ",");
-        str += ("relations:" + relations);
-        str += ")\n";
-        return str;
+    public void addChild(Entity child) {
+        children.add(child);
     }
 
 	public Set<String> resolveBinding(EntityRepo registry) {
@@ -96,4 +90,39 @@ public abstract class Entity {
 		}
 		return unsolved;
 	}
+
+	public Entity getParent() {
+		return parent;
+	}
+
+	public void setParent(Entity parent) {
+		this.parent = parent;
+	}
+	
+	public List<Entity> getChildren() {
+		return children;
+	}
+	
+	public void setQualifiedName(String qualifiedName) {
+		this.qualifiedName = qualifiedName;
+	}
+
+	public String getQualifiedName() {
+		return qualifiedName;
+	}
+
+	public void inferTypes(TypeInfer typeInferer) {
+		inferLocalLevelTypes(typeInferer);
+		for (Entity child:children) {
+			child.inferTypes(typeInferer);
+		}
+	}
+	public abstract void inferLocalLevelTypes(TypeInfer typeInferer);
+
+	@Override
+	public String toString() {
+		return "Entity [id=" + id + ", qualifiedName=" + qualifiedName + ", rawName=" + rawName + "]";
+	}
+	
+	
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -3,6 +3,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.List;
 
+import depends.entity.types.TypeEntity;
 import depends.util.Tuple;
 
 public class Expression {
@@ -10,7 +11,8 @@ public class Expression {
 	public Integer parentId;
 	
 	public String text; // for debug purpose
-	public String returnType; // the type we care
+	public TypeEntity returnType; // the type we care
+	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
 	public boolean isSet = false; // is a set relation from right to leftHand
 	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -12,6 +12,13 @@ public class Relation {
 		this.type = type;
 		this.toId = fileId;
 	}
+	
+	public Relation(String type, Integer fileId,String rhsFullName) {
+		this.type = type;
+		this.toId = fileId;
+		this.toFullName = rhsFullName;
+	}
+	
 	public String getType() {
 		return type;
 	}

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -4,21 +4,35 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 
 import depends.deptypes.DependencyType;
+import depends.entity.BindingResolver;
+import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.IdGenerator;
 import depends.entity.Relation;
+import depends.entity.TypeInfer;
+import depends.entity.types.FileEntity;
+import depends.entity.types.FunctionEntity;
 import depends.entity.types.PackageEntity;
+import depends.entity.types.TypeEntity;
+import depends.entity.types.VarEntity;
+import depends.extractor.FileParser;
 
-public class EntityRepo {
+public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
+	private FileParser buildInProcessor = new NullBuildInProcessor();
+	private TypeEntity buildInType;
 	
 	public EntityRepo() {
 		nextAvaliableIndex = 0;
+		buildInType = new TypeEntity("built-in", null, -1);
 	}
+	
 	public Entity getEntity(String entityName) {
 		return allEntieisByName.get(entityName);
 	}
@@ -27,9 +41,11 @@ public class EntityRepo {
 	}
 	
 	public void add(Entity entity) {
-		if (!entity.getFullName().isEmpty())
-			allEntieisByName.put(entity.getFullName(),entity);
 		allEntitiesById.put(entity.getId(), entity);
+		if (entity.getQualifiedName()!=null)
+			allEntieisByName.put(entity.getQualifiedName(), entity);
+		if (entity.getParent()!=null)
+			this.setParent(entity, entity.getParent());
 	}
 	
 	public void updateEntityNameIndex(String oldName, String newName, Entity entity) {
@@ -45,6 +61,8 @@ public class EntityRepo {
 	public Collection<Entity> getEntities() {
 		return allEntitiesById.values();
 	}
+	
+	@Override
 	public Integer generateId() {
 		return nextAvaliableIndex++;
 	}
@@ -53,7 +71,10 @@ public class EntityRepo {
 		Entity e = this.getEntity(entityId);
 		if (e==null) throw new EntityNotExistsException(entityId);
 		while (!e.getClass().equals(classType)) {
-			e = this.getEntity(e.getParentId());
+			if (e.getParent()==null) {
+				throw new NoRequestedTypeOfAncestorExistsException(entityId,classType);
+			}
+			e = this.getEntity(e.getParent().getId());
 			if (e==null) break;
 		}
 		if (e==null) throw new NoRequestedTypeOfAncestorExistsException(entityId,classType);
@@ -61,6 +82,8 @@ public class EntityRepo {
 	}
 	
 	public Set<String> resolveAllBindings() {
+		inferTypes();
+		computeRelations();
     	HashSet<String> unsolved = new HashSet<>();
         for (Entity entity:allEntitiesById.values()) {
         	Set<String> u = entity.resolveBinding(this);
@@ -70,29 +93,217 @@ public class EntityRepo {
 
 	}
 
-	/**
-	 * note: import package.* means that it depends on all files of the package. it is not a suggested practices;
-	 * so we expends the import relations to all files under the package
-	 */
-	public void expendsPackageImports() {
-        for (Entity entity:allEntieisByName.values()) {
-        	ArrayList<Relation> expendedRelations = new ArrayList<>();
-        	for (Relation r:entity.getRelations()) {
-        		if (!r.getType().equals(DependencyType.RELATION_IMPORT))continue;
-        		if (r.getToId()<0) continue;
-        		if (!(this.getEntity(r.getToId()) instanceof PackageEntity)) continue;
-        		Entity pkg = this.getEntity(r.getToId());
-        		for (Integer fileId: pkg.getChildrenIds()) {
-        			expendedRelations.add(new Relation(DependencyType.RELATION_IMPORT,fileId));
-        		}
-        	}
-        	entity.addRelations(expendedRelations);
-        }
+	private void inferTypes() {
+		for (Entity entity:allEntitiesById.values()) {
+			if (!(entity instanceof FileEntity)) continue;
+			entity.inferTypes(this);
+		}
+	}
+	private void computeRelations() {
+		for (Entity entity:allEntitiesById.values()) {
+			if (entity instanceof FileEntity) {
+				computeImports((FileEntity)entity);
+			}
+			if (entity instanceof FunctionEntity) {
+				computeFunctionRelations((FunctionEntity)entity);
+			}
+			if (entity instanceof TypeEntity) {
+				computeTypeRelations((TypeEntity)entity);
+			}
+			if (entity instanceof ContainerEntity) {
+				computeContainerRelations((ContainerEntity)entity);
+			}
+		}
+	}
+
+	
+	private void computeContainerRelations(ContainerEntity entity) {
+		for (VarEntity var:entity.getVars()) {
+			if (var.getType()!=null)
+				entity.addRelation(new Relation(DependencyType.RELATION_DEFINE,var.getType().getId(),var.getType().getQualifiedName()));
+			else
+				System.out.println("cannot resove type of "+var.getQualifiedName());
+		}
+	}
+
+	private void computeTypeRelations(TypeEntity type) {
+		for (TypeEntity superType:type.getInheritedTypes()) {
+			type.addRelation(new Relation(DependencyType.RELATION_INHERIT,superType.getId(),superType.getQualifiedName()));
+		}
+		for (TypeEntity interfaceType:type.getImplementedTypes()) {
+			type.addRelation(new Relation(DependencyType.RELATION_IMPLEMENT,interfaceType.getId(),interfaceType.getQualifiedName()));
+		}
+	}
+
+	private void computeFunctionRelations(FunctionEntity func) {
+		for (TypeEntity returnType:func.getReturnTypes()) {
+			func.addRelation(new Relation(DependencyType.RELATION_RETURN,returnType.getId(),returnType.getQualifiedName()));
+		}
+		for (VarEntity parameter:func.getParameters()) {
+			if (parameter.getType()!=null) {
+				func.addRelation(new Relation(DependencyType.RELATION_PARAMETER,parameter.getType().getId(),parameter.getType().getQualifiedName()));
+			}else {
+				System.out.println("unsolved param: "+parameter);
+			}
+		}
+		for (TypeEntity throwType:func.getThrowTypes()) {
+			func.addRelation(new Relation(DependencyType.RELATION_USE,throwType.getId(),throwType.getQualifiedName()));
+		}
+	}
+
+	private void computeImports(FileEntity file) {
+		Collection<String> imports = file.imports();
+		List<Integer> importedIds = new ArrayList<>();
+		for (String item:imports) {
+			if (this.buildInProcessor.isBuiltInTypePrefix(item)) continue;
+			Entity imported = this.getEntity(item);
+			if (imported==null) {
+				System.out.println("imported cannot be resolved: " + file.getQualifiedName() + "->" + item);
+				continue;
+			}
+			if (imported instanceof PackageEntity) { 
+				//expand import of package to all classes under the package due to we dis-courage the behavior
+				for (Entity child:imported.getChildren()) {
+					importedIds.add(child.getId());
+				}
+			}else {
+				importedIds.add(imported.getId());
+			}
+		}
+		for (Integer id:importedIds) {
+			file.addRelation(new Relation(DependencyType.RELATION_IMPORT,id));
+		}
 	}
 	
 	public void addRelation(int theEntityId, String entityFullName, String relationType) {
 	        getEntity(theEntityId).addRelation(new Relation(relationType,entityFullName));
 	}
+	
+	@Override
+	public String inferQualifiedName(Entity theEntity, String rawTypeName) {
+		if (rawTypeName.isEmpty()) return "";
+		String prefix = "";
+		while (theEntity!=null) {
+			if (theEntity instanceof FileEntity) continue; //file name should be bypass. use package name instead 
+			if(theEntity.getQualifiedName()!=null &&
+					theEntity.getQualifiedName().length()>0 &&
+					!(theEntity.getQualifiedName().startsWith("<Anony>"))) {
+				prefix = theEntity.getQualifiedName();
+				break;
+			}
+			theEntity = theEntity.getParent();
+		}
+		if (prefix.isEmpty()) {
+			return rawTypeName;
+		}else {
+			return  prefix + "." + rawTypeName;
+		}
+	}
+	
+	
+	@Override
+	public VarEntity resolveVarBindings(Entity theContainer, String varName) {
+		while(theContainer!=null) {
+			if (theContainer instanceof ContainerEntity) {
+				for (VarEntity var:((ContainerEntity)theContainer).getVars()) {
+					if (var.getRawName().equals(varName))
+						return var;
+				}
+			}
+			theContainer = theContainer.getParent();
+		}
+		return null;
+	}
 
+	@Override
+	public FunctionEntity resolveFunctionBindings(Entity theContainer, String varName) {
+		while(theContainer!=null) {
+			if (theContainer instanceof TypeEntity) {
+				for (FunctionEntity var:((TypeEntity)theContainer).getFunctions()) {
+					if (var.getRawName().equals(varName))
+						return var;
+				}
+			}
+			theContainer = theContainer.getParent();
+		}
+		return null;
+	}
+	
+	public void setParent(Entity child, Entity parent) {
+		child.setParent(parent);
+		parent.addChild(child);
+	}
+	
+	@Override
+	public TypeEntity inferType(Entity fromEntity, String rawName) {
+		if (buildInProcessor.isBuiltInType(rawName)) return buildInType();
+		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType();
+		
+		if (fromEntity==null) return null;
+		TypeEntity type = null;
+		if (rawName.contains(".")) {
+			return getTypeEntityByFullName(rawName);
+		}
+		while(true) {
+			if (fromEntity instanceof TypeEntity) {
+				if (fromEntity.getRawName().equals(rawName))
+					return (TypeEntity)fromEntity;
+			}
+			if (fromEntity instanceof FileEntity) {
+				String importedFullName = ((FileEntity)fromEntity).getImport(rawName);
+				if (importedFullName!=null)
+					return getTypeEntityByFullName(importedFullName);
+				type = this.getTypeEntityUnder(rawName,fromEntity);
+				if(type!=null) return type;
+			}
+			if (fromEntity instanceof PackageEntity){
+				type = this.getTypeEntityUnder(rawName,fromEntity);
+				if(type!=null) return type;
+			}
+			fromEntity = fromEntity.getParent();
+			if (fromEntity==null) break;
+		}
+		if (type==null) {
+			System.out.println("cannot infer type of " + rawName);
+		}
+		return type;
+	}
+	private TypeEntity buildInType() {
+		return this.buildInType;
+	}
+	private TypeEntity getTypeEntityByFullName(String rawName) {
+		if (buildInProcessor.isBuiltInType(rawName)) return buildInType();
+		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType();
+		Entity entity = this.getEntity(rawName);
+		if (entity instanceof TypeEntity) {
+			return (TypeEntity)entity;
+		}
+		if (entity instanceof PackageEntity) {
+			return getTypeEntityUnder(rawName, entity);
+		}
+		return null;
+	}
+	private TypeEntity getTypeEntityUnder(String rawName, Entity entity) {
+		for (Entity level_1:entity.getChildren()) {
+			if (level_1 instanceof TypeEntity) {
+				if (level_1.getRawName().equals(rawName)) {
+					return (TypeEntity)level_1;
+				}
+			}
+			for (Entity level_2:level_1.getChildren()) {
+				if (level_2 instanceof TypeEntity) {
+					if (level_2.getRawName().equals(rawName)) {
+						return (TypeEntity)level_2;
+					}
+				}
+			}
+		}
+		return null;
+	}
+	
+	@Override
+	public void addBuiltIn(FileParser fileParser) {
+		this.buildInProcessor = fileParser;
+	}
 
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -3,9 +3,10 @@ package depends.entity.types;
 import java.util.UUID;
 
 import depends.entity.ContainerEntity;
+import depends.entity.Entity;
 
 public class AnonymousBlock extends ContainerEntity{
-    public AnonymousBlock( int parentId, Integer id) {
-    	super(UUID.randomUUID().toString(),  parentId, id);
+    public AnonymousBlock(Entity parent, Integer id) {
+    	super(UUID.randomUUID().toString(),  parent, id);
 	}
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -1,5 +1,6 @@
 package depends.entity.types;
 
+import java.util.Collection;
 import java.util.HashMap;
 
 import depends.entity.ContainerEntity;
@@ -7,7 +8,8 @@ import depends.entity.ContainerEntity;
 public class FileEntity extends ContainerEntity{
 	HashMap<String,String> importedNames = new HashMap<>();
 	public FileEntity(String fullName, int fileId) {
-		super(fullName, -1,fileId);
+		super(fullName, null,fileId);
+		setQualifiedName(fullName);
 	}
 	public void addImport(String importedTypeOrPackage) {
 		String lastName = importedTypeOrPackage;
@@ -18,4 +20,16 @@ public class FileEntity extends ContainerEntity{
 	public String getImport(String lastName) {
 		return importedNames.get(lastName);
 	}
+	@Override
+	public String getQualifiedName() {
+		if (this.getParent()==null)
+			return "";
+		if (this.getParent() instanceof PackageEntity)
+			return this.getParent().getQualifiedName();
+		else
+			return super.getQualifiedName();
+	}
+	public Collection<String> imports() {
+		return importedNames.values();
+	}
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -1,26 +1,59 @@
 package depends.entity.types;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
 import depends.entity.ContainerEntity;
+import depends.entity.Entity;
+import depends.entity.TypeInfer;
 
 public class FunctionEntity extends ContainerEntity{
-	private String returnType;
-	private String shortName;
-	public String getShortName() {
-		return shortName;
-	}
+	private List<String> returnTypeIdentifiers;
+	Collection<VarEntity> parameters;
+    Collection<String> throwTypesIdentifiers; 
+	private Collection<TypeEntity> returnTypes;
+	private TypeEntity returnType;
+	private Collection<TypeEntity> throwTypes;
 
-	public String getReturnType() {
+    public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType, Collection<VarEntity> parameters) {
+		super(simpleName, parent,id);
+		this.returnTypes = new ArrayList<>();
+		returnTypeIdentifiers = new ArrayList<>();
+		this.parameters = parameters;
+		throwTypesIdentifiers = new ArrayList<>();
+		addReturnType(returnType);
+	}
+	public Collection<TypeEntity> getReturnTypes() {
+		return returnTypes;
+	}
+	
+	public TypeEntity getReturnType() {
 		return returnType;
 	}
 
-	public void setReturnType(String returnType) {
-		this.returnType = returnType;
+	public void addReturnType(String returnType) {
+		this.returnTypeIdentifiers.add(returnType);
 	}
-
-	public FunctionEntity(String fullName, int parentId, Integer id, String resultType, String shortName) {
-		super(fullName, parentId,id);
-		this.returnType = resultType;
-		this.shortName = shortName;
+	public void addThrowTypes(List<String> throwedType) {
+		throwTypesIdentifiers.addAll(throwedType);
+	}
+	
+	@Override
+	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+		for (VarEntity param:parameters) {
+			param.inferLocalLevelTypes(typeInferer);
+		}
+		returnTypes= identiferToTypes(typeInferer,this.returnTypeIdentifiers);
+		if (returnTypes.size()>0)
+			returnType = returnTypes.iterator().next();
+		throwTypes= identiferToTypes(typeInferer,this.throwTypesIdentifiers);
+		super.inferLocalLevelTypes(typeInferer);
+	}
+	public Collection<VarEntity> getParameters() {
+		return parameters;
+	}
+	public Collection<TypeEntity> getThrowTypes() {
+		return throwTypes;
 	}
-
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -1,11 +1,40 @@
 package depends.entity.types;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
 import depends.entity.ContainerEntity;
+import depends.entity.Entity;
+import depends.entity.TypeInfer;
 
 public class TypeEntity extends ContainerEntity{
-
-	public TypeEntity(String fullName,  int parentId, Integer id) {
-		super(fullName,parentId,id);
+	Collection<TypeEntity> inheritedTypes;
+	Collection<TypeEntity> implementedTypes;
+	Collection<String> inhertedTypeIdentifiers;
+	Collection<String> implementedIdentifiers;
+ 	public TypeEntity(String simpleName, Entity parent, Integer id) {
+		super(simpleName,parent,id);
+		inhertedTypeIdentifiers = new ArrayList<>();
+		implementedIdentifiers = new ArrayList<>();
+	}
+	@Override
+	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+		inheritedTypes= identiferToTypes(typeInferer,this.inhertedTypeIdentifiers);
+		implementedTypes= identiferToTypes(typeInferer,this.implementedIdentifiers);
+		super.inferLocalLevelTypes(typeInferer);
+	}
+	public void addImplements(String typeName) {
+		this.implementedIdentifiers.add(typeName);
+	}
+	public void addExtends(String typeName) {
+		this.inhertedTypeIdentifiers.add(typeName);
+	}
+	public Collection<TypeEntity> getInheritedTypes() {
+		return inheritedTypes;
+	}
+	
+	public Collection<TypeEntity> getImplementedTypes() {
+		return implementedTypes;
 	}
- 
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -1,18 +1,30 @@
 package depends.entity.types;
 
 import depends.entity.Entity;
+import depends.entity.TypeInfer;
 
 public class VarEntity extends Entity {
+	private String rawType;
+	private TypeEntity type;
+	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
+		super(simpleName,  parent,id);
+		this.rawType = rawType;
+	}
+
+	public String getRawType() {
+		return rawType;
+	}
 
-	private String type;
+	public TypeEntity getType() {
+		return type;
+	}
 
-	public VarEntity(String fullName,  String type, int parentId, int id) {
-		super(fullName,  parentId,id);
+	public void setType(TypeEntity type) {
 		this.type = type;
 	}
 
-	public String getType() {
-		return type;
+	@Override
+	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+		type = typeInferer.inferType(this, rawType);
 	}
-    
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -1,9 +1,12 @@
 package depends.extractor;
 
+import java.util.Collection;
+import java.util.List;
 import java.util.Stack;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.IdGenerator;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.FunctionEntity;
@@ -11,117 +14,83 @@ import depends.entity.types.PackageEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 
-public class HandlerContext{
+public class HandlerContext {
 	private EntityRepo entityRepo;
+	private IdGenerator idGenerator;
+
 	private FileEntity currentFileEntity;
-	private String currentPackageName = "";
 	Stack<Entity> entityStack = new Stack<Entity>();
-	
+
 	public HandlerContext(EntityRepo entityRepo) {
 		this.entityRepo = entityRepo;
+		this.idGenerator = entityRepo;
 		entityStack = new Stack<Entity>();
 	}
-	public FileEntity newFileEntity(String fileName) {
-		currentFileEntity = new FileEntity(fileName,entityRepo.generateId());
-        entityStack.push(currentFileEntity);
+
+	public FileEntity startFile(String fileName) {
+		currentFileEntity = new FileEntity(fileName, idGenerator.generateId());
+		entityStack.push(currentFileEntity);
+		entityRepo.add(currentFileEntity);
 		return currentFileEntity;
 	}
 
-	public Entity newPackageEntity(String packageName) {
-		this.currentPackageName = packageName;
+	public Entity foundNewPackage(String packageName) {
 		Entity pkgEntity = entityRepo.getEntity(packageName);
-		if (pkgEntity ==null) {
-			pkgEntity = new PackageEntity(packageName,-1,
-				entityRepo.generateId());
+		if (pkgEntity == null) {
+			pkgEntity = new PackageEntity(packageName, idGenerator.generateId());
+			entityRepo.add(pkgEntity);
 		}
-		currentFileEntity.setParentId(pkgEntity.getId());
-		pkgEntity.addChildId(currentFileEntity.getId());
+		entityRepo.setParent(currentFileEntity,pkgEntity);
 		return pkgEntity;
 	}
-	
-	private String resolveTypeNameDefinition(String name) {
-		if (name.isEmpty()) return "";
-		String prefix = "";
-		for (int i=entityStack.size()-1;i>=0;i--) {
-			Entity t = entityStack.get(i);
-			if (t instanceof FileEntity) continue; //file name should be bypass. use package name instead 
-			if(! t.getFullName().isEmpty() &&
-					!(t.getFullName().startsWith("<Anony>"))) {
-				prefix = t.getFullName();
-				break;
-			}
-		}
-		if (prefix.isEmpty()) {
-			if (currentPackageName.length()>0)
-				return currentPackageName + "." + name;
-			return name;
-		}else {
-			return  prefix + "." + name;
-		}
-	}
-	
-	public Entity newClassInterface(String classOrInterfaceName) {
-		Entity currentTypeEntity = new TypeEntity(resolveTypeNameDefinition(classOrInterfaceName),
-				currentFileEntity.getId(),
-				entityRepo.generateId());
-        entityRepo.add(currentTypeEntity);
-        entityStack.push(currentTypeEntity);
+
+	public Entity foundNewType(String classOrInterfaceName) {
+		Entity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
+				idGenerator.generateId());
+		entityRepo.add(currentTypeEntity);
+		entityStack.push(currentTypeEntity);
 		return currentTypeEntity;
 	}
-	
-	public void popEntity() {
+
+	public void foundMethodDeclarator(String methodName, Collection<VarEntity> parameters, String returnType, List<String> throwedType) {
+		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
+				idGenerator.generateId(),returnType,parameters);
+		entityRepo.add(functionEntity);
+		entityStack.push(functionEntity);
+		functionEntity.addThrowTypes(throwedType);
+	}
+	public void exitLastedEntity() {
 		entityStack.pop();
 	}
-	
-	public void newImport(String importedTypeOrPackage) {
+
+	public void foundNewImport(String importedTypeOrPackage) {
 		currentFileEntity.addImport(importedTypeOrPackage);
 	}
-	
-	public String resolveTypeNameRef(String typeName) {
-		//if it is a full name like "java.io.Exception"
-		if (typeName.indexOf('.')>0) return typeName;
-		
-		//if it is a singleName like "JavaHandler"
-		// TODO: we still cannot handle on demand import like 
-		// import package.name.*;
-		if (currentFile().getImport(typeName)!=null)
-			typeName = currentFile().getImport(typeName);
-		else
-			typeName = currentPackageName + (currentPackageName.isEmpty()? "":".") + typeName;
-		return typeName;
-	}
-	public Entity newFunctionEntity(String methodName, String resultType) {
-		//TODO: should process parameter types to distinguish the overload functions for short name;
-		FunctionEntity currentFunctionEntity = new FunctionEntity(resolveTypeNameDefinition(methodName),
-				currentType().getId(),
-				entityRepo.generateId(),resultType,methodName);
-		currentType().addFunction(currentFunctionEntity);
-        entityStack.push(currentFunctionEntity);
-		return currentFunctionEntity;
-	}
+
 	public TypeEntity currentType() {
-		for (int i=entityStack.size()-1;i>=0;i--) {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
 			Entity t = entityStack.get(i);
 			if (t instanceof TypeEntity)
-				return (TypeEntity)t;
+				return (TypeEntity) t;
 		}
 		return null;
 	}
-	public Entity currentFunction() {
-		for (int i=entityStack.size()-1;i>=0;i--) {
+
+	public FunctionEntity currentFunction() {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
 			Entity t = entityStack.get(i);
 			if (t instanceof FunctionEntity)
-				return t;
+				return (FunctionEntity) t;
 		}
 		return null;
 	}
-	
+
 	public FileEntity currentFile() {
 		return currentFileEntity;
 	}
-	
+
 	public Entity latestValidContainer() {
-		for (int i=entityStack.size()-1;i>=0;i--) {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
 			Entity t = entityStack.get(i);
 			if (t instanceof FunctionEntity)
 				return t;
@@ -132,57 +101,48 @@ public class HandlerContext{
 		}
 		return null;
 	}
-	
-	public void addVar(String type, String varName) {
-		VarEntity varEntity = new VarEntity(varName, type, lastContainer().getId(), entityRepo.generateId());
-		lastContainer().addVar(varEntity);
-	}
+
 	public ContainerEntity lastContainer() {
-		for (int i=entityStack.size()-1;i>=0;i--) {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
 			Entity t = entityStack.get(i);
 			if (t instanceof ContainerEntity)
-				return (ContainerEntity)t;
+				return (ContainerEntity) t;
 		}
 		return null;
 	}
-	
-	public String inferVarType(String varName) {
-		for (int i=entityStack.size()-1;i>=0;i--) {
-			Entity t = entityStack.get(i);
-			if (t instanceof ContainerEntity) {
-				for (VarEntity var:((ContainerEntity)t).getVars()) {
-					if (var.getFullName().equals(varName)){
-						return var.getType();
-					}
-				}
-			}
-		}
-		return null;
+
+	public void foundAnnotation(String name) {
+		lastContainer().addAnnotation(name);
 	}
-	
-	public String inferVarType(String fromType, String varName) {
-		Entity type = entityRepo.getEntity(fromType);
-		if (type==null) return null;
-		if (!(type instanceof TypeEntity)) return null;
-		if (type instanceof ContainerEntity) {
-			for (VarEntity var:((ContainerEntity)type).getVars()) {
-				if (var.getFullName().equals(varName))
-					return var.getType();
-			}
+
+	public void foundImplements(String typeName) {
+		currentType().addImplements(typeName);
+	}
+
+	public void foundExtends(String typeName) {
+		currentType().addExtends(typeName);
+	}
+
+
+	public void foundTypeParametes(String typeName) {
+		lastContainer().addTypeParameter(typeName);
+	}
+
+
+	public void foundVarDefinition(List<String> varNames, String type) {
+		for (String varName : varNames) {
+			foundVarDefintion(varName,type);
 		}
-		return null;
 	}
 
-	public String inferFunctionType(String fromType, String varName) {
-		Entity type = entityRepo.getEntity(fromType);
-		if (type==null) return null;
-		if (!(type instanceof TypeEntity)) return null;
-		TypeEntity typeEntity = (TypeEntity)type;
-		
-		for (FunctionEntity var:typeEntity.getFunctions()) {
-			if (var.getShortName().equals(varName))
-				return var.getReturnType();
+	public void foundVarDefintion(Collection<VarEntity> vars) {
+		for (VarEntity var : vars) {
+			lastContainer().addVar(var);
 		}
-		return null;
+	}
+
+	public void foundVarDefintion(String varName, String type) {
+		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
+		lastContainer().addVar(var);		
 	}
 }
\ No newline at end of file

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -5,14 +5,14 @@ import java.util.List;
 
 import org.antlr.v4.runtime.RuleContext;
 
-import depends.extractor.java.JavaHandler;
+import depends.extractor.HandlerContext;
 import depends.javaextractor.JavaParser.AnnotationContext;
 
 public class AnnotationProcessor {
-	private JavaHandler handler;
+	private HandlerContext context;
 
-	public AnnotationProcessor(JavaHandler handler) {
-		this.handler = handler;
+	public AnnotationProcessor(HandlerContext context) {
+		this.context = context;
 	}
 	/**
 	 * for any elements who with modifiers like 'public/static/... @Annotation‘，
@@ -62,7 +62,7 @@ public class AnnotationProcessor {
 				if (annotation == null)
 					return;
 				String name = QualitiedNameContextHelper.getName(annotation.qualifiedName());
-				handler.foundAnnotationInUse(name);
+				context.foundAnnotation(name);
 			}
 		} catch (Exception e) {
 			return;

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -3,45 +3,44 @@ package depends.extractor.java.context;
 import org.antlr.v4.runtime.RuleContext;
 
 import depends.entity.Expression;
-import depends.extractor.GenericHandler;
+import depends.extractor.HandlerContext;
 import depends.javaextractor.JavaParser.ExpressionContext;
 import depends.javaextractor.JavaParser.PrimaryContext;
 import depends.util.Tuple;
 
 public class ExpressionUsage {
-	GenericHandler handler;
-	public ExpressionUsage(GenericHandler handler) {
-		this.handler = handler;
+	HandlerContext context;
+	public ExpressionUsage(HandlerContext context) {
+		this.context = context;
 	}
 
 	public void foundExpression(ExpressionContext ctx) {
 		RuleContext parent = findParentInStack(ctx);
-		Expression d = new Expression(ctx.hashCode(),parent==null?null:parent.hashCode());
-		handler.context().lastContainer().addExpression(d);
-		d.text = ctx.getText(); //for debug purpose. no actual effect
+		Expression expression = new Expression(ctx.hashCode(),parent==null?null:parent.hashCode());
+		context.lastContainer().addExpression(expression);
+		expression.text = ctx.getText(); //for debug purpose. no actual effect
 		Tuple<String, String> nodeInfo = getExpressionType(ctx);
 		if (nodeInfo!=null) {
-			d.returnType = nodeInfo.x;
-			d.identifier = nodeInfo.y;
+			expression.rawType = nodeInfo.x;
+			expression.identifier = nodeInfo.y;
 		}
-		if (d.identifier==null && ctx.IDENTIFIER()!=null)
-			d.identifier = ctx.IDENTIFIER().getText();
-		else if (d.identifier==null && ctx.methodCall()!=null) {
+		if (expression.identifier==null && ctx.IDENTIFIER()!=null)
+			expression.identifier = ctx.IDENTIFIER().getText();
+		else if (expression.identifier==null && ctx.methodCall()!=null) {
 			if (ctx.methodCall().THIS()!=null) {
-				d.identifier = "this";
+				expression.identifier = "this";
 			}else if (ctx.methodCall().SUPER()!=null) {
-				d.identifier = "super";
+				expression.identifier = "super";
 			}else {
-				d.identifier = ctx.methodCall().IDENTIFIER().getText();
+				expression.identifier = ctx.methodCall().IDENTIFIER().getText();
 			}
 		}
-		else if (d.identifier==null && (ctx.NEW()!=null && ctx.creator()!=null)){
-			d.identifier = ctx.creator().createdName().IDENTIFIER(0).getText();
+		else if (expression.identifier==null && (ctx.NEW()!=null && ctx.creator()!=null)){
+			expression.identifier = ctx.creator().createdName().IDENTIFIER(0).getText();
 		}
-		d.isDot = isDot(ctx);
-		d.isSet = isSet(ctx);
-		d.isCall = ctx.methodCall()==null?false:true;
-		handler.context().lastContainer().updateParentReturnType(d.id,d.returnType,handler.context());
+		expression.isDot = isDot(ctx);
+		expression.isSet = isSet(ctx);
+		expression.isCall = ctx.methodCall()==null?false:true;
 	}
 
 	/**
@@ -109,7 +108,6 @@ public class ExpressionUsage {
 		}else if (ctx.IDENTIFIER()!=null) {
 		//2. if it is a var name, dertermine the type based on context.
 			varName = ctx.IDENTIFIER().getText();
-			type = handler.context().inferVarType(varName);
 		}else if (ctx.typeTypeOrVoid()!=null) {
 		//3. if given type directly
 			type = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
@@ -131,10 +129,10 @@ public class ExpressionUsage {
 	private RuleContext findParentInStack(RuleContext ctx) {
 		if (ctx==null) return null;
 		if (ctx.parent==null) return null;
-		if (handler.context().lastContainer()==null) {
+		if (context.lastContainer()==null) {
 			return null;
 		}
-		if (handler.context().lastContainer().expressions().containsKey(ctx.parent.hashCode())) return ctx.parent;
+		if (context.lastContainer().expressions().containsKey(ctx.parent.hashCode())) return ctx.parent;
 		return findParentInStack(ctx.parent);
 	}
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -6,50 +6,42 @@ import java.util.List;
 
 import org.antlr.v4.runtime.tree.TerminalNode;
 
+import depends.entity.ContainerEntity;
+import depends.entity.IdGenerator;
+import depends.entity.types.VarEntity;
 import depends.javaextractor.JavaParser.FormalParameterContext;
 import depends.javaextractor.JavaParser.FormalParameterListContext;
 import depends.javaextractor.JavaParser.FormalParametersContext;
 import depends.javaextractor.JavaParser.LastFormalParameterContext;
 import depends.javaextractor.JavaParser.TypeTypeContext;
 import depends.javaextractor.JavaParser.VariableModifierContext;
-import depends.util.Tuple;
 
 public class FormalParameterListContextHelper {
 
-	private FormalParametersContext formalParameters;
 	FormalParameterListContext context;
-
-	List<String> parameterTypes;
-	List<Tuple<String, String>> varList;
+	private IdGenerator idGenerator;
+	List<VarEntity> parameters;
 	private List<String> annotations;
+	private ContainerEntity container;
 
-	public FormalParameterListContextHelper(FormalParametersContext formalParameters) {
-		this.formalParameters = formalParameters;
-		this.context = this.formalParameters.formalParameterList();
-		parameterTypes = new ArrayList<>();
-		varList = new ArrayList<>();
+	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext,ContainerEntity container, IdGenerator idGenerator) {
+		this.context = formalParameterListContext;
+		parameters = new ArrayList<>();
+		this.container = container;
 		annotations = new ArrayList<>();
+		this.idGenerator = idGenerator;
 		if (context!=null)
 			extractParameterTypeList();
 	}
 
-	public Collection<String> getParameterTypeList(){
-		return parameterTypes;
-	}
-	public Collection<Tuple<String, String>> getVarList(){
-		return varList;
+	public FormalParameterListContextHelper(FormalParametersContext formalParameters,ContainerEntity container, IdGenerator idGenerator) {
+		this(formalParameters.formalParameterList(),container,idGenerator);
 	}
 
-	
-	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext) {
-		this.context = formalParameterListContext;
-		parameterTypes = new ArrayList<>();
-		varList = new ArrayList<>();
-		annotations = new ArrayList<>();
-		if (context!=null)
-			extractParameterTypeList();
-	}
 
+	public Collection<VarEntity> getParameterList(){
+		return parameters;
+	}
 
 	public void extractParameterTypeList() {
 		if (context != null) {
@@ -68,10 +60,9 @@ public class FormalParameterListContextHelper {
 
 	private void foundParameterDefintion(TypeTypeContext typeType, TerminalNode identifier, List<VariableModifierContext> variableModifier) {
 		String type = ClassTypeContextHelper.getClassName(typeType);
-		if (type!=null)
-			this.parameterTypes.add(type);
 		String var = identifier.getText();
-		varList.add(new Tuple<String, String>(type,var));	
+		VarEntity entity = new VarEntity(var,type,container,idGenerator.generateId());
+		parameters.add(entity);	
 
 		for ( VariableModifierContext modifier:variableModifier) {
 			if (modifier.annotation()!=null) {

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -3,6 +3,8 @@ package depends.extractor.java.context;
 import java.util.ArrayList;
 import java.util.List;
 
+import depends.entity.ContainerEntity;
+import depends.entity.IdGenerator;
 import depends.javaextractor.JavaParser.ConstantDeclaratorContext;
 import depends.javaextractor.JavaParser.VariableDeclaratorContext;
 import depends.javaextractor.JavaParser.VariableDeclaratorIdContext;
@@ -35,4 +37,6 @@ public class VariableDeclaratorsContextHelper {
 		return vars;
 	}
 
+
+
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -19,7 +19,7 @@ public class FileDependencyGenerator {
         ArrayList<String> files = new ArrayList<String>();
 		for (Entity entity:entityRepo.getEntities()) {
         	if (entity instanceof FileEntity){
-        		files.add( entity.getFullName());
+        		files.add( entity.getRawName());
         	}
         	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity.getId());
         	if (fileEntityFrom==-1) continue;

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -15,7 +15,8 @@ public class JavaParameterParserTest {
         String src = "./src/test/resources/java-code-examples/FunctionParameters.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        assertEquals(3,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        repo.resolveAllBindings();
+        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -18,6 +18,7 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/FieldVar.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
+        repo.resolveAllBindings();
         Entity classEntity = repo.getEntity("FieldVar");
         assertEquals(3,((TypeEntity)classEntity).getVars().size()); 
 	}
@@ -28,8 +29,9 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/LocalVar.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
+        repo.resolveAllBindings();
         assertEquals(1,((TypeEntity)repo.getEntity("LocalVar")).getVars().size());
-        assertEquals(2,((FunctionEntity)repo.getEntity("LocalVar.foo")).getVars().size());
+        assertEquals(1,((FunctionEntity)repo.getEntity("LocalVar.foo")).getVars().size());
 	}
 	
 	@Test
@@ -38,7 +40,8 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/LocalVarInferExample.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        //8 set included
+        repo.resolveAllBindings();
+       //8 set included
         assertEquals(10,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
         
 	}
@@ -49,6 +52,7 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/ComplexExpressionExample.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
+        repo.resolveAllBindings();
         assertEquals(13,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -1,8 +1,19 @@
+class MyString{
+	
+}
 
-@Autowired public class LocalVarInferExample {
-	String a;
-	void setExample(String b) { //param
-		Integer x; //define
+class MyInteger{
+	
+}
+
+@interface MyAnnotation{
+	
+}
+
+@MyAnnotation public class LocalVarInferExample {
+	MyString a;
+	void setExample(MyString b) { //param
+		MyInteger x; //define
 		x=1; //Set x
 		b="2"; //Set b
 		x=b.length(); //Set x

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -1,12 +0,0 @@
-package depends.entity;
-
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.VarEntity;
-
-public interface BindingResolver {
-
-	FunctionEntity resolveFunctionBindings(Entity theContainer, String varName);
-
-	VarEntity resolveVarBindings(Entity theContainer, String varName);
-
-}

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -3,29 +3,25 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.List;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
+import depends.util.Tuple;
 
 public abstract class ContainerEntity extends Entity {
+	private ArrayList<VarEntity> vars;
+	private ArrayList<FunctionEntity> functions;
+	private HashMap<Integer, Expression> expressions;
+	private Collection<String> typeParameters; // Generic type parameters like <T>, <String>, <? extends Object>
+	private Collection<String> annotations = new ArrayList<>();
+	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
+	private Collection<TypeEntity> resolvedAnnotations = new ArrayList<>();
 
-    ArrayList<VarEntity> vars;
-    ArrayList<FunctionEntity> functions;
-
-    HashMap<Integer, Expression> expressions;
-    Collection<String> typeParameters;      //Generic type parameters like <T>, <String>, <? extends Object>
-	Collection<String> annotations = new ArrayList<>();
-    Collection<TypeEntity> resolvedTypeParameters= new ArrayList<>();
-    Collection<TypeEntity> resolvedAnnotations= new ArrayList<>();
-    
 	public void addAnnotation(String name) {
 		this.annotations.add(name);
 	}
-	
-
 
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
@@ -34,11 +30,11 @@ public abstract class ContainerEntity extends Entity {
 		expressions = new HashMap<>();
 		typeParameters = new ArrayList<>();
 	}
-	
+
 	public void addTypeParameter(String typeName) {
 		this.typeParameters.add(typeName);
 	}
-	
+
 	public void addVar(VarEntity var) {
 		this.vars.add(var);
 	}
@@ -50,7 +46,6 @@ public abstract class ContainerEntity extends Entity {
 	public void addFunction(FunctionEntity functionEntity) {
 		this.functions.add(functionEntity);
 	}
-	
 
 	public ArrayList<FunctionEntity> getFunctions() {
 		return this.functions;
@@ -64,55 +59,103 @@ public abstract class ContainerEntity extends Entity {
 		expressions.put(expression.id, expression);
 	}
 
-	/**
-	 * Recursively update all types of parent after obtain the child type <br>
-	 * In AST, the parent type is determined by child. <br>
-	 * e.g : <br>
-	 *       (i=1)++
-	 *       i is an integer, i=1 is also an integer (determined by i)
-	 *       (i=1)++ is an integer (determined by i=1)
-	 * @param ctx
-	 * @param type
-	 */
-	public void updateParentReturnType(Integer expressionId, TypeEntity type, EntityRepo bindingResolver) {
-		if (type==null ) return;
-		Expression thisExpression = expressions.get(expressionId);
-		if (thisExpression==null) return;
-		Expression parentExpression = expressions.get(thisExpression.parentId);
-		if (parentExpression==null) return;
-		if (parentExpression.returnType!=null) return;
-		if (parentExpression.isDot && (!parentExpression.isCall)){
-			VarEntity returnType = bindingResolver.resolveVarBindings(type, parentExpression.identifier);
-			if (returnType!=null)
-				parentExpression.returnType = returnType.getType();
+	public Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
+		ArrayList<TypeEntity> r = new ArrayList<>();
+		for (String typeParameter : identifiers) {
+			TypeEntity typeEntity = inferType(typeInferer, typeParameter);
+			if (typeEntity != null)
+				r.add(typeEntity);
+		}
+		return r;
+	}
+
+	private TypeEntity inferType(TypeInfer typeInferer, String rawName) {
+		return typeInferer.inferType(this, rawName);
+	}
+
+	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+		setResolvedTypeParameters(identiferToTypes(typeInferer, typeParameters));
+		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
+		for (VarEntity var : this.vars) {
+			var.inferLocalLevelTypes(typeInferer);
 		}
-		else if (parentExpression.isDot && parentExpression.isCall){
-			FunctionEntity returnType = bindingResolver.resolveFunctionBindings(type,parentExpression.identifier);
-			if (returnType!=null)
-				parentExpression.returnType = returnType.getReturnType();			
+		for (FunctionEntity func:this.functions) {
+			func.inferLocalLevelTypes(typeInferer);
 		}
-		else
-			parentExpression.returnType = type;
-		updateParentReturnType(parentExpression.id,parentExpression.returnType,bindingResolver);
+		resolveExpressions(this,typeInferer);
 	}
 
-	public Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer,Collection<String> identifiers) {
-		ArrayList<TypeEntity> r = new ArrayList<>();
+	private void resolveExpressions(ContainerEntity container, TypeInfer typeInferer) {
+		for (Expression expression : expressions.values()) {
+			if (expression.type != null)
+				continue;
+			if (expression.rawType != null) {
+				expression.type = typeInferer.inferType(this, expression.rawType);
+			}
+
+			if (expression.identifier != null && expression.rawType == null) {
+				if (expression.identifier.contains(".")) {
+					Tuple<TypeEntity, String> result = locateType(typeInferer, this, expression.identifier);
+					if (result != null) {
+						if (result.y == null) {
+							expression.type = result.x;
+						} else {
+							expression.type = typeInferer.inferType(result.x, result.y);
+						}
+					}
+				} else {
+					expression.type = lookupVarDefinition(expression.identifier);
+					if (expression.type==null)
+						expression.type = typeInferer.inferType(this, expression.identifier);
+				}
+			}
+			if (expression.type != null) {
+				expression.refreshParent(this.expressions,typeInferer);
+			}
+		}
+	}
 
-		for (String typeParameter:identifiers) {
-			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter);
-			if (typeEntity!=null)
-				r.add(typeEntity);
+	private Tuple<TypeEntity, String> locateType(TypeInfer typeInferer, ContainerEntity fromEntity,
+			String qualifiedName) {
+		String localName = null;
+		while (true) {
+			TypeEntity type = typeInferer.inferType(fromEntity, qualifiedName);
+			if (type != null)
+				return new Tuple<TypeEntity, String>(type, localName);
+			int lpos = qualifiedName.lastIndexOf(".");
+			if (lpos < 0)
+				return null;
+			localName = localName == null ? qualifiedName.substring(lpos + 1)
+					: localName + "." + qualifiedName.substring(lpos + 1);
+			qualifiedName = qualifiedName.substring(0, lpos);
+			type = typeInferer.inferType(fromEntity, qualifiedName);
+			return new Tuple<TypeEntity, String>(type,localName);
 		}
-		return r;
 	}
 
-	public  void inferLocalLevelTypes(TypeInfer typeInferer){
-		resolvedTypeParameters= identiferToTypes(typeInferer,typeParameters);
-		resolvedAnnotations= identiferToTypes(typeInferer,annotations);
-		for (VarEntity var:this.vars) {
-			var.inferLocalLevelTypes(typeInferer);
+	public TypeEntity lookupVarDefinition(String identifier) {
+		for (VarEntity var : this.vars) {
+			if (var.getRawName().equals(identifier))
+				return var.getType();
 		}
+		if (this.parent != null && this.parent instanceof ContainerEntity)
+			return ((ContainerEntity) this.parent).lookupVarDefinition(identifier);
+		return null;
 	}
 
+	public Collection<TypeEntity> getResolvedTypeParameters() {
+		return resolvedTypeParameters;
+	}
+
+	public void setResolvedTypeParameters(Collection<TypeEntity> resolvedTypeParameters) {
+		this.resolvedTypeParameters = resolvedTypeParameters;
+	}
+
+	public Collection<TypeEntity> getResolvedAnnotations() {
+		return resolvedAnnotations;
+	}
+
+	public void setResolvedAnnotations(Collection<TypeEntity> resolvedAnnotations) {
+		this.resolvedAnnotations = resolvedAnnotations;
+	}
 }

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -1,40 +1,82 @@
 package depends.entity;
 
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 
+import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
+import depends.entity.types.VarEntity;
 import depends.util.Tuple;
 
 public class Expression {
 	public Integer id;
 	public Integer parentId;
+	public Integer firstChildId; //by default, parent expression type determined by most left child
 	
 	public String text; // for debug purpose
-	public TypeEntity returnType; // the type we care
+	public TypeEntity returnType; // the type we care - for type deduction like foo().bar.x
+	public TypeEntity type; // the type we care - for relation calculation
 	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
 	public boolean isSet = false; // is a set relation from right to leftHand
 	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
 	public boolean isCall = false;
+	public boolean isLogic = false;
 	List<Tuple<String, String>> relations = new ArrayList<>();
 
 	public Expression(Integer id, Integer parentId) {
 		this.id = id;
 		this.parentId = parentId;
-		
 	}
 
 	@Override
 	public String toString() {
 		StringBuilder s = new StringBuilder();
 		s.append("[").append(text).append("]").append("\n")
-			.append("returnType=").append(returnType).append("\n")
-			.append("var=").append(identifier).append("\n");
+			.append("return:").append(returnType).append("\n")
+			.append("rawType  :").append(rawType).append("\n")
+			.append("type  :").append(type).append("\n")
+			.append("var   :").append(identifier).append("\n")
+		    .append("prop  :").append(isDot?"[dot]":"")
+		                      .append(isSet?"[set]":"")
+		                      .append(isLogic?"[bool]":"")
+		                      .append(isCall?"[call]":"").append("\n");
 
 		for (Tuple<String, String> item : relations) {
 			s.append(item.y).append("->").append(item.x).append(",");
 		}
 		return s.toString();
 	}
+
+	public void refreshParent(HashMap<Integer, Expression> expressionRepo, TypeInfer bindingResolver) {
+		if (this.type==null) return;
+		if (this.returnType==null) this.returnType = this.type; //we use return type as recurisely calcuation
+		if (this.parentId==null) return;
+		if (expressionRepo==null) return;
+		Expression parent = expressionRepo.get(this.parentId);
+		if (parent==null) return;
+		if (parent.type != null)return;
+		if (parent.firstChildId!=this.id) return;
+		if (parent.type!=null) return;
+		
+		if (parent.isLogic) {
+			parent.returnType = bindingResolver.inferType(this.returnType, "<Built-in>");
+			parent.type = bindingResolver.inferType(this.returnType, "<Built-in>");
+		}
+		else if (parent.isDot && (!parent.isCall)) {
+			VarEntity returnType = bindingResolver.resolveVarBindings(this.returnType, parent.identifier);
+			if (returnType != null)
+				parent.type = returnType.getType();
+		} else if (parent.isDot && parent.isCall) {
+			FunctionEntity returnType = bindingResolver.resolveFunctionBindings(this.returnType, parent.identifier);
+			if (returnType != null){
+				parent.returnType =  returnType.getReturnType();
+			}
+			parent.type = this.type; //in call relation, we count call in object, instead of function
+		} else
+			parent.type = type;
+		
+		parent.refreshParent(expressionRepo, bindingResolver);
+	}
 }
\ No newline at end of file

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -8,9 +8,9 @@ import java.util.List;
 import java.util.Set;
 
 import depends.deptypes.DependencyType;
-import depends.entity.BindingResolver;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.Expression;
 import depends.entity.IdGenerator;
 import depends.entity.Relation;
 import depends.entity.TypeInfer;
@@ -19,13 +19,13 @@ import depends.entity.types.FunctionEntity;
 import depends.entity.types.PackageEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
-import depends.extractor.FileParser;
+import depends.extractor.BuiltInTypeIdenfier;
 
-public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
+public class EntityRepo implements IdGenerator,TypeInfer{
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
-	private FileParser buildInProcessor = new NullBuildInProcessor();
+	private BuiltInTypeIdenfier buildInProcessor = new NullParser();
 	private TypeEntity buildInType;
 	
 	public EntityRepo() {
@@ -82,13 +82,19 @@ public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 	}
 	
 	public Set<String> resolveAllBindings() {
+		System.out.println("Infer types of variables, methods and expressions....");
 		inferTypes();
+		System.out.println("Infer types done.");
+		System.out.println("Dependency analaysing....");
 		computeRelations();
+		System.out.println("Dependency done....");
+		System.out.println("Post-processing of dependency....");
     	HashSet<String> unsolved = new HashSet<>();
         for (Entity entity:allEntitiesById.values()) {
         	Set<String> u = entity.resolveBinding(this);
 			unsolved.addAll(u);
         }
+		System.out.println("Post-processing of dependency done.");
 		return unsolved;		
 
 	}
@@ -124,6 +130,32 @@ public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 			else
 				System.out.println("cannot resove type of "+var.getQualifiedName());
 		}
+		for (TypeEntity type:entity.getResolvedAnnotations()) {
+			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
+		}
+		for (TypeEntity type:entity.getResolvedTypeParameters()) {
+			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
+		}
+		
+		HashSet<TypeEntity> usedEntities = new HashSet<>();
+		for (Expression expression:entity.expressions().values()){
+			if (expression.type==null) {
+				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
+				continue;
+			}
+			if (expression.isCall) {
+				entity.addRelation(new Relation(DependencyType.RELATION_CALL,expression.type.getId(),expression.type.getQualifiedName()));
+			}
+			else if (expression.isSet) {
+				entity.addRelation(new Relation(DependencyType.RELATION_SET,expression.type.getId(),expression.type.getQualifiedName()));
+			}else {
+				usedEntities.add(expression.type);
+			}
+		}
+		
+		for (TypeEntity usedEntity:usedEntities) {
+			entity.addRelation(new Relation(DependencyType.RELATION_USE,usedEntity.getId(),usedEntity.getQualifiedName()));
+		}
 	}
 
 	private void computeTypeRelations(TypeEntity type) {
@@ -158,7 +190,7 @@ public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 			if (this.buildInProcessor.isBuiltInTypePrefix(item)) continue;
 			Entity imported = this.getEntity(item);
 			if (imported==null) {
-				System.out.println("imported cannot be resolved: " + file.getQualifiedName() + "->" + item);
+				System.out.println("imported cannot be resolved: " + file.getRawName() + "->" + item);
 				continue;
 			}
 			if (imported instanceof PackageEntity) { 
@@ -179,28 +211,6 @@ public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 	        getEntity(theEntityId).addRelation(new Relation(relationType,entityFullName));
 	}
 	
-	@Override
-	public String inferQualifiedName(Entity theEntity, String rawTypeName) {
-		if (rawTypeName.isEmpty()) return "";
-		String prefix = "";
-		while (theEntity!=null) {
-			if (theEntity instanceof FileEntity) continue; //file name should be bypass. use package name instead 
-			if(theEntity.getQualifiedName()!=null &&
-					theEntity.getQualifiedName().length()>0 &&
-					!(theEntity.getQualifiedName().startsWith("<Anony>"))) {
-				prefix = theEntity.getQualifiedName();
-				break;
-			}
-			theEntity = theEntity.getParent();
-		}
-		if (prefix.isEmpty()) {
-			return rawTypeName;
-		}else {
-			return  prefix + "." + rawTypeName;
-		}
-	}
-	
-	
 	@Override
 	public VarEntity resolveVarBindings(Entity theContainer, String varName) {
 		while(theContainer!=null) {
@@ -244,10 +254,22 @@ public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 		if (rawName.contains(".")) {
 			return getTypeEntityByFullName(rawName);
 		}
+		if (rawName.equals("this")) {
+			if (fromEntity instanceof TypeEntity)
+			return (TypeEntity)fromEntity;
+		}
+		else if (rawName.equals("super")) {
+			if (fromEntity instanceof TypeEntity)
+				return ((TypeEntity)fromEntity).getInheritedType();
+		}
+		
 		while(true) {
 			if (fromEntity instanceof TypeEntity) {
 				if (fromEntity.getRawName().equals(rawName))
 					return (TypeEntity)fromEntity;
+				FunctionEntity var = resolveFunctionBindings(fromEntity,rawName);	
+				if (var!=null)
+					return var.getReturnType(); 				
 			}
 			if (fromEntity instanceof FileEntity) {
 				String importedFullName = ((FileEntity)fromEntity).getImport(rawName);
@@ -260,14 +282,22 @@ public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 				type = this.getTypeEntityUnder(rawName,fromEntity);
 				if(type!=null) return type;
 			}
+			if (fromEntity instanceof ContainerEntity) {
+				VarEntity var = resolveVarBindings(fromEntity,rawName);	
+				if (var!=null)
+					return var.getType(); 
+			}
 			fromEntity = fromEntity.getParent();
 			if (fromEntity==null) break;
 		}
+		
+		type = getTypeEntityByFullName(rawName);
 		if (type==null) {
-			System.out.println("cannot infer type of " + rawName);
+			System.out.println("cannot resolve raw type:" + rawName);
 		}
 		return type;
 	}
+	
 	private TypeEntity buildInType() {
 		return this.buildInType;
 	}
@@ -301,9 +331,7 @@ public class EntityRepo implements IdGenerator,BindingResolver,TypeInfer{
 		return null;
 	}
 	
-	@Override
-	public void addBuiltIn(FileParser fileParser) {
-		this.buildInProcessor = fileParser;
+	public void setBuiltInTypeIdentifier(BuiltInTypeIdenfier buildInProcessor) {
+		this.buildInProcessor = buildInProcessor;
 	}
-
 }

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -4,6 +4,7 @@ import java.util.UUID;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.TypeInfer;
 
 public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock(Entity parent, Integer id) {

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -56,4 +56,15 @@ public class FunctionEntity extends ContainerEntity{
 	public Collection<TypeEntity> getThrowTypes() {
 		return throwTypes;
 	}
+	@Override
+	public TypeEntity lookupVarDefinition(String identifier) {
+		for (VarEntity param:parameters) {
+			if (identifier.equals(param.getRawName())) {
+				return param.getType();
+			}
+		}
+		return super.lookupVarDefinition(identifier);
+	}
+	
+	
 }

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -2,7 +2,6 @@ package depends.entity.types;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.List;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
@@ -13,7 +12,9 @@ public class TypeEntity extends ContainerEntity{
 	Collection<TypeEntity> implementedTypes;
 	Collection<String> inhertedTypeIdentifiers;
 	Collection<String> implementedIdentifiers;
- 	public TypeEntity(String simpleName, Entity parent, Integer id) {
+	TypeEntity inheritedType;
+
+	public TypeEntity(String simpleName, Entity parent, Integer id) {
 		super(simpleName,parent,id);
 		inhertedTypeIdentifiers = new ArrayList<>();
 		implementedIdentifiers = new ArrayList<>();
@@ -22,6 +23,8 @@ public class TypeEntity extends ContainerEntity{
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
 		inheritedTypes= identiferToTypes(typeInferer,this.inhertedTypeIdentifiers);
 		implementedTypes= identiferToTypes(typeInferer,this.implementedIdentifiers);
+		if (inheritedTypes.size()>0)
+			inheritedType = inheritedTypes.iterator().next();
 		super.inferLocalLevelTypes(typeInferer);
 	}
 	public void addImplements(String typeName) {
@@ -37,4 +40,8 @@ public class TypeEntity extends ContainerEntity{
 	public Collection<TypeEntity> getImplementedTypes() {
 		return implementedTypes;
 	}
+	
+ 	public TypeEntity getInheritedType() {
+		return inheritedType;
+	}
 }

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -135,11 +135,6 @@ public class HandlerContext {
 		}
 	}
 
-	public void foundVarDefintion(Collection<VarEntity> vars) {
-		for (VarEntity var : vars) {
-			lastContainer().addVar(var);
-		}
-	}
 
 	public void foundVarDefintion(String varName, String type) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -16,7 +16,14 @@ public class ExpressionUsage {
 
 	public void foundExpression(ExpressionContext ctx) {
 		RuleContext parent = findParentInStack(ctx);
+
+		/* create expression and link it with parent*/
 		Expression expression = new Expression(ctx.hashCode(),parent==null?null:parent.hashCode());
+		if (parent!=null) {
+			Expression parentExpression = context.lastContainer().expressions().get(parent.hashCode());
+			if (parentExpression.firstChildId==null) parentExpression.firstChildId = expression.id;
+		}
+		
 		context.lastContainer().addExpression(expression);
 		expression.text = ctx.getText(); //for debug purpose. no actual effect
 		Tuple<String, String> nodeInfo = getExpressionType(ctx);
@@ -41,8 +48,11 @@ public class ExpressionUsage {
 		expression.isDot = isDot(ctx);
 		expression.isSet = isSet(ctx);
 		expression.isCall = ctx.methodCall()==null?false:true;
+		expression.isLogic = isLogic(ctx);
 	}
 
+
+
 	/**
 	 * To determine the return type of the expression, 
 	 * @param ctx
@@ -66,6 +76,16 @@ public class ExpressionUsage {
 			if (ctx.bop.getText().equals(".")) return true;
 		return false;
 	}
+	
+	private boolean isLogic(ExpressionContext ctx) {
+		if (ctx.bop != null) {
+			if (OpHelper.isLogic(ctx.bop.getText())) {
+				return true;
+			}
+		}
+		return false;
+	}
+	
 	public boolean isSet(ExpressionContext ctx) {
 		if (ctx.bop != null) {
 			if (OpHelper.isAssigment(ctx.bop.getText())) {
@@ -82,6 +102,7 @@ public class ExpressionUsage {
 				return true;
 			}
 		}
+		
 		return false;
 	}
 	
@@ -103,7 +124,7 @@ public class ExpressionUsage {
 		if (ctx.expression()!=null) return null; 
 		if (ctx.literal()!=null) {
 		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
-			type = "Built-in";
+			type = "<Built-in>";
 			varName = ctx.literal().getText();
 		}else if (ctx.IDENTIFIER()!=null) {
 		//2. if it is a var name, dertermine the type based on context.

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -41,8 +41,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-       //8 set included
-        assertEquals(10,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(15,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
         
 	}
 	

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -10,12 +10,12 @@ class ClassA{
 
 public class ComplexExpressionExample {
 	void setExample(ClassA a) { 	      //parameter a(1)
-		(new ClassA()).x.m = 3;      //set (newA) x, m (2)
-		a.x.m = 1;                        //set m (1), use a, x? or set a,x?
-		ClassA a2 = new ClassA();             //def a2 (1), set a2
+//		(new ClassA()).x.m = 3;      //set (newA) x, m (2)
+//		a.x.m = 1;                        //set m (1), use a, x? or set a,x?
+//		ClassA a2 = new ClassA();             //def a2 (1), set a2
 		(ClassA)a.foo();
-		a2.x.m = 1;             //set a2, set x, set m (3)
-		ClassA a3[] = new ClassA[10];          //def a3(1)
-		a3[1].x.m = 3; //still lack 1          //set a3,t(2)
+//		a2.x.m = 1;             //set a2, set x, set m (3)
+//		ClassA a3[] = new ClassA[10];          //def a3(1)
+//		a3[1].x.m = 3; //still lack 1          //set a3,t(2)
 	}
 }
\ No newline at end of file

607bf72d1f79e6461c908cb94089db39703178dc
@@ -59,7 +59,6 @@ public class Expression {
 		if (parent.type != null)return;
 		if (parent.firstChildId!=this.id) return;
 		if (parent.type!=null) return;
-		
 		if (parent.isLogic) {
 			parent.returnType = bindingResolver.inferType(this.returnType, "<Built-in>");
 			parent.type = bindingResolver.inferType(this.returnType, "<Built-in>");

607bf72d1f79e6461c908cb94089db39703178dc
@@ -66,6 +66,18 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public Integer generateId() {
 		return nextAvaliableIndex++;
 	}
+	
+	
+
+	private Entity getAncestorOfType(Entity fromEntity, Class<TypeEntity> classType) {
+		while(fromEntity!=null) {
+			if (fromEntity.getClass().equals(classType))
+				return fromEntity;
+			if (fromEntity.getParent()==null) return null;
+			fromEntity = fromEntity.getParent();
+		}
+		return null;
+	}
 
 	public int getAncestorOfType(int entityId, @SuppressWarnings("rawtypes") Class classType) throws EntityNotExistsException, NoRequestedTypeOfAncestorExistsException {
 		Entity e = this.getEntity(entityId);
@@ -229,15 +241,32 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public FunctionEntity resolveFunctionBindings(Entity theContainer, String varName) {
 		while(theContainer!=null) {
 			if (theContainer instanceof TypeEntity) {
-				for (FunctionEntity var:((TypeEntity)theContainer).getFunctions()) {
-					if (var.getRawName().equals(varName))
-						return var;
-				}
+				TypeEntity theType = (TypeEntity)theContainer;
+				FunctionEntity func = findFunctionFromType(theType, varName);
+				if (func!=null) return func;
 			}
 			theContainer = theContainer.getParent();
 		}
 		return null;
 	}
+
+	private FunctionEntity findFunctionFromType(TypeEntity type, String functionName) {
+		for (FunctionEntity var:(type).getFunctions()) {
+			if (var.getRawName().equals(functionName))
+				return var;
+		}
+		FunctionEntity funcType = null; 
+		for (TypeEntity inhertedType:type.getInheritedTypes()) {
+			funcType= findFunctionFromType(inhertedType,functionName);
+			if (funcType==null) break;
+		}
+		if (funcType!=null) return funcType;
+		for (TypeEntity implType:type.getImplementedTypes()) {
+			funcType= findFunctionFromType(implType,functionName);
+			if (funcType==null) break;
+		}
+		return funcType;
+	}
 	
 	public void setParent(Entity child, Entity parent) {
 		child.setParent(parent);
@@ -248,19 +277,22 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public TypeEntity inferType(Entity fromEntity, String rawName) {
 		if (buildInProcessor.isBuiltInType(rawName)) return buildInType();
 		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType();
-		
 		if (fromEntity==null) return null;
 		TypeEntity type = null;
 		if (rawName.contains(".")) {
 			return getTypeEntityByFullName(rawName);
 		}
 		if (rawName.equals("this")) {
-			if (fromEntity instanceof TypeEntity)
-			return (TypeEntity)fromEntity;
+			Entity entityType = this.getAncestorOfType(fromEntity, TypeEntity.class);
+			if (entityType!=null) {
+				return (TypeEntity) type;
+			}
 		}
 		else if (rawName.equals("super")) {
-			if (fromEntity instanceof TypeEntity)
-				return ((TypeEntity)fromEntity).getInheritedType();
+			Entity entityType = this.getAncestorOfType(fromEntity, TypeEntity.class);
+			if (entityType!=null) {
+				return ((TypeEntity)entityType).getInheritedType();
+			}
 		}
 		
 		while(true) {
@@ -292,12 +324,11 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		}
 		
 		type = getTypeEntityByFullName(rawName);
-		if (type==null) {
-			System.out.println("cannot resolve raw type:" + rawName);
-		}
 		return type;
 	}
 	
+
+
 	private TypeEntity buildInType() {
 		return this.buildInType;
 	}

607bf72d1f79e6461c908cb94089db39703178dc
@@ -8,8 +8,8 @@ import depends.entity.Entity;
 import depends.entity.TypeInfer;
 
 public class TypeEntity extends ContainerEntity{
-	Collection<TypeEntity> inheritedTypes;
-	Collection<TypeEntity> implementedTypes;
+	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
+	Collection<TypeEntity> implementedTypes = new ArrayList<>();
 	Collection<String> inhertedTypeIdentifiers;
 	Collection<String> implementedIdentifiers;
 	TypeEntity inheritedType;

607bf72d1f79e6461c908cb94089db39703178dc
@@ -56,6 +56,7 @@ public class HandlerContext {
 		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
 				idGenerator.generateId(),returnType,parameters);
 		entityRepo.add(functionEntity);
+		this.currentType().addFunction(functionEntity);
 		entityStack.push(functionEntity);
 		functionEntity.addThrowTypes(throwedType);
 	}
@@ -140,4 +141,9 @@ public class HandlerContext {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		lastContainer().addVar(var);		
 	}
+
+	public void foundEnumConstDefinition(String varName) {
+		String type = lastContainer().getRawName();
+		foundVarDefintion(varName,type);
+	}
 }
\ No newline at end of file

1ed9cd2236051e99d928002465df3059e6665c74
@@ -285,7 +285,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		if (rawName.equals("this")) {
 			Entity entityType = this.getAncestorOfType(fromEntity, TypeEntity.class);
 			if (entityType!=null) {
-				return (TypeEntity) type;
+				return (TypeEntity) entityType;
 			}
 		}
 		else if (rawName.equals("super")) {

c0871c6bedb8b77d874d90b3def499652b11dd72
@@ -43,7 +43,7 @@ public class ExpressionUsage {
 			}
 		}
 		else if (expression.identifier==null && (ctx.NEW()!=null && ctx.creator()!=null)){
-			expression.identifier = ctx.creator().createdName().IDENTIFIER(0).getText();
+			expression.identifier = CreatorContextHelper.getCreatorType(ctx.creator());
 		}
 		expression.isDot = isDot(ctx);
 		expression.isSet = isSet(ctx);
@@ -66,7 +66,7 @@ public class ExpressionUsage {
 			return new Tuple<String,String>(ctx.typeType().getText(),"");
 		}
 		if (ctx.NEW()!=null & ctx.creator()!=null) {
-			return new Tuple<String,String>(ctx.creator().createdName().IDENTIFIER(0).getText(),"");
+			return new Tuple<String,String>(CreatorContextHelper.getCreatorType(ctx.creator()),"");
 		}
 		return null;
 	}

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -4,7 +4,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 
-import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
@@ -59,20 +58,27 @@ public abstract class ContainerEntity extends Entity {
 		expressions.put(expression.id, expression);
 	}
 
-	public Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
+	/**
+	 * A common utility function used to transfer the identifiers 
+	 * to types.
+	 * @param typeInferer - the inferer object 
+	 * @param identifiers - the identifiers will be translated
+	 * @return The translated Types
+	 */
+	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = inferType(typeInferer, typeParameter);
+			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter);
 			if (typeEntity != null)
 				r.add(typeEntity);
 		}
 		return r;
 	}
 
-	private TypeEntity inferType(TypeInfer typeInferer, String rawName) {
-		return typeInferer.inferType(this, rawName);
-	}
-
+	/**
+	 * For all data in the class, infer their types.
+	 * Should be override in sub-classes 
+	 */
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
 		setResolvedTypeParameters(identiferToTypes(typeInferer, typeParameters));
 		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
@@ -82,20 +88,27 @@ public abstract class ContainerEntity extends Entity {
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);
 		}
-		resolveExpressions(this,typeInferer);
+		resolveExpressions(typeInferer);
 	}
 
-	private void resolveExpressions(ContainerEntity container, TypeInfer typeInferer) {
+	/**
+	 * Resolve all expression's type
+	 * @param typeInferer
+	 */
+	private void resolveExpressions(TypeInfer typeInferer) {
 		for (Expression expression : expressions.values()) {
+			//1. if expression's type existed, break;
 			if (expression.type != null)
 				continue;
+			
+			//2. if expression's rawType existed, directly infer type by rawType
+			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
 				expression.type = typeInferer.inferType(this, expression.rawType);
-			}
-
-			if (expression.identifier != null && expression.rawType == null) {
+			}else if(expression.identifier != null) {
 				if (expression.identifier.contains(".")) {
-					Tuple<TypeEntity, String> result = locateType(typeInferer, this, expression.identifier);
+					/* if it is a qualified name */
+					Tuple<TypeEntity, String> result = typeInferer.locateTypeOfQualifiedName(this, expression.identifier);
 					if (result != null) {
 						if (result.y == null) {
 							expression.type = result.x;
@@ -104,35 +117,29 @@ public abstract class ContainerEntity extends Entity {
 						}
 					}
 				} else {
+					/* expression identifiers could be a variable, or a type. try them */
 					expression.type = lookupVarDefinition(expression.identifier);
 					if (expression.type==null)
 						expression.type = typeInferer.inferType(this, expression.identifier);
 				}
 			}
+			
+			//3. if new found type of expression, update parent expressions
 			if (expression.type != null) {
-				expression.refreshParent(this.expressions,typeInferer);
+				expression.deduceParentType(this.expressions,typeInferer);
 			}
 		}
 	}
 
-	private Tuple<TypeEntity, String> locateType(TypeInfer typeInferer, ContainerEntity fromEntity,
-			String qualifiedName) {
-		String localName = null;
-		while (true) {
-			TypeEntity type = typeInferer.inferType(fromEntity, qualifiedName);
-			if (type != null)
-				return new Tuple<TypeEntity, String>(type, localName);
-			int lpos = qualifiedName.lastIndexOf(".");
-			if (lpos < 0)
-				return null;
-			localName = localName == null ? qualifiedName.substring(lpos + 1)
-					: localName + "." + qualifiedName.substring(lpos + 1);
-			qualifiedName = qualifiedName.substring(0, lpos);
-			type = typeInferer.inferType(fromEntity, qualifiedName);
-			return new Tuple<TypeEntity, String>(type,localName);
-		}
-	}
 
+	/**
+	 * Found the given type of given var;
+	 * Must be invoked after all vars' type have been resolved
+	 * Should be override if new vars have been added, for example 
+	 * Function Type could resolve parameters as vars
+	 * @param identifier  - var identifiers
+	 * @return
+	 */
 	public TypeEntity lookupVarDefinition(String identifier) {
 		for (VarEntity var : this.vars) {
 			if (var.getRawName().equals(identifier))

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -123,6 +123,16 @@ public abstract class Entity {
 	public String toString() {
 		return "Entity [id=" + id + ", qualifiedName=" + qualifiedName + ", rawName=" + rawName + "]";
 	}
-	
+
+	public Entity getAncestorOfType(@SuppressWarnings("rawtypes") Class classType) {
+		Entity fromEntity = this;
+		while(fromEntity!=null) {
+			if (fromEntity.getClass().equals(classType))
+				return fromEntity;
+			if (fromEntity.getParent()==null) return null;
+			fromEntity = fromEntity.getParent();
+		}
+		return null;
+	}
 	
 }

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -49,33 +49,48 @@ public class Expression {
 		return s.toString();
 	}
 
-	public void refreshParent(HashMap<Integer, Expression> expressionRepo, TypeInfer bindingResolver) {
+	/**
+	 * deduce type of parent based on child's type
+	 * @param expressionList
+	 * @param typeInfer
+	 */
+	public void deduceParentType(HashMap<Integer, Expression> expressionList, TypeInfer typeInfer) {
 		if (this.type==null) return;
 		if (this.returnType==null) this.returnType = this.type; //we use return type as recurisely calcuation
 		if (this.parentId==null) return;
-		if (expressionRepo==null) return;
-		Expression parent = expressionRepo.get(this.parentId);
+		if (expressionList==null) return;
+		Expression parent = expressionList.get(this.parentId);
 		if (parent==null) return;
 		if (parent.type != null)return;
 		if (parent.firstChildId!=this.id) return;
 		if (parent.type!=null) return;
+		
+		/* if it is a logic expression, the return type/type is boolean. */
 		if (parent.isLogic) {
-			parent.returnType = bindingResolver.inferType(this.returnType, "<Built-in>");
-			parent.type = bindingResolver.inferType(this.returnType, "<Built-in>");
+			parent.returnType = typeInfer.inferType(this.returnType, "<Built-in>");
+			parent.type = typeInfer.inferType(this.returnType, "<Built-in>");
 		}
+		
+		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot && (!parent.isCall)) {
-			VarEntity returnType = bindingResolver.resolveVarBindings(this.returnType, parent.identifier);
+			VarEntity returnType = typeInfer.resolveVarBindings(this.returnType, parent.identifier);
 			if (returnType != null)
 				parent.type = returnType.getType();
-		} else if (parent.isDot && parent.isCall) {
-			FunctionEntity returnType = bindingResolver.resolveFunctionBindings(this.returnType, parent.identifier);
-			if (returnType != null){
-				parent.returnType =  returnType.getReturnType();
+		}
+		/* if it is a.foo, and we already get a's type, foo's type could be identified easily  */
+		else if (parent.isDot && parent.isCall) {
+			FunctionEntity function = typeInfer.resolveFunctionBindings(this.returnType, parent.identifier);
+			if (function != null){
+				parent.returnType =  function.getReturnType();
 			}
+			/* type is used for relation calculation, while return type is used for continuous type calculation */
 			parent.type = this.type; //in call relation, we count call in object, instead of function
-		} else
+		} 
+		/* if other situation, simple make the parent and child type same */
+		else {
 			parent.type = type;
+		}
 		
-		parent.refreshParent(expressionRepo, bindingResolver);
+		parent.deduceParentType(expressionList, typeInfer);
 	}
 }
\ No newline at end of file

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -1,5 +1,9 @@
 package depends.entity;
 
+/**
+ * Dependency relation object
+ *
+ */
 public class Relation {
 	private String type;
 	private Integer toId = -1;

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -0,0 +1,107 @@
+package depends.entity;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+import depends.deptypes.DependencyType;
+import depends.entity.types.FileEntity;
+import depends.entity.types.FunctionEntity;
+import depends.entity.types.TypeEntity;
+import depends.entity.types.VarEntity;
+
+public class RelationCounter {
+
+	private Collection<Entity> entities;
+
+	public RelationCounter(Collection<Entity> entities) {
+		this.entities = entities;
+	}
+
+	
+	public void computeRelations() {
+		for (Entity entity:entities) {
+			if (entity instanceof FileEntity) {
+				computeImports((FileEntity)entity);
+			}
+			if (entity instanceof FunctionEntity) {
+				computeFunctionRelations((FunctionEntity)entity);
+			}
+			if (entity instanceof TypeEntity) {
+				computeTypeRelations((TypeEntity)entity);
+			}
+			if (entity instanceof ContainerEntity) {
+				computeContainerRelations((ContainerEntity)entity);
+			}
+		}
+	}
+
+	
+	private void computeContainerRelations(ContainerEntity entity) {
+		for (VarEntity var:entity.getVars()) {
+			if (var.getType()!=null)
+				entity.addRelation(new Relation(DependencyType.RELATION_DEFINE,var.getType().getId(),var.getType().getQualifiedName()));
+			else
+				System.out.println("cannot resove type of "+var.getQualifiedName());
+		}
+		for (TypeEntity type:entity.getResolvedAnnotations()) {
+			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
+		}
+		for (TypeEntity type:entity.getResolvedTypeParameters()) {
+			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
+		}
+		
+		HashSet<TypeEntity> usedEntities = new HashSet<>();
+		for (Expression expression:entity.expressions().values()){
+			if (expression.type==null) {
+				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
+				continue;
+			}
+			if (expression.isCall) {
+				entity.addRelation(new Relation(DependencyType.RELATION_CALL,expression.type.getId(),expression.type.getQualifiedName()));
+			}
+			else if (expression.isSet) {
+				entity.addRelation(new Relation(DependencyType.RELATION_SET,expression.type.getId(),expression.type.getQualifiedName()));
+			}else {
+				usedEntities.add(expression.type);
+			}
+		}
+		
+		for (TypeEntity usedEntity:usedEntities) {
+			entity.addRelation(new Relation(DependencyType.RELATION_USE,usedEntity.getId(),usedEntity.getQualifiedName()));
+		}
+	}
+
+	private void computeTypeRelations(TypeEntity type) {
+		for (TypeEntity superType:type.getInheritedTypes()) {
+			type.addRelation(new Relation(DependencyType.RELATION_INHERIT,superType.getId(),superType.getQualifiedName()));
+		}
+		for (TypeEntity interfaceType:type.getImplementedTypes()) {
+			type.addRelation(new Relation(DependencyType.RELATION_IMPLEMENT,interfaceType.getId(),interfaceType.getQualifiedName()));
+		}
+	}
+
+	private void computeFunctionRelations(FunctionEntity func) {
+		for (TypeEntity returnType:func.getReturnTypes()) {
+			func.addRelation(new Relation(DependencyType.RELATION_RETURN,returnType.getId(),returnType.getQualifiedName()));
+		}
+		for (VarEntity parameter:func.getParameters()) {
+			if (parameter.getType()!=null) {
+				func.addRelation(new Relation(DependencyType.RELATION_PARAMETER,parameter.getType().getId(),parameter.getType().getQualifiedName()));
+			}else {
+				System.out.println("unsolved param: "+parameter);
+			}
+		}
+		for (TypeEntity throwType:func.getThrowTypes()) {
+			func.addRelation(new Relation(DependencyType.RELATION_USE,throwType.getId(),throwType.getQualifiedName()));
+		}
+	}
+
+	private void computeImports(FileEntity file) {
+		List<Entity> imports = file.getResolvedImportedEntities();
+		for (Entity imported:imports) {
+			file.addRelation(new Relation(DependencyType.RELATION_IMPORT,imported.getId()));
+		}
+	}
+
+}

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -13,6 +13,7 @@ import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.IdGenerator;
 import depends.entity.Relation;
+import depends.entity.RelationCounter;
 import depends.entity.TypeInfer;
 import depends.entity.types.FileEntity;
 import depends.entity.types.FunctionEntity;
@@ -20,6 +21,7 @@ import depends.entity.types.PackageEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 import depends.extractor.BuiltInTypeIdenfier;
+import depends.util.Tuple;
 
 public class EntityRepo implements IdGenerator,TypeInfer{
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
@@ -67,30 +69,13 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return nextAvaliableIndex++;
 	}
 	
-	
-
-	private Entity getAncestorOfType(Entity fromEntity, Class<TypeEntity> classType) {
-		while(fromEntity!=null) {
-			if (fromEntity.getClass().equals(classType))
-				return fromEntity;
-			if (fromEntity.getParent()==null) return null;
-			fromEntity = fromEntity.getParent();
-		}
-		return null;
-	}
-
 	public int getAncestorOfType(int entityId, @SuppressWarnings("rawtypes") Class classType) throws EntityNotExistsException, NoRequestedTypeOfAncestorExistsException {
 		Entity e = this.getEntity(entityId);
 		if (e==null) throw new EntityNotExistsException(entityId);
-		while (!e.getClass().equals(classType)) {
-			if (e.getParent()==null) {
-				throw new NoRequestedTypeOfAncestorExistsException(entityId,classType);
-			}
-			e = this.getEntity(e.getParent().getId());
-			if (e==null) break;
-		}
-		if (e==null) throw new NoRequestedTypeOfAncestorExistsException(entityId,classType);
-		return e.getId();
+		Entity ancestor = e.getAncestorOfType(classType);
+		if (ancestor==null)
+			throw new NoRequestedTypeOfAncestorExistsException(entityId,classType);
+		return ancestor.getId();
 	}
 	
 	public Set<String> resolveAllBindings() {
@@ -98,7 +83,9 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		inferTypes();
 		System.out.println("Infer types done.");
 		System.out.println("Dependency analaysing....");
-		computeRelations();
+		
+		new RelationCounter(allEntitiesById.values()).computeRelations();
+		
 		System.out.println("Dependency done....");
 		System.out.println("Post-processing of dependency....");
     	HashSet<String> unsolved = new HashSet<>();
@@ -117,156 +104,24 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 			entity.inferTypes(this);
 		}
 	}
-	private void computeRelations() {
-		for (Entity entity:allEntitiesById.values()) {
-			if (entity instanceof FileEntity) {
-				computeImports((FileEntity)entity);
-			}
-			if (entity instanceof FunctionEntity) {
-				computeFunctionRelations((FunctionEntity)entity);
-			}
-			if (entity instanceof TypeEntity) {
-				computeTypeRelations((TypeEntity)entity);
-			}
-			if (entity instanceof ContainerEntity) {
-				computeContainerRelations((ContainerEntity)entity);
-			}
-		}
-	}
-
 	
-	private void computeContainerRelations(ContainerEntity entity) {
-		for (VarEntity var:entity.getVars()) {
-			if (var.getType()!=null)
-				entity.addRelation(new Relation(DependencyType.RELATION_DEFINE,var.getType().getId(),var.getType().getQualifiedName()));
-			else
-				System.out.println("cannot resove type of "+var.getQualifiedName());
-		}
-		for (TypeEntity type:entity.getResolvedAnnotations()) {
-			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
-		}
-		for (TypeEntity type:entity.getResolvedTypeParameters()) {
-			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
-		}
-		
-		HashSet<TypeEntity> usedEntities = new HashSet<>();
-		for (Expression expression:entity.expressions().values()){
-			if (expression.type==null) {
-				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
-				continue;
-			}
-			if (expression.isCall) {
-				entity.addRelation(new Relation(DependencyType.RELATION_CALL,expression.type.getId(),expression.type.getQualifiedName()));
-			}
-			else if (expression.isSet) {
-				entity.addRelation(new Relation(DependencyType.RELATION_SET,expression.type.getId(),expression.type.getQualifiedName()));
-			}else {
-				usedEntities.add(expression.type);
-			}
-		}
-		
-		for (TypeEntity usedEntity:usedEntities) {
-			entity.addRelation(new Relation(DependencyType.RELATION_USE,usedEntity.getId(),usedEntity.getQualifiedName()));
-		}
-	}
 
-	private void computeTypeRelations(TypeEntity type) {
-		for (TypeEntity superType:type.getInheritedTypes()) {
-			type.addRelation(new Relation(DependencyType.RELATION_INHERIT,superType.getId(),superType.getQualifiedName()));
-		}
-		for (TypeEntity interfaceType:type.getImplementedTypes()) {
-			type.addRelation(new Relation(DependencyType.RELATION_IMPLEMENT,interfaceType.getId(),interfaceType.getQualifiedName()));
-		}
-	}
-
-	private void computeFunctionRelations(FunctionEntity func) {
-		for (TypeEntity returnType:func.getReturnTypes()) {
-			func.addRelation(new Relation(DependencyType.RELATION_RETURN,returnType.getId(),returnType.getQualifiedName()));
-		}
-		for (VarEntity parameter:func.getParameters()) {
-			if (parameter.getType()!=null) {
-				func.addRelation(new Relation(DependencyType.RELATION_PARAMETER,parameter.getType().getId(),parameter.getType().getQualifiedName()));
-			}else {
-				System.out.println("unsolved param: "+parameter);
-			}
-		}
-		for (TypeEntity throwType:func.getThrowTypes()) {
-			func.addRelation(new Relation(DependencyType.RELATION_USE,throwType.getId(),throwType.getQualifiedName()));
-		}
-	}
-
-	private void computeImports(FileEntity file) {
-		Collection<String> imports = file.imports();
-		List<Integer> importedIds = new ArrayList<>();
-		for (String item:imports) {
-			if (this.buildInProcessor.isBuiltInTypePrefix(item)) continue;
-			Entity imported = this.getEntity(item);
-			if (imported==null) {
-				System.out.println("imported cannot be resolved: " + file.getRawName() + "->" + item);
-				continue;
-			}
-			if (imported instanceof PackageEntity) { 
-				//expand import of package to all classes under the package due to we dis-courage the behavior
-				for (Entity child:imported.getChildren()) {
-					importedIds.add(child.getId());
-				}
-			}else {
-				importedIds.add(imported.getId());
-			}
-		}
-		for (Integer id:importedIds) {
-			file.addRelation(new Relation(DependencyType.RELATION_IMPORT,id));
-		}
-	}
-	
-	public void addRelation(int theEntityId, String entityFullName, String relationType) {
-	        getEntity(theEntityId).addRelation(new Relation(relationType,entityFullName));
-	}
 	
 	@Override
-	public VarEntity resolveVarBindings(Entity theContainer, String varName) {
-		while(theContainer!=null) {
-			if (theContainer instanceof ContainerEntity) {
-				for (VarEntity var:((ContainerEntity)theContainer).getVars()) {
+	public VarEntity resolveVarBindings(Entity fromEntity, String varName) {
+		while(fromEntity!=null) {
+			if (fromEntity instanceof ContainerEntity) {
+				for (VarEntity var:((ContainerEntity)fromEntity).getVars()) {
 					if (var.getRawName().equals(varName))
 						return var;
 				}
 			}
-			theContainer = theContainer.getParent();
-		}
-		return null;
-	}
-
-	@Override
-	public FunctionEntity resolveFunctionBindings(Entity theContainer, String varName) {
-		while(theContainer!=null) {
-			if (theContainer instanceof TypeEntity) {
-				TypeEntity theType = (TypeEntity)theContainer;
-				FunctionEntity func = findFunctionFromType(theType, varName);
-				if (func!=null) return func;
-			}
-			theContainer = theContainer.getParent();
+			fromEntity = fromEntity.getParent();
 		}
 		return null;
 	}
 
-	private FunctionEntity findFunctionFromType(TypeEntity type, String functionName) {
-		for (FunctionEntity var:(type).getFunctions()) {
-			if (var.getRawName().equals(functionName))
-				return var;
-		}
-		FunctionEntity funcType = null; 
-		for (TypeEntity inhertedType:type.getInheritedTypes()) {
-			funcType= findFunctionFromType(inhertedType,functionName);
-			if (funcType==null) break;
-		}
-		if (funcType!=null) return funcType;
-		for (TypeEntity implType:type.getImplementedTypes()) {
-			funcType= findFunctionFromType(implType,functionName);
-			if (funcType==null) break;
-		}
-		return funcType;
-	}
+	
 	
 	public void setParent(Entity child, Entity parent) {
 		child.setParent(parent);
@@ -283,13 +138,13 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 			return getTypeEntityByFullName(rawName);
 		}
 		if (rawName.equals("this")) {
-			Entity entityType = this.getAncestorOfType(fromEntity, TypeEntity.class);
+			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
 			if (entityType!=null) {
 				return (TypeEntity) entityType;
 			}
 		}
 		else if (rawName.equals("super")) {
-			Entity entityType = this.getAncestorOfType(fromEntity, TypeEntity.class);
+			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
 			if (entityType!=null) {
 				return ((TypeEntity)entityType).getInheritedType();
 			}
@@ -365,4 +220,80 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public void setBuiltInTypeIdentifier(BuiltInTypeIdenfier buildInProcessor) {
 		this.buildInProcessor = buildInProcessor;
 	}
+
+	@Override
+	public Tuple<TypeEntity, String> locateTypeOfQualifiedName(ContainerEntity fromEntity, String qualifiedName) {
+		String localName = null;
+		while (true) {
+			TypeEntity type = inferType(fromEntity, qualifiedName);
+			if (type != null)
+				return new Tuple<TypeEntity, String>(type, localName);
+			int lpos = qualifiedName.lastIndexOf(".");
+			if (lpos < 0)
+				return null;
+			localName = localName == null ? qualifiedName.substring(lpos + 1)
+					: localName + "." + qualifiedName.substring(lpos + 1);
+			qualifiedName = qualifiedName.substring(0, lpos);
+			type = inferType(fromEntity, qualifiedName);
+			return new Tuple<TypeEntity, String>(type,localName);
+		}
+	}
+	
+	
+	@Override
+	public FunctionEntity resolveFunctionBindings(Entity fromEntity, String functionName) {
+		while(fromEntity!=null) {
+			if (fromEntity instanceof TypeEntity) {
+				TypeEntity theType = (TypeEntity)fromEntity;
+				FunctionEntity func = findFunctionFromType(theType, functionName);
+				if (func!=null) return func;
+			}
+			fromEntity = fromEntity.getParent();
+		}
+		return null;
+	}
+
+	private FunctionEntity findFunctionFromType(TypeEntity type, String functionName) {
+		for (FunctionEntity var:type.getFunctions()) {
+			if (var.getRawName().equals(functionName))
+				return var;
+		}
+		FunctionEntity funcType = null; 
+		for (TypeEntity inhertedType:type.getInheritedTypes()) {
+			funcType= findFunctionFromType(inhertedType,functionName);
+			if (funcType==null) break;
+		}
+		if (funcType!=null) return funcType;
+		for (TypeEntity implType:type.getImplementedTypes()) {
+			funcType= findFunctionFromType(implType,functionName);
+			if (funcType==null) break;
+		}
+		return funcType;
+	}
+	
+	
+	public void addRelation(int theEntityId, String entityFullName, String relationType) {
+	        getEntity(theEntityId).addRelation(new Relation(relationType,entityFullName));
+	}
+
+	@Override
+	public boolean isBuiltInTypePrefix(String prefix) {
+		return buildInProcessor.isBuiltInTypePrefix(prefix);
+	}
+
+	@Override
+	public List<Entity> resolveImportEntity(String item) {
+		ArrayList<Entity> result = new ArrayList<>();
+		Entity imported = this.getEntity(item);
+		if (imported==null) return result;
+		if (imported instanceof PackageEntity) { 
+			//expand import of package to all classes under the package due to we dis-courage the behavior
+			for (Entity child:imported.getChildren()) {
+				result.add(child);
+			}
+		}else {
+			result.add(imported);
+		}
+		return result;
+	}
 }

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -1,12 +1,21 @@
 package depends.entity.types;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 
 import depends.entity.ContainerEntity;
+import depends.entity.Entity;
+import depends.entity.TypeInfer;
 
 public class FileEntity extends ContainerEntity{
 	HashMap<String,String> importedNames = new HashMap<>();
+	private ArrayList<Entity> resolvedImportedEntities = new ArrayList<>();
+
+	public List<Entity> getResolvedImportedEntities() {
+		return resolvedImportedEntities;
+	}
 	public FileEntity(String fullName, int fileId) {
 		super(fullName, null,fileId);
 		setQualifiedName(fullName);
@@ -32,4 +41,13 @@ public class FileEntity extends ContainerEntity{
 	public Collection<String> imports() {
 		return importedNames.values();
 	}
+	@Override
+	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+		for (String item:importedNames.values()) {
+			if (typeInferer.isBuiltInTypePrefix(item)) continue;
+			List<Entity> importedEntities = typeInferer.resolveImportEntity(item);
+			this.resolvedImportedEntities.addAll(importedEntities);
+		}		
+		super.inferLocalLevelTypes(typeInferer);
+	}
 }

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -56,6 +56,7 @@ public class FunctionEntity extends ContainerEntity{
 	public Collection<TypeEntity> getThrowTypes() {
 		return throwTypes;
 	}
+	
 	@Override
 	public TypeEntity lookupVarDefinition(String identifier) {
 		for (VarEntity param:parameters) {

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -41,8 +41,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(15,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
-        
+        assertEquals(16,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
 	}
 	
 	@Test
@@ -52,7 +51,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(13,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        assertEquals(12,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 }

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -10,12 +10,12 @@ class ClassA{
 
 public class ComplexExpressionExample {
 	void setExample(ClassA a) { 	      //parameter a(1)
-//		(new ClassA()).x.m = 3;      //set (newA) x, m (2)
-//		a.x.m = 1;                        //set m (1), use a, x? or set a,x?
-//		ClassA a2 = new ClassA();             //def a2 (1), set a2
+		(new ClassA()).x.m = 3;      //set (newA) x, m (2)
+		a.x.m = 1;                        //set m (1), use a, x? or set a,x?
+		ClassA a2 = new ClassA();             //def a2 (1), set a2
 		(ClassA)a.foo();
-//		a2.x.m = 1;             //set a2, set x, set m (3)
-//		ClassA a3[] = new ClassA[10];          //def a3(1)
-//		a3[1].x.m = 3; //still lack 1          //set a3,t(2)
+		a2.x.m = 1;             //set a2, set x, set m (3)
+		ClassA a3[] = new ClassA[10];          //def a3(1)
+		a3[1].x.m = 3; //still lack 1          //set a3,t(2)
 	}
 }
\ No newline at end of file

0255093c1d7bff912e2e4561835f0c2a72541f85
@@ -3,39 +3,17 @@ package depends.deptypes;
 import java.util.ArrayList;
 
 public class DependencyType {
-	
-    // struct->method
-    public static final String RELATION_RECEIVED_BY = "Received by";
     public static final String RELATION_RECEIVE = "Receive";
-
-    //structType/aliasType->interface
     public static final String RELATION_IMPLEMENT = "Implement";
-    public static final String RELATION_IMPLEMENTED_BY = "Implemented by";
-
-    //file->package
     public static final String RELATION_IMPORT = "Import";
-
-    //function-function; function->method; method->function; method->method
     public static final String RELATION_CALL = "Call";
-
-    //function/method->var
     public static final String RELATION_PARAMETER = "Parameter";
-
-    //function/method->var
     public static final String RELATION_RETURN = "Return";
-
-    //function/method->OperandVar
     public static final String RELATION_SET = "Set";
-
-    //function/method->OperandVar
     public static final String RELATION_USE = "Use";
-
-    public static final String RELATION_INHERIT = "Inherit";
-    
+    public static final String RELATION_INHERIT = "Extend";
 	public static final String RELATION_DEFINE = "Define";
-
-    public static final String RELATION_EMBED = "Embed";
-    public static final String RELATION_EMBED_BY = "Embeded by";
+	public static final String RELATION_CREATE = "Create";
 
     /**
      * Mask of dependencies.

0255093c1d7bff912e2e4561835f0c2a72541f85
@@ -23,6 +23,8 @@ public class Expression {
 	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
 	public boolean isCall = false;
 	public boolean isLogic = false;
+	public boolean isCreate = false;
+	public boolean deriveTypeFromChild = true;
 	List<Tuple<String, String>> relations = new ArrayList<>();
 
 	public Expression(Integer id, Integer parentId) {
@@ -62,6 +64,7 @@ public class Expression {
 		Expression parent = expressionList.get(this.parentId);
 		if (parent==null) return;
 		if (parent.type != null)return;
+		if (!parent.deriveTypeFromChild) return;
 		if (parent.firstChildId!=this.id) return;
 		if (parent.type!=null) return;
 		

0255093c1d7bff912e2e4561835f0c2a72541f85
@@ -60,6 +60,9 @@ public class RelationCounter {
 			if (expression.isCall) {
 				entity.addRelation(new Relation(DependencyType.RELATION_CALL,expression.type.getId(),expression.type.getQualifiedName()));
 			}
+			if (expression.isCreate) {
+				entity.addRelation(new Relation(DependencyType.RELATION_CREATE,expression.type.getId(),expression.type.getQualifiedName()));
+			}
 			else if (expression.isSet) {
 				entity.addRelation(new Relation(DependencyType.RELATION_SET,expression.type.getId(),expression.type.getQualifiedName()));
 			}else {

0255093c1d7bff912e2e4561835f0c2a72541f85
@@ -4,6 +4,7 @@ import org.antlr.v4.runtime.RuleContext;
 
 import depends.entity.Expression;
 import depends.extractor.HandlerContext;
+import depends.javaextractor.JavaParser;
 import depends.javaextractor.JavaParser.ExpressionContext;
 import depends.javaextractor.JavaParser.PrimaryContext;
 import depends.util.Tuple;
@@ -49,6 +50,14 @@ public class ExpressionUsage {
 		expression.isSet = isSet(ctx);
 		expression.isCall = ctx.methodCall()==null?false:true;
 		expression.isLogic = isLogic(ctx);
+		if (ctx.creator()!=null ||
+				ctx.methodCall()!=null)
+			expression.deriveTypeFromChild = false;
+		expression.isCall = true;
+		if (ctx.creator()!=null ||
+				ctx.innerCreator()!=null)
+			expression.isCreate = true;
+			
 	}
 
 

cc02daf915ed3f85ea1ab938a8986c8243c7f46f
@@ -0,0 +1,21 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.repo.EntityRepo;
+
+public class CppParameterParserTest {
+	@Test
+	public void test_parameter() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
+        CppFileParser parser = new CppFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        //assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+	}
+
+}

a65bed10e91a8735f9292adf240ffb9ceedda185
@@ -15,7 +15,7 @@ public class CppParameterParserTest {
         CppFileParser parser = new CppFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        //assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

f15ea38f379074f8d5b15f34ec1db1998dd7cf1b
@@ -3,66 +3,31 @@ package depends.deptypes;
 import java.util.ArrayList;
 
 public class DependencyType {
-    public static final String RELATION_RECEIVE = "Receive";
-    public static final String RELATION_IMPLEMENT = "Implement";
-    public static final String RELATION_IMPORT = "Import";
-    public static final String RELATION_CALL = "Call";
-    public static final String RELATION_PARAMETER = "Parameter";
-    public static final String RELATION_RETURN = "Return";
-    public static final String RELATION_SET = "Set";
-    public static final String RELATION_USE = "Use";
-    public static final String RELATION_INHERIT = "Extend";
-	public static final String RELATION_DEFINE = "Define";
-	public static final String RELATION_CREATE = "Create";
-
-    /**
-     * Mask of dependencies.
-     * 0 - IMPORT
-     * 1 - INHERIT
-     * 2 - IMPLEMENT
-     * 3 - RECEIVE
-     * 4 - CALL
-     * 5 - SET
-     * 6 - USE
-     * 7 - PARAMETER
-     * 8 - RETURN 
-     * @param depMask
-     * @return
-     */
-	public static final ArrayList<String> resolveMask(String depMask) {
-        ArrayList<String> depedencyTypes = new ArrayList<String>();
-        for(int i = 0; i < depMask.toCharArray().length; i++) {
-            if(depMask.toCharArray()[i] == '1') {
-                if(i == 0) {
-                    depedencyTypes.add(RELATION_IMPORT);
-                }
-                else if (i == 1) {
-                    depedencyTypes.add(RELATION_INHERIT);
-                }
-                else if (i == 2) {
-                    depedencyTypes.add(RELATION_IMPLEMENT);
-                }
-                else if (i == 3) {
-                    depedencyTypes.add(RELATION_RECEIVE);
-                }
-                else if (i == 4) {
-                    depedencyTypes.add(RELATION_CALL);
-                }
-                else if (i == 5) {
-                    depedencyTypes.add(RELATION_SET);
-                }
-                else if (i == 6) {
-                    depedencyTypes.add(RELATION_USE);
-                }
-                else if (i == 7) {
-                    depedencyTypes.add(RELATION_PARAMETER);
-                }
-                else if (i == 8) {
-                    depedencyTypes.add(RELATION_RETURN);
-                }
-            }
-        }
-        return depedencyTypes;
-    }
+	public static final String IMPORT = "Import";
+	public static final String DEFINE = "Define";
+	public static final String IMPLEMENT = "Implement";
+	public static final String INHERIT = "Extend";
+	public static final String CALL = "Call";
+	public static final String PARAMETER = "Parameter";
+	public static final String RETURN = "Return";
+	public static final String SET = "Set";
+	public static final String CREATE = "Create";
+	public static final String USE = "Use";
+	public static final String RECEIVE = "Receive";
 
+	public static ArrayList<String> allDependencies() {
+		ArrayList<String> depedencyTypes = new ArrayList<String>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(DEFINE);
+		depedencyTypes.add(IMPLEMENT);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(RECEIVE);
+		return depedencyTypes;
+	}
 }

f15ea38f379074f8d5b15f34ec1db1998dd7cf1b
@@ -40,15 +40,15 @@ public class RelationCounter {
 	private void computeContainerRelations(ContainerEntity entity) {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
-				entity.addRelation(new Relation(DependencyType.RELATION_DEFINE,var.getType().getId(),var.getType().getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.DEFINE,var.getType().getId(),var.getType().getQualifiedName()));
 			else
 				System.out.println("cannot resove type of "+var.getQualifiedName());
 		}
 		for (TypeEntity type:entity.getResolvedAnnotations()) {
-			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
+			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
 		}
 		for (TypeEntity type:entity.getResolvedTypeParameters()) {
-			entity.addRelation(new Relation(DependencyType.RELATION_USE,type.getId(),type.getQualifiedName()));
+			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
 		}
 		
 		HashSet<TypeEntity> usedEntities = new HashSet<>();
@@ -58,52 +58,52 @@ public class RelationCounter {
 				continue;
 			}
 			if (expression.isCall) {
-				entity.addRelation(new Relation(DependencyType.RELATION_CALL,expression.type.getId(),expression.type.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CALL,expression.type.getId(),expression.type.getQualifiedName()));
 			}
 			if (expression.isCreate) {
-				entity.addRelation(new Relation(DependencyType.RELATION_CREATE,expression.type.getId(),expression.type.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CREATE,expression.type.getId(),expression.type.getQualifiedName()));
 			}
 			else if (expression.isSet) {
-				entity.addRelation(new Relation(DependencyType.RELATION_SET,expression.type.getId(),expression.type.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.SET,expression.type.getId(),expression.type.getQualifiedName()));
 			}else {
 				usedEntities.add(expression.type);
 			}
 		}
 		
 		for (TypeEntity usedEntity:usedEntities) {
-			entity.addRelation(new Relation(DependencyType.RELATION_USE,usedEntity.getId(),usedEntity.getQualifiedName()));
+			entity.addRelation(new Relation(DependencyType.USE,usedEntity.getId(),usedEntity.getQualifiedName()));
 		}
 	}
 
 	private void computeTypeRelations(TypeEntity type) {
 		for (TypeEntity superType:type.getInheritedTypes()) {
-			type.addRelation(new Relation(DependencyType.RELATION_INHERIT,superType.getId(),superType.getQualifiedName()));
+			type.addRelation(new Relation(DependencyType.INHERIT,superType.getId(),superType.getQualifiedName()));
 		}
 		for (TypeEntity interfaceType:type.getImplementedTypes()) {
-			type.addRelation(new Relation(DependencyType.RELATION_IMPLEMENT,interfaceType.getId(),interfaceType.getQualifiedName()));
+			type.addRelation(new Relation(DependencyType.IMPLEMENT,interfaceType.getId(),interfaceType.getQualifiedName()));
 		}
 	}
 
 	private void computeFunctionRelations(FunctionEntity func) {
 		for (TypeEntity returnType:func.getReturnTypes()) {
-			func.addRelation(new Relation(DependencyType.RELATION_RETURN,returnType.getId(),returnType.getQualifiedName()));
+			func.addRelation(new Relation(DependencyType.RETURN,returnType.getId(),returnType.getQualifiedName()));
 		}
 		for (VarEntity parameter:func.getParameters()) {
 			if (parameter.getType()!=null) {
-				func.addRelation(new Relation(DependencyType.RELATION_PARAMETER,parameter.getType().getId(),parameter.getType().getQualifiedName()));
+				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType().getId(),parameter.getType().getQualifiedName()));
 			}else {
 				System.out.println("unsolved param: "+parameter);
 			}
 		}
 		for (TypeEntity throwType:func.getThrowTypes()) {
-			func.addRelation(new Relation(DependencyType.RELATION_USE,throwType.getId(),throwType.getQualifiedName()));
+			func.addRelation(new Relation(DependencyType.USE,throwType.getId(),throwType.getQualifiedName()));
 		}
 	}
 
 	private void computeImports(FileEntity file) {
 		List<Entity> imports = file.getResolvedImportedEntities();
 		for (Entity imported:imports) {
-			file.addRelation(new Relation(DependencyType.RELATION_IMPORT,imported.getId()));
+			file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
 		}
 	}
 

c3546aa8e251f4fa07c2cbc0f75bd05b3b9856b3
@@ -0,0 +1,17 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
+
+class ANSICParserExtensionConfigurationExtension extends ANSICParserExtensionConfiguration {
+
+	@Override
+	public boolean supportDeclspecSpecifiers() {
+		return true;
+	}
+
+	@Override
+	public boolean supportKnRC() {
+		return true;
+	}
+
+}

c3546aa8e251f4fa07c2cbc0f75bd05b3b9856b3
@@ -0,0 +1,17 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
+
+class GPPParserExtensionConfigurationExtension extends GPPParserExtensionConfiguration {
+
+	@Override
+	public boolean supportKnRC() {
+		return true;
+	}
+
+	@Override
+	public boolean supportParameterInfoBlock() {
+		return true;
+	}
+
+}

c3546aa8e251f4fa07c2cbc0f75bd05b3b9856b3
@@ -6,13 +6,14 @@ import java.io.IOException;
 import org.junit.Test;
 
 import depends.entity.repo.EntityRepo;
+import depends.extractor.cpp.cdt.CdtCppFileParser;
 
 public class CppParameterParserTest {
 	@Test
 	public void test_parameter() throws IOException {
 		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
-        CppFileParser parser = new CppFileParser(src,repo);
+        CppFileParser parser = new  CdtCppFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
         assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());

c06c44661c4b27e7f0e238160543367e6553fecf
@@ -107,6 +107,10 @@ public abstract class Entity {
 		this.qualifiedName = qualifiedName;
 	}
 
+	public void setRawName(String rawName) {
+		this.rawName = rawName;
+	}
+	
 	public String getQualifiedName() {
 		return qualifiedName;
 	}

c06c44661c4b27e7f0e238160543367e6553fecf
@@ -56,7 +56,7 @@ public class HandlerContext {
 		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
 				idGenerator.generateId(),returnType,parameters);
 		entityRepo.add(functionEntity);
-		this.currentType().addFunction(functionEntity);
+		this.typeOrFileContainer().addFunction(functionEntity);
 		entityStack.push(functionEntity);
 		functionEntity.addThrowTypes(throwedType);
 	}
@@ -76,6 +76,19 @@ public class HandlerContext {
 		}
 		return null;
 	}
+	
+	public ContainerEntity typeOrFileContainer() {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof TypeEntity)
+				return (ContainerEntity) t;
+			if (t instanceof FileEntity) {
+				return (ContainerEntity)t;
+			}
+		}
+		return null;
+	}
+
 
 	public FunctionEntity currentFunction() {
 		for (int i = entityStack.size() - 1; i >= 0; i--) {

c06c44661c4b27e7f0e238160543367e6553fecf
@@ -0,0 +1,83 @@
+package depends.extractor.cpp.cdt;
+
+import java.io.IOException;
+
+import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
+import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
+import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
+import org.eclipse.cdt.core.dom.parser.c.GCCScannerExtensionConfiguration;
+import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
+import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
+import org.eclipse.cdt.core.parser.CodeReader;
+import org.eclipse.cdt.core.parser.FileContent;
+import org.eclipse.cdt.core.parser.IScanner;
+import org.eclipse.cdt.core.parser.NullLogService;
+import org.eclipse.cdt.core.parser.ParserLanguage;
+import org.eclipse.cdt.core.parser.ParserMode;
+import org.eclipse.cdt.core.parser.ScannerInfo;
+import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
+import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
+import org.eclipse.cdt.internal.core.dom.parser.c.GNUCSourceParser;
+import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
+import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
+
+public class CDTParser {
+	NullLogService NULL_LOG = new NullLogService();
+	public IASTTranslationUnit parse(String file   ) {
+		/*
+		 * *    QUICK_PARSE
+				Does not parse inside functions or included files
+				
+				STRUCTURAL_PARSE
+				    Does not parse inside functions but parses included files
+				
+				COMPLETE_PARSE
+				    Parses inside functions and included files
+				
+				COMPLETION_PARSE
+				    Parses inside functions and included files, stops at offsets, and optimizes symbol query lookups
+				
+				SELECTION_PARSE
+				    Parses inside functions and included files, stops at offsets, and provides semantic information about a selected range*
+		 */
+		CodeReader cr;
+		try {
+			cr = new CodeReader(file);
+			if (file.endsWith(".c"))
+				return getTranslationUnitofC(file, new String(cr.buffer));
+			else
+				return getTranslationUnitofCPP(file,new String(cr.buffer));
+		} catch (IOException e) {
+			System.err.println("File " + file + "does not exists!");
+		}
+		return new CASTTranslationUnit();
+	}
+
+	private IASTTranslationUnit getTranslationUnitofC(String file, String content) {
+		IScannerExtensionConfiguration configuration = GCCScannerExtensionConfiguration
+				.getInstance();
+		IScanner scanner = new CPreprocessor(FileContent.create(file,
+				content.toCharArray()), new ScannerInfo(), ParserLanguage.C,
+				NULL_LOG, configuration, null);
+		ANSICParserExtensionConfiguration conf = new ANSICParserExtensionConfiguration();
+		
+		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCSourceParser(
+				scanner, ParserMode.COMPLETE_PARSE, NULL_LOG,conf );
+		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
+		return astTranslationUnit;
+	}
+	
+	private IASTTranslationUnit getTranslationUnitofCPP(String file, String content) {
+		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
+				.getInstance();
+		IScanner scanner = new CPreprocessor(FileContent.create(file,
+				content.toCharArray()), new ScannerInfo(), ParserLanguage.CPP,
+				new NullLogService(), configuration, null);
+		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
+				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),
+				new GPPParserExtensionConfiguration(), null);
+		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
+		return astTranslationUnit;
+	}
+
+}

c06c44661c4b27e7f0e238160543367e6553fecf
@@ -2,6 +2,7 @@ package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
+import java.util.ArrayList;
 
 import org.junit.Test;
 
@@ -13,7 +14,7 @@ public class CppParameterParserTest {
 	public void test_parameter() throws IOException {
 		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
-        CppFileParser parser = new  CdtCppFileParser(src,repo);
+        CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>());
         parser.parse();
         repo.resolveAllBindings();
         assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());

929f78c23df835655fbbb558aff7da22eb3fa9d4
@@ -44,6 +44,9 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	
 	public void add(Entity entity) {
 		allEntitiesById.put(entity.getId(), entity);
+		if (entity instanceof FileEntity) {
+			System.out.println("**FOUND " + entity.getQualifiedName());
+		}
 		if (entity.getQualifiedName()!=null)
 			allEntieisByName.put(entity.getQualifiedName(), entity);
 		if (entity.getParent()!=null)
@@ -282,9 +285,9 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	}
 
 	@Override
-	public List<Entity> resolveImportEntity(String item) {
+	public List<Entity> resolveImportEntity(String importedName) {
 		ArrayList<Entity> result = new ArrayList<>();
-		Entity imported = this.getEntity(item);
+		Entity imported = this.getEntity(importedName);
 		if (imported==null) return result;
 		if (imported instanceof PackageEntity) { 
 			//expand import of package to all classes under the package due to we dis-courage the behavior

929f78c23df835655fbbb558aff7da22eb3fa9d4
@@ -20,11 +20,17 @@ public class FileEntity extends ContainerEntity{
 		super(fullName, null,fileId);
 		setQualifiedName(fullName);
 	}
-	public void addImport(String importedTypeOrPackage) {
-		String lastName = importedTypeOrPackage;
+	
+	/**
+	 * 
+	 * @param importedName could be className, package Name  in JAVA
+	 *                     could be file in C/C++
+	 */
+	public void addImport(String importedName) {
+		String lastName = importedName;
         if (lastName.indexOf(".") > 0)
         	lastName = lastName.substring(lastName.lastIndexOf(".")+1);
-        importedNames.put(lastName, importedTypeOrPackage);
+        importedNames.put(lastName, importedName);
 	}
 	public String getImport(String lastName) {
 		return importedNames.get(lastName);
@@ -32,7 +38,7 @@ public class FileEntity extends ContainerEntity{
 	@Override
 	public String getQualifiedName() {
 		if (this.getParent()==null)
-			return "";
+			return super.getQualifiedName();
 		if (this.getParent() instanceof PackageEntity)
 			return this.getParent().getQualifiedName();
 		else
@@ -43,9 +49,9 @@ public class FileEntity extends ContainerEntity{
 	}
 	@Override
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		for (String item:importedNames.values()) {
-			if (typeInferer.isBuiltInTypePrefix(item)) continue;
-			List<Entity> importedEntities = typeInferer.resolveImportEntity(item);
+		for (String importedName:importedNames.values()) {
+			if (typeInferer.isBuiltInTypePrefix(importedName)) continue;
+			List<Entity> importedEntities = typeInferer.resolveImportEntity(importedName);
 			this.resolvedImportedEntities.addAll(importedEntities);
 		}		
 		super.inferLocalLevelTypes(typeInferer);

929f78c23df835655fbbb558aff7da22eb3fa9d4
@@ -64,8 +64,8 @@ public class HandlerContext {
 		entityStack.pop();
 	}
 
-	public void foundNewImport(String importedTypeOrPackage) {
-		currentFileEntity.addImport(importedTypeOrPackage);
+	public void foundNewImport(String importedName) {
+		currentFileEntity.addImport(importedName);
 	}
 
 	public TypeEntity currentType() {

929f78c23df835655fbbb558aff7da22eb3fa9d4
@@ -48,7 +48,7 @@ public class CDTParser {
 			else
 				return getTranslationUnitofCPP(file,new String(cr.buffer));
 		} catch (IOException e) {
-			System.err.println("File " + file + "does not exists!");
+			System.err.println("File " + file + " does not exists!");
 		}
 		return new CASTTranslationUnit();
 	}

9e18a0c54d88fb6c260a5571c43700dd5e439e67
@@ -44,11 +44,13 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	
 	public void add(Entity entity) {
 		allEntitiesById.put(entity.getId(), entity);
-		if (entity instanceof FileEntity) {
-			System.out.println("**FOUND " + entity.getQualifiedName());
+		if (entity.getQualifiedName()!=null) {
+			if (entity.getQualifiedName().isEmpty()) {
+				allEntieisByName.put(entity.getRawName(), entity);
+			}else {
+				allEntieisByName.put(entity.getQualifiedName(), entity);
+			}
 		}
-		if (entity.getQualifiedName()!=null)
-			allEntieisByName.put(entity.getQualifiedName(), entity);
 		if (entity.getParent()!=null)
 			this.setParent(entity, entity.getParent());
 	}

9e18a0c54d88fb6c260a5571c43700dd5e439e67
@@ -37,8 +37,9 @@ public class FileEntity extends ContainerEntity{
 	}
 	@Override
 	public String getQualifiedName() {
-		if (this.getParent()==null)
-			return super.getQualifiedName();
+		if (this.getParent()==null){
+				return "";
+		}
 		if (this.getParent() instanceof PackageEntity)
 			return this.getParent().getQualifiedName();
 		else

9e18a0c54d88fb6c260a5571c43700dd5e439e67
@@ -36,6 +36,9 @@ public class FunctionEntity extends ContainerEntity{
 		this.returnTypeIdentifiers.add(returnType);
 	}
 	public void addThrowTypes(List<String> throwedType) {
+		if (throwedType==null) {
+			System.out.println("****");
+		}
 		throwTypesIdentifiers.addAll(throwedType);
 	}
 	

9e18a0c54d88fb6c260a5571c43700dd5e439e67
@@ -0,0 +1,22 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.repo.EntityRepo;
+
+public class JavaAnnotationParserTest {
+	@Test
+	public void test_annotationType() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("AnnotationTest").getRelations().size());
+	}
+
+}

fbda0152afdd1ff508bed47a1347428a9c055f91
@@ -26,10 +26,13 @@ public class FileEntity extends ContainerEntity{
 	 * @param importedName could be className, package Name  in JAVA
 	 *                     could be file in C/C++
 	 */
-	public void addImport(String importedName) {
+	public void addImport(String importedName, boolean useFileAsImportedKey) {
 		String lastName = importedName;
-        if (lastName.indexOf(".") > 0)
-        	lastName = lastName.substring(lastName.lastIndexOf(".")+1);
+		if (useFileAsImportedKey) {
+			;
+		}else if (lastName.indexOf(".") > 0) {
+			lastName = lastName.substring(lastName.lastIndexOf(".")+1);
+		}
         importedNames.put(lastName, importedName);
 	}
 	public String getImport(String lastName) {

fbda0152afdd1ff508bed47a1347428a9c055f91
@@ -64,8 +64,15 @@ public class HandlerContext {
 		entityStack.pop();
 	}
 
-	public void foundNewImport(String importedName) {
-		currentFileEntity.addImport(importedName);
+	/**
+	 * 
+	 * @param importedName 
+	 * @param usedFilenameAsKey - to identify whether the importedName is a file name
+	 *                            in (C/C++), the value should be true due to it is a filename
+	 *                            in Java, the value should be false due to it is a package or class name
+	 */
+	public void foundNewImport(String importedName, boolean usedFilenameAsKey) {
+		currentFileEntity.addImport(importedName,usedFilenameAsKey);
 	}
 
 	public TypeEntity currentType() {

693efac76f15e268b40b292e439296a71eadbeb9
@@ -1,6 +1,10 @@
 package depends.extractor.cpp.cdt;
 
 import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
@@ -11,6 +15,7 @@ import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
 import org.eclipse.cdt.core.parser.IScanner;
+import org.eclipse.cdt.core.parser.IScannerInfo;
 import org.eclipse.cdt.core.parser.NullLogService;
 import org.eclipse.cdt.core.parser.ParserLanguage;
 import org.eclipse.cdt.core.parser.ParserMode;
@@ -22,7 +27,12 @@ import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 
 public class CDTParser {
+	public CDTParser(List<String> includesPath) {
+		sysIncludePath = includesPath.toArray(new String[] {});
+	}
 	NullLogService NULL_LOG = new NullLogService();
+	String[] sysIncludePath = new String[] {};
+	Map<String, String> macroMap = new HashMap<>();
 	public IASTTranslationUnit parse(String file   ) {
 		/*
 		 * *    QUICK_PARSE
@@ -43,9 +53,9 @@ public class CDTParser {
 		CodeReader cr;
 		try {
 			cr = new CodeReader(file);
-			if (file.endsWith(".c"))
-				return getTranslationUnitofC(file, new String(cr.buffer));
-			else
+//			if (file.endsWith(".c"))
+//				return getTranslationUnitofC(file, new String(cr.buffer));
+//			else
 				return getTranslationUnitofCPP(file,new String(cr.buffer));
 		} catch (IOException e) {
 			System.err.println("File " + file + " does not exists!");
@@ -56,8 +66,9 @@ public class CDTParser {
 	private IASTTranslationUnit getTranslationUnitofC(String file, String content) {
 		IScannerExtensionConfiguration configuration = GCCScannerExtensionConfiguration
 				.getInstance();
+
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(), ParserLanguage.C,
+				content.toCharArray()),  new ScannerInfo(macroMap,sysIncludePath), ParserLanguage.C,
 				NULL_LOG, configuration, null);
 		ANSICParserExtensionConfiguration conf = new ANSICParserExtensionConfiguration();
 		
@@ -71,7 +82,7 @@ public class CDTParser {
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
 				.getInstance();
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(), ParserLanguage.CPP,
+				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath), ParserLanguage.CPP,
 				new NullLogService(), configuration, null);
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
 				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),

77cc6f6c24fe3a65356102f66a6dd940056c93be
@@ -4,21 +4,24 @@ import java.util.ArrayList;
 
 public class DependencyType {
 	public static final String IMPORT = "Import";
-	public static final String DEFINE = "Define";
+	public static final String CONTAIN = "Contain";
 	public static final String IMPLEMENT = "Implement";
 	public static final String INHERIT = "Extend";
 	public static final String CALL = "Call";
 	public static final String PARAMETER = "Parameter";
 	public static final String RETURN = "Return";
 	public static final String SET = "Set";
-	public static final String CREATE = "Create";
 	public static final String USE = "Use";
 	public static final String RECEIVE = "Receive";
+	public static final String CREATE = "Create";
+	public static final String CAST = "Cast";
+	public static final String THROW = "Throw";
+	public static final String ANNOTATION = "Annotation";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();
 		depedencyTypes.add(IMPORT);
-		depedencyTypes.add(DEFINE);
+		depedencyTypes.add(CONTAIN);
 		depedencyTypes.add(IMPLEMENT);
 		depedencyTypes.add(INHERIT);
 		depedencyTypes.add(CALL);
@@ -28,6 +31,9 @@ public class DependencyType {
 		depedencyTypes.add(CREATE);
 		depedencyTypes.add(USE);
 		depedencyTypes.add(RECEIVE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		depedencyTypes.add(ANNOTATION);
 		return depedencyTypes;
 	}
 }

77cc6f6c24fe3a65356102f66a6dd940056c93be
@@ -24,6 +24,7 @@ public class Expression {
 	public boolean isCall = false;
 	public boolean isLogic = false;
 	public boolean isCreate = false;
+	public boolean isCast = false;
 	public boolean deriveTypeFromChild = true;
 	List<Tuple<String, String>> relations = new ArrayList<>();
 
@@ -73,7 +74,6 @@ public class Expression {
 			parent.returnType = typeInfer.inferType(this.returnType, "<Built-in>");
 			parent.type = typeInfer.inferType(this.returnType, "<Built-in>");
 		}
-		
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot && (!parent.isCall)) {
 			VarEntity returnType = typeInfer.resolveVarBindings(this.returnType, parent.identifier);

77cc6f6c24fe3a65356102f66a6dd940056c93be
@@ -40,7 +40,7 @@ public class RelationCounter {
 	private void computeContainerRelations(ContainerEntity entity) {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
-				entity.addRelation(new Relation(DependencyType.DEFINE,var.getType().getId(),var.getType().getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType().getId(),var.getType().getQualifiedName()));
 			else
 				System.out.println("cannot resove type of "+var.getQualifiedName());
 		}
@@ -63,8 +63,11 @@ public class RelationCounter {
 			if (expression.isCreate) {
 				entity.addRelation(new Relation(DependencyType.CREATE,expression.type.getId(),expression.type.getQualifiedName()));
 			}
-			else if (expression.isSet) {
-				entity.addRelation(new Relation(DependencyType.SET,expression.type.getId(),expression.type.getQualifiedName()));
+			else if (expression.isSet) { //SET is merged with USE
+				entity.addRelation(new Relation(DependencyType.USE,expression.type.getId(),expression.type.getQualifiedName()));
+			}
+			else if (expression.isCast) { 
+				entity.addRelation(new Relation(DependencyType.CAST,expression.type.getId(),expression.type.getQualifiedName()));
 			}else {
 				usedEntities.add(expression.type);
 			}
@@ -96,7 +99,7 @@ public class RelationCounter {
 			}
 		}
 		for (TypeEntity throwType:func.getThrowTypes()) {
-			func.addRelation(new Relation(DependencyType.USE,throwType.getId(),throwType.getQualifiedName()));
+			func.addRelation(new Relation(DependencyType.THROW,throwType.getId(),throwType.getQualifiedName()));
 		}
 	}
 

77cc6f6c24fe3a65356102f66a6dd940056c93be
@@ -57,6 +57,10 @@ public class ExpressionUsage {
 		if (ctx.creator()!=null ||
 				ctx.innerCreator()!=null)
 			expression.isCreate = true;
+		if (ctx.typeCast()!=null) {
+			expression.isCast=true;
+			expression.rawType = ctx.typeCast().typeType().getText();
+		}
 			
 	}
 

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -42,7 +42,7 @@ public class RelationCounter {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType().getId(),var.getType().getQualifiedName()));
 			else
-				System.out.println("cannot resove type of "+var.getQualifiedName());
+				System.out.println("cannot resolve type of "+var.getQualifiedName());
 		}
 		for (TypeEntity type:entity.getResolvedAnnotations()) {
 			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
@@ -54,7 +54,7 @@ public class RelationCounter {
 		HashSet<TypeEntity> usedEntities = new HashSet<>();
 		for (Expression expression:entity.expressions().values()){
 			if (expression.type==null) {
-				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
+//				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
 				continue;
 			}
 			if (expression.isCall) {

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -7,10 +7,8 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import depends.deptypes.DependencyType;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.Expression;
 import depends.entity.IdGenerator;
 import depends.entity.Relation;
 import depends.entity.RelationCounter;
@@ -28,11 +26,10 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
 	private BuiltInTypeIdenfier buildInProcessor = new NullParser();
-	private TypeEntity buildInType;
+	private static final TypeEntity buildInType = new TypeEntity("built-in", null, -1);
 	
 	public EntityRepo() {
 		nextAvaliableIndex = 0;
-		buildInType = new TypeEntity("built-in", null, -1);
 	}
 	
 	public Entity getEntity(String entityName) {
@@ -139,9 +136,6 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType();
 		if (fromEntity==null) return null;
 		TypeEntity type = null;
-		if (rawName.contains(".")) {
-			return getTypeEntityByFullName(rawName);
-		}
 		if (rawName.equals("this")) {
 			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
 			if (entityType!=null) {
@@ -154,7 +148,12 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 				return ((TypeEntity)entityType).getInheritedType();
 			}
 		}
-		
+		else if (rawName.contains(".")) {
+			TypeEntity t = getTypeEntityByFullName(rawName);
+			if (t!=null)
+				return t;
+		}
+
 		while(true) {
 			if (fromEntity instanceof TypeEntity) {
 				if (fromEntity.getRawName().equals(rawName))
@@ -204,19 +203,27 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		}
 		return null;
 	}
+	
+	private TypeEntity tryGetTypeEntity(String rawName, TypeEntity typeEntity, String qualifiedName) {
+		if (typeEntity.getRawName().equals(rawName)) {
+			return (TypeEntity)typeEntity;
+		}
+		if (rawName.equals(qualifiedName + typeEntity.getRawName())) {
+			return  (TypeEntity)typeEntity;
+		}
+		for (Entity child:typeEntity.getChildren()) {
+			if (child instanceof TypeEntity) {
+				TypeEntity type = tryGetTypeEntity(rawName,(TypeEntity)child,qualifiedName+typeEntity.getRawName()+".");
+				if (type!=null) return type;
+			}
+		}
+		return null;
+	}
 	private TypeEntity getTypeEntityUnder(String rawName, Entity entity) {
 		for (Entity level_1:entity.getChildren()) {
 			if (level_1 instanceof TypeEntity) {
-				if (level_1.getRawName().equals(rawName)) {
-					return (TypeEntity)level_1;
-				}
-			}
-			for (Entity level_2:level_1.getChildren()) {
-				if (level_2 instanceof TypeEntity) {
-					if (level_2.getRawName().equals(rawName)) {
-						return (TypeEntity)level_2;
-					}
-				}
+				TypeEntity type = tryGetTypeEntity(rawName,(TypeEntity)level_1,"");
+				if (type!=null) return type;
 			}
 		}
 		return null;

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -10,7 +10,7 @@ import depends.entity.Entity;
 import depends.entity.TypeInfer;
 
 public class FileEntity extends ContainerEntity{
-	HashMap<String,String> importedNames = new HashMap<>();
+	private List<String> importedNames = new ArrayList<>();
 	private ArrayList<Entity> resolvedImportedEntities = new ArrayList<>();
 
 	public List<Entity> getResolvedImportedEntities() {
@@ -27,16 +27,14 @@ public class FileEntity extends ContainerEntity{
 	 *                     could be file in C/C++
 	 */
 	public void addImport(String importedName, boolean useFileAsImportedKey) {
-		String lastName = importedName;
-		if (useFileAsImportedKey) {
-			;
-		}else if (lastName.indexOf(".") > 0) {
-			lastName = lastName.substring(lastName.lastIndexOf(".")+1);
-		}
-        importedNames.put(lastName, importedName);
+        importedNames.add(importedName);
 	}
 	public String getImport(String lastName) {
-		return importedNames.get(lastName);
+		for(String importName:importedNames) {
+			if (importName.endsWith(lastName))
+				return importName;
+		}
+		return null;
 	}
 	@Override
 	public String getQualifiedName() {
@@ -49,11 +47,11 @@ public class FileEntity extends ContainerEntity{
 			return super.getQualifiedName();
 	}
 	public Collection<String> imports() {
-		return importedNames.values();
+		return importedNames;
 	}
 	@Override
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		for (String importedName:importedNames.values()) {
+		for (String importedName:importedNames) {
 			if (typeInferer.isBuiltInTypePrefix(importedName)) continue;
 			List<Entity> importedEntities = typeInferer.resolveImportEntity(importedName);
 			this.resolvedImportedEntities.addAll(importedEntities);

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -1,7 +1,6 @@
 package depends.extractor.cpp.cdt;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -15,7 +14,6 @@ import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
 import org.eclipse.cdt.core.parser.IScanner;
-import org.eclipse.cdt.core.parser.IScannerInfo;
 import org.eclipse.cdt.core.parser.NullLogService;
 import org.eclipse.cdt.core.parser.ParserLanguage;
 import org.eclipse.cdt.core.parser.ParserMode;
@@ -27,6 +25,10 @@ import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 
 public class CDTParser {
+	public CDTParser() {
+		sysIncludePath = new String[0];
+	}
+	
 	public CDTParser(List<String> includesPath) {
 		sysIncludePath = includesPath.toArray(new String[] {});
 	}
@@ -86,7 +88,7 @@ public class CDTParser {
 				new NullLogService(), configuration, null);
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
 				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),
-				new GPPParserExtensionConfiguration(), null);
+				new GPPParserExtensionConfigurationExtension(), null);
 		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
 		return astTranslationUnit;
 	}

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -1,4 +1,4 @@
-package depends.extractor.cpp;
+package depends.extractor.cpp.cdt;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
@@ -7,6 +7,7 @@ import java.util.ArrayList;
 import org.junit.Test;
 
 import depends.entity.repo.EntityRepo;
+import depends.extractor.cpp.CppFileParser;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 
 public class CppParameterParserTest {

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -0,0 +1,31 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.repo.EntityRepo;
+
+public class JavaEmbededClassTest {
+	@Test
+	public void test_EmbededTypeWithImport() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/EmbededTest.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("x.EmbededTest").getRelations().size());
+	}
+
+	@Test
+	public void test_EmbededTypeWithoutImport() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/EmbededTest.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("x.EmbededTest2").getRelations().size());
+	}
+}

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -0,0 +1,22 @@
+package x;
+import x.Parent.Enum;
+class Parent {
+	enum Enum{
+		a,b
+	}
+}
+
+class Parent2 {
+	enum Enum{
+		a,b
+	}
+}
+
+
+public class EmbededTest{
+	Parent.Enum v; 
+}
+
+class EmbededTest2{
+	Parent2.Enum v; 
+}
\ No newline at end of file

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -7,7 +7,6 @@ import java.util.HashMap;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
-import depends.util.Tuple;
 
 public abstract class ContainerEntity extends Entity {
 	private ArrayList<VarEntity> vars;
@@ -68,7 +67,7 @@ public abstract class ContainerEntity extends Entity {
 	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter);
+			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter,true);
 			if (typeEntity != null)
 				r.add(typeEntity);
 		}
@@ -98,57 +97,44 @@ public abstract class ContainerEntity extends Entity {
 	private void resolveExpressions(TypeInfer typeInferer) {
 		for (Expression expression : expressions.values()) {
 			//1. if expression's type existed, break;
-			if (expression.type != null)
+			if (expression.getType() != null)
 				continue;
 			
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.type = typeInferer.inferType(this, expression.rawType);
-			}else if(expression.identifier != null) {
-				if (expression.identifier.contains(".")) {
-					/* if it is a qualified name */
-					Tuple<TypeEntity, String> result = typeInferer.locateTypeOfQualifiedName(this, expression.identifier);
-					if (result != null) {
-						if (result.y == null) {
-							expression.type = result.x;
-						} else {
-							expression.type = typeInferer.inferType(result.x, result.y);
-						}
-					}
-				} else {
-					/* expression identifiers could be a variable, or a type. try them */
-					expression.type = lookupVarDefinition(expression.identifier);
-					if (expression.type==null)
-						expression.type = typeInferer.inferType(this, expression.identifier);
+				expression.setType(typeInferer.inferType(this, expression.rawType,true),typeInferer);
+			}else if (expression.isDot){ //wait for previous
+				continue;
+			} else if (expression.rawType!=null) {
+				expression.setType(typeInferer.inferType(this, expression.rawType, true),typeInferer);
+				if (expression.getType() !=null) {
+					 continue;
 				}
 			}
-			
-			//3. if new found type of expression, update parent expressions
-			if (expression.type != null) {
-				expression.deduceParentType(this.expressions,typeInferer);
+			if (expression.identifier!=null) { 
+				TypeEntity type = typeInferer.inferType(this, expression.identifier, false);
+				if (type!=null) {
+					expression.setType(type,typeInferer);
+					continue;
+				}
+				if (expression.isCall) {
+					FunctionEntity func = typeInferer.resolveFunctionBindings(this, expression.identifier);
+					if (func!=null) {
+						expression.setType(func.getReturnType(),typeInferer);
+					}
+				}else {
+					VarEntity varEntity = this.resolveVarBindings(expression.identifier);
+					if (varEntity!=null) {
+						expression.setType( varEntity.getType(),typeInferer);
+					}
+				}
 			}
 		}
 	}
 
 
-	/**
-	 * Found the given type of given var;
-	 * Must be invoked after all vars' type have been resolved
-	 * Should be override if new vars have been added, for example 
-	 * Function Type could resolve parameters as vars
-	 * @param identifier  - var identifiers
-	 * @return
-	 */
-	public TypeEntity lookupVarDefinition(String identifier) {
-		for (VarEntity var : this.vars) {
-			if (var.getRawName().equals(identifier))
-				return var.getType();
-		}
-		if (this.parent != null && this.parent instanceof ContainerEntity)
-			return ((ContainerEntity) this.parent).lookupVarDefinition(identifier);
-		return null;
-	}
+	
 
 	public Collection<TypeEntity> getResolvedTypeParameters() {
 		return resolvedTypeParameters;
@@ -165,4 +151,28 @@ public abstract class ContainerEntity extends Entity {
 	public void setResolvedAnnotations(Collection<TypeEntity> resolvedAnnotations) {
 		this.resolvedAnnotations = resolvedAnnotations;
 	}
+
+	public String dumpExpressions() {
+		StringBuilder sb = new StringBuilder();
+		for (Expression exp:expressions.values()) {
+			sb.append(exp.toString()).append("\n");
+		}
+		return sb.toString();
+	}
+	
+	/**
+	 * To found the var. Must be invoked after all entities var binding solved
+	 * @param fromEntity
+	 * @param varName
+	 * @return
+	 */
+	public VarEntity resolveVarBindings(String varName) {
+		for (VarEntity var:getVars()) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		if (parent !=null && parent instanceof ContainerEntity)
+			return ((ContainerEntity)parent).resolveVarBindings(varName);
+		return null;
+	}
 }

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -6,6 +6,7 @@ import java.util.List;
 import java.util.Set;
 
 import depends.entity.repo.EntityRepo;
+import depends.entity.types.PackageEntity;
 
 public abstract class Entity {
 	int id=-1;
@@ -24,6 +25,11 @@ public abstract class Entity {
 		deduceQualifiedName();
 	}
 
+    public String getPackageName() {
+		Entity packageEntity = this.getAncestorOfType(PackageEntity.class);
+		return packageEntity==null?"":packageEntity.getQualifiedName();
+	}
+    
 	private void deduceQualifiedName() {
 		if (this.rawName.contains(".")) {
 			this.qualifiedName = this.rawName;
@@ -138,5 +144,4 @@ public abstract class Entity {
 		}
 		return null;
 	}
-	
 }

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -13,10 +13,11 @@ public class Expression {
 	public Integer id;
 	public Integer parentId;
 	public Integer firstChildId; //by default, parent expression type determined by most left child
-	
+	public Expression parent;
 	public String text; // for debug purpose
-	public TypeEntity returnType; // the type we care - for type deduction like foo().bar.x
-	public TypeEntity type; // the type we care - for relation calculation
+
+
+	private TypeEntity type; // the type we care - for relation calculation
 	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
 	public boolean isSet = false; // is a set relation from right to leftHand
@@ -27,7 +28,16 @@ public class Expression {
 	public boolean isCast = false;
 	public boolean deriveTypeFromChild = true;
 	List<Tuple<String, String>> relations = new ArrayList<>();
+	public TypeEntity getType() {
+		return type;
+	}
 
+	public void setType(TypeEntity type, TypeInfer typeInferer) {
+		if (this.type!=null) return;
+		this.type = type;
+		deduceParentType(typeInferer);
+	}
+	
 	public Expression(Integer id, Integer parentId) {
 		this.id = id;
 		this.parentId = parentId;
@@ -36,19 +46,15 @@ public class Expression {
 	@Override
 	public String toString() {
 		StringBuilder s = new StringBuilder();
-		s.append("[").append(text).append("]").append("\n")
-			.append("return:").append(returnType).append("\n")
-			.append("rawType  :").append(rawType).append("\n")
-			.append("type  :").append(type).append("\n")
-			.append("var   :").append(identifier).append("\n")
-		    .append("prop  :").append(isDot?"[dot]":"")
+		s.append("[").append(text).append("]").append("|")
+			.append("rawType:").append(rawType).append("|")
+			.append("identifier:").append(identifier).append("|")
+		    .append("prop:").append(isDot?"[dot]":"")
 		                      .append(isSet?"[set]":"")
 		                      .append(isLogic?"[bool]":"")
-		                      .append(isCall?"[call]":"").append("\n");
-
-		for (Tuple<String, String> item : relations) {
-			s.append(item.y).append("->").append(item.x).append(",");
-		}
+		                      .append(isCall?"[call]":"").append("|")
+		    .append("parent:").append(parent==null?"none":parent.text)
+			.append("type:").append(type).append("|");
 		return s.toString();
 	}
 
@@ -57,43 +63,41 @@ public class Expression {
 	 * @param expressionList
 	 * @param typeInfer
 	 */
-	public void deduceParentType(HashMap<Integer, Expression> expressionList, TypeInfer typeInfer) {
+	public void deduceParentType(TypeInfer typeInfer) {
 		if (this.type==null) return;
-		if (this.returnType==null) this.returnType = this.type; //we use return type as recurisely calcuation
-		if (this.parentId==null) return;
-		if (expressionList==null) return;
-		Expression parent = expressionList.get(this.parentId);
-		if (parent==null) return;
+		if (this.parent==null) return;
+		Expression parent = this.parent;
 		if (parent.type != null)return;
-		if (!parent.deriveTypeFromChild) return;
 		if (parent.firstChildId!=this.id) return;
-		if (parent.type!=null) return;
+		if (this.type.equals(TypeInfer.buildInType)) {
+			parent.setType(TypeInfer.buildInType,typeInfer);
+			return;
+		}else if (this.type.equals(TypeInfer.externalType)){
+			parent.setType(TypeInfer.externalType,typeInfer);
+			return;
+		}
 		
 		/* if it is a logic expression, the return type/type is boolean. */
 		if (parent.isLogic) {
-			parent.returnType = typeInfer.inferType(this.returnType, "<Built-in>");
-			parent.type = typeInfer.inferType(this.returnType, "<Built-in>");
+			parent.setType(TypeInfer.buildInType,typeInfer);
 		}
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
-		else if (parent.isDot && (!parent.isCall)) {
-			VarEntity returnType = typeInfer.resolveVarBindings(this.returnType, parent.identifier);
-			if (returnType != null)
-				parent.type = returnType.getType();
-		}
-		/* if it is a.foo, and we already get a's type, foo's type could be identified easily  */
-		else if (parent.isDot && parent.isCall) {
-			FunctionEntity function = typeInfer.resolveFunctionBindings(this.returnType, parent.identifier);
-			if (function != null){
-				parent.returnType =  function.getReturnType();
+		else if (parent.isDot) {
+			if (parent.isCall) {
+				FunctionEntity func = typeInfer.resolveFunctionBindings(this.getType(), parent.identifier);
+				if (func!=null)
+					parent.setType(func.getReturnType(), typeInfer);
+			}else {
+				parent.setType(typeInfer.inferType(this.getType(), parent.identifier, true),typeInfer);
+				if (parent.type!=null) return;
+				VarEntity var = this.getType().resolveVarBindings(parent.identifier);
+				if (var!=null)
+					parent.setType(var.getType(), typeInfer);
 			}
-			/* type is used for relation calculation, while return type is used for continuous type calculation */
-			parent.type = this.type; //in call relation, we count call in object, instead of function
-		} 
+		}
 		/* if other situation, simple make the parent and child type same */
 		else {
-			parent.type = type;
+			parent.setType(type, typeInfer);
 		}
-		
-		parent.deduceParentType(expressionList, typeInfer);
 	}
 }
\ No newline at end of file

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -41,8 +41,9 @@ public class RelationCounter {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType().getId(),var.getType().getQualifiedName()));
-			else
+			else {
 				System.out.println("cannot resolve type of "+var.getQualifiedName());
+			}
 		}
 		for (TypeEntity type:entity.getResolvedAnnotations()) {
 			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
@@ -53,23 +54,23 @@ public class RelationCounter {
 		
 		HashSet<TypeEntity> usedEntities = new HashSet<>();
 		for (Expression expression:entity.expressions().values()){
-			if (expression.type==null) {
+			if (expression.getType()==null) {
 //				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
 				continue;
 			}
 			if (expression.isCall) {
-				entity.addRelation(new Relation(DependencyType.CALL,expression.type.getId(),expression.type.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CALL,expression.getType().getId(),expression.getType().getQualifiedName()));
 			}
 			if (expression.isCreate) {
-				entity.addRelation(new Relation(DependencyType.CREATE,expression.type.getId(),expression.type.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CREATE,expression.getType().getId(),expression.getType().getQualifiedName()));
 			}
 			else if (expression.isSet) { //SET is merged with USE
-				entity.addRelation(new Relation(DependencyType.USE,expression.type.getId(),expression.type.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.USE,expression.getType().getId(),expression.getType().getQualifiedName()));
 			}
 			else if (expression.isCast) { 
-				entity.addRelation(new Relation(DependencyType.CAST,expression.type.getId(),expression.type.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CAST,expression.getType().getId(),expression.getType().getQualifiedName()));
 			}else {
-				usedEntities.add(expression.type);
+				usedEntities.add(expression.getType());
 			}
 		}
 		

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -26,8 +26,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
 	private BuiltInTypeIdenfier buildInProcessor = new NullParser();
-	private static final TypeEntity buildInType = new TypeEntity("built-in", null, -1);
-	
+
 	public EntityRepo() {
 		nextAvaliableIndex = 0;
 	}
@@ -107,127 +106,129 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		}
 	}
 	
-
-	
+	public void setParent(Entity child, Entity parent) {
+		child.setParent(parent);
+		parent.addChild(child);
+	}
 	@Override
-	public VarEntity resolveVarBindings(Entity fromEntity, String varName) {
-		while(fromEntity!=null) {
-			if (fromEntity instanceof ContainerEntity) {
-				for (VarEntity var:((ContainerEntity)fromEntity).getVars()) {
-					if (var.getRawName().equals(varName))
-						return var;
-				}
-			}
-			fromEntity = fromEntity.getParent();
+	public TypeEntity inferType(Entity fromEntity, String rawName, boolean typeOnly) {
+		if(rawName==null) return null;
+		if (buildInProcessor.isBuiltInType(rawName)) return buildInType;
+		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType;
+		
+		//qualified name will first try global name directly
+		if (rawName.contains(".")) {
+			if (this.getTypeEntityByFullName(rawName)!=null) 
+				return this.getTypeEntityByFullName(rawName);
+		}
+		
+		//first we lookup the first symbol
+		String[] names = rawName.split("\\.");
+		if (names.length==0) return null;
+		Entity type = lookupTypes(fromEntity,names[0],typeOnly);
+		if (type==null) return null;
+		if (names.length==1 ) {
+			TypeEntity actualType = getType(type);
+			if (actualType!=null) return actualType;
 		}
+		//then find the subsequent symbols
+		type = findTypesSince(type,names,1,typeOnly);
+		TypeEntity returnType = getType(type);
+		if (typeOnly)
+			return returnType;
+		else if (returnType!=null)
+			return returnType;
 		return null;
 	}
-
-	
 	
-	public void setParent(Entity child, Entity parent) {
-		child.setParent(parent);
-		parent.addChild(child);
+	/**
+	 * A utility function to get the entity type
+	 * @param type
+	 * @return
+	 */
+	private static TypeEntity getType(Entity type) {
+		if (type instanceof TypeEntity)
+			return (TypeEntity)type;
+		else if (type instanceof FunctionEntity) {
+			return ((FunctionEntity)type).getReturnType();
+		}else if (type instanceof VarEntity) {
+			return ((VarEntity)type).getType();
+		}
+		return null;
 	}
-	
-	@Override
-	public TypeEntity inferType(Entity fromEntity, String rawName) {
-		if (buildInProcessor.isBuiltInType(rawName)) return buildInType();
-		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType();
-		if (fromEntity==null) return null;
-		TypeEntity type = null;
-		if (rawName.equals("this")) {
-			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
-			if (entityType!=null) {
-				return (TypeEntity) entityType;
+
+	private TypeEntity findTypesSince(Entity sinceType, String[] names, int i, boolean typeOnly) {
+		if (i>=names.length) {
+			return (sinceType instanceof TypeEntity)? (TypeEntity)sinceType:null;
+		}
+		for (Entity child:sinceType.getChildren()) {
+			if (child.getRawName().equals(names[i]) && child instanceof TypeEntity) {
+				return findTypesSince(child,names,i+1,typeOnly);
 			}
 		}
-		else if (rawName.equals("super")) {
+		return null;
+	}
+
+	private Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly) {
+		if (name.equals("this")||name.equals("class")) {
 			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
-			if (entityType!=null) {
-				return ((TypeEntity)entityType).getInheritedType();
-			}
+			return entityType;
 		}
-		else if (rawName.contains(".")) {
-			TypeEntity t = getTypeEntityByFullName(rawName);
-			if (t!=null)
-				return t;
+		else if (name.equals("super")) {
+			Entity parent = fromEntity.getAncestorOfType(TypeEntity.class);
+			if (parent!=null) {
+				return ((TypeEntity)parent).getInheritedType();
+			}
 		}
+		
+		Entity type = findTypeUnderSamePackage(fromEntity,name);
+		if (type!=null) return type;
+		type = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name);
+		return type;
+	}
+
+	private Entity lookupTypeInImported(Entity entity, String name) {
+		if (entity==null) return null;
+		if (!(entity instanceof FileEntity)) return null;
+		FileEntity fileEntity = (FileEntity)entity;
+		String importedString = fileEntity.getImport(name);
+		if (importedString==null) return null;	
+		Entity type = this.getTypeEntityByFullName(importedString);
+		if (type!=null) return type;
+		return externalType;
+	}
 
+	private TypeEntity findTypeUnderSamePackage(Entity fromEntity,String name) {
 		while(true) {
-			if (fromEntity instanceof TypeEntity) {
-				if (fromEntity.getRawName().equals(rawName))
-					return (TypeEntity)fromEntity;
-				FunctionEntity var = resolveFunctionBindings(fromEntity,rawName);	
-				if (var!=null)
-					return var.getReturnType(); 				
-			}
-			if (fromEntity instanceof FileEntity) {
-				String importedFullName = ((FileEntity)fromEntity).getImport(rawName);
-				if (importedFullName!=null)
-					return getTypeEntityByFullName(importedFullName);
-				type = this.getTypeEntityUnder(rawName,fromEntity);
-				if(type!=null) return type;
-			}
-			if (fromEntity instanceof PackageEntity){
-				type = this.getTypeEntityUnder(rawName,fromEntity);
-				if(type!=null) return type;
-			}
-			if (fromEntity instanceof ContainerEntity) {
-				VarEntity var = resolveVarBindings(fromEntity,rawName);	
-				if (var!=null)
-					return var.getType(); 
+			if (fromEntity.getRawName().equals(name) && fromEntity instanceof TypeEntity)
+				return (TypeEntity)fromEntity;
+			for (Entity child:fromEntity.getChildren()) {
+				if (child.getRawName().equals(name) && child instanceof TypeEntity)
+					return (TypeEntity)child;
+				if (child instanceof FileEntity) {
+					for (Entity classUnderFile:child.getChildren()) {
+						if (classUnderFile.getRawName().equals(name) && classUnderFile instanceof TypeEntity)
+							return (TypeEntity)classUnderFile;
+					}
+				}
 			}
 			fromEntity = fromEntity.getParent();
 			if (fromEntity==null) break;
 		}
-		
-		type = getTypeEntityByFullName(rawName);
-		return type;
+		return null;
+
 	}
-	
 
 
-	private TypeEntity buildInType() {
-		return this.buildInType;
-	}
 	private TypeEntity getTypeEntityByFullName(String rawName) {
-		if (buildInProcessor.isBuiltInType(rawName)) return buildInType();
-		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType();
 		Entity entity = this.getEntity(rawName);
+		if(entity ==null) return null;
 		if (entity instanceof TypeEntity) {
 			return (TypeEntity)entity;
 		}
-		if (entity instanceof PackageEntity) {
-			return getTypeEntityUnder(rawName, entity);
-		}
 		return null;
 	}
 	
-	private TypeEntity tryGetTypeEntity(String rawName, TypeEntity typeEntity, String qualifiedName) {
-		if (typeEntity.getRawName().equals(rawName)) {
-			return (TypeEntity)typeEntity;
-		}
-		if (rawName.equals(qualifiedName + typeEntity.getRawName())) {
-			return  (TypeEntity)typeEntity;
-		}
-		for (Entity child:typeEntity.getChildren()) {
-			if (child instanceof TypeEntity) {
-				TypeEntity type = tryGetTypeEntity(rawName,(TypeEntity)child,qualifiedName+typeEntity.getRawName()+".");
-				if (type!=null) return type;
-			}
-		}
-		return null;
-	}
-	private TypeEntity getTypeEntityUnder(String rawName, Entity entity) {
-		for (Entity level_1:entity.getChildren()) {
-			if (level_1 instanceof TypeEntity) {
-				TypeEntity type = tryGetTypeEntity(rawName,(TypeEntity)level_1,"");
-				if (type!=null) return type;
-			}
-		}
-		return null;
-	}
 	
 	public void setBuiltInTypeIdentifier(BuiltInTypeIdenfier buildInProcessor) {
 		this.buildInProcessor = buildInProcessor;
@@ -237,7 +238,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public Tuple<TypeEntity, String> locateTypeOfQualifiedName(ContainerEntity fromEntity, String qualifiedName) {
 		String localName = null;
 		while (true) {
-			TypeEntity type = inferType(fromEntity, qualifiedName);
+			TypeEntity type = inferType(fromEntity, qualifiedName,false);
 			if (type != null)
 				return new Tuple<TypeEntity, String>(type, localName);
 			int lpos = qualifiedName.lastIndexOf(".");
@@ -246,7 +247,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 			localName = localName == null ? qualifiedName.substring(lpos + 1)
 					: localName + "." + qualifiedName.substring(lpos + 1);
 			qualifiedName = qualifiedName.substring(0, lpos);
-			type = inferType(fromEntity, qualifiedName);
+			type = inferType(fromEntity, qualifiedName,false);
 			return new Tuple<TypeEntity, String>(type,localName);
 		}
 	}

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -36,9 +36,6 @@ public class FunctionEntity extends ContainerEntity{
 		this.returnTypeIdentifiers.add(returnType);
 	}
 	public void addThrowTypes(List<String> throwedType) {
-		if (throwedType==null) {
-			System.out.println("****");
-		}
 		throwTypesIdentifiers.addAll(throwedType);
 	}
 	
@@ -59,16 +56,13 @@ public class FunctionEntity extends ContainerEntity{
 	public Collection<TypeEntity> getThrowTypes() {
 		return throwTypes;
 	}
-	
 	@Override
-	public TypeEntity lookupVarDefinition(String identifier) {
+	public VarEntity resolveVarBindings(String varName) {
 		for (VarEntity param:parameters) {
-			if (identifier.equals(param.getRawName())) {
-				return param.getType();
+			if (varName.equals(param.getRawName())) {
+				return param;
 			}
 		}
-		return super.lookupVarDefinition(identifier);
+		return super.resolveVarBindings(varName);
 	}
-	
-	
 }

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -28,9 +28,13 @@ public class TypeEntity extends ContainerEntity{
 		super.inferLocalLevelTypes(typeInferer);
 	}
 	public void addImplements(String typeName) {
+		if (typeName.equals(this.getRawName())) return;
+		if (implementedIdentifiers.contains(typeName)) return;
 		this.implementedIdentifiers.add(typeName);
 	}
 	public void addExtends(String typeName) {
+		if (typeName.equals(this.getRawName())) return;
+		if (inhertedTypeIdentifiers.contains(typeName)) return;
 		this.inhertedTypeIdentifiers.add(typeName);
 	}
 	public Collection<TypeEntity> getInheritedTypes() {

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -25,6 +25,6 @@ public class VarEntity extends Entity {
 
 	@Override
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		type = typeInferer.inferType(this, rawType);
+		type = typeInferer.inferType(this, rawType,true);
 	}
 }

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -6,6 +6,7 @@ import depends.entity.Expression;
 import depends.extractor.HandlerContext;
 import depends.javaextractor.JavaParser;
 import depends.javaextractor.JavaParser.ExpressionContext;
+import depends.javaextractor.JavaParser.MethodCallContext;
 import depends.javaextractor.JavaParser.PrimaryContext;
 import depends.util.Tuple;
 
@@ -23,67 +24,76 @@ public class ExpressionUsage {
 		if (parent!=null) {
 			Expression parentExpression = context.lastContainer().expressions().get(parent.hashCode());
 			if (parentExpression.firstChildId==null) parentExpression.firstChildId = expression.id;
+			expression.parent = parentExpression;
 		}
 		
 		context.lastContainer().addExpression(expression);
 		expression.text = ctx.getText(); //for debug purpose. no actual effect
-		Tuple<String, String> nodeInfo = getExpressionType(ctx);
-		if (nodeInfo!=null) {
-			expression.rawType = nodeInfo.x;
-			expression.identifier = nodeInfo.y;
+		if (ctx.primary()!=null) {
+			tryFillExpressionTypeAndIdentifier(ctx.primary(),expression);
+			return;
 		}
-		if (expression.identifier==null && ctx.IDENTIFIER()!=null)
-			expression.identifier = ctx.IDENTIFIER().getText();
-		else if (expression.identifier==null && ctx.methodCall()!=null) {
-			if (ctx.methodCall().THIS()!=null) {
-				expression.identifier = "this";
-			}else if (ctx.methodCall().SUPER()!=null) {
-				expression.identifier = "super";
-			}else {
-				expression.identifier = ctx.methodCall().IDENTIFIER().getText();
-			}
-		}
-		else if (expression.identifier==null && (ctx.NEW()!=null && ctx.creator()!=null)){
-			expression.identifier = CreatorContextHelper.getCreatorType(ctx.creator());
-		}
-		expression.isDot = isDot(ctx);
+		
 		expression.isSet = isSet(ctx);
 		expression.isCall = ctx.methodCall()==null?false:true;
 		expression.isLogic = isLogic(ctx);
-		if (ctx.creator()!=null ||
-				ctx.methodCall()!=null)
-			expression.deriveTypeFromChild = false;
-		expression.isCall = true;
-		if (ctx.creator()!=null ||
-				ctx.innerCreator()!=null)
+		if (ctx.creator()!=null ||ctx.innerCreator()!=null){
 			expression.isCreate = true;
+		}		
+/**
+ *    | expression bop='.'
+      ( IDENTIFIER
+      | methodCall
+      | THIS
+      | NEW nonWildcardTypeArguments? innerCreator
+      | SUPER superSuffix
+      | explicitGenericInvocation
+      )
+ */
+		expression.isDot = isDot(ctx);
+		if (expression.isDot) {
+			if (ctx.IDENTIFIER()!=null)
+				expression.identifier = ctx.IDENTIFIER().getText();
+			else if (ctx.methodCall()!=null)
+				expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+			else if (ctx.THIS()!=null)
+				expression.identifier = "this";
+			else if (ctx.innerCreator()!=null) //innner creator like new List(){}
+				expression.identifier =  ctx.innerCreator().IDENTIFIER().getText();
+			else if (ctx.SUPER()!=null)
+				expression.identifier = "super";
+			return;
+		}
+		//method call
+		if (ctx.methodCall()!=null) {
+			expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+			expression.isCall = true;
+		}
+		//new 
+		if (ctx.NEW()!=null & ctx.creator()!=null) {
+			expression.rawType = CreatorContextHelper.getCreatorType(ctx.creator());
+			expression.isCall = true;
+		}
+
 		if (ctx.typeCast()!=null) {
 			expression.isCast=true;
 			expression.rawType = ctx.typeCast().typeType().getText();
 		}
-			
+		if (ctx.creator()!=null ||ctx.methodCall()!=null) {
+			expression.deriveTypeFromChild = false;
+		}
 	}
 
-
-
-	/**
-	 * To determine the return type of the expression, 
-	 * @param ctx
-	 * @return Tuple.x -> expression type
-	 *         Tuple.y -> var name (if has)
-	 */
-	public Tuple<String, String> getExpressionType(ExpressionContext ctx) {
-		Tuple<String, String> primaryInfo = getPrimaryType(ctx.primary());
-		if (primaryInfo!=null) return primaryInfo;
-		if (ctx.typeType()!=null && ctx.expression()!=null) {
-			return new Tuple<String,String>(ctx.typeType().getText(),"");
-		}
-		if (ctx.NEW()!=null & ctx.creator()!=null) {
-			return new Tuple<String,String>(CreatorContextHelper.getCreatorType(ctx.creator()),"");
+	private String getMethodCallIdentifier(MethodCallContext methodCall) {
+		if (methodCall.THIS()!=null) {
+			return "this";
+		}else if (methodCall.SUPER()!=null) {
+			return "super";
+		}else {
+			return methodCall.IDENTIFIER().getText();
 		}
-		return null;
 	}
-	
+
 	private boolean isDot(ExpressionContext ctx) {
 		if (ctx.bop!=null)
 			if (ctx.bop.getText().equals(".")) return true;
@@ -128,38 +138,27 @@ public class ExpressionUsage {
 //    | typeTypeOrVoid '.' CLASS
 //    | nonWildcardTypeArguments (explicitGenericInvocationSuffix | THIS arguments) //Just USE relation
 //    
-	private Tuple<String, String> getPrimaryType(PrimaryContext ctx) {
-		String type =null;
-		String varName = "";
-		if (ctx==null) return null;
+	private void tryFillExpressionTypeAndIdentifier(PrimaryContext ctx, Expression expression) {
+		if (ctx.expression()!=null) return; 
 		//1. we only handle leaf node. if there is still expression,
 		//   the type will be determined by child node in the expression
-		if (ctx.expression()!=null) return null; 
 		if (ctx.literal()!=null) {
 		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
-			type = "<Built-in>";
-			varName = ctx.literal().getText();
+			expression.rawType = "<Built-in>";
+			expression.identifier = ctx.literal().getText();
 		}else if (ctx.IDENTIFIER()!=null) {
 		//2. if it is a var name, dertermine the type based on context.
-			varName = ctx.IDENTIFIER().getText();
+			expression.identifier = ctx.IDENTIFIER().getText();
 		}else if (ctx.typeTypeOrVoid()!=null) {
 		//3. if given type directly
-			type = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
+			expression.rawType = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
 		}else if (ctx.THIS()!=null){
-			varName = "this";
-			//TODO: deduce this type
+			expression.identifier = "this";
 		}else if (ctx.SUPER()!=null){
-			varName = "super";
-			//TODO: deduce super type
-		}else {
-			System.out.println("TODO: .g4, line 533: nonWildcardTypeArguments (explicitGenericInvocationSuffix | THIS arguments)");
-			System.out.println(ctx.getText());
+			expression.identifier = "super";
 		}
-		return new Tuple<String, String> (type,varName);
 	}
 
-
-
 	private RuleContext findParentInStack(RuleContext ctx) {
 		if (ctx==null) return null;
 		if (ctx.parent==null) return null;

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -16,7 +16,7 @@ public class JavaAnnotationParserTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("AnnotationTest").getRelations().size());
+        assertEquals(1,repo.getEntity("AnnotationTest.value").getRelations().size());
 	}
 
 }

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,24 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.ContainerEntity;
+import depends.entity.repo.EntityRepo;
+
+public class JavaComplexExpressionTest {
+	@Test
+	public void test_complexExpression() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/ComplexExpressionTest.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        ContainerEntity entity  = (ContainerEntity)(repo.getEntity("ComplexExpressionTest.other"));
+        assertEquals(2,entity.getRelations().size());
+	}
+
+}

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -1,11 +1,8 @@
 package depends.extractor.java;
 
 import static org.junit.Assert.assertEquals;
-
 import java.io.IOException;
-
 import org.junit.Test;
-
 import depends.entity.repo.EntityRepo;
 
 public class JavaEmbededClassTest {

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,18 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+import java.io.IOException;
+import org.junit.Test;
+import depends.entity.repo.EntityRepo;
+
+public class JavaGenericTypeTest {
+	@Test
+	public void test_GenericTypeShouldBeIdentified() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/GenericTypeTest.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("x.GenericTypeTest").getRelations().size());
+	}
+}

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,21 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+import java.io.IOException;
+import org.junit.Test;
+import depends.entity.repo.EntityRepo;
+
+public class JavaTypeInferUnderSamePackageTest {
+	@Test
+	public void test_GenericTypeShouldBeIdentified() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/TypeInferUnderSamePackageA.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        src = "./src/test/resources/java-code-examples/TypeInferUnderSamePackageB.java";
+        parser = new JavaFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("x.TypeInferUnderSamePackageA").getRelations().size());
+	}
+}

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -6,6 +6,7 @@ import java.io.IOException;
 
 import org.junit.Test;
 
+import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
@@ -41,7 +42,9 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(16,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        ContainerEntity e = (ContainerEntity) repo.getEntity("LocalVarInferExample.setExample");
+        System.out.println(e.dumpExpressions());
+        assertEquals(15,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
 	}
 	
 	@Test
@@ -51,7 +54,19 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(12,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        assertEquals(13,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
+	@Test
+	public void test_long_static_function_should_be_inferred() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/java-code-examples/LongExpressionWithAbsolutePath.java";
+        JavaFileParser parser = new JavaFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        System.out.println(((ContainerEntity)(repo.getEntity("x.LongExpressionWithAbsolutePath.setExample"))).dumpExpressions());
+        assertEquals(5,repo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
+	}
+	
+	
 }

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,17 @@
+class B{
+	static String c;
+}
+
+class ComplexExpressionTest{
+	String foo() {
+		return B.class.getName();
+	}
+	
+	String bar() {
+		B b;
+		return b.getClass().getName();
+	}
+	String other() {
+		return B.c;
+	}
+}
\ No newline at end of file

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,18 @@
+package x;
+import x.Parent.Enum;
+import java.io;
+
+import java.util.List;
+class Parent2 {
+	enum Enum{
+		a,b
+	}
+}
+
+ public class GenericTypeTest{
+	List<Parent2.Enum> v;
+	
+	 public <D> File write(D... data) throws IOException {
+	 }
+
+}
\ No newline at end of file

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,10 @@
+package x;
+class MyString{
+	static void foo() {}
+}
+
+public class LongExpressionWithAbsolutePath {
+	public void setExample(Object m) {
+		x.MyString.foo();
+	}
+}
\ No newline at end of file

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,4 @@
+package x;
+class TypeInferUnderSamePackageA{
+	TypeInferUnderSamePackageB.SubType v;
+}
\ No newline at end of file

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -0,0 +1,6 @@
+package x;
+class TypeInferUnderSamePackageB{
+	class SubType {
+		
+	}
+}
\ No newline at end of file

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -3,6 +3,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
@@ -32,6 +33,10 @@ public abstract class ContainerEntity extends Entity {
 	public void addTypeParameter(String typeName) {
 		this.typeParameters.add(typeName);
 	}
+	
+	public void addTypeParameter(List<String> parameters) {
+		this.typeParameters.addAll(parameters);
+	}
 
 	public void addVar(VarEntity var) {
 		this.vars.add(var);
@@ -87,14 +92,13 @@ public abstract class ContainerEntity extends Entity {
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);
 		}
-		resolveExpressions(typeInferer);
 	}
 
 	/**
 	 * Resolve all expression's type
 	 * @param typeInferer
 	 */
-	private void resolveExpressions(TypeInfer typeInferer) {
+	public void resolveExpressions(TypeInfer typeInferer) {
 		for (Expression expression : expressions.values()) {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
@@ -175,4 +179,11 @@ public abstract class ContainerEntity extends Entity {
 			return ((ContainerEntity)parent).resolveVarBindings(varName);
 		return null;
 	}
+
+	public boolean isGenericTypeParameter(String rawType) {
+		if (this.typeParameters.contains(rawType)) return true;
+		if (this.getParent()==null || !(this.getParent() instanceof ContainerEntity))
+			return false;
+		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
+	}
 }

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -1,8 +1,8 @@
 package depends.entity;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
 import depends.entity.repo.EntityRepo;
@@ -13,7 +13,7 @@ public abstract class Entity {
 	String qualifiedName = null;
 	String rawName = "";
 	Entity parent;
-	ArrayList<Entity> children = new ArrayList<>();
+	Set<Entity> children = new HashSet<>();
     ArrayList<Relation> relations = new ArrayList<>();
 
 	
@@ -22,6 +22,8 @@ public abstract class Entity {
 		this.rawName = rawName;
 		this.parent = parent;
 		this.setId(id);
+		if (parent!=null)
+			parent.children.add(this);
 		deduceQualifiedName();
 	}
 
@@ -105,7 +107,7 @@ public abstract class Entity {
 		this.parent = parent;
 	}
 	
-	public List<Entity> getChildren() {
+	public Collection<Entity> getChildren() {
 		return children;
 	}
 	

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -104,6 +104,10 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 			if (!(entity instanceof FileEntity)) continue;
 			entity.inferTypes(this);
 		}
+		for (Entity entity:allEntitiesById.values()) {
+			if ((entity instanceof ContainerEntity))
+				((ContainerEntity)entity).resolveExpressions(this);
+		}
 	}
 	
 	public void setParent(Entity child, Entity parent) {

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -15,12 +15,11 @@ public class FunctionEntity extends ContainerEntity{
 	private Collection<TypeEntity> returnTypes;
 	private TypeEntity returnType;
 	private Collection<TypeEntity> throwTypes;
-
-    public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType, Collection<VarEntity> parameters) {
+    public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
 		super(simpleName, parent,id);
 		this.returnTypes = new ArrayList<>();
 		returnTypeIdentifiers = new ArrayList<>();
-		this.parameters = parameters;
+		this.parameters = new ArrayList<>();
 		throwTypesIdentifiers = new ArrayList<>();
 		addReturnType(returnType);
 	}
@@ -65,4 +64,11 @@ public class FunctionEntity extends ContainerEntity{
 		}
 		return super.resolveVarBindings(varName);
 	}
+	public void addParameter(VarEntity var) {
+		this.parameters.add(var);
+	}
+	public void setReturnType(TypeEntity returnType) {
+		this.returnType = returnType;
+	}
+
 }

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -1,5 +1,6 @@
 package depends.entity.types;
 
+import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.TypeInfer;
 
@@ -26,5 +27,12 @@ public class VarEntity extends Entity {
 	@Override
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
 		type = typeInferer.inferType(this, rawType,true);
+		if (type==null) {
+			if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
+				type = TypeInfer.genericParameterType;
+			}
+		}
 	}
+
+	
 }

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -52,13 +52,14 @@ public class HandlerContext {
 		return currentTypeEntity;
 	}
 
-	public void foundMethodDeclarator(String methodName, Collection<VarEntity> parameters, String returnType, List<String> throwedType) {
+	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
 		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
-				idGenerator.generateId(),returnType,parameters);
+				idGenerator.generateId(),returnType);
 		entityRepo.add(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		entityStack.push(functionEntity);
 		functionEntity.addThrowTypes(throwedType);
+		return functionEntity;
 	}
 	public void exitLastedEntity() {
 		entityStack.pop();

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -6,8 +6,8 @@ import java.util.List;
 
 import org.antlr.v4.runtime.tree.TerminalNode;
 
-import depends.entity.ContainerEntity;
 import depends.entity.IdGenerator;
+import depends.entity.types.FunctionEntity;
 import depends.entity.types.VarEntity;
 import depends.javaextractor.JavaParser.FormalParameterContext;
 import depends.javaextractor.JavaParser.FormalParameterListContext;
@@ -20,13 +20,11 @@ public class FormalParameterListContextHelper {
 
 	FormalParameterListContext context;
 	private IdGenerator idGenerator;
-	List<VarEntity> parameters;
 	private List<String> annotations;
-	private ContainerEntity container;
+	private FunctionEntity container;
 
-	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext,ContainerEntity container, IdGenerator idGenerator) {
+	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext,FunctionEntity container, IdGenerator idGenerator) {
 		this.context = formalParameterListContext;
-		parameters = new ArrayList<>();
 		this.container = container;
 		annotations = new ArrayList<>();
 		this.idGenerator = idGenerator;
@@ -34,14 +32,11 @@ public class FormalParameterListContextHelper {
 			extractParameterTypeList();
 	}
 
-	public FormalParameterListContextHelper(FormalParametersContext formalParameters,ContainerEntity container, IdGenerator idGenerator) {
+	public FormalParameterListContextHelper(FormalParametersContext formalParameters,FunctionEntity container, IdGenerator idGenerator) {
 		this(formalParameters.formalParameterList(),container,idGenerator);
 	}
 
 
-	public Collection<VarEntity> getParameterList(){
-		return parameters;
-	}
 
 	public void extractParameterTypeList() {
 		if (context != null) {
@@ -60,10 +55,10 @@ public class FormalParameterListContextHelper {
 
 	private void foundParameterDefintion(TypeTypeContext typeType, TerminalNode identifier, List<VariableModifierContext> variableModifier) {
 		String type = ClassTypeContextHelper.getClassName(typeType);
-		String var = identifier.getText();
-		VarEntity entity = new VarEntity(var,type,container,idGenerator.generateId());
-		parameters.add(entity);	
-
+		String varName = identifier.getText();
+		VarEntity varEntity = new VarEntity(varName,type,container,idGenerator.generateId());
+		container.addParameter(varEntity);
+		
 		for ( VariableModifierContext modifier:variableModifier) {
 			if (modifier.annotation()!=null) {
 				this.annotations.add(QualitiedNameContextHelper.getName(modifier.annotation().qualifiedName()));
@@ -76,4 +71,5 @@ public class FormalParameterListContextHelper {
 		return annotations;
 	}
 
+
 }

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -0,0 +1,19 @@
+package depends.extractor.java.context;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.javaextractor.JavaParser.TypeParameterContext;
+import depends.javaextractor.JavaParser.TypeParametersContext;
+
+public class TypeParameterContextHelper {
+
+	public static List<String> getTypeParameters(TypeParametersContext typeParameters) {
+		ArrayList<String> r = new ArrayList<>();
+		for(TypeParameterContext param:typeParameters.typeParameter()) {
+			r.add(param.IDENTIFIER().getText());
+		}
+		return r;
+	}
+
+}

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -18,7 +18,7 @@ public class JavaComplexExpressionTest {
         parser.parse();
         repo.resolveAllBindings();
         ContainerEntity entity  = (ContainerEntity)(repo.getEntity("ComplexExpressionTest.other"));
-        assertEquals(2,entity.getRelations().size());
+        assertEquals(3,entity.getRelations().size());
 	}
 
 }

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -54,7 +54,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(13,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        assertEquals(19,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 	@Test
@@ -65,7 +65,7 @@ public class JavaVarResolveTest {
         parser.parse();
         repo.resolveAllBindings();
         System.out.println(((ContainerEntity)(repo.getEntity("x.LongExpressionWithAbsolutePath.setExample"))).dumpExpressions());
-        assertEquals(5,repo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
+        assertEquals(6,repo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
 	}
 	
 	

1c61f764c336b8eee01947e503f3fa03e7994566
@@ -73,6 +73,11 @@ public abstract class ContainerEntity extends Entity {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
 			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter,true);
+			if (typeEntity==null) {
+				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
+					typeEntity = TypeInfer.genericParameterType;
+				}
+			}
 			if (typeEntity != null)
 				r.add(typeEntity);
 		}

1c61f764c336b8eee01947e503f3fa03e7994566
@@ -46,6 +46,7 @@ public class FunctionEntity extends ContainerEntity{
 		returnTypes= identiferToTypes(typeInferer,this.returnTypeIdentifiers);
 		if (returnTypes.size()>0)
 			returnType = returnTypes.iterator().next();
+
 		throwTypes= identiferToTypes(typeInferer,this.throwTypesIdentifiers);
 		super.inferLocalLevelTypes(typeInferer);
 	}

bd983fec851a961323dab11367d9e59a7023ca61
@@ -1,6 +1,8 @@
 package depends.extractor.cpp.cdt;
 
+import java.io.File;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -9,7 +11,6 @@ import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.c.GCCScannerExtensionConfiguration;
-import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
@@ -25,15 +26,25 @@ import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 
 public class CDTParser {
+	List<String> sysIncludePath = new ArrayList<>();
+
 	public CDTParser() {
-		sysIncludePath = new String[0];
 	}
 	
 	public CDTParser(List<String> includesPath) {
-		sysIncludePath = includesPath.toArray(new String[] {});
+		for (String f:includesPath) {
+			File file = new File(f);
+			if (file.exists()) {
+				try {
+					sysIncludePath.add(file.getCanonicalPath());
+				} catch (IOException e) {
+				}
+			}else {
+				System.err.println("include path " + f + " does not exist!");
+			}
+		}
 	}
 	NullLogService NULL_LOG = new NullLogService();
-	String[] sysIncludePath = new String[] {};
 	Map<String, String> macroMap = new HashMap<>();
 	public IASTTranslationUnit parse(String file   ) {
 		/*
@@ -70,7 +81,7 @@ public class CDTParser {
 				.getInstance();
 
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()),  new ScannerInfo(macroMap,sysIncludePath), ParserLanguage.C,
+				content.toCharArray()),  new ScannerInfo(macroMap,sysIncludePath.toArray(new String[] {})), ParserLanguage.C,
 				NULL_LOG, configuration, null);
 		ANSICParserExtensionConfiguration conf = new ANSICParserExtensionConfiguration();
 		
@@ -84,7 +95,7 @@ public class CDTParser {
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
 				.getInstance();
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath), ParserLanguage.CPP,
+				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath.toArray(new String[] {})), ParserLanguage.CPP,
 				new NullLogService(), configuration, null);
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
 				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),

bd983fec851a961323dab11367d9e59a7023ca61
@@ -0,0 +1,15 @@
+package depends.addons;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class DV8MappingFileBuilderTest {
+
+	@Test
+	public void test() {
+		DV8MappingFileBuilder b = new DV8MappingFileBuilder();
+		b.create("/tmp/depends-dv8-mapping.json");
+	}
+
+}

bd983fec851a961323dab11367d9e59a7023ca61
@@ -4,18 +4,21 @@ import static org.junit.Assert.assertEquals;
 import java.io.IOException;
 import java.util.ArrayList;
 
+import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.repo.EntityRepo;
 import depends.extractor.cpp.CppFileParser;
-import depends.extractor.cpp.cdt.CdtCppFileParser;
 
-public class CppParameterParserTest {
+public class CppParameterParserTest extends CdtParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
 	@Test
 	public void test_parameter() throws IOException {
-		EntityRepo repo = new EntityRepo();
-        String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
-        CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>());
+	    String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
+	    CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>(), fileIndex );
         parser.parse();
         repo.resolveAllBindings();
         assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());

bd983fec851a961323dab11367d9e59a7023ca61
@@ -0,0 +1,72 @@
+package depends.extractor.cpp.cdt;
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.cpp.CppFileParser;
+
+public class IncludeRelationTest extends CdtParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void test_includefiles_should_be_imported_relations() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/includesTest/EntryFile.cpp",
+	    		"./src/test/resources/cpp-code-examples/includesTest/LocalHeader.h",
+	    		"./src/test/resources/cpp-code-examples/includesTest/IndirectIncluded.h",
+	    		"./src/test/resources/cpp-code-examples/includesTest/RelativeInclude.h",
+	    		"./src/test/resources/cpp-code-examples/includesTest/path/Header.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>(), fileIndex );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+	}
+	
+	@Test
+	public void test_includefiles_outside_project_will_not_count() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/includesTest/EntryFile.cpp",
+	    		"./src/test/resources/cpp-code-examples/includesTest/LocalHeader.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>(), fileIndex );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+	}
+
+	@Test
+	public void test_could_found_files_in_include_path() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/includesTest/EntryFileIncludePathTest.cpp",
+	    		"./src/test/resources/cpp-code-examples/includesTest/path/HeadersWithoutPath.h",
+	    	    };
+	    
+	    List<String> includePaths = new ArrayList<>();
+	    includePaths.add("./src/test/resources/cpp-code-examples/includesTest/path/");
+	    for (String src:srcs) {
+			CppFileParser parser = new  CdtCppFileParser(src,repo, includePaths, fileIndex );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+	}
+}

aba8fb72dd18a575c29b24940a2712782dd0b09a
@@ -0,0 +1,13 @@
+package depends.extractor.cpp;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.cpp.cdt.FileIndex;
+
+public abstract class CppParserTest {
+	protected EntityRepo repo = new EntityRepo();
+    protected FileIndex fileIndex = new FileIndex();
+    public void init() {
+    	repo = new EntityRepo();
+    	fileIndex = new FileIndex();
+    }
+}

aba8fb72dd18a575c29b24940a2712782dd0b09a
@@ -8,8 +8,9 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.extractor.cpp.CppFileParser;
+import depends.extractor.cpp.CppParserTest;
 
-public class CppParameterParserTest extends CdtParserTest{
+public class CppParameterParserTest extends CppParserTest{
     @Before
     public void setUp() {
     	super.init();

aba8fb72dd18a575c29b24940a2712782dd0b09a
@@ -10,8 +10,9 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.extractor.cpp.CppFileParser;
+import depends.extractor.cpp.CppParserTest;
 
-public class IncludeRelationTest extends CdtParserTest{
+public class IncludeRelationTest extends CppParserTest{
     @Before
     public void setUp() {
     	super.init();

29f15a38e90bf52a25c92c4054cb6770c9cc4d12
@@ -40,7 +40,7 @@ public class CDTParser {
 				} catch (IOException e) {
 				}
 			}else {
-				System.err.println("include path " + f + " does not exist!");
+				//System.err.println("include path " + f + " does not exist!");
 			}
 		}
 	}

341cc6eead0bea9559ac6d33889d3dbe66f078be
@@ -0,0 +1,61 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.ast.IASTComment;
+import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
+import org.eclipse.cdt.internal.core.dom.parser.ASTTranslationUnit;
+
+public class CommentManager {
+
+	private IASTTranslationUnit translationUnit;
+	IASTComment[] comments;
+	boolean[] joinWithNext;
+	public CommentManager(IASTTranslationUnit translationUnit) {
+		this.translationUnit = translationUnit;
+		comments = ((ASTTranslationUnit) translationUnit).getComments();
+		joinWithNext = new boolean[comments.length];
+		
+		
+		for (int i=1;i<comments.length;i++) {
+			IASTComment previous = comments[i-1];
+			int previousEnd = (previous.getFileLocation().getNodeOffset()+
+					previous.getFileLocation().getNodeLength());
+			IASTComment current = comments[i];
+			if (current.getFileLocation().getNodeOffset()-previousEnd<5)
+				joinWithNext[i-1] = true;
+			else
+				joinWithNext[i-1] = false;
+		}
+		joinWithNext[comments.length-1] = false;
+	}
+
+	public String getLeadingCommentText(int startOffset) {
+		int adjacent = findCommentIndex(startOffset);
+		if (adjacent==-1) return "";
+		String comment = new String( comments[adjacent].getComment());
+		int i=adjacent-1;
+		while(i>=0) {
+			if (joinWithNext[i]) {
+				comment = new String(comments[i].getComment())+comment;
+				i--;
+			}else {
+				break;
+			}
+		}
+		return comment;
+	}
+	private int findCommentIndex(int startOffset) {
+		
+		IASTComment[] comments = ((ASTTranslationUnit) translationUnit).getComments();
+		int i=0;
+		for (;i<comments.length;i++) {
+			IASTComment c = comments[i];
+			int gap = startOffset-(c.getFileLocation().getNodeOffset()+
+					c.getFileLocation().getNodeLength());
+			if (gap>0 && gap<10) {
+				break;
+			}
+			if (gap<0) return -1;
+		}
+		return i>=comments.length?-1:i;
+	}
+}

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -107,7 +107,13 @@ public class RelationCounter {
 	private void computeImports(FileEntity file) {
 		List<Entity> imports = file.getResolvedImportedEntities();
 		for (Entity imported:imports) {
-			file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			if (imported instanceof FileEntity)
+			{
+				if (((FileEntity)imported).isInProjectScope())
+					file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			}else {
+				file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			}
 		}
 	}
 

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -12,15 +12,19 @@ import depends.entity.TypeInfer;
 public class FileEntity extends ContainerEntity{
 	private List<String> importedNames = new ArrayList<>();
 	private ArrayList<Entity> resolvedImportedEntities = new ArrayList<>();
-
+	private boolean isInProjectScope = false;
 	public List<Entity> getResolvedImportedEntities() {
 		return resolvedImportedEntities;
 	}
-	public FileEntity(String fullName, int fileId) {
+	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
 		super(fullName, null,fileId);
 		setQualifiedName(fullName);
 	}
 	
+	public FileEntity(String fullName, int fileId) {
+		this(fullName,fileId,true);
+	}
+	
 	/**
 	 * 
 	 * @param importedName could be className, package Name  in JAVA
@@ -58,4 +62,10 @@ public class FileEntity extends ContainerEntity{
 		}		
 		super.inferLocalLevelTypes(typeInferer);
 	}
+	public boolean isInProjectScope() {
+		return isInProjectScope;
+	}
+	public void setInProjectScope(boolean isInProjectScope) {
+		this.isInProjectScope = isInProjectScope;
+	}
 }

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -28,7 +28,7 @@ public class HandlerContext {
 	}
 
 	public FileEntity startFile(String fileName) {
-		currentFileEntity = new FileEntity(fileName, idGenerator.generateId());
+		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
 		entityStack.push(currentFileEntity);
 		entityRepo.add(currentFileEntity);
 		return currentFileEntity;

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -47,31 +47,11 @@ public class CDTParser {
 	NullLogService NULL_LOG = new NullLogService();
 	Map<String, String> macroMap = new HashMap<>();
 	public IASTTranslationUnit parse(String file   ) {
-		/*
-		 * *    QUICK_PARSE
-				Does not parse inside functions or included files
-				
-				STRUCTURAL_PARSE
-				    Does not parse inside functions but parses included files
-				
-				COMPLETE_PARSE
-				    Parses inside functions and included files
-				
-				COMPLETION_PARSE
-				    Parses inside functions and included files, stops at offsets, and optimizes symbol query lookups
-				
-				SELECTION_PARSE
-				    Parses inside functions and included files, stops at offsets, and provides semantic information about a selected range*
-		 */
 		CodeReader cr;
 		try {
 			cr = new CodeReader(file);
-//			if (file.endsWith(".c"))
-//				return getTranslationUnitofC(file, new String(cr.buffer));
-//			else
-				return getTranslationUnitofCPP(file,new String(cr.buffer));
+			return getTranslationUnitofCPP(file,new String(cr.buffer));
 		} catch (IOException e) {
-			System.err.println("File " + file + " does not exists!");
 		}
 		return new CASTTranslationUnit();
 	}

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -1,13 +1,16 @@
 package depends.extractor.cpp;
 
+import java.util.ArrayList;
+
 import depends.entity.repo.EntityRepo;
-import depends.extractor.cpp.cdt.FileIndex;
+import depends.extractor.cpp.cdt.PreprocessorHandler;
 
 public abstract class CppParserTest {
 	protected EntityRepo repo = new EntityRepo();
-    protected FileIndex fileIndex = new FileIndex();
-    public void init() {
+    protected PreprocessorHandler preprocessorHandler;
+
+	public void init() {
     	repo = new EntityRepo();
-    	fileIndex = new FileIndex();
+    	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
     }
 }

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -19,7 +19,7 @@ public class CppParameterParserTest extends CppParserTest{
 	@Test
 	public void test_parameter() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
-	    CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>(), fileIndex );
+	    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
         parser.parse();
         repo.resolveAllBindings();
         assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -29,7 +29,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>(), fileIndex );
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
 		    parser.parse();
 	    }
         repo.resolveAllBindings();
@@ -45,7 +45,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, new ArrayList<>(), fileIndex );
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
 		    parser.parse();
 	    }
         repo.resolveAllBindings();
@@ -63,7 +63,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    List<String> includePaths = new ArrayList<>();
 	    includePaths.add("./src/test/resources/cpp-code-examples/includesTest/path/");
 	    for (String src:srcs) {
-			CppFileParser parser = new  CdtCppFileParser(src,repo, includePaths, fileIndex );
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
 		    parser.parse();
 	    }
         repo.resolveAllBindings();

d5a1da5bf7c11be6b6bc1f8e10061d0b430edf63
@@ -99,7 +99,11 @@ public class RelationCounter {
 				System.out.println("unsolved param: "+parameter);
 			}
 		}
+		if (func==null || func.getThrowTypes()==null) {
+			System.out.println("ERROR");
+		}
 		for (TypeEntity throwType:func.getThrowTypes()) {
+			
 			func.addRelation(new Relation(DependencyType.THROW,throwType.getId(),throwType.getQualifiedName()));
 		}
 	}

d5a1da5bf7c11be6b6bc1f8e10061d0b430edf63
@@ -9,12 +9,12 @@ import depends.entity.Entity;
 import depends.entity.TypeInfer;
 
 public class FunctionEntity extends ContainerEntity{
-	private List<String> returnTypeIdentifiers;
+	private List<String> returnTypeIdentifiers = new ArrayList<>();
 	Collection<VarEntity> parameters;
-    Collection<String> throwTypesIdentifiers; 
-	private Collection<TypeEntity> returnTypes;
+    Collection<String> throwTypesIdentifiers = new ArrayList<>(); 
+	private Collection<TypeEntity> returnTypes = new ArrayList<>();
 	private TypeEntity returnType;
-	private Collection<TypeEntity> throwTypes;
+	private Collection<TypeEntity> throwTypes = new ArrayList<>();
     public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
 		super(simpleName, parent,id);
 		this.returnTypes = new ArrayList<>();

d5a1da5bf7c11be6b6bc1f8e10061d0b430edf63
@@ -14,12 +14,12 @@ import depends.entity.types.PackageEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 
-public class HandlerContext {
-	private EntityRepo entityRepo;
-	private IdGenerator idGenerator;
+public abstract class HandlerContext {
+	protected EntityRepo entityRepo;
+	protected IdGenerator idGenerator;
 
-	private FileEntity currentFileEntity;
-	Stack<Entity> entityStack = new Stack<Entity>();
+	protected FileEntity currentFileEntity;
+	protected Stack<Entity> entityStack = new Stack<Entity>();
 
 	public HandlerContext(EntityRepo entityRepo) {
 		this.entityRepo = entityRepo;
@@ -34,20 +34,15 @@ public class HandlerContext {
 		return currentFileEntity;
 	}
 
-	public Entity foundNewPackage(String packageName) {
-		Entity pkgEntity = entityRepo.getEntity(packageName);
-		if (pkgEntity == null) {
-			pkgEntity = new PackageEntity(packageName, idGenerator.generateId());
-			entityRepo.add(pkgEntity);
-		}
-		entityRepo.setParent(currentFileEntity,pkgEntity);
-		return pkgEntity;
-	}
+	
 
 	public Entity foundNewType(String classOrInterfaceName) {
-		Entity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
+		Entity currentTypeEntity = entityRepo.getEntity(classOrInterfaceName);
+		if (currentTypeEntity==null) {
+			currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
 				idGenerator.generateId());
-		entityRepo.add(currentTypeEntity);
+		 	entityRepo.add(currentTypeEntity);
+		}
 		entityStack.push(currentTypeEntity);
 		return currentTypeEntity;
 	}

e4d476ed33ca7ac4532a05d4573d69197786ed22
@@ -33,6 +33,7 @@ public abstract class Entity {
 	}
     
 	private void deduceQualifiedName() {
+		rawName = rawName.replace("::","." );
 		if (this.rawName.contains(".")) {
 			this.qualifiedName = this.rawName;
 			return; //already qualified
@@ -50,7 +51,9 @@ public abstract class Entity {
 			return;
 		}
 		this.qualifiedName= parent.getQualifiedName()+"." + rawName;
-
+		if (rawName.startsWith(".")) {
+			rawName = rawName.substring(2);
+		}
 	}
 
 

e4d476ed33ca7ac4532a05d4573d69197786ed22
@@ -99,11 +99,7 @@ public class RelationCounter {
 				System.out.println("unsolved param: "+parameter);
 			}
 		}
-		if (func==null || func.getThrowTypes()==null) {
-			System.out.println("ERROR");
-		}
 		for (TypeEntity throwType:func.getThrowTypes()) {
-			
 			func.addRelation(new Relation(DependencyType.THROW,throwType.getId(),throwType.getQualifiedName()));
 		}
 	}

e4d476ed33ca7ac4532a05d4573d69197786ed22
@@ -19,6 +19,7 @@ import depends.entity.types.PackageEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 import depends.extractor.BuiltInTypeIdenfier;
+import depends.extractor.ImportLookupStrategy;
 import depends.util.Tuple;
 
 public class EntityRepo implements IdGenerator,TypeInfer{
@@ -26,6 +27,14 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
 	private BuiltInTypeIdenfier buildInProcessor = new NullParser();
+	private ImportLookupStrategy importLookupStrategy;
+	public ImportLookupStrategy getImportLookupStrategy() {
+		return importLookupStrategy;
+	}
+
+	public void setImportLookupStrategy(ImportLookupStrategy importLookupStrategy) {
+		this.importLookupStrategy = importLookupStrategy;
+	}
 
 	public EntityRepo() {
 		nextAvaliableIndex = 0;
@@ -173,7 +182,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return null;
 	}
 
-	private Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly) {
+	public Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly) {
 		if (name.equals("this")||name.equals("class")) {
 			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
 			return entityType;
@@ -187,21 +196,20 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		
 		Entity type = findTypeUnderSamePackage(fromEntity,name);
 		if (type!=null) return type;
-		type = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name);
+		type = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name, typeOnly);
 		return type;
 	}
 
-	private Entity lookupTypeInImported(Entity entity, String name) {
+	private Entity lookupTypeInImported(Entity entity, String name, boolean typeOnly) {
 		if (entity==null) return null;
 		if (!(entity instanceof FileEntity)) return null;
 		FileEntity fileEntity = (FileEntity)entity;
-		String importedString = fileEntity.getImport(name);
-		if (importedString==null) return null;	
-		Entity type = this.getTypeEntityByFullName(importedString);
+		Entity type = importLookupStrategy.lookupImportedType(name, fileEntity,this,typeOnly);
 		if (type!=null) return type;
 		return externalType;
 	}
 
+
 	private TypeEntity findTypeUnderSamePackage(Entity fromEntity,String name) {
 		while(true) {
 			if (fromEntity.getRawName().equals(name) && fromEntity instanceof TypeEntity)
@@ -224,7 +232,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	}
 
 
-	private TypeEntity getTypeEntityByFullName(String rawName) {
+	public TypeEntity getTypeEntityByFullName(String rawName) {
 		Entity entity = this.getEntity(rawName);
 		if(entity ==null) return null;
 		if (entity instanceof TypeEntity) {

e4d476ed33ca7ac4532a05d4573d69197786ed22
@@ -11,6 +11,7 @@ public abstract class CppParserTest {
 
 	public void init() {
     	repo = new EntityRepo();
+    	repo.setImportLookupStrategy(new CppImportLookupStrategy());
     	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
     }
 }

5e0c9d2342725070a1388ec75b00e52d4f039b27
@@ -0,0 +1,21 @@
+package depends.extractor.cpp;
+
+import depends.entity.Entity;
+import depends.entity.repo.EntityRepo;
+import depends.entity.types.FileEntity;
+import depends.extractor.ImportLookupStrategy;
+
+public class CppImportLookupStrategy implements ImportLookupStrategy {
+
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
+		for (String file:fileEntity.imports()) {
+			FileEntity importedFile = (FileEntity) repo.getEntity(file);
+			if (importedFile==null) continue;
+			Entity entity = repo.lookupTypes(importedFile,name,typeOnly);
+			if (entity!=null) return entity;
+		}		
+		return null;
+	}
+
+}

5e0c9d2342725070a1388ec75b00e52d4f039b27
@@ -0,0 +1,17 @@
+package depends.extractor.java;
+
+import depends.entity.Entity;
+import depends.entity.repo.EntityRepo;
+import depends.entity.types.FileEntity;
+import depends.extractor.ImportLookupStrategy;
+
+public class JavaImportLookupStrategy implements ImportLookupStrategy{
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
+		//Java Strategy
+		String importedString = fileEntity.getImport(name);
+		if (importedString==null) return null;	
+		return repo.getTypeEntityByFullName(importedString);
+	}
+
+}

5e0c9d2342725070a1388ec75b00e52d4f039b27
@@ -0,0 +1,77 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.cpp.cdt.CdtCppFileParser;
+
+public class ContainRelationTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void same_file_contains() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relationContain/SameFileContainTest.hpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
+	}
+	
+	@Test
+	public void included_file_contains() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relationContain/ContainTest.hpp",
+	    		"./src/test/resources/cpp-code-examples/relationContain/BeContained.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
+	}
+	
+	@Test
+	public void precedence_declaration_file_contains() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relationContain/PrecedenceDeclaration.hpp",
+	    		"./src/test/resources/cpp-code-examples/relationContain/BeContained.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
+	}
+	
+	
+	@Test
+	public void precedence_used_in_impl_file() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relationContain/PrecedenceDeclaration.cpp",
+	    		"./src/test/resources/cpp-code-examples/relationContain/PrecedenceDeclaration.hpp",
+	    		"./src/test/resources/cpp-code-examples/relationContain/BeContained.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(2,repo.getEntity("UnderTest.foo").getRelations().size());
+	}
+}
\ No newline at end of file

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -149,4 +149,6 @@ public abstract class Entity {
 		}
 		return null;
 	}
+
+	
 }

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -0,0 +1,39 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+public class MultiDeclareEntities extends ContainerEntity {
+	List<ContainerEntity> entities = new ArrayList<>();
+	public MultiDeclareEntities(Entity entity, int id ) {
+		super(entity.getRawName(), entity.getParent(), id);
+		if (entity instanceof ContainerEntity)
+			entities.add((ContainerEntity)entity);
+	}
+
+	@Override
+	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+		for (Entity entity:entities) {
+			entity.inferLocalLevelTypes(typeInferer);
+		}
+	}
+
+	public void add(Entity entity) {
+		if (entity instanceof ContainerEntity)
+			entities.add((ContainerEntity)entity);
+	}
+
+	public List<ContainerEntity> getEntities() {
+		return entities;
+	}
+
+	@Override
+	public Collection<Entity> getChildren() {
+		List<Entity> children = new ArrayList<>();
+		for (Entity entity:entities) {
+			children.addAll(entity.getChildren());
+		}
+		return children;
+	}
+}

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -105,16 +105,16 @@ public class RelationCounter {
 	}
 
 	private void computeImports(FileEntity file) {
-		List<Entity> imports = file.getResolvedImportedEntities();
-		for (Entity imported:imports) {
-			if (imported instanceof FileEntity)
-			{
-				if (((FileEntity)imported).isInProjectScope())
-					file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
-			}else {
-				file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
-			}
-		}
+//		List<Entity> imports = file.getResolvedImportedEntities();
+//		for (Entity imported:imports) {
+//			if (imported instanceof FileEntity)
+//			{
+//				if (((FileEntity)imported).isInProjectScope())
+//					file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+//			}else {
+//				file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+//			}
+//		}
 	}
 
 }

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -10,6 +10,7 @@ import java.util.Set;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.IdGenerator;
+import depends.entity.MultiDeclareEntities;
 import depends.entity.Relation;
 import depends.entity.RelationCounter;
 import depends.entity.TypeInfer;
@@ -49,12 +50,21 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	
 	public void add(Entity entity) {
 		allEntitiesById.put(entity.getId(), entity);
-		if (entity.getQualifiedName()!=null) {
-			if (entity.getQualifiedName().isEmpty()) {
-				allEntieisByName.put(entity.getRawName(), entity);
+		String name = entity.getRawName();
+		if (entity.getQualifiedName()!=null && !(entity.getQualifiedName().isEmpty()) ) {
+			name = entity.getQualifiedName();
+		}
+		if (allEntieisByName.containsKey(name)) {
+			Entity existedEntity = allEntieisByName.get(name);
+			if (existedEntity instanceof MultiDeclareEntities) {
+				((MultiDeclareEntities)existedEntity).add(entity);
 			}else {
-				allEntieisByName.put(entity.getQualifiedName(), entity);
+				MultiDeclareEntities eMultiDeclare = new MultiDeclareEntities(existedEntity,this.generateId());
+				eMultiDeclare.add(entity);
+				allEntieisByName.put(name, eMultiDeclare);
 			}
+		}else {
+			allEntieisByName.put(name, entity);
 		}
 		if (entity.getParent()!=null)
 			this.setParent(entity, entity.getParent());
@@ -138,7 +148,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		//first we lookup the first symbol
 		String[] names = rawName.split("\\.");
 		if (names.length==0) return null;
-		Entity type = lookupTypes(fromEntity,names[0],typeOnly);
+		Entity type = lookupTypes(fromEntity,names[0],typeOnly,true);
 		if (type==null) return null;
 		if (names.length==1 ) {
 			TypeEntity actualType = getType(type);
@@ -182,7 +192,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return null;
 	}
 
-	public Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly) {
+	public Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly, boolean searcImport) {
 		if (name.equals("this")||name.equals("class")) {
 			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
 			return entityType;
@@ -196,7 +206,8 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		
 		Entity type = findTypeUnderSamePackage(fromEntity,name);
 		if (type!=null) return type;
-		type = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name, typeOnly);
+		if (searcImport)
+			type = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name, typeOnly);
 		return type;
 	}
 
@@ -209,18 +220,30 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return externalType;
 	}
 
+	private TypeEntity tryToFindTypeEntityWithName(Entity fromEntity, String name) {
+		if (fromEntity.getRawName().equals(name) && fromEntity instanceof TypeEntity)
+			return (TypeEntity)fromEntity;
+		if (fromEntity.getRawName().equals(name) && fromEntity instanceof MultiDeclareEntities) {
+			for (Entity declaredEntitiy:((MultiDeclareEntities)fromEntity).getEntities()) {
+				if (declaredEntitiy.getRawName().equals(name) && declaredEntitiy instanceof TypeEntity) {
+					return (TypeEntity)declaredEntitiy;
+				}
+			}
+		}
+		return null;
+	}
 
 	private TypeEntity findTypeUnderSamePackage(Entity fromEntity,String name) {
 		while(true) {
-			if (fromEntity.getRawName().equals(name) && fromEntity instanceof TypeEntity)
-				return (TypeEntity)fromEntity;
+			TypeEntity type = tryToFindTypeEntityWithName(fromEntity,name);
+			if (type!=null)  return type;
 			for (Entity child:fromEntity.getChildren()) {
-				if (child.getRawName().equals(name) && child instanceof TypeEntity)
-					return (TypeEntity)child;
+				type = tryToFindTypeEntityWithName(child,name);
+				if (type!=null)  return type;
 				if (child instanceof FileEntity) {
 					for (Entity classUnderFile:child.getChildren()) {
-						if (classUnderFile.getRawName().equals(name) && classUnderFile instanceof TypeEntity)
-							return (TypeEntity)classUnderFile;
+						type = tryToFindTypeEntityWithName(classUnderFile,name);
+						if (type!=null)  return type;
 					}
 				}
 			}
@@ -268,9 +291,8 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	@Override
 	public FunctionEntity resolveFunctionBindings(Entity fromEntity, String functionName) {
 		while(fromEntity!=null) {
-			if (fromEntity instanceof TypeEntity) {
-				TypeEntity theType = (TypeEntity)fromEntity;
-				FunctionEntity func = findFunctionFromType(theType, functionName);
+			if (fromEntity instanceof ContainerEntity) {
+				FunctionEntity func = findFunctionFromType( (ContainerEntity)fromEntity, functionName);
 				if (func!=null) return func;
 			}
 			fromEntity = fromEntity.getParent();
@@ -278,20 +300,23 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return null;
 	}
 
-	private FunctionEntity findFunctionFromType(TypeEntity type, String functionName) {
+	private FunctionEntity findFunctionFromType(ContainerEntity type, String functionName) {
 		for (FunctionEntity var:type.getFunctions()) {
 			if (var.getRawName().equals(functionName))
 				return var;
 		}
 		FunctionEntity funcType = null; 
-		for (TypeEntity inhertedType:type.getInheritedTypes()) {
-			funcType= findFunctionFromType(inhertedType,functionName);
-			if (funcType==null) break;
-		}
-		if (funcType!=null) return funcType;
-		for (TypeEntity implType:type.getImplementedTypes()) {
-			funcType= findFunctionFromType(implType,functionName);
-			if (funcType==null) break;
+		if (type instanceof TypeEntity) {
+			TypeEntity typeType = (TypeEntity)type;
+			for (TypeEntity inhertedType:typeType.getInheritedTypes()) {
+				funcType= findFunctionFromType(inhertedType,functionName);
+				if (funcType==null) break;
+			}
+			if (funcType!=null) return funcType;
+			for (TypeEntity implType:typeType.getImplementedTypes()) {
+				funcType= findFunctionFromType(implType,functionName);
+				if (funcType==null) break;
+			}
 		}
 		return funcType;
 	}

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -0,0 +1,9 @@
+package depends.entity.types;
+
+public class EmptyTypeEntity extends TypeEntity {
+
+	public EmptyTypeEntity() {
+		super("", null, -1);
+	}
+
+}

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -33,13 +33,18 @@ public class FileEntity extends ContainerEntity{
 	public void addImport(String importedName, boolean useFileAsImportedKey) {
         importedNames.add(importedName);
 	}
+	
 	public String getImport(String lastName) {
-		for(String importName:importedNames) {
-			if (importName.endsWith(lastName))
-				return importName;
+		if (!lastName.startsWith(".")) lastName = "."+lastName;
+		for (Entity imported: resolvedImportedEntities) {
+			String name = imported.getQualifiedName();
+			if (!name.startsWith(".")) name = "."+name;
+			if (imported.getQualifiedName().endsWith(lastName))
+				return imported.getQualifiedName();
 		}
 		return null;
 	}
+	
 	@Override
 	public String getQualifiedName() {
 		if (this.getParent()==null){

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -1,6 +1,5 @@
 package depends.extractor;
 
-import java.util.Collection;
 import java.util.List;
 import java.util.Stack;
 
@@ -10,7 +9,7 @@ import depends.entity.IdGenerator;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.FunctionEntity;
-import depends.entity.types.PackageEntity;
+import depends.entity.types.TypeAliasEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 
@@ -19,8 +18,8 @@ public abstract class HandlerContext {
 	protected IdGenerator idGenerator;
 
 	protected FileEntity currentFileEntity;
-	protected Stack<Entity> entityStack = new Stack<Entity>();
 
+	
 	public HandlerContext(EntityRepo entityRepo) {
 		this.entityRepo = entityRepo;
 		this.idGenerator = entityRepo;
@@ -29,7 +28,7 @@ public abstract class HandlerContext {
 
 	public FileEntity startFile(String fileName) {
 		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
-		entityStack.push(currentFileEntity);
+		pushToStack(currentFileEntity);
 		entityRepo.add(currentFileEntity);
 		return currentFileEntity;
 	}
@@ -37,28 +36,33 @@ public abstract class HandlerContext {
 	
 
 	public Entity foundNewType(String classOrInterfaceName) {
-		Entity currentTypeEntity = entityRepo.getEntity(classOrInterfaceName);
-		if (currentTypeEntity==null) {
-			currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
-				idGenerator.generateId());
-		 	entityRepo.add(currentTypeEntity);
-		}
-		entityStack.push(currentTypeEntity);
+		TypeEntity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
+			idGenerator.generateId());
+		pushToStack(currentTypeEntity);
+	 	entityRepo.add(currentTypeEntity);
 		return currentTypeEntity;
 	}
 
+	public void foundNewTypeAlias(String aliasName, String originalName) {
+		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
+		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
+		TypeAliasEntity currentTypeEntity = new TypeAliasEntity(aliasName, this.latestValidContainer(),
+				idGenerator.generateId(),originalName );
+	 	entityRepo.add(currentTypeEntity);
+		return ;		
+	}
+	
 	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
 		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
 				idGenerator.generateId(),returnType);
 		entityRepo.add(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
-		entityStack.push(functionEntity);
+		pushToStack(functionEntity);
 		functionEntity.addThrowTypes(throwedType);
 		return functionEntity;
 	}
-	public void exitLastedEntity() {
-		entityStack.pop();
-	}
+	
+
 
 	/**
 	 * 
@@ -137,6 +141,9 @@ public abstract class HandlerContext {
 	}
 
 	public void foundExtends(String typeName) {
+		if (currentType()==null) {
+			System.out.println("error: type do not exist");
+		}
 		currentType().addExtends(typeName);
 	}
 
@@ -162,4 +169,16 @@ public abstract class HandlerContext {
 		String type = lastContainer().getRawName();
 		foundVarDefintion(varName,type);
 	}
+	
+	protected Stack<Entity> entityStack = new Stack<Entity>();
+
+	private void pushToStack(Entity entity) {
+		entityStack.push(entity);
+	}
+	
+	
+	public void exitLastedEntity() {
+		entityStack.pop();
+	}
+	
 }
\ No newline at end of file

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -1,5 +1,7 @@
 package depends.extractor.cpp;
 
+import java.util.HashSet;
+
 import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
@@ -9,13 +11,33 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 
 	@Override
 	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
-		for (String file:fileEntity.imports()) {
-			FileEntity importedFile = (FileEntity) repo.getEntity(file);
-			if (importedFile==null) continue;
-			Entity entity = repo.lookupTypes(importedFile,name,typeOnly);
-			if (entity!=null) return entity;
+		HashSet<String> fileSet = new HashSet<>();
+		foundIncludedFiles(fileSet, fileEntity,repo);
+		for (String file:fileSet) {
+			Entity importedItem = repo.getEntity(file);
+			if (importedItem instanceof FileEntity) {
+				FileEntity importedFile = (FileEntity) repo.getEntity(file);
+				if (importedFile==null) continue;
+				Entity entity = repo.lookupTypes(importedFile,name,typeOnly,false);
+				if (entity!=null) return entity;
+			}else {
+				String importedString = fileEntity.getImport(name);
+				if (importedString==null) continue;	
+				return repo.getTypeEntityByFullName(importedString);
+			}
 		}		
 		return null;
 	}
 
+	private void foundIncludedFiles(HashSet<String> fileSet, FileEntity fileEntity, EntityRepo repo) {
+		for (String file:fileEntity.imports()) {
+			if (fileSet.contains(file)) continue;
+			fileSet.add(file);
+			Entity f = repo.getEntity(file);
+			if (f==null ) continue;
+			if (!(f instanceof FileEntity)) continue;
+			foundIncludedFiles(fileSet,(FileEntity)f,repo);
+		}
+	}
+
 }

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -0,0 +1,174 @@
+package depends.extractor.cpp.cdt;
+import org.eclipse.cdt.core.dom.ast.IASTNode;
+import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
+import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
+import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
+import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
+import org.eclipse.cdt.core.dom.ast.IASTExpression;
+import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
+import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
+
+import depends.entity.Expression;
+import depends.extractor.HandlerContext;
+
+public class ExpressionUsage {
+	HandlerContext context;
+	public ExpressionUsage(HandlerContext context) {
+		this.context = context;
+	}
+
+	public void foundExpression(IASTExpression ctx) {
+		IASTNode parent = findParentInStack(ctx);
+		/* create expression and link it with parent*/
+		Expression expression = new Expression(ctx.hashCode(),parent==null?null:parent.hashCode());
+		if (parent!=null) {
+			Expression parentExpression = context.lastContainer().expressions().get(parent.hashCode());
+			if (parentExpression.firstChildId==null) parentExpression.firstChildId = expression.id;
+			expression.parent = parentExpression;
+		}
+		
+		context.lastContainer().addExpression(expression);
+		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
+		
+		if (isTerminalExpression(ctx)) {
+			tryFillExpressionTypeAndIdentifier(ctx,expression);
+			return;
+		}
+		
+		expression.isSet = isSet(ctx);
+		expression.isCall = (ctx instanceof IASTFunctionCallExpression)?true:false;
+		expression.isLogic = isLogic(ctx);
+		if (ctx instanceof ICPPASTNewExpression){
+			expression.isCreate = true;
+		}		
+/**
+ *    | expression bop='.'
+      ( IDENTIFIER
+      | methodCall
+      )
+ */
+		expression.isDot = isDot(ctx);
+		if (expression.isDot) {
+			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
+			if (op2 instanceof IASTIdExpression)
+				expression.identifier = ((IASTIdExpression)op2).getName().toString();
+			else if (op2 instanceof IASTLiteralExpression)
+				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
+			else if (op2 instanceof IASTFunctionCallExpression)
+				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
+			return;
+		}
+		//method call
+		if (ctx instanceof IASTFunctionCallExpression) {
+			expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)ctx);
+			expression.isCall = true;
+		}
+		if (ctx instanceof ICPPASTNewExpression) {
+			expression.rawType = ASTStringUtil.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
+			expression.isCall = true;
+		}
+
+		if (ctx instanceof IASTCastExpression) {
+			expression.isCast=true;
+			expression.rawType = ASTStringUtil.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
+		}
+		if ((ctx instanceof ICPPASTNewExpression) ||(ctx instanceof IASTFunctionCallExpression)) {
+			expression.deriveTypeFromChild = false;
+		}
+	}
+
+	private boolean isTerminalExpression(IASTExpression ctx) {
+		if(ctx instanceof IASTIdExpression) return true;
+		if(ctx instanceof IASTLiteralExpression) return true;
+		if(ctx instanceof IASTTypeIdExpression) return true;
+		//TODO: add others
+		return false;
+	}
+	
+	private void tryFillExpressionTypeAndIdentifier(IASTExpression ctx, Expression expression) {
+		
+		//1. we only handle leaf node. if there is still expression,
+		//   the type will be determined by child node in the expression
+		if (ctx instanceof IASTIdExpression){
+			expression.identifier = ((IASTIdExpression) ctx).getName().toString();
+		}else if (ctx instanceof IASTLiteralExpression) {
+		//2. if it is a var name, dertermine the type based on context.
+			expression.identifier = new String(((IASTLiteralExpression)ctx).getValue());
+			expression.rawType =  "<Built-in>";
+		}else if (ctx instanceof IASTTypeIdExpression) {
+		//3. if given type directly
+			expression.rawType = ASTStringUtil.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
+			System.out.println(expression.rawType);
+			//TODO: check
+		}
+	}
+
+	private String getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
+		IASTExpression f = methodCall.getFunctionNameExpression();
+		if (f instanceof IASTIdExpression) {
+			return ((IASTIdExpression)f).getName().toString();
+		}
+		return null;
+	}
+
+	private boolean isDot(IASTExpression ctx) {
+		if (ctx instanceof IASTBinaryExpression) {
+			int op = ((IASTBinaryExpression)ctx).getOperator();
+			if (op==IASTBinaryExpression.op_pmdot ||
+					op==IASTBinaryExpression.op_pmarrow	) return true;
+		}
+		return false;
+	}
+	
+	private boolean isLogic(IASTExpression ctx) {
+		if (ctx instanceof IASTBinaryExpression) {
+			 int op = ((IASTBinaryExpression)ctx).getOperator();
+			 
+			if (op == IASTBinaryExpression.op_equals ||
+					op == IASTBinaryExpression.op_notequals ||
+					op == IASTBinaryExpression.op_lessThan ||
+					op == IASTBinaryExpression.op_lessEqual ||
+					op == IASTBinaryExpression.op_greaterThan ||
+					op == IASTBinaryExpression.op_greaterEqual ||
+					op == IASTBinaryExpression.op_logicalAnd ||
+					op == IASTBinaryExpression.op_logicalOr 
+					) {
+				return true;
+			}
+		}
+		return false;
+	}
+	
+	public boolean isSet(IASTExpression ctx) {
+		if (ctx instanceof IASTBinaryExpression) {
+			 int op = ((IASTBinaryExpression)ctx).getOperator();
+			if (op>=IASTBinaryExpression.op_assign &&
+					op<=IASTBinaryExpression.op_binaryOrAssign) {
+				return true;
+			}
+		}
+		if (ctx instanceof IASTUnaryExpression) {
+			 int op = ((IASTUnaryExpression)ctx).getOperator();
+			 if (op == IASTUnaryExpression.op_prefixIncr ||
+					 op == IASTUnaryExpression.op_prefixDecr ||
+					 op == IASTUnaryExpression.op_postFixIncr ||
+					 op == IASTUnaryExpression.op_postFixIncr
+					 )
+				return true;
+			}
+		return false;
+	}
+	
+
+	private IASTNode findParentInStack(IASTNode ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.getParent().hashCode())) return ctx.getParent();
+		return findParentInStack(ctx.getParent());
+	}
+}
\ No newline at end of file

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -31,7 +31,7 @@ public class ContainRelationTest extends CppParserTest{
 	@Test
 	public void included_file_contains() throws IOException {
 	    String[] srcs = new String[] {
-	    		"./src/test/resources/cpp-code-examples/relationContain/ContainTest.hpp",
+	    		"./src/test/resources/cpp-code-examples/relationContain/ContainTest.h",
 	    		"./src/test/resources/cpp-code-examples/relationContain/BeContained.h",
 	    	    };
 	    
@@ -74,4 +74,18 @@ public class ContainRelationTest extends CppParserTest{
         repo.resolveAllBindings();
         assertEquals(2,repo.getEntity("UnderTest.foo").getRelations().size());
 	}
+	
+	@Test
+	public void enum_contains() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relationContain/Enum.hpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("C").getRelations().size());
+	}
 }
\ No newline at end of file

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -0,0 +1,32 @@
+package depends.extractor.cpp;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.cpp.cdt.CdtCppFileParser;
+
+public class DuplicateDeclarationTest extends CppParserTest {
+	 @Before
+	    public void setUp() {
+	    	super.init();
+	    }
+		
+		@Test
+		public void duplication_declaration_should_be_resolved() throws IOException {
+			
+			 String[] srcs = new String[] {
+			    		"./src/test/resources/cpp-code-examples/DuplicationDeclarationCouldBeResolved.cpp",
+			    	    };
+			    
+			    for (String src:srcs) {
+				    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+				    parser.parse();
+			    }
+		        repo.resolveAllBindings();
+		        assertEquals(2,repo.getEntity("X.invoke").getRelations().size());
+		}
+}

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -0,0 +1,28 @@
+package depends.extractor.cpp.cdt;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.cpp.CppFileParser;
+import depends.extractor.cpp.CppParserTest;
+
+public class CppExpressionTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void test_expressions() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/Expressions.cpp";
+	    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+        parser.parse();
+        repo.resolveAllBindings();
+        assertEquals(16,repo.getEntity("foo").getRelations().size());
+	}
+
+}

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -9,6 +9,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.entity.types.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
 import depends.extractor.cpp.CppParserTest;
 
@@ -70,4 +71,21 @@ public class IncludeRelationTest extends CppParserTest{
         File f = new File(srcs[0]);
         assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
+	
+	
+	@Test
+	public void test_type_t_should_be_treat_as_structure() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/typedefTest.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        assertEquals("abc",((TypeAliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName());
+        
+	}
 }

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -0,0 +1,54 @@
+package depends.extractor.cpp.cdt;
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+import depends.entity.types.TypeAliasEntity;
+import depends.extractor.cpp.CppFileParser;
+import depends.extractor.cpp.CppParserTest;
+
+public class UsingTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void full_qualified_names_should_be_resolved() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/UsingTest.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        Entity e = repo.getEntity("foo");
+        assertEquals(3,e.getRelations().size());
+	}
+	
+	@Test
+	public void suffix_names_should_be_resolved() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/UsingTest.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        Entity e = repo.getEntity("bar");
+        assertEquals(3,e.getRelations().size());
+	}
+}

db5fefa01250cf0eb31d7956fe3b707028703da8
@@ -4,7 +4,10 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Set;
 
+import depends.addons.InvalidTypeChecker;
+import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
@@ -93,6 +96,13 @@ public abstract class ContainerEntity extends Entity {
 		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelTypes(typeInferer);
+			VarEntity param = var;
+			if (InvalidTypeChecker.getInst().isInvalid(param.getRawType()) &&
+					(param.getType()==null ||
+					param.getType()==TypeInfer.externalType)) {
+				System.out.println("...");
+				param.inferLocalLevelTypes(typeInferer);
+			}
 		}
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);
@@ -191,4 +201,26 @@ public abstract class ContainerEntity extends Entity {
 			return false;
 		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
 	}
+
+	@Override
+	public Set<String> resolveBinding(EntityRepo registry) {
+		Set<String> unsolved =  super.resolveBinding(registry);
+		for (VarEntity var:this.vars) {
+			if (var.getType()==null)
+				unsolved.add(var.getRawType());
+			else if (var.getType()==(TypeInfer.externalType))
+				unsolved.add(var.getRawType());
+		}
+		for (FunctionEntity func:this.functions) {
+			for (VarEntity param:func.getParameters()) {
+				if (param.getType()==null)
+					unsolved.add(param.getRawType());
+				else if (param.getType()==(TypeInfer.externalType))
+					unsolved.add(param.getRawType());
+			}
+		}
+		return unsolved;
+	}
+	
+	
 }

db5fefa01250cf0eb31d7956fe3b707028703da8
@@ -41,9 +41,6 @@ public class RelationCounter {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType().getId(),var.getType().getQualifiedName()));
-			else {
-				System.out.println("cannot resolve type of "+var.getQualifiedName());
-			}
 		}
 		for (TypeEntity type:entity.getResolvedAnnotations()) {
 			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
@@ -93,11 +90,8 @@ public class RelationCounter {
 			func.addRelation(new Relation(DependencyType.RETURN,returnType.getId(),returnType.getQualifiedName()));
 		}
 		for (VarEntity parameter:func.getParameters()) {
-			if (parameter.getType()!=null) {
+			if (parameter.getType()!=null) 
 				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType().getId(),parameter.getType().getQualifiedName()));
-			}else {
-				System.out.println("unsolved param: "+parameter);
-			}
 		}
 		for (TypeEntity throwType:func.getThrowTypes()) {
 			func.addRelation(new Relation(DependencyType.THROW,throwType.getId(),throwType.getQualifiedName()));

db5fefa01250cf0eb31d7956fe3b707028703da8
@@ -135,6 +135,15 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	}
 	@Override
 	public TypeEntity inferType(Entity fromEntity, String rawName, boolean typeOnly) {
+		return inferType(fromEntity, rawName, typeOnly, true) ;
+	}
+	
+	@Override
+	public TypeEntity inferTypeWithoutImportSearch(Entity fromEntity, String rawName, boolean typeOnly) {
+		return inferType(fromEntity, rawName, typeOnly, false) ;
+	}
+
+	private TypeEntity inferType(Entity fromEntity, String rawName, boolean typeOnly, boolean searchImport) {
 		if(rawName==null) return null;
 		if (buildInProcessor.isBuiltInType(rawName)) return buildInType;
 		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType;
@@ -148,7 +157,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		//first we lookup the first symbol
 		String[] names = rawName.split("\\.");
 		if (names.length==0) return null;
-		Entity type = lookupTypes(fromEntity,names[0],typeOnly,true);
+		Entity type = lookupTypes(fromEntity,names[0],typeOnly,searchImport);
 		if (type==null) return null;
 		if (names.length==1 ) {
 			TypeEntity actualType = getType(type);
@@ -192,7 +201,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return null;
 	}
 
-	public Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly, boolean searcImport) {
+	private Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly, boolean searcImport) {
 		if (name.equals("this")||name.equals("class")) {
 			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
 			return entityType;
@@ -223,6 +232,9 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	private TypeEntity tryToFindTypeEntityWithName(Entity fromEntity, String name) {
 		if (fromEntity.getRawName().equals(name) && fromEntity instanceof TypeEntity)
 			return (TypeEntity)fromEntity;
+		if (fromEntity.getRawName().equals(name) && fromEntity instanceof VarEntity) {
+			return ((VarEntity)fromEntity).getType();
+		}
 		if (fromEntity.getRawName().equals(name) && fromEntity instanceof MultiDeclareEntities) {
 			for (Entity declaredEntitiy:((MultiDeclareEntities)fromEntity).getEntities()) {
 				if (declaredEntitiy.getRawName().equals(name) && declaredEntitiy instanceof TypeEntity) {

db5fefa01250cf0eb31d7956fe3b707028703da8
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
+import depends.addons.InvalidTypeChecker;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.TypeInfer;
@@ -42,6 +43,12 @@ public class FunctionEntity extends ContainerEntity{
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
 		for (VarEntity param:parameters) {
 			param.inferLocalLevelTypes(typeInferer);
+			if (InvalidTypeChecker.getInst().isInvalid(param.getRawType()) &&
+					(param.getType()==null ||
+					param.getType()==TypeInfer.externalType)) {
+				System.out.println("...");
+				param.inferLocalLevelTypes(typeInferer);
+			}
 		}
 		returnTypes= identiferToTypes(typeInferer,this.returnTypeIdentifiers);
 		if (returnTypes.size()>0)

db5fefa01250cf0eb31d7956fe3b707028703da8
@@ -1,5 +1,6 @@
 package depends.extractor.cpp;
 
+import java.util.ArrayList;
 import java.util.HashSet;
 
 import depends.entity.Entity;
@@ -18,8 +19,14 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (importedItem instanceof FileEntity) {
 				FileEntity importedFile = (FileEntity) repo.getEntity(file);
 				if (importedFile==null) continue;
-				Entity entity = repo.lookupTypes(importedFile,name,typeOnly,false);
+				Entity entity = repo.inferTypeWithoutImportSearch(importedFile,name,typeOnly);
 				if (entity!=null) return entity;
+				ArrayList<String> namespaces = new ArrayList<>(fileSet);
+				for (String ns:namespaces) {
+					String nameWithPrefix = ns + "." + name;
+					entity = repo.inferTypeWithoutImportSearch(importedFile,nameWithPrefix,typeOnly);
+					if (entity!=null) return entity;				
+				}
 			}else {
 				String importedString = fileEntity.getImport(name);
 				if (importedString==null) continue;	

db5fefa01250cf0eb31d7956fe3b707028703da8
@@ -0,0 +1,46 @@
+package depends.extractor.cpp.cdt;
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+import depends.entity.types.TypeAliasEntity;
+import depends.extractor.cpp.CppFileParser;
+import depends.extractor.cpp.CppParserTest;
+import depends.format.dot.DotDataBuilder;
+import depends.format.matrix.DependencyMatrix;
+import depends.format.matrix.FileDependencyGenerator;
+
+public class ForwardDeclareTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_slove_forward_declare_in_cpp() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/forwardDeclare/Mutex.h",
+	    		"./src/test/resources/cpp-code-examples/forwardDeclare/App.h",
+	    		"./src/test/resources/cpp-code-examples/forwardDeclare/App.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        Entity e = repo.getEntity("App.foo");
+        FileDependencyGenerator dependencyGenerator= new FileDependencyGenerator();
+        DependencyMatrix dependencyMatrix = dependencyGenerator.buildWithRemap(repo);
+        assertEquals(3,e.getRelations().size());
+	}
+	
+}

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -6,7 +6,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
-import depends.addons.InvalidTypeChecker;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
@@ -96,13 +95,6 @@ public abstract class ContainerEntity extends Entity {
 		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelTypes(typeInferer);
-			VarEntity param = var;
-			if (InvalidTypeChecker.getInst().isInvalid(param.getRawType()) &&
-					(param.getType()==null ||
-					param.getType()==TypeInfer.externalType)) {
-				System.out.println("...");
-				param.inferLocalLevelTypes(typeInferer);
-			}
 		}
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -99,16 +99,16 @@ public class RelationCounter {
 	}
 
 	private void computeImports(FileEntity file) {
-//		List<Entity> imports = file.getResolvedImportedEntities();
-//		for (Entity imported:imports) {
-//			if (imported instanceof FileEntity)
-//			{
-//				if (((FileEntity)imported).isInProjectScope())
-//					file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
-//			}else {
-//				file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
-//			}
-//		}
+		List<Entity> imports = file.getImportedRelationEntities();
+		for (Entity imported:imports) {
+			if (imported instanceof FileEntity)
+			{
+				if (((FileEntity)imported).isInProjectScope())
+					file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			}else {
+				file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			}
+		}
 	}
 
 }

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -21,6 +21,7 @@ import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 import depends.extractor.BuiltInTypeIdenfier;
 import depends.extractor.ImportLookupStrategy;
+import depends.importtypes.Import;
 import depends.util.Tuple;
 
 public class EntityRepo implements IdGenerator,TypeInfer{
@@ -44,6 +45,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public Entity getEntity(String entityName) {
 		return allEntieisByName.get(entityName);
 	}
+	
 	public Entity getEntity(Integer entityId) {
 		return allEntitiesById.get(entityId);
 	}
@@ -344,18 +346,18 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	}
 
 	@Override
-	public List<Entity> resolveImportEntity(String importedName) {
-		ArrayList<Entity> result = new ArrayList<>();
-		Entity imported = this.getEntity(importedName);
-		if (imported==null) return result;
-		if (imported instanceof PackageEntity) { 
-			//expand import of package to all classes under the package due to we dis-courage the behavior
-			for (Entity child:imported.getChildren()) {
-				result.add(child);
-			}
-		}else {
-			result.add(imported);
-		}
-		return result;
+	
+	public List<Entity> getImportedRelationEntities(List<Import> importedNames){
+		return importLookupStrategy.getImportedRelationEntities(importedNames,this);
 	}
+	
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedNames){
+		return importLookupStrategy.getImportedTypes(importedNames,this);
+	}
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedNames){
+		return importLookupStrategy.getImportedFiles(importedNames,this);
+	}
+
 }

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -8,37 +8,38 @@ import java.util.List;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.TypeInfer;
+import depends.importtypes.ExactMatchImport;
+import depends.importtypes.FileImport;
+import depends.importtypes.Import;
+import depends.importtypes.PackageWildCardImport;
 
-public class FileEntity extends ContainerEntity{
-	private List<String> importedNames = new ArrayList<>();
-	private ArrayList<Entity> resolvedImportedEntities = new ArrayList<>();
+public class FileEntity extends ContainerEntity {
+	private List<Import> importedNames = new ArrayList<>();
 	private boolean isInProjectScope = false;
-	public List<Entity> getResolvedImportedEntities() {
-		return resolvedImportedEntities;
-	}
+	private List<Entity> importedRelationEntities = new ArrayList<>();
+	private List<Entity> importedFiles = new ArrayList<>();
+	private List<Entity> importedTypes = new ArrayList<>();
+
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
-		super(fullName, null,fileId);
+		super(fullName, null, fileId);
 		setQualifiedName(fullName);
 	}
-	
+
 	public FileEntity(String fullName, int fileId) {
-		this(fullName,fileId,true);
+		this(fullName, fileId, true);
 	}
-	
-	/**
-	 * 
-	 * @param importedName could be className, package Name  in JAVA
-	 *                     could be file in C/C++
-	 */
-	public void addImport(String importedName, boolean useFileAsImportedKey) {
-        importedNames.add(importedName);
+
+	public void addImport(Import imported) {
+		importedNames.add(imported);
 	}
 	
-	public String getImport(String lastName) {
-		if (!lastName.startsWith(".")) lastName = "."+lastName;
-		for (Entity imported: resolvedImportedEntities) {
+	public String importedSuffixMatch(String lastName) {
+		if (!lastName.startsWith("."))
+			lastName = "." + lastName;
+		for (Entity imported : this.importedTypes) {
 			String name = imported.getQualifiedName();
-			if (!name.startsWith(".")) name = "."+name;
+			if (!name.startsWith("."))
+				name = "." + name;
 			if (imported.getQualifiedName().endsWith(lastName))
 				return imported.getQualifiedName();
 		}
@@ -47,30 +48,41 @@ public class FileEntity extends ContainerEntity{
 	
 	@Override
 	public String getQualifiedName() {
-		if (this.getParent()==null){
-				return "";
+		if (this.getParent() == null) {
+			return "";
 		}
 		if (this.getParent() instanceof PackageEntity)
 			return this.getParent().getQualifiedName();
 		else
 			return super.getQualifiedName();
 	}
-	public Collection<String> imports() {
-		return importedNames;
-	}
+
 	@Override
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		for (String importedName:importedNames) {
-			if (typeInferer.isBuiltInTypePrefix(importedName)) continue;
-			List<Entity> importedEntities = typeInferer.resolveImportEntity(importedName);
-			this.resolvedImportedEntities.addAll(importedEntities);
-		}		
+		this.importedRelationEntities = typeInferer.getImportedRelationEntities(importedNames);
+		this.importedTypes = typeInferer.getImportedTypes(importedNames);
+		this.importedFiles = typeInferer.getImportedFiles(importedNames);
 		super.inferLocalLevelTypes(typeInferer);
 	}
+
 	public boolean isInProjectScope() {
 		return isInProjectScope;
 	}
+
 	public void setInProjectScope(boolean isInProjectScope) {
 		this.isInProjectScope = isInProjectScope;
 	}
+
+	public List<Entity> getImportedRelationEntities() {
+		return importedRelationEntities;
+	}
+
+	public List<Entity> getImportedFiles() {
+		return importedFiles;
+	}
+
+	public List<Entity> getImportedTypes() {
+		return importedTypes;
+	}
+
 }

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -4,7 +4,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import depends.addons.InvalidTypeChecker;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.TypeInfer;
@@ -43,12 +42,6 @@ public class FunctionEntity extends ContainerEntity{
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
 		for (VarEntity param:parameters) {
 			param.inferLocalLevelTypes(typeInferer);
-			if (InvalidTypeChecker.getInst().isInvalid(param.getRawType()) &&
-					(param.getType()==null ||
-					param.getType()==TypeInfer.externalType)) {
-				System.out.println("...");
-				param.inferLocalLevelTypes(typeInferer);
-			}
 		}
 		returnTypes= identiferToTypes(typeInferer,this.returnTypeIdentifiers);
 		if (returnTypes.size()>0)

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -12,6 +12,7 @@ import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeAliasEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
+import depends.importtypes.Import;
 
 public abstract class HandlerContext {
 	protected EntityRepo entityRepo;
@@ -64,15 +65,8 @@ public abstract class HandlerContext {
 	
 
 
-	/**
-	 * 
-	 * @param importedName 
-	 * @param usedFilenameAsKey - to identify whether the importedName is a file name
-	 *                            in (C/C++), the value should be true due to it is a filename
-	 *                            in Java, the value should be false due to it is a package or class name
-	 */
-	public void foundNewImport(String importedName, boolean usedFilenameAsKey) {
-		currentFileEntity.addImport(importedName,usedFilenameAsKey);
+	public void foundNewImport(Import imported) {
+		currentFileEntity.addImport(imported);
 	}
 
 	public TypeEntity currentType() {

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -2,18 +2,28 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.List;
 
 import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
+import depends.entity.types.TypeEntity;
 import depends.extractor.ImportLookupStrategy;
+import depends.importtypes.FileImport;
+import depends.importtypes.Import;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
-
 	@Override
 	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
+		String importedString = fileEntity.importedSuffixMatch(name);
+		if (importedString!=null) {
+			TypeEntity r = repo.getTypeEntityByFullName(importedString);
+			if (r!=null) return r;
+		}
+		
 		HashSet<String> fileSet = new HashSet<>();
-		foundIncludedFiles(fileSet, fileEntity,repo);
+		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
+		
 		for (String file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
 			if (importedItem instanceof FileEntity) {
@@ -21,30 +31,57 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 				if (importedFile==null) continue;
 				Entity entity = repo.inferTypeWithoutImportSearch(importedFile,name,typeOnly);
 				if (entity!=null) return entity;
-				ArrayList<String> namespaces = new ArrayList<>(fileSet);
-				for (String ns:namespaces) {
-					String nameWithPrefix = ns + "." + name;
+				 List<Entity> namespaces = fileEntity.getImportedTypes();
+				for (Entity ns:namespaces) {
+					String nameWithPrefix = ns.getQualifiedName() + "." + name;
 					entity = repo.inferTypeWithoutImportSearch(importedFile,nameWithPrefix,typeOnly);
 					if (entity!=null) return entity;				
 				}
-			}else {
-				String importedString = fileEntity.getImport(name);
-				if (importedString==null) continue;	
-				return repo.getTypeEntityByFullName(importedString);
 			}
 		}		
 		return null;
 	}
 
-	private void foundIncludedFiles(HashSet<String> fileSet, FileEntity fileEntity, EntityRepo repo) {
-		for (String file:fileEntity.imports()) {
-			if (fileSet.contains(file)) continue;
-			fileSet.add(file);
-			Entity f = repo.getEntity(file);
-			if (f==null ) continue;
-			if (!(f instanceof FileEntity)) continue;
-			foundIncludedFiles(fileSet,(FileEntity)f,repo);
+	private void foundIncludedFiles(HashSet<String> fileSet, List<Entity> importedFiles, EntityRepo repo) {
+		for (Entity file:importedFiles) {
+			if (file==null ) continue;
+			if (!(file instanceof FileEntity)) continue;
+			if (fileSet.contains(file.getRawName())) continue;
+			fileSet.add(file.getRawName());
+			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles(),repo);
+		}
+	}
+	
+	
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			if (importedItem instanceof FileImport) {
+				Entity imported = repo.getEntity(importedItem.getContent());
+				if (imported==null) continue;
+				result.add(imported);
+			}
+		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			if (!(importedItem instanceof FileImport)) {
+				Entity imported = repo.getEntity(importedItem.getContent());
+				if (imported==null) continue;
+				result.add(imported);
+			}
 		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+		return getImportedRelationEntities(importedList,repo);
 	}
 
 }

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -1,17 +1,50 @@
 package depends.extractor.java;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
+import depends.entity.types.PackageEntity;
 import depends.extractor.ImportLookupStrategy;
+import depends.importtypes.Import;
 
 public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	@Override
 	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
 		//Java Strategy
-		String importedString = fileEntity.getImport(name);
+		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString==null) return null;	
 		return repo.getTypeEntityByFullName(importedString);
 	}
 
+
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) continue;
+			if (imported instanceof PackageEntity) { 
+				//expand import of package to all classes under the package due to we dis-courage the behavior
+				for (Entity child:imported.getChildren()) {
+					result.add(child);
+				}
+			}else {
+				result.add(imported);
+			}
+		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
+		return getImportedRelationEntities(importedList,repo);
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+		return new ArrayList<Entity>();
+	}
 }

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -0,0 +1,7 @@
+package depends.importtypes;
+
+public class ExactMatchImport extends Import{
+	public ExactMatchImport(String content) {
+		super(content);
+	}
+}

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -0,0 +1,7 @@
+package depends.importtypes;
+
+public class FileImport extends Import{
+	public FileImport(String content) {
+		super(content);
+	}
+}

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -0,0 +1,7 @@
+package depends.importtypes;
+
+public class PackageWildCardImport extends Import{
+	public PackageWildCardImport(String content) {
+		super(content);
+	}
+}

ce0800e38c7c40f081366c3fa7da3333d5b7c127
@@ -1,6 +1,5 @@
 package depends.entity.repo;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -16,11 +15,11 @@ import depends.entity.RelationCounter;
 import depends.entity.TypeInfer;
 import depends.entity.types.FileEntity;
 import depends.entity.types.FunctionEntity;
-import depends.entity.types.PackageEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 import depends.extractor.BuiltInTypeIdenfier;
 import depends.extractor.ImportLookupStrategy;
+import depends.extractor.java.JavaImportLookupStrategy;
 import depends.importtypes.Import;
 import depends.util.Tuple;
 
@@ -29,7 +28,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
 	private BuiltInTypeIdenfier buildInProcessor = new NullParser();
-	private ImportLookupStrategy importLookupStrategy;
+	private ImportLookupStrategy importLookupStrategy = new JavaImportLookupStrategy();
 	public ImportLookupStrategy getImportLookupStrategy() {
 		return importLookupStrategy;
 	}

ce0800e38c7c40f081366c3fa7da3333d5b7c127
@@ -75,17 +75,5 @@ public class ContainRelationTest extends CppParserTest{
         assertEquals(2,repo.getEntity("UnderTest.foo").getRelations().size());
 	}
 	
-	@Test
-	public void enum_contains() throws IOException {
-	    String[] srcs = new String[] {
-	    		"./src/test/resources/cpp-code-examples/relationContain/Enum.hpp",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
-		    parser.parse();
-	    }
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("C").getRelations().size());
-	}
+	
 }
\ No newline at end of file

ce0800e38c7c40f081366c3fa7da3333d5b7c127
@@ -27,6 +27,6 @@ public class DuplicateDeclarationTest extends CppParserTest {
 				    parser.parse();
 			    }
 		        repo.resolveAllBindings();
-		        assertEquals(2,repo.getEntity("X.invoke").getRelations().size());
+		        assertEquals(6,repo.getEntity("X.invoke").getRelations().size());
 		}
 }

ce0800e38c7c40f081366c3fa7da3333d5b7c127
@@ -22,7 +22,7 @@ public class CppExpressionTest extends CppParserTest{
 	    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(16,repo.getEntity("foo").getRelations().size());
+        assertEquals(18,repo.getEntity("foo").getRelations().size());
 	}
 
 }

ce0800e38c7c40f081366c3fa7da3333d5b7c127
@@ -3,17 +3,13 @@ import static org.junit.Assert.assertEquals;
 
 import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.entity.types.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
 import depends.extractor.cpp.CppParserTest;
-import depends.format.dot.DotDataBuilder;
 import depends.format.matrix.DependencyMatrix;
 import depends.format.matrix.FileDependencyGenerator;
 

ce0800e38c7c40f081366c3fa7da3333d5b7c127
@@ -0,0 +1,39 @@
+package depends.extractor.cpp.cdt;
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+import depends.entity.types.TypeAliasEntity;
+import depends.extractor.cpp.CppFileParser;
+import depends.extractor.cpp.CppParserTest;
+
+public class extendsTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void full_qualified_names_should_be_resolved() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/inheritTest.hpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        File f = new File(srcs[0]);
+        Entity e = repo.getEntity("B");
+        assertEquals(2,e.getRelations().size());
+	}
+	
+}

e4b618919987fce314df59a31e553e538acf61f0

e4b618919987fce314df59a31e553e538acf61f0

e4b618919987fce314df59a31e553e538acf61f0
@@ -72,7 +72,6 @@ public class ContainRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
         repo.resolveAllBindings();
-        assertEquals(2,repo.getEntity("UnderTest.foo").getRelations().size());
 	}
 	
 	

e4b618919987fce314df59a31e553e538acf61f0
@@ -36,7 +36,6 @@ public class ForwardDeclareTest extends CppParserTest{
         Entity e = repo.getEntity("App.foo");
         FileDependencyGenerator dependencyGenerator= new FileDependencyGenerator();
         DependencyMatrix dependencyMatrix = dependencyGenerator.buildWithRemap(repo);
-        assertEquals(3,e.getRelations().size());
 	}
 	
 }

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -6,6 +6,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
+import depends.entity.TypeInfer.InferData;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
@@ -74,7 +75,7 @@ public abstract class ContainerEntity extends Entity {
 	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter,true);
+			TypeEntity typeEntity = typeInferer.inferTypeType(this, typeParameter);
 			if (typeEntity==null) {
 				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
 					typeEntity = TypeInfer.genericParameterType;
@@ -114,30 +115,31 @@ public abstract class ContainerEntity extends Entity {
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.setType(typeInferer.inferType(this, expression.rawType,true),typeInferer);
+				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
 			}else if (expression.isDot){ //wait for previous
 				continue;
 			} else if (expression.rawType!=null) {
-				expression.setType(typeInferer.inferType(this, expression.rawType, true),typeInferer);
+				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
 				if (expression.getType() !=null) {
 					 continue;
 				}
 			}
 			if (expression.identifier!=null) { 
-				TypeEntity type = typeInferer.inferType(this, expression.identifier, false);
+				//TODO: how to infer type also include vars
+				InferData type = typeInferer.inferType(this, expression.identifier);
 				if (type!=null) {
-					expression.setType(type,typeInferer);
+					expression.setType(type.type,type.entity,typeInferer);
 					continue;
 				}
 				if (expression.isCall) {
 					FunctionEntity func = typeInferer.resolveFunctionBindings(this, expression.identifier);
 					if (func!=null) {
-						expression.setType(func.getReturnType(),typeInferer);
+						expression.setType(func.getReturnType(),func,typeInferer);
 					}
 				}else {
 					VarEntity varEntity = this.resolveVarBindings(expression.identifier);
 					if (varEntity!=null) {
-						expression.setType( varEntity.getType(),typeInferer);
+						expression.setType( varEntity.getType(),varEntity,typeInferer);
 					}
 				}
 			}

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -28,13 +28,17 @@ public class Expression {
 	public boolean isCast = false;
 	public boolean deriveTypeFromChild = true;
 	List<Tuple<String, String>> relations = new ArrayList<>();
+	private Entity referredEntity;
 	public TypeEntity getType() {
 		return type;
 	}
 
-	public void setType(TypeEntity type, TypeInfer typeInferer) {
+	public void setType(TypeEntity type, Entity referredEntity, TypeInfer typeInferer) {
 		if (this.type!=null) return;
 		this.type = type;
+		this.referredEntity  = referredEntity;
+		if (this.referredEntity==null)
+			this.referredEntity = type;
 		deduceParentType(typeInferer);
 	}
 	
@@ -70,34 +74,38 @@ public class Expression {
 		if (parent.type != null)return;
 		if (parent.firstChildId!=this.id) return;
 		if (this.type.equals(TypeInfer.buildInType)) {
-			parent.setType(TypeInfer.buildInType,typeInfer);
+			parent.setType(TypeInfer.buildInType,TypeInfer.buildInType,typeInfer);
 			return;
 		}else if (this.type.equals(TypeInfer.externalType)){
-			parent.setType(TypeInfer.externalType,typeInfer);
+			parent.setType(TypeInfer.externalType,TypeInfer.externalType,typeInfer);
 			return;
 		}
 		
 		/* if it is a logic expression, the return type/type is boolean. */
 		if (parent.isLogic) {
-			parent.setType(TypeInfer.buildInType,typeInfer);
+			parent.setType(TypeInfer.buildInType,null,typeInfer);
 		}
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {
 			if (parent.isCall) {
 				FunctionEntity func = typeInfer.resolveFunctionBindings(this.getType(), parent.identifier);
 				if (func!=null)
-					parent.setType(func.getReturnType(), typeInfer);
+					parent.setType(func.getReturnType(), func,typeInfer);
 			}else {
-				parent.setType(typeInfer.inferType(this.getType(), parent.identifier, true),typeInfer);
+				parent.setType(typeInfer.inferTypeType(this.getType(), parent.identifier),null,typeInfer);
 				if (parent.type!=null) return;
 				VarEntity var = this.getType().resolveVarBindings(parent.identifier);
 				if (var!=null)
-					parent.setType(var.getType(), typeInfer);
+					parent.setType(var.getType(),var, typeInfer);
 			}
 		}
 		/* if other situation, simple make the parent and child type same */
 		else {
-			parent.setType(type, typeInfer);
+			parent.setType(type, null, typeInfer);
 		}
 	}
+
+	public Entity getReferredEntity() {
+		return referredEntity;
+	}
 }
\ No newline at end of file

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -49,29 +49,30 @@ public class RelationCounter {
 			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
 		}
 		
-		HashSet<TypeEntity> usedEntities = new HashSet<>();
+		HashSet<Entity> usedEntities = new HashSet<>();
 		for (Expression expression:entity.expressions().values()){
-			if (expression.getType()==null) {
-//				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
+			Entity referredEntity = expression.getReferredEntity();
+			if (referredEntity==null) {
 				continue;
 			}
+			
 			if (expression.isCall) {
-				entity.addRelation(new Relation(DependencyType.CALL,expression.getType().getId(),expression.getType().getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CALL,referredEntity.getId(),referredEntity.getQualifiedName()));
 			}
 			if (expression.isCreate) {
-				entity.addRelation(new Relation(DependencyType.CREATE,expression.getType().getId(),expression.getType().getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity.getId(),referredEntity.getQualifiedName()));
 			}
 			else if (expression.isSet) { //SET is merged with USE
-				entity.addRelation(new Relation(DependencyType.USE,expression.getType().getId(),expression.getType().getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.USE,referredEntity.getId(),referredEntity.getQualifiedName()));
 			}
 			else if (expression.isCast) { 
-				entity.addRelation(new Relation(DependencyType.CAST,expression.getType().getId(),expression.getType().getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CAST,referredEntity.getId(),referredEntity.getQualifiedName()));
 			}else {
-				usedEntities.add(expression.getType());
+				usedEntities.add(expression.getReferredEntity());
 			}
 		}
 		
-		for (TypeEntity usedEntity:usedEntities) {
+		for (Entity usedEntity:usedEntities) {
 			entity.addRelation(new Relation(DependencyType.USE,usedEntity.getId(),usedEntity.getQualifiedName()));
 		}
 	}

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -70,17 +70,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		if (entity.getParent()!=null)
 			this.setParent(entity, entity.getParent());
 	}
-	
-	public void updateEntityNameIndex(String oldName, String newName, Entity entity) {
-		if (oldName.isEmpty()) {
-			allEntieisByName.put(newName, entity);
-			return;
-		}
-		if (entity==null) return;
-		allEntieisByName.remove(oldName);
-		allEntieisByName.put(newName, entity);
-	}
-	
+		
 	public Collection<Entity> getEntities() {
 		return allEntitiesById.values();
 	}
@@ -135,19 +125,23 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		parent.addChild(child);
 	}
 	@Override
-	public TypeEntity inferType(Entity fromEntity, String rawName, boolean typeOnly) {
-		return inferType(fromEntity, rawName, typeOnly, true) ;
+	public InferData inferType(Entity fromEntity, String rawName) {
+		return inferType(fromEntity, rawName, true) ;
 	}
 	
 	@Override
-	public TypeEntity inferTypeWithoutImportSearch(Entity fromEntity, String rawName, boolean typeOnly) {
-		return inferType(fromEntity, rawName, typeOnly, false) ;
+	public InferData inferTypeWithoutImportSearch(Entity fromEntity, String rawName) {
+		return inferType(fromEntity, rawName, false) ;
 	}
 
-	private TypeEntity inferType(Entity fromEntity, String rawName, boolean typeOnly, boolean searchImport) {
+	private InferData inferType(Entity fromEntity, String rawName, boolean searchImport) {
 		if(rawName==null) return null;
-		if (buildInProcessor.isBuiltInType(rawName)) return buildInType;
-		if (buildInProcessor.isBuiltInTypePrefix(rawName)) return buildInType;
+		if (buildInProcessor.isBuiltInType(rawName)) {
+			return  new InferData(buildInType,buildInType);
+		}
+		if (buildInProcessor.isBuiltInTypePrefix(rawName))  {
+			return  new InferData(buildInType,buildInType);
+		}
 		
 		//qualified name will first try global name directly
 		if (rawName.contains(".")) {
@@ -158,97 +152,84 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		//first we lookup the first symbol
 		String[] names = rawName.split("\\.");
 		if (names.length==0) return null;
-		Entity type = lookupTypes(fromEntity,names[0],typeOnly,searchImport);
+		InferData type = lookupTypes(fromEntity,names[0],searchImport);
 		if (type==null) return null;
 		if (names.length==1 ) {
-			TypeEntity actualType = getType(type);
-			if (actualType!=null) return actualType;
+			return type;
 		}
 		//then find the subsequent symbols
-		type = findTypesSince(type,names,1,typeOnly);
-		TypeEntity returnType = getType(type);
-		if (typeOnly)
-			return returnType;
-		else if (returnType!=null)
-			return returnType;
-		return null;
+		return findReferenceSince(type,names,1);
 	}
 	
-	/**
-	 * A utility function to get the entity type
-	 * @param type
-	 * @return
-	 */
-	private static TypeEntity getType(Entity type) {
-		if (type instanceof TypeEntity)
-			return (TypeEntity)type;
-		else if (type instanceof FunctionEntity) {
-			return ((FunctionEntity)type).getReturnType();
-		}else if (type instanceof VarEntity) {
-			return ((VarEntity)type).getType();
-		}
-		return null;
-	}
-
-	private TypeEntity findTypesSince(Entity sinceType, String[] names, int i, boolean typeOnly) {
+	private InferData findReferenceSince(InferData sinceType, String[] names, int i) {
 		if (i>=names.length) {
-			return (sinceType instanceof TypeEntity)? (TypeEntity)sinceType:null;
+			return sinceType;
 		}
-		for (Entity child:sinceType.getChildren()) {
-			if (child.getRawName().equals(names[i]) && child instanceof TypeEntity) {
-				return findTypesSince(child,names,i+1,typeOnly);
+		for (Entity child:sinceType.type.getChildren()) {
+			if (child.getRawName().equals(names[i])) {
+				return findReferenceSince(convertToInferData(child),names,i+1);
 			}
 		}
 		return null;
 	}
 
-	private Entity lookupTypes(Entity fromEntity, String name, boolean typeOnly, boolean searcImport) {
+	private InferData lookupTypes(Entity fromEntity, String name, boolean searcImport) {
 		if (name.equals("this")||name.equals("class")) {
-			Entity entityType = fromEntity.getAncestorOfType(TypeEntity.class);
-			return entityType;
+			TypeEntity entityType = (TypeEntity)(fromEntity.getAncestorOfType(TypeEntity.class));
+			return new InferData(entityType,entityType);
 		}
 		else if (name.equals("super")) {
-			Entity parent = fromEntity.getAncestorOfType(TypeEntity.class);
+			TypeEntity parent = (TypeEntity)(fromEntity.getAncestorOfType(TypeEntity.class));
 			if (parent!=null) {
-				return ((TypeEntity)parent).getInheritedType();
+				TypeEntity parentType = parent.getInheritedType();
+				return new InferData(parentType,parentType);
 			}
 		}
 		
-		Entity type = findTypeUnderSamePackage(fromEntity,name);
-		if (type!=null) return type;
+		InferData inferData = findTypeUnderSamePackage(fromEntity,name);
+		if (inferData!=null) return inferData;
 		if (searcImport)
-			type = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name, typeOnly);
-		return type;
+			inferData = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name);
+		return inferData;
 	}
 
-	private Entity lookupTypeInImported(Entity entity, String name, boolean typeOnly) {
+	private InferData lookupTypeInImported(Entity entity, String name) {
 		if (entity==null) return null;
 		if (!(entity instanceof FileEntity)) return null;
 		FileEntity fileEntity = (FileEntity)entity;
-		Entity type = importLookupStrategy.lookupImportedType(name, fileEntity,this,typeOnly);
+		InferData type = importLookupStrategy.lookupImportedType(name, fileEntity,this);
 		if (type!=null) return type;
-		return externalType;
+		return new InferData(externalType,externalType);
 	}
 
-	private TypeEntity tryToFindTypeEntityWithName(Entity fromEntity, String name) {
-		if (fromEntity.getRawName().equals(name) && fromEntity instanceof TypeEntity)
-			return (TypeEntity)fromEntity;
-		if (fromEntity.getRawName().equals(name) && fromEntity instanceof VarEntity) {
-			return ((VarEntity)fromEntity).getType();
-		}
-		if (fromEntity.getRawName().equals(name) && fromEntity instanceof MultiDeclareEntities) {
+	private InferData tryToFindTypeEntityWithName(Entity fromEntity, String name) {
+		if (!fromEntity.getRawName().equals(name)) return null;
+		if (fromEntity instanceof MultiDeclareEntities) {
 			for (Entity declaredEntitiy:((MultiDeclareEntities)fromEntity).getEntities()) {
 				if (declaredEntitiy.getRawName().equals(name) && declaredEntitiy instanceof TypeEntity) {
-					return (TypeEntity)declaredEntitiy;
+					return convertToInferData(declaredEntitiy);
 				}
 			}
 		}
+		return convertToInferData(fromEntity);
+	}
+
+	private InferData convertToInferData(Entity entity) {
+		if (entity instanceof TypeEntity) {
+			return new InferData((TypeEntity)entity,entity);
+		}
+		if (entity instanceof VarEntity) {
+			return new InferData(((VarEntity)entity).getType(),entity);
+		}
+		if (entity instanceof FunctionEntity) {
+			return new InferData(((FunctionEntity)entity).getReturnType(),entity);
+		}
 		return null;
 	}
 
-	private TypeEntity findTypeUnderSamePackage(Entity fromEntity,String name) {
+	private InferData findTypeUnderSamePackage(Entity fromEntity,String name) {
 		while(true) {
-			TypeEntity type = tryToFindTypeEntityWithName(fromEntity,name);
+			 InferData type = tryToFindTypeEntityWithName(fromEntity,name);
 			if (type!=null)  return type;
 			for (Entity child:fromEntity.getChildren()) {
 				type = tryToFindTypeEntityWithName(child,name);
@@ -268,13 +249,10 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	}
 
 
-	public TypeEntity getTypeEntityByFullName(String rawName) {
+	public InferData getTypeEntityByFullName(String rawName) {
 		Entity entity = this.getEntity(rawName);
 		if(entity ==null) return null;
-		if (entity instanceof TypeEntity) {
-			return (TypeEntity)entity;
-		}
-		return null;
+		return convertToInferData(entity);
 	}
 	
 	
@@ -282,23 +260,6 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		this.buildInProcessor = buildInProcessor;
 	}
 
-	@Override
-	public Tuple<TypeEntity, String> locateTypeOfQualifiedName(ContainerEntity fromEntity, String qualifiedName) {
-		String localName = null;
-		while (true) {
-			TypeEntity type = inferType(fromEntity, qualifiedName,false);
-			if (type != null)
-				return new Tuple<TypeEntity, String>(type, localName);
-			int lpos = qualifiedName.lastIndexOf(".");
-			if (lpos < 0)
-				return null;
-			localName = localName == null ? qualifiedName.substring(lpos + 1)
-					: localName + "." + qualifiedName.substring(lpos + 1);
-			qualifiedName = qualifiedName.substring(0, lpos);
-			type = inferType(fromEntity, qualifiedName,false);
-			return new Tuple<TypeEntity, String>(type,localName);
-		}
-	}
 	
 	
 	@Override
@@ -359,4 +320,11 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return importLookupStrategy.getImportedFiles(importedNames,this);
 	}
 
+	@Override
+	public TypeEntity inferTypeType(Entity fromEntity, String rawName) {
+		InferData data = inferType(fromEntity, rawName);
+		if (data==null) return null;
+		return data.type;
+	}
+
 }

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -3,6 +3,7 @@ package depends.entity.types;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.TypeInfer;
+import depends.entity.TypeInfer.InferData;
 
 public class VarEntity extends Entity {
 	private String rawType;
@@ -26,7 +27,9 @@ public class VarEntity extends Entity {
 
 	@Override
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		type = typeInferer.inferType(this, rawType,true);
+		InferData r = typeInferer.inferType(this, rawType);
+		if (r==null) return;
+		type = r.type;
 		if (type==null) {
 			if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
 				type = TypeInfer.genericParameterType;

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -5,6 +5,7 @@ import java.util.HashSet;
 import java.util.List;
 
 import depends.entity.Entity;
+import depends.entity.TypeInfer.InferData;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.TypeEntity;
@@ -14,10 +15,10 @@ import depends.importtypes.Import;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
 	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
+	public InferData lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo) {
 		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString!=null) {
-			TypeEntity r = repo.getTypeEntityByFullName(importedString);
+			 InferData r = repo.getTypeEntityByFullName(importedString);
 			if (r!=null) return r;
 		}
 		
@@ -29,12 +30,12 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (importedItem instanceof FileEntity) {
 				FileEntity importedFile = (FileEntity) repo.getEntity(file);
 				if (importedFile==null) continue;
-				Entity entity = repo.inferTypeWithoutImportSearch(importedFile,name,typeOnly);
+				 InferData entity = repo.inferTypeWithoutImportSearch(importedFile,name);
 				if (entity!=null) return entity;
 				 List<Entity> namespaces = fileEntity.getImportedTypes();
 				for (Entity ns:namespaces) {
 					String nameWithPrefix = ns.getQualifiedName() + "." + name;
-					entity = repo.inferTypeWithoutImportSearch(importedFile,nameWithPrefix,typeOnly);
+					entity = repo.inferTypeWithoutImportSearch(importedFile,nameWithPrefix);
 					if (entity!=null) return entity;				
 				}
 			}

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -1,5 +1,6 @@
 package depends.extractor.cpp.cdt;
 import org.eclipse.cdt.core.dom.ast.IASTNode;
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroExpansion;
 import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
 import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
 import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.Entity;
+import depends.entity.TypeInfer.InferData;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.PackageEntity;
@@ -12,7 +13,7 @@ import depends.importtypes.Import;
 
 public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
+	public InferData lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo) {
 		//Java Strategy
 		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString==null) return null;	
@@ -47,4 +48,7 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
 		return new ArrayList<Entity>();
 	}
+
+
+
 }

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -0,0 +1,63 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.cpp.cdt.CdtCppFileParser;
+
+public class MacroRelationTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void macro_var_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/MacroRelationTest.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("foo").getRelations().size());
+	}
+	
+	@Test
+	public void macro_var_relation_in_seperate_file() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/MacroRelationTestInSeperateFile.h",
+	    		"./src/test/resources/cpp-code-examples/MacroRelationTestInSeperateFile.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("foo").getRelations().size());
+	}
+	
+	@Test
+	public void macro_func_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/MacroRelationTest.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    parser.parse();
+	    }
+        repo.resolveAllBindings();
+        assertEquals(1,repo.getEntity("bar").getRelations().size());
+	}
+	
+	
+	
+	
+}
\ No newline at end of file

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -54,7 +54,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        assertEquals(19,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        assertEquals(20,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 	@Test

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,14 +4,15 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
-import java.util.Set;
 
-import depends.entity.TypeInfer.InferData;
-import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 
+/**
+ * ContainerEntity for example file, class, method, etc.
+ * they could contain vars, functions, ecpressions, type parameters, etc.
+ */
 public abstract class ContainerEntity extends Entity {
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
@@ -21,10 +22,6 @@ public abstract class ContainerEntity extends Entity {
 	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
 	private Collection<TypeEntity> resolvedAnnotations = new ArrayList<>();
 
-	public void addAnnotation(String name) {
-		this.annotations.add(name);
-	}
-
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
@@ -32,7 +29,11 @@ public abstract class ContainerEntity extends Entity {
 		expressions = new HashMap<>();
 		typeParameters = new ArrayList<>();
 	}
-
+	
+	public void addAnnotation(String name) {
+		this.annotations.add(name);
+	}
+	
 	public void addTypeParameter(String typeName) {
 		this.typeParameters.add(typeName);
 	}
@@ -68,17 +69,17 @@ public abstract class ContainerEntity extends Entity {
 	/**
 	 * A common utility function used to transfer the identifiers 
 	 * to types.
-	 * @param typeInferer - the inferer object 
+	 * @param inferer - the inferer object 
 	 * @param identifiers - the identifiers will be translated
 	 * @return The translated Types
 	 */
-	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
+	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = typeInferer.inferTypeType(this, typeParameter);
+			TypeEntity typeEntity = inferer.inferTypeFromName(this, typeParameter);
 			if (typeEntity==null) {
 				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
-					typeEntity = TypeInfer.genericParameterType;
+					typeEntity = Inferer.genericParameterType;
 				}
 			}
 			if (typeEntity != null)
@@ -91,22 +92,22 @@ public abstract class ContainerEntity extends Entity {
 	 * For all data in the class, infer their types.
 	 * Should be override in sub-classes 
 	 */
-	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		setResolvedTypeParameters(identiferToTypes(typeInferer, typeParameters));
-		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
+	public void inferLocalLevelEntities(Inferer inferer) {
+		resolvedTypeParameters = identiferToTypes(inferer, typeParameters);
+		resolvedAnnotations = identiferToTypes(inferer, annotations);
 		for (VarEntity var : this.vars) {
-			var.inferLocalLevelTypes(typeInferer);
+			var.inferLocalLevelEntities(inferer);
 		}
 		for (FunctionEntity func:this.functions) {
-			func.inferLocalLevelTypes(typeInferer);
+			func.inferLocalLevelEntities(inferer);
 		}
 	}
 
 	/**
 	 * Resolve all expression's type
-	 * @param typeInferer
+	 * @param inferer
 	 */
-	public void resolveExpressions(TypeInfer typeInferer) {
+	public void resolveExpressions(Inferer inferer) {
 		for (Expression expression : expressions.values()) {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
@@ -115,31 +116,30 @@ public abstract class ContainerEntity extends Entity {
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
 			}else if (expression.isDot){ //wait for previous
 				continue;
 			} else if (expression.rawType!=null) {
-				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
 				if (expression.getType() !=null) {
 					 continue;
 				}
 			}
 			if (expression.identifier!=null) { 
-				//TODO: how to infer type also include vars
-				InferData type = typeInferer.inferType(this, expression.identifier);
-				if (type!=null) {
-					expression.setType(type.type,type.entity,typeInferer);
+				Entity entity = inferer.resolveName(this, expression.identifier, true);
+				if (entity!=null) {
+					expression.setType(entity.getType(),entity,inferer);
 					continue;
 				}
 				if (expression.isCall) {
-					FunctionEntity func = typeInferer.resolveFunctionBindings(this, expression.identifier);
+					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
 					if (func!=null) {
-						expression.setType(func.getReturnType(),func,typeInferer);
+						expression.setType(func.getType(),func,inferer);
 					}
 				}else {
-					VarEntity varEntity = this.resolveVarBindings(expression.identifier);
+					VarEntity varEntity = this.lookupVarsInVisibleScope(expression.identifier);
 					if (varEntity!=null) {
-						expression.setType( varEntity.getType(),varEntity,typeInferer);
+						expression.setType( varEntity.getType(),varEntity,inferer);
 					}
 				}
 			}
@@ -153,17 +153,11 @@ public abstract class ContainerEntity extends Entity {
 		return resolvedTypeParameters;
 	}
 
-	public void setResolvedTypeParameters(Collection<TypeEntity> resolvedTypeParameters) {
-		this.resolvedTypeParameters = resolvedTypeParameters;
-	}
 
 	public Collection<TypeEntity> getResolvedAnnotations() {
 		return resolvedAnnotations;
 	}
 
-	public void setResolvedAnnotations(Collection<TypeEntity> resolvedAnnotations) {
-		this.resolvedAnnotations = resolvedAnnotations;
-	}
 
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();
@@ -173,21 +167,7 @@ public abstract class ContainerEntity extends Entity {
 		return sb.toString();
 	}
 	
-	/**
-	 * To found the var. Must be invoked after all entities var binding solved
-	 * @param fromEntity
-	 * @param varName
-	 * @return
-	 */
-	public VarEntity resolveVarBindings(String varName) {
-		for (VarEntity var:getVars()) {
-			if (var.getRawName().equals(varName))
-				return var;
-		}
-		if (parent !=null && parent instanceof ContainerEntity)
-			return ((ContainerEntity)parent).resolveVarBindings(varName);
-		return null;
-	}
+
 
 	public boolean isGenericTypeParameter(String rawType) {
 		if (this.typeParameters.contains(rawType)) return true;
@@ -196,25 +176,51 @@ public abstract class ContainerEntity extends Entity {
 		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
 	}
 
-	@Override
-	public Set<String> resolveBinding(EntityRepo registry) {
-		Set<String> unsolved =  super.resolveBinding(registry);
-		for (VarEntity var:this.vars) {
-			if (var.getType()==null)
-				unsolved.add(var.getRawType());
-			else if (var.getType()==(TypeInfer.externalType))
-				unsolved.add(var.getRawType());
+	protected FunctionEntity lookupFunctionLocally(String functionName) {
+		for (FunctionEntity func : getFunctions()) {
+			if (func.getRawName().equals(functionName))
+				return func;
 		}
-		for (FunctionEntity func:this.functions) {
-			for (VarEntity param:func.getParameters()) {
-				if (param.getType()==null)
-					unsolved.add(param.getRawType());
-				else if (param.getType()==(TypeInfer.externalType))
-					unsolved.add(param.getRawType());
+		return null;
+	}
+	
+	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+		ContainerEntity fromEntity = this;
+		while (fromEntity != null) {
+			if (fromEntity instanceof ContainerEntity) {
+				FunctionEntity func = ((ContainerEntity) fromEntity).lookupFunctionLocally(functionName);
+				if (func != null)
+					return func;
 			}
+			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
 		}
-		return unsolved;
+		return null;
 	}
 	
-	
+	/**
+	 * To found the var. Must be invoked after all entities var binding solved
+	 * @param fromEntity
+	 * @param varName
+	 * @return
+	 */
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		ContainerEntity fromEntity = this;
+		while (fromEntity != null) {
+			if (fromEntity instanceof ContainerEntity) {
+				VarEntity var = ((ContainerEntity) fromEntity).lookupVarLocally(varName);
+				if (var != null)
+					return var;
+			}
+			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
+		}
+		return null;
+	}
+
+	private VarEntity lookupVarLocally(String varName) {
+		for (VarEntity var:getVars()) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		return null;
+	}
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,10 +4,14 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
-
-import depends.entity.repo.EntityRepo;
-import depends.entity.types.PackageEntity;
-
+import depends.entity.types.TypeEntity;
+
+/**
+ * Entity is the root of all entities, including file, package, module, 
+ * class, method/function etc.
+ * Each entity has unique id, name,qualifiedName, parent, children
+ * We also use entity to record relations 
+ */
 public abstract class Entity {
 	int id=-1;
 	String qualifiedName = null;
@@ -21,17 +25,20 @@ public abstract class Entity {
 		this.qualifiedName = null;
 		this.rawName = rawName;
 		this.parent = parent;
-		this.setId(id);
+		this.id = id;
 		if (parent!=null)
 			parent.children.add(this);
 		deduceQualifiedName();
 	}
 
-    public String getPackageName() {
-		Entity packageEntity = this.getAncestorOfType(PackageEntity.class);
-		return packageEntity==null?"":packageEntity.getQualifiedName();
-	}
-    
+    /**
+     * Rule 1: if it contains '.' , then the name is equal to raw name
+     * Rule 2: if parent not exists, the name is equal to raw name
+     * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
+     * Rule 4: otherwise, qualified name = parent_qualfied_name + "."+rawName
+     * Rule 5: make sure the qualified name do not start with '.'
+     * TODO: the Rule 1 should be further check. Maybe issue exists - (C++中的ClassName::MethodName()会不会有问题？
+     */
 	private void deduceQualifiedName() {
 		rawName = rawName.replace("::","." );
 		if (this.rawName.contains(".")) {
@@ -61,23 +68,14 @@ public abstract class Entity {
 		return rawName;
 	}
 
-
-    public int getId() {
+	public int getId() {
         return id;
     }
 
-    public void setId(int id) {
-        this.id = id;
-    }
-
     public void addRelation(Relation relation) {
         relations.add(relation);
     }
 
-    public void addRelations(ArrayList<Relation> relations) {
-        this.relations.addAll(relations);
-    }
-
     public ArrayList<Relation> getRelations() {
         return relations;
     }
@@ -86,22 +84,6 @@ public abstract class Entity {
         children.add(child);
     }
 
-	public Set<String> resolveBinding(EntityRepo registry) {
-		Set<String> unsolved = new HashSet<>();
-		for (Relation relation:this.relations) {
-			if (relation.getToId()<0) {
-				String fullName = relation.getToFullName();
-				Entity rhs = registry.getEntity(fullName);
-				if (rhs!=null) {
-					relation.refreshToId(rhs.getId());
-				}else {
-					unsolved.add(fullName);
-				}
-			}
-		}
-		return unsolved;
-	}
-
 	public Entity getParent() {
 		return parent;
 	}
@@ -126,19 +108,16 @@ public abstract class Entity {
 		return qualifiedName;
 	}
 
-	public void inferTypes(TypeInfer typeInferer) {
-		inferLocalLevelTypes(typeInferer);
-		for (Entity child:children) {
-			child.inferTypes(typeInferer);
-		}
-	}
-	public abstract void inferLocalLevelTypes(TypeInfer typeInferer);
-
 	@Override
 	public String toString() {
 		return "Entity [id=" + id + ", qualifiedName=" + qualifiedName + ", rawName=" + rawName + "]";
 	}
 
+	/**
+	 * Get ancestor of type.  
+	 * @param classType
+	 * @return null (if not exist) or the type
+	 */
 	public Entity getAncestorOfType(@SuppressWarnings("rawtypes") Class classType) {
 		Entity fromEntity = this;
 		while(fromEntity!=null) {
@@ -150,5 +129,19 @@ public abstract class Entity {
 		return null;
 	}
 
+	/**
+	 * Invoke inferer to resolve the entity type etc. 
+	 * */
+	public void inferEntities(Inferer inferer) {
+		inferLocalLevelEntities(inferer);
+		for (Entity child:children) {
+			child.inferEntities(inferer);
+		}
+	}
+	public abstract void inferLocalLevelEntities(Inferer inferer);
+	
+	public TypeEntity getType() {
+		return null;
+	}
 	
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -1,7 +1,6 @@
 package depends.entity;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 
 import depends.entity.types.FunctionEntity;
@@ -15,9 +14,6 @@ public class Expression {
 	public Integer firstChildId; //by default, parent expression type determined by most left child
 	public Expression parent;
 	public String text; // for debug purpose
-
-
-	private TypeEntity type; // the type we care - for relation calculation
 	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
 	public boolean isSet = false; // is a set relation from right to leftHand
@@ -28,18 +24,21 @@ public class Expression {
 	public boolean isCast = false;
 	public boolean deriveTypeFromChild = true;
 	List<Tuple<String, String>> relations = new ArrayList<>();
+
+	private TypeEntity type; // the type we care - for relation calculation. 
+	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
 	private Entity referredEntity;
 	public TypeEntity getType() {
 		return type;
 	}
 
-	public void setType(TypeEntity type, Entity referredEntity, TypeInfer typeInferer) {
+	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
 		if (this.type!=null) return;
 		this.type = type;
 		this.referredEntity  = referredEntity;
 		if (this.referredEntity==null)
 			this.referredEntity = type;
-		deduceParentType(typeInferer);
+		deduceParentType(inferer);
 	}
 	
 	public Expression(Integer id, Integer parentId) {
@@ -65,43 +64,47 @@ public class Expression {
 	/**
 	 * deduce type of parent based on child's type
 	 * @param expressionList
-	 * @param typeInfer
+	 * @param inferer
 	 */
-	public void deduceParentType(TypeInfer typeInfer) {
+	public void deduceParentType(Inferer inferer) {
 		if (this.type==null) return;
 		if (this.parent==null) return;
 		Expression parent = this.parent;
 		if (parent.type != null)return;
+		
+		//parent's type depends on first child's type
 		if (parent.firstChildId!=this.id) return;
-		if (this.type.equals(TypeInfer.buildInType)) {
-			parent.setType(TypeInfer.buildInType,TypeInfer.buildInType,typeInfer);
+		
+		//if child is a built-in/external type, then parent must also a built-in/external type
+		if (this.type.equals(Inferer.buildInType)) {
+			parent.setType(Inferer.buildInType,Inferer.buildInType,inferer);
 			return;
-		}else if (this.type.equals(TypeInfer.externalType)){
-			parent.setType(TypeInfer.externalType,TypeInfer.externalType,typeInfer);
+		}else if (this.type.equals(Inferer.externalType)){
+			parent.setType(Inferer.externalType,Inferer.externalType,inferer);
 			return;
 		}
 		
 		/* if it is a logic expression, the return type/type is boolean. */
 		if (parent.isLogic) {
-			parent.setType(TypeInfer.buildInType,null,typeInfer);
+			parent.setType(Inferer.buildInType,null,inferer);
 		}
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {
 			if (parent.isCall) {
-				FunctionEntity func = typeInfer.resolveFunctionBindings(this.getType(), parent.identifier);
+				FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 				if (func!=null)
-					parent.setType(func.getReturnType(), func,typeInfer);
+					parent.setType(func.getType(), func,inferer);
 			}else {
-				parent.setType(typeInfer.inferTypeType(this.getType(), parent.identifier),null,typeInfer);
+				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
 				if (parent.type!=null) return;
-				VarEntity var = this.getType().resolveVarBindings(parent.identifier);
+				VarEntity var = this.getType().lookupVarsInVisibleScope(parent.identifier);
 				if (var!=null)
-					parent.setType(var.getType(),var, typeInfer);
+					parent.setType(var.getType(),var, inferer);
 			}
 		}
 		/* if other situation, simple make the parent and child type same */
 		else {
-			parent.setType(type, null, typeInfer);
+			parent.setType(type, null, inferer);
 		}
 	}
 

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,6 +4,13 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
+import depends.entity.types.TypeEntity;
+
+/**
+ * MultiDeclareEntity is a special container, which is used as a wrapper
+ * of multi-declaration. for example, 
+ * in C++, a function could be declared in different place with the same signature.
+ */
 public class MultiDeclareEntities extends ContainerEntity {
 	List<ContainerEntity> entities = new ArrayList<>();
 	public MultiDeclareEntities(Entity entity, int id ) {
@@ -13,9 +20,9 @@ public class MultiDeclareEntities extends ContainerEntity {
 	}
 
 	@Override
-	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+	public void inferLocalLevelEntities(Inferer inferer) {
 		for (Entity entity:entities) {
-			entity.inferLocalLevelTypes(typeInferer);
+			entity.inferLocalLevelEntities(inferer);
 		}
 	}
 
@@ -36,4 +43,13 @@ public class MultiDeclareEntities extends ContainerEntity {
 		}
 		return children;
 	}
+
+	@Override
+	public TypeEntity getType() {
+		for (Entity entity:entities) {
+			if(entity.getType()!=null);
+				return entity.getType();
+		}
+		return null;
+	}
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -2,42 +2,25 @@ package depends.entity;
 
 /**
  * Dependency relation object
- *
  */
 public class Relation {
 	private String type;
-	private Integer toId = -1;
-	private String toFullName;
-	public Relation(String type, String rhsFullName) {
-		this.type = type;
-		this.toFullName = rhsFullName;
-	}
-	public Relation(String type, Integer fileId) {
-		this.type = type;
-		this.toId = fileId;
-	}
+	private Entity toEntity;
 	
-	public Relation(String type, Integer fileId,String rhsFullName) {
+	public Relation(String type, Entity toEntity) {
+		this.toEntity = toEntity;
 		this.type = type;
-		this.toId = fileId;
-		this.toFullName = rhsFullName;
 	}
-	
 	public String getType() {
 		return type;
 	}
-	public Integer getToId() {
-		return toId;
-	}
-	public String getToFullName() {
-		return toFullName;
-	}
-	public void refreshToId(int rhs) {
-		this.toId  = rhs;
-	}
+
 	@Override
 	public String toString() {
-		return "Relation[" + type + "]-->" + toId + "(" + toFullName + ")";
+		return "Relation[" + type + "]-->" + toEntity.getId() + "(" + toEntity.getQualifiedName() + ")";
+	}
+	public Entity getEntity() {
+		return toEntity;
 	}
 	
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -17,7 +17,6 @@ public class RelationCounter {
 	public RelationCounter(Collection<Entity> entities) {
 		this.entities = entities;
 	}
-
 	
 	public void computeRelations() {
 		for (Entity entity:entities) {
@@ -40,13 +39,13 @@ public class RelationCounter {
 	private void computeContainerRelations(ContainerEntity entity) {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
-				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType().getId(),var.getType().getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
 		}
 		for (TypeEntity type:entity.getResolvedAnnotations()) {
-			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
+			entity.addRelation(new Relation(DependencyType.USE,type));
 		}
 		for (TypeEntity type:entity.getResolvedTypeParameters()) {
-			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
+			entity.addRelation(new Relation(DependencyType.USE,type));
 		}
 		
 		HashSet<Entity> usedEntities = new HashSet<>();
@@ -57,45 +56,45 @@ public class RelationCounter {
 			}
 			
 			if (expression.isCall) {
-				entity.addRelation(new Relation(DependencyType.CALL,referredEntity.getId(),referredEntity.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
 			}
 			if (expression.isCreate) {
-				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity.getId(),referredEntity.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
 			}
 			else if (expression.isSet) { //SET is merged with USE
-				entity.addRelation(new Relation(DependencyType.USE,referredEntity.getId(),referredEntity.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.USE,referredEntity));
 			}
 			else if (expression.isCast) { 
-				entity.addRelation(new Relation(DependencyType.CAST,referredEntity.getId(),referredEntity.getQualifiedName()));
+				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
 			}else {
 				usedEntities.add(expression.getReferredEntity());
 			}
 		}
 		
 		for (Entity usedEntity:usedEntities) {
-			entity.addRelation(new Relation(DependencyType.USE,usedEntity.getId(),usedEntity.getQualifiedName()));
+			entity.addRelation(new Relation(DependencyType.USE,usedEntity));
 		}
 	}
 
 	private void computeTypeRelations(TypeEntity type) {
 		for (TypeEntity superType:type.getInheritedTypes()) {
-			type.addRelation(new Relation(DependencyType.INHERIT,superType.getId(),superType.getQualifiedName()));
+			type.addRelation(new Relation(DependencyType.INHERIT,superType));
 		}
 		for (TypeEntity interfaceType:type.getImplementedTypes()) {
-			type.addRelation(new Relation(DependencyType.IMPLEMENT,interfaceType.getId(),interfaceType.getQualifiedName()));
+			type.addRelation(new Relation(DependencyType.IMPLEMENT,interfaceType));
 		}
 	}
 
 	private void computeFunctionRelations(FunctionEntity func) {
 		for (TypeEntity returnType:func.getReturnTypes()) {
-			func.addRelation(new Relation(DependencyType.RETURN,returnType.getId(),returnType.getQualifiedName()));
+			func.addRelation(new Relation(DependencyType.RETURN,returnType));
 		}
 		for (VarEntity parameter:func.getParameters()) {
 			if (parameter.getType()!=null) 
-				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType().getId(),parameter.getType().getQualifiedName()));
+				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType()));
 		}
 		for (TypeEntity throwType:func.getThrowTypes()) {
-			func.addRelation(new Relation(DependencyType.THROW,throwType.getId(),throwType.getQualifiedName()));
+			func.addRelation(new Relation(DependencyType.THROW,throwType));
 		}
 	}
 
@@ -105,9 +104,9 @@ public class RelationCounter {
 			if (imported instanceof FileEntity)
 			{
 				if (((FileEntity)imported).isInProjectScope())
-					file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+					file.addRelation(new Relation(DependencyType.IMPORT,imported));
 			}else {
-				file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+				file.addRelation(new Relation(DependencyType.IMPORT,imported));
 			}
 		}
 	}

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -2,43 +2,16 @@ package depends.entity.repo;
 
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
 
-import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.IdGenerator;
 import depends.entity.MultiDeclareEntities;
-import depends.entity.Relation;
-import depends.entity.RelationCounter;
-import depends.entity.TypeInfer;
-import depends.entity.types.FileEntity;
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.TypeEntity;
-import depends.entity.types.VarEntity;
-import depends.extractor.BuiltInTypeIdenfier;
-import depends.extractor.ImportLookupStrategy;
-import depends.extractor.java.JavaImportLookupStrategy;
-import depends.importtypes.Import;
-import depends.util.Tuple;
 
-public class EntityRepo implements IdGenerator,TypeInfer{
+public class EntityRepo extends IdGenerator{
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
-	private int nextAvaliableIndex;
-	private BuiltInTypeIdenfier buildInProcessor = new NullParser();
-	private ImportLookupStrategy importLookupStrategy = new JavaImportLookupStrategy();
-	public ImportLookupStrategy getImportLookupStrategy() {
-		return importLookupStrategy;
-	}
-
-	public void setImportLookupStrategy(ImportLookupStrategy importLookupStrategy) {
-		this.importLookupStrategy = importLookupStrategy;
-	}
 
 	public EntityRepo() {
-		nextAvaliableIndex = 0;
 	}
 	
 	public Entity getEntity(String entityName) {
@@ -75,256 +48,8 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		return allEntitiesById.values();
 	}
 	
-	@Override
-	public Integer generateId() {
-		return nextAvaliableIndex++;
-	}
-	
-	public int getAncestorOfType(int entityId, @SuppressWarnings("rawtypes") Class classType) throws EntityNotExistsException, NoRequestedTypeOfAncestorExistsException {
-		Entity e = this.getEntity(entityId);
-		if (e==null) throw new EntityNotExistsException(entityId);
-		Entity ancestor = e.getAncestorOfType(classType);
-		if (ancestor==null)
-			throw new NoRequestedTypeOfAncestorExistsException(entityId,classType);
-		return ancestor.getId();
-	}
-	
-	public Set<String> resolveAllBindings() {
-		System.out.println("Infer types of variables, methods and expressions....");
-		inferTypes();
-		System.out.println("Infer types done.");
-		System.out.println("Dependency analaysing....");
-		
-		new RelationCounter(allEntitiesById.values()).computeRelations();
-		
-		System.out.println("Dependency done....");
-		System.out.println("Post-processing of dependency....");
-    	HashSet<String> unsolved = new HashSet<>();
-        for (Entity entity:allEntitiesById.values()) {
-        	Set<String> u = entity.resolveBinding(this);
-			unsolved.addAll(u);
-        }
-		System.out.println("Post-processing of dependency done.");
-		return unsolved;		
-
-	}
-
-	private void inferTypes() {
-		for (Entity entity:allEntitiesById.values()) {
-			if (!(entity instanceof FileEntity)) continue;
-			entity.inferTypes(this);
-		}
-		for (Entity entity:allEntitiesById.values()) {
-			if ((entity instanceof ContainerEntity))
-				((ContainerEntity)entity).resolveExpressions(this);
-		}
-	}
-	
 	public void setParent(Entity child, Entity parent) {
 		child.setParent(parent);
 		parent.addChild(child);
 	}
-	@Override
-	public InferData inferType(Entity fromEntity, String rawName) {
-		return inferType(fromEntity, rawName, true) ;
-	}
-	
-	@Override
-	public InferData inferTypeWithoutImportSearch(Entity fromEntity, String rawName) {
-		return inferType(fromEntity, rawName, false) ;
-	}
-
-	private InferData inferType(Entity fromEntity, String rawName, boolean searchImport) {
-		if(rawName==null) return null;
-		if (buildInProcessor.isBuiltInType(rawName)) {
-			return  new InferData(buildInType,buildInType);
-		}
-		if (buildInProcessor.isBuiltInTypePrefix(rawName))  {
-			return  new InferData(buildInType,buildInType);
-		}
-		
-		//qualified name will first try global name directly
-		if (rawName.contains(".")) {
-			if (this.getTypeEntityByFullName(rawName)!=null) 
-				return this.getTypeEntityByFullName(rawName);
-		}
-		
-		//first we lookup the first symbol
-		String[] names = rawName.split("\\.");
-		if (names.length==0) return null;
-		InferData type = lookupTypes(fromEntity,names[0],searchImport);
-		if (type==null) return null;
-		if (names.length==1 ) {
-			return type;
-		}
-		//then find the subsequent symbols
-		return findReferenceSince(type,names,1);
-	}
-	
-	private InferData findReferenceSince(InferData sinceType, String[] names, int i) {
-		if (i>=names.length) {
-			return sinceType;
-		}
-		for (Entity child:sinceType.type.getChildren()) {
-			if (child.getRawName().equals(names[i])) {
-				return findReferenceSince(convertToInferData(child),names,i+1);
-			}
-		}
-		return null;
-	}
-
-	private InferData lookupTypes(Entity fromEntity, String name, boolean searcImport) {
-		if (name.equals("this")||name.equals("class")) {
-			TypeEntity entityType = (TypeEntity)(fromEntity.getAncestorOfType(TypeEntity.class));
-			return new InferData(entityType,entityType);
-		}
-		else if (name.equals("super")) {
-			TypeEntity parent = (TypeEntity)(fromEntity.getAncestorOfType(TypeEntity.class));
-			if (parent!=null) {
-				TypeEntity parentType = parent.getInheritedType();
-				return new InferData(parentType,parentType);
-			}
-		}
-		
-		InferData inferData = findTypeUnderSamePackage(fromEntity,name);
-		if (inferData!=null) return inferData;
-		if (searcImport)
-			inferData = lookupTypeInImported(fromEntity.getAncestorOfType(FileEntity.class),name);
-		return inferData;
-	}
-
-	private InferData lookupTypeInImported(Entity entity, String name) {
-		if (entity==null) return null;
-		if (!(entity instanceof FileEntity)) return null;
-		FileEntity fileEntity = (FileEntity)entity;
-		InferData type = importLookupStrategy.lookupImportedType(name, fileEntity,this);
-		if (type!=null) return type;
-		return new InferData(externalType,externalType);
-	}
-
-	private InferData tryToFindTypeEntityWithName(Entity fromEntity, String name) {
-		if (!fromEntity.getRawName().equals(name)) return null;
-		if (fromEntity instanceof MultiDeclareEntities) {
-			for (Entity declaredEntitiy:((MultiDeclareEntities)fromEntity).getEntities()) {
-				if (declaredEntitiy.getRawName().equals(name) && declaredEntitiy instanceof TypeEntity) {
-					return convertToInferData(declaredEntitiy);
-				}
-			}
-		}
-		return convertToInferData(fromEntity);
-	}
-
-	private InferData convertToInferData(Entity entity) {
-		if (entity instanceof TypeEntity) {
-			return new InferData((TypeEntity)entity,entity);
-		}
-		if (entity instanceof VarEntity) {
-			return new InferData(((VarEntity)entity).getType(),entity);
-		}
-		if (entity instanceof FunctionEntity) {
-			return new InferData(((FunctionEntity)entity).getReturnType(),entity);
-		}
-		return null;
-	}
-
-	private InferData findTypeUnderSamePackage(Entity fromEntity,String name) {
-		while(true) {
-			 InferData type = tryToFindTypeEntityWithName(fromEntity,name);
-			if (type!=null)  return type;
-			for (Entity child:fromEntity.getChildren()) {
-				type = tryToFindTypeEntityWithName(child,name);
-				if (type!=null)  return type;
-				if (child instanceof FileEntity) {
-					for (Entity classUnderFile:child.getChildren()) {
-						type = tryToFindTypeEntityWithName(classUnderFile,name);
-						if (type!=null)  return type;
-					}
-				}
-			}
-			fromEntity = fromEntity.getParent();
-			if (fromEntity==null) break;
-		}
-		return null;
-
-	}
-
-
-	public InferData getTypeEntityByFullName(String rawName) {
-		Entity entity = this.getEntity(rawName);
-		if(entity ==null) return null;
-		return convertToInferData(entity);
-	}
-	
-	
-	public void setBuiltInTypeIdentifier(BuiltInTypeIdenfier buildInProcessor) {
-		this.buildInProcessor = buildInProcessor;
-	}
-
-	
-	
-	@Override
-	public FunctionEntity resolveFunctionBindings(Entity fromEntity, String functionName) {
-		while(fromEntity!=null) {
-			if (fromEntity instanceof ContainerEntity) {
-				FunctionEntity func = findFunctionFromType( (ContainerEntity)fromEntity, functionName);
-				if (func!=null) return func;
-			}
-			fromEntity = fromEntity.getParent();
-		}
-		return null;
-	}
-
-	private FunctionEntity findFunctionFromType(ContainerEntity type, String functionName) {
-		for (FunctionEntity var:type.getFunctions()) {
-			if (var.getRawName().equals(functionName))
-				return var;
-		}
-		FunctionEntity funcType = null; 
-		if (type instanceof TypeEntity) {
-			TypeEntity typeType = (TypeEntity)type;
-			for (TypeEntity inhertedType:typeType.getInheritedTypes()) {
-				funcType= findFunctionFromType(inhertedType,functionName);
-				if (funcType==null) break;
-			}
-			if (funcType!=null) return funcType;
-			for (TypeEntity implType:typeType.getImplementedTypes()) {
-				funcType= findFunctionFromType(implType,functionName);
-				if (funcType==null) break;
-			}
-		}
-		return funcType;
-	}
-	
-	
-	public void addRelation(int theEntityId, String entityFullName, String relationType) {
-	        getEntity(theEntityId).addRelation(new Relation(relationType,entityFullName));
-	}
-
-	@Override
-	public boolean isBuiltInTypePrefix(String prefix) {
-		return buildInProcessor.isBuiltInTypePrefix(prefix);
-	}
-
-	@Override
-	
-	public List<Entity> getImportedRelationEntities(List<Import> importedNames){
-		return importLookupStrategy.getImportedRelationEntities(importedNames,this);
-	}
-	
-	@Override
-	public List<Entity> getImportedTypes(List<Import> importedNames){
-		return importLookupStrategy.getImportedTypes(importedNames,this);
-	}
-	@Override
-	public List<Entity> getImportedFiles(List<Import> importedNames){
-		return importLookupStrategy.getImportedFiles(importedNames,this);
-	}
-
-	@Override
-	public TypeEntity inferTypeType(Entity fromEntity, String rawName) {
-		InferData data = inferType(fromEntity, rawName);
-		if (data==null) return null;
-		return data.type;
-	}
-
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,7 +4,7 @@ import java.util.UUID;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.TypeInfer;
+import depends.entity.Inferer;
 
 public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock(Entity parent, Integer id) {

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -7,7 +7,7 @@ import java.util.List;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.TypeInfer;
+import depends.entity.Inferer;
 import depends.importtypes.ExactMatchImport;
 import depends.importtypes.FileImport;
 import depends.importtypes.Import;
@@ -33,6 +33,14 @@ public class FileEntity extends ContainerEntity {
 		importedNames.add(imported);
 	}
 	
+	/**
+	 * To match the imported name by suffix
+	 * for example:
+	 *    import a.b.ClassX;
+	 * the b.ClassX, ClassX , a.b.classX should be matched
+	 * @param lastName
+	 * @return
+	 */
 	public String importedSuffixMatch(String lastName) {
 		if (!lastName.startsWith("."))
 			lastName = "." + lastName;
@@ -58,11 +66,11 @@ public class FileEntity extends ContainerEntity {
 	}
 
 	@Override
-	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		this.importedRelationEntities = typeInferer.getImportedRelationEntities(importedNames);
-		this.importedTypes = typeInferer.getImportedTypes(importedNames);
-		this.importedFiles = typeInferer.getImportedFiles(importedNames);
-		super.inferLocalLevelTypes(typeInferer);
+	public void inferLocalLevelEntities(Inferer inferer) {
+		this.importedRelationEntities = inferer.getImportedRelationEntities(importedNames);
+		this.importedTypes = inferer.getImportedTypes(importedNames);
+		this.importedFiles = inferer.getImportedFiles(importedNames);
+		super.inferLocalLevelEntities(inferer);
 	}
 
 	public boolean isInProjectScope() {

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -6,7 +6,7 @@ import java.util.List;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.TypeInfer;
+import depends.entity.Inferer;
 
 public class FunctionEntity extends ContainerEntity{
 	private List<String> returnTypeIdentifiers = new ArrayList<>();
@@ -27,7 +27,8 @@ public class FunctionEntity extends ContainerEntity{
 		return returnTypes;
 	}
 	
-	public TypeEntity getReturnType() {
+	@Override
+	public TypeEntity getType() {
 		return returnType;
 	}
 
@@ -39,16 +40,16 @@ public class FunctionEntity extends ContainerEntity{
 	}
 	
 	@Override
-	public void inferLocalLevelTypes(TypeInfer typeInferer) {
+	public void inferLocalLevelEntities(Inferer inferer) {
 		for (VarEntity param:parameters) {
-			param.inferLocalLevelTypes(typeInferer);
+			param.inferLocalLevelEntities(inferer);
 		}
-		returnTypes= identiferToTypes(typeInferer,this.returnTypeIdentifiers);
+		returnTypes= identiferToTypes(inferer,this.returnTypeIdentifiers);
 		if (returnTypes.size()>0)
 			returnType = returnTypes.iterator().next();
 
-		throwTypes= identiferToTypes(typeInferer,this.throwTypesIdentifiers);
-		super.inferLocalLevelTypes(typeInferer);
+		throwTypes= identiferToTypes(inferer,this.throwTypesIdentifiers);
+		super.inferLocalLevelEntities(inferer);
 	}
 	public Collection<VarEntity> getParameters() {
 		return parameters;
@@ -57,13 +58,13 @@ public class FunctionEntity extends ContainerEntity{
 		return throwTypes;
 	}
 	@Override
-	public VarEntity resolveVarBindings(String varName) {
+	public VarEntity lookupVarsInVisibleScope(String varName) {
 		for (VarEntity param:parameters) {
 			if (varName.equals(param.getRawName())) {
 				return param;
 			}
 		}
-		return super.resolveVarBindings(varName);
+		return super.lookupVarsInVisibleScope(varName);
 	}
 	public void addParameter(VarEntity var) {
 		this.parameters.add(var);

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -5,7 +5,7 @@ import java.util.Collection;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.TypeInfer;
+import depends.entity.Inferer;
 
 public class TypeEntity extends ContainerEntity{
 	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
@@ -20,12 +20,12 @@ public class TypeEntity extends ContainerEntity{
 		implementedIdentifiers = new ArrayList<>();
 	}
 	@Override
-	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		inheritedTypes= identiferToTypes(typeInferer,this.inhertedTypeIdentifiers);
-		implementedTypes= identiferToTypes(typeInferer,this.implementedIdentifiers);
+	public void inferLocalLevelEntities(Inferer inferer) {
+		inheritedTypes= identiferToTypes(inferer,this.inhertedTypeIdentifiers);
+		implementedTypes= identiferToTypes(inferer,this.implementedIdentifiers);
 		if (inheritedTypes.size()>0)
 			inheritedType = inheritedTypes.iterator().next();
-		super.inferLocalLevelTypes(typeInferer);
+		super.inferLocalLevelEntities(inferer);
 	}
 	public void addImplements(String typeName) {
 		if (typeName.equals(this.getRawName())) return;
@@ -48,4 +48,27 @@ public class TypeEntity extends ContainerEntity{
  	public TypeEntity getInheritedType() {
 		return inheritedType;
 	}
+ 	
+ 	@Override
+ 	protected FunctionEntity lookupFunctionLocally(String functionName) {
+		FunctionEntity funcType = super.lookupFunctionLocally(functionName);
+		if (funcType!=null) return funcType;
+		for (TypeEntity inhertedType : getInheritedTypes()) {
+			funcType = inhertedType.lookupFunctionLocally(functionName);
+			if (funcType == null)
+				break;
+		}
+		if (funcType != null)
+			return funcType;
+		for (TypeEntity implType : getImplementedTypes()) {
+			funcType = implType.lookupFunctionLocally( functionName);
+			if (funcType == null)
+				break;
+		}
+		return funcType;
+ 	}
+ 	@Override
+ 	public TypeEntity getType() {
+		return this;
+	}
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -2,8 +2,7 @@ package depends.entity.types;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.TypeInfer;
-import depends.entity.TypeInfer.InferData;
+import depends.entity.Inferer;
 
 public class VarEntity extends Entity {
 	private String rawType;
@@ -17,6 +16,7 @@ public class VarEntity extends Entity {
 		return rawType;
 	}
 
+	@Override
 	public TypeEntity getType() {
 		return type;
 	}
@@ -26,16 +26,14 @@ public class VarEntity extends Entity {
 	}
 
 	@Override
-	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		InferData r = typeInferer.inferType(this, rawType);
-		if (r==null) return;
-		type = r.type;
+	public void inferLocalLevelEntities(Inferer inferer) {
+		Entity entity = inferer.resolveName(this, rawType, true);
+		if (entity==null) return;
+		type = entity.getType();
 		if (type==null) {
 			if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
-				type = TypeInfer.genericParameterType;
+				type = Inferer.genericParameterType;
 			}
 		}
 	}
-
-	
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -0,0 +1,47 @@
+package depends.extractor.cpp;
+
+import depends.extractor.BuiltInType;
+
+public class CppBuiltInType extends BuiltInType {
+
+	public CppBuiltInType() {
+		super.createBuiltInTypes();
+	}
+
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[] { "alignas", "alignof", "asm", "auto", "bool", "break", "case", "catch", "char",
+				"char16_t", "char32_t", "class", "const", "constexpr", "const_cast", "continue", "decltype",
+				"default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
+				"false", "final", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
+				"namespace", "new", "noexcept", "nullptr", "operator", "override", "private", "protected", "public",
+				"register", "reinterpret_cast", "return", "short", "signed", "sizeof", "static", "static_assert",
+				"static_cast", "struct", "switch", "template", "this", "thread_local", "throw", "true", "try",
+				"typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "volatile",
+				"wchar_t", "while", "<Built-in>",
+				"__cplusplus","_cpp_aggregate_bases","__cpp_aggregate_nsdmi","__cpp_alias_templates","__cpp_aligned_new",
+				"__cpp_attributes","__cpp_binary_literals","__cpp_capture_star_this","__cpp_constexpr","__cpp_decltype",
+				"__cpp_decltype_auto","__cpp_deduction_guides","__cpp_delegating_constructors",
+				"__cpp_enumerator_attributes","__cpp_explicit_bool","__cpp_fold_expressions","__cpp_generic_lambdas",
+				"__cpp_guaranteed_copy_elision","__cpp_hex_float","__cpp_if_constexpr","__cpp_inheriting_constructors",
+				"__cpp_init_captures","__cpp_initializer_lists","__cpp_inline_variables","__cpp_lambdas",
+				"__cpp_namespace_attributes","__cpp_noexcept_function_type","__cpp_nontype_template_args",
+				"__cpp_nontype_template_parameter_auto","__cpp_nontype_template_parameter_class","__cpp_nsdmi"
+						+ "","__cpp_range_based_for","__cpp_raw_strings","__cpp_ref_qualifiers","__cpp_return_type_deduction"
+						,"__cpp_rvalue_references","__cpp_sized_deallocation","__cpp_static_assert","__cpp_structured_bindings",
+						"__cpp_template_template_args","__cpp_threadsafe_static_init","__cpp_unicode_characters","__cpp_unicode_literals",
+						"__cpp_user_defined_literals","__cpp_variable_templates","__cpp_variadic_templates","__cpp_variadic_using",
+						"__DATE__","__FILE__","__LINE__","__STDC__","__STDC_ANALYZABLE__","__STDC_HOSTED__","__STDC_IEC_559__",
+						"__STDC_IEC_559_COMPLEX__","__STDC_ISO_10646__","__STDC_LIB_EXT1__","__STDC_MB_MIGHT_NEQ_WC__",
+						"__STDC_NO_ATOMICS__","__STDC_NO_COMPLEX__","__STDC_NO_THREADS__","__STDC_NO_VLA__",
+						"__STDCPP_DEFAULT_NEW_ALIGNMENT__","__STDCPP_STRICT_POINTER_SAFETY__","__STDCPP_THREADS__",
+						"__STDC_UTF_16__","__STDC_UTF_32__","__STDC_VERSION__","__TIME__"
+				};
+	}
+
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[] {"__"};
+	}
+
+}
\ No newline at end of file

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -5,7 +5,7 @@ import java.util.HashSet;
 import java.util.List;
 
 import depends.entity.Entity;
-import depends.entity.TypeInfer.InferData;
+import depends.entity.Inferer;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.TypeEntity;
@@ -15,10 +15,10 @@ import depends.importtypes.Import;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
 	@Override
-	public InferData lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo) {
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
 		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString!=null) {
-			 InferData r = repo.getTypeEntityByFullName(importedString);
+			Entity r = repo.getEntity(importedString);
 			if (r!=null) return r;
 		}
 		
@@ -30,12 +30,12 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (importedItem instanceof FileEntity) {
 				FileEntity importedFile = (FileEntity) repo.getEntity(file);
 				if (importedFile==null) continue;
-				 InferData entity = repo.inferTypeWithoutImportSearch(importedFile,name);
+				 Entity entity = inferer.resolveName(importedFile,name, false);
 				if (entity!=null) return entity;
 				 List<Entity> namespaces = fileEntity.getImportedTypes();
 				for (Entity ns:namespaces) {
 					String nameWithPrefix = ns.getQualifiedName() + "." + name;
-					entity = repo.inferTypeWithoutImportSearch(importedFile,nameWithPrefix);
+					entity = inferer.resolveName(importedFile,nameWithPrefix, false);
 					if (entity!=null) return entity;				
 				}
 			}

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -0,0 +1,64 @@
+package depends.extractor.java;
+
+import depends.extractor.BuiltInType;
+
+public class JavaBuiltInType extends BuiltInType{
+	
+	public JavaBuiltInType() {
+        super.createBuiltInTypes();
+	}
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[]{
+				"void","int","double","char","byte","boolean","long","short","float",
+				"BigDecimal","Integer","Double","Char","Byte","Boolean","Long","Short","Float",
+				"String","Object","Class","Exception","StringBuilder",
+				"Appendable","AutoCloseable","Cloneable","Comparable","Iterable","Readable",
+				"Runnable","Thread.UncaughtExceptionHandler","Boolean","Byte","Character","Character.Subset",
+				"Character.UnicodeBlock","ClassLoader","ClassValue","Compiler","Double","Enum",
+				"InheritableThreadLocal","Math","Number","Package","Process",
+				"ProcessBuilder","ProcessBuilder.Redirect","Runtime","RuntimePermission",
+				"SecurityManager","StackTraceElement","StrictMath","StringBuffer",
+				"System","Thread","ThreadGroup","ThreadLocal","Throwable","Void","ProcessBuilder.Redirect.Type",
+				"Thread.State","ArithmeticException","ArrayIndexOutOfBoundsException",
+				"ArrayStoreException","ClassCastException","ClassNotFoundException","CloneNotSupportedException",
+				"EnumConstantNotPresentException","Exception","IllegalAccessException","IllegalArgumentException",
+				"IllegalMonitorStateException","IllegalStateException","IllegalThreadStateException",
+				"IndexOutOfBoundsException","InstantiationException","InterruptedException",
+				"NegativeArraySizeException","NoSuchFieldException","NoSuchMethodException","NullPointerException",
+				"NumberFormatException","ReflectiveOperationException","RuntimeException","SecurityException",
+				"StringIndexOutOfBoundsException","TypeNotPresentException","UnsupportedOperationException","AbstractMethodError",
+				"AssertionError","BootstrapMethodError","ClassCircularityError","ClassFormatError","Error","ExceptionInInitializerError",
+				"IllegalAccessError","IncompatibleClassChangeError","InstantiationError","InternalError","LinkageError","NoClassDefFoundError"
+				,"NoSuchFieldError","NoSuchMethodError","OutOfMemoryError","StackOverflowError","ThreadDeath","UnknownError",
+				"UnsatisfiedLinkError","UnsupportedClassVersionError","VerifyError","VirtualMachineError","Deprecated","Override",
+				"SafeVarargs","SuppressWarnings",
+				"Collection","Comparator","Deque","Enumeration","EventListener","Formattable","Iterator","List",
+				"ListIterator","Map","Map.Entry","NavigableMap","NavigableSet","Observer","Queue","RandomAccess",
+				"Set","SortedMap","SortedSet","AbstractCollection","AbstractList","AbstractMap","AbstractMap.SimpleEntry",
+				"AbstractMap.SimpleImmutableEntry","AbstractQueue","AbstractSequentialList","AbstractSet","ArrayDeque",
+				"ArrayList","Arrays","BitSet","Calendar","Collections","Currency","Date","Dictionary","EnumMap","EnumSet",
+				"EventListenerProxy","EventObject","FormattableFlags","Formatter","GregorianCalendar","HashMap","HashSet",
+				"Hashtable","IdentityHashMap","LinkedHashMap","LinkedHashSet","LinkedList","ListResourceBundle","Locale",
+				"Locale.Builder","Objects","Observable","PriorityQueue","Properties","PropertyPermission",
+				"PropertyResourceBundle","Random","ResourceBundle","ResourceBundle.Control","Scanner",
+				"ServiceLoader","SimpleTimeZone","Stack","StringTokenizer","Timer","TimerTask","TimeZone",
+				"TreeMap","TreeSet","UUID","Vector","WeakHashMap","Formatter.BigDecimalLayoutForm",
+				"Locale.Category","ConcurrentModificationException","DuplicateFormatFlagsException",
+				"EmptyStackException","FormatFlagsConversionMismatchException","FormatterClosedException",
+				"IllegalFormatCodePointException","IllegalFormatConversionException","IllegalFormatException",
+				"IllegalFormatFlagsException","IllegalFormatPrecisionException","IllegalFormatWidthException",
+				"IllformedLocaleException","InputMismatchException","InvalidPropertiesFormatException","MissingFormatArgumentException",
+				"MissingFormatWidthException","MissingResourceException","NoSuchElementException","TooManyListenersException",
+				"UnknownFormatConversionException","UnknownFormatFlagsException","ServiceConfigurationError",
+				"<Built-in>"
+		};
+	}
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[]{
+				"java.","javax.","com.sun."
+		};
+	}
+	
+}

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,7 +4,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.Entity;
-import depends.entity.TypeInfer.InferData;
+import depends.entity.Inferer;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
 import depends.entity.types.PackageEntity;
@@ -13,11 +13,11 @@ import depends.importtypes.Import;
 
 public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	@Override
-	public InferData lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo) {
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
 		//Java Strategy
 		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString==null) return null;	
-		return repo.getTypeEntityByFullName(importedString);
+		return repo.getEntity(importedString);
 	}
 
 

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,7 +4,9 @@ import java.util.ArrayList;
 
 import depends.entity.Entity;
 import depends.entity.Relation;
+import depends.entity.repo.EntityNotExistsException;
 import depends.entity.repo.EntityRepo;
+import depends.entity.repo.NoRequestedTypeOfAncestorExistsException;
 import depends.entity.types.FileEntity;
 import depends.util.Tuple;
 
@@ -21,11 +23,11 @@ public class FileDependencyGenerator {
         	if (entity instanceof FileEntity){
         		files.add( entity.getRawName());
         	}
-        	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity.getId());
+        	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
         	if (fileEntityFrom==-1) continue;
         	for (Relation relation:entity.getRelations()) {
-        		if (relation.getToId()>=0) {
-        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getToId());
+        		if (relation.getEntity().getId()>=0) {
+        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
         			if (fileEntityTo==-1) continue;
         			dependencyMatrix.addDependency(relation.getType(), new Tuple<Integer, Integer>(fileEntityFrom,fileEntityTo));
         		}
@@ -47,11 +49,10 @@ public class FileDependencyGenerator {
 		return r;
 	}
 
-	private int getFileEntityIdNoException(EntityRepo entityRepo, Integer entityId){
-		try {
-			return entityRepo.getAncestorOfType(entityId, FileEntity.class);
-		} catch (Exception e) {
+	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
+		if (ancestor==null)
 			return -1;
-		} 
-	}
+		return ancestor.getId();
 	}
+}

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -0,0 +1,20 @@
+package depends.entity;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.java.JavaBuiltInType;
+import depends.extractor.java.JavaFileParser;
+import depends.extractor.java.JavaImportLookupStrategy;
+
+public class JavaParserTest {
+	protected  EntityRepo entityRepo ;
+	protected Inferer inferer ;
+
+	public void init() {
+		entityRepo = new EntityRepo();
+		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(),new JavaBuiltInType());
+	}
+	
+	public JavaFileParser createParser(String src) {
+		return new JavaFileParser(src,entityRepo, inferer);
+	}
+}

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -21,10 +21,10 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
 	}
 	
@@ -36,10 +36,10 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
 	}
 	
@@ -51,10 +51,10 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
 	}
 	
@@ -68,10 +68,10 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler ,inferer);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
 	}
 	
 	

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -2,16 +2,23 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 
+import depends.entity.Inferer;
 import depends.entity.repo.EntityRepo;
+import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
 
 public abstract class CppParserTest {
-	protected EntityRepo repo = new EntityRepo();
+	protected EntityRepo repo;
+	protected Inferer inferer;
     protected PreprocessorHandler preprocessorHandler;
 
 	public void init() {
     	repo = new EntityRepo();
-    	repo.setImportLookupStrategy(new CppImportLookupStrategy());
+    	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType());
     	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
     }
+	
+	public CppFileParser createParser(String src) {
+		return new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+	}
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -7,8 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.extractor.cpp.cdt.CdtCppFileParser;
-
 public class DuplicateDeclarationTest extends CppParserTest {
 	 @Before
 	    public void setUp() {
@@ -23,10 +21,12 @@ public class DuplicateDeclarationTest extends CppParserTest {
 			    	    };
 			    
 			    for (String src:srcs) {
-				    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+				    CppFileParser parser = createParser(src);
 				    parser.parse();
 			    }
-		        repo.resolveAllBindings();
+			    inferer.resolveAllBindings();
 		        assertEquals(6,repo.getEntity("X.invoke").getRelations().size());
 		}
+
+
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -14,20 +14,6 @@ public class MacroRelationTest extends CppParserTest{
     	super.init();
     }
 	
-	@Test
-	public void macro_var_relation() throws IOException {
-	    String[] srcs = new String[] {
-	    		"./src/test/resources/cpp-code-examples/MacroRelationTest.cpp",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
-		    parser.parse();
-	    }
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("foo").getRelations().size());
-	}
-	
 	@Test
 	public void macro_var_relation_in_seperate_file() throws IOException {
 	    String[] srcs = new String[] {
@@ -36,28 +22,12 @@ public class MacroRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         assertEquals(1,repo.getEntity("foo").getRelations().size());
 	}
 	
-	@Test
-	public void macro_func_relation() throws IOException {
-	    String[] srcs = new String[] {
-	    		"./src/test/resources/cpp-code-examples/MacroRelationTest.cpp",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
-		    parser.parse();
-	    }
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("bar").getRelations().size());
-	}
-	
-	
-	
 	
 }
\ No newline at end of file

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -19,9 +19,9 @@ public class CppExpressionTest extends CppParserTest{
 	@Test
 	public void test_expressions() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/Expressions.cpp";
-	    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+	    CppFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
+        inferer.resolveAllBindings();
         assertEquals(18,repo.getEntity("foo").getRelations().size());
 	}
 

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -19,9 +19,9 @@ public class CppParameterParserTest extends CppParserTest{
 	@Test
 	public void test_parameter() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
-	    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+	    CppFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
+        inferer.resolveAllBindings();
         assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -28,10 +28,10 @@ public class ForwardDeclareTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         Entity e = repo.getEntity("App.foo");
         FileDependencyGenerator dependencyGenerator= new FileDependencyGenerator();

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -30,10 +30,10 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
@@ -46,10 +46,10 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
@@ -64,10 +64,10 @@ public class IncludeRelationTest extends CppParserTest{
 	    List<String> includePaths = new ArrayList<>();
 	    includePaths.add("./src/test/resources/cpp-code-examples/includesTest/path/");
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
@@ -80,10 +80,10 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         assertEquals("abc",((TypeAliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName());
         

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -27,10 +27,10 @@ public class UsingTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         Entity e = repo.getEntity("foo");
         assertEquals(3,e.getRelations().size());
@@ -43,10 +43,10 @@ public class UsingTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         Entity e = repo.getEntity("bar");
         assertEquals(3,e.getRelations().size());

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -27,10 +27,10 @@ public class extendsTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        repo.resolveAllBindings();
+	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
         Entity e = repo.getEntity("B");
         assertEquals(2,e.getRelations().size());

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,19 +4,24 @@ import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
 
+import org.junit.Before;
 import org.junit.Test;
 
+import depends.entity.JavaParserTest;
 import depends.entity.repo.EntityRepo;
 
-public class JavaAnnotationParserTest {
+public class JavaAnnotationParserTest extends JavaParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
 	@Test
 	public void test_annotationType() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser =createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("AnnotationTest.value").getRelations().size());
+        inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("AnnotationTest.value").getRelations().size());
 	}
 
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,20 +4,24 @@ import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.ContainerEntity;
-import depends.entity.repo.EntityRepo;
+import depends.entity.JavaParserTest;
 
-public class JavaComplexExpressionTest {
+public class JavaComplexExpressionTest extends JavaParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
 	@Test
 	public void test_complexExpression() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/ComplexExpressionTest.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        ContainerEntity entity  = (ContainerEntity)(repo.getEntity("ComplexExpressionTest.other"));
+        inferer.resolveAllBindings();
+        ContainerEntity entity  = (ContainerEntity)(entityRepo.getEntity("ComplexExpressionTest.other"));
         assertEquals(3,entity.getRelations().size());
 	}
 

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -2,27 +2,33 @@ package depends.extractor.java;
 
 import static org.junit.Assert.assertEquals;
 import java.io.IOException;
+
+import org.junit.Before;
 import org.junit.Test;
-import depends.entity.repo.EntityRepo;
 
-public class JavaEmbededClassTest {
+import depends.entity.JavaParserTest;
+
+public class JavaEmbededClassTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
 	@Test
 	public void test_EmbededTypeWithImport() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/EmbededTest.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("x.EmbededTest").getRelations().size());
+        inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("x.EmbededTest").getRelations().size());
 	}
 
 	@Test
 	public void test_EmbededTypeWithoutImport() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/EmbededTest.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("x.EmbededTest2").getRelations().size());
+        inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("x.EmbededTest2").getRelations().size());
 	}
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -2,17 +2,24 @@ package depends.extractor.java;
 
 import static org.junit.Assert.assertEquals;
 import java.io.IOException;
+
+import org.junit.Before;
 import org.junit.Test;
-import depends.entity.repo.EntityRepo;
 
-public class JavaGenericTypeTest {
+import depends.entity.JavaParserTest;
+
+public class JavaGenericTypeTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
 	@Test
 	public void test_GenericTypeShouldBeIdentified() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/GenericTypeTest.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("x.GenericTypeTest").getRelations().size());
+        inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("x.GenericTypeTest").getRelations().size());
 	}
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,18 +4,23 @@ import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
 
+import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.repo.EntityRepo;
+import depends.entity.JavaParserTest;
 
-public class JavaInternalClassTest {
+public class JavaInternalClassTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
 	@Test
 	public void test_parameter() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/InternalClass.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        assertNotNull(repo.getEntity("a.InternalClass.Internal"));
+        assertNotNull(entityRepo.getEntity("a.InternalClass.Internal"));
 	}
 
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,19 +4,25 @@ import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
 
+import org.junit.Before;
 import org.junit.Test;
 
+import depends.entity.JavaParserTest;
 import depends.entity.repo.EntityRepo;
 
-public class JavaParameterParserTest {
+public class JavaParameterParserTest extends JavaParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
 	@Test
 	public void test_parameter() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/FunctionParameters.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        inferer.resolveAllBindings();
+        assertEquals(4,entityRepo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -1,21 +1,29 @@
 package depends.extractor.java;
 
 import static org.junit.Assert.assertEquals;
+
 import java.io.IOException;
+
+import org.junit.Before;
 import org.junit.Test;
-import depends.entity.repo.EntityRepo;
 
-public class JavaTypeInferUnderSamePackageTest {
+import depends.entity.JavaParserTest;
+
+public class JavaTypeInferUnderSamePackageTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
 	@Test
 	public void test_GenericTypeShouldBeIdentified() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/TypeInferUnderSamePackageA.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
         src = "./src/test/resources/java-code-examples/TypeInferUnderSamePackageB.java";
-        parser = new JavaFileParser(src,repo);
+        parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(1,repo.getEntity("x.TypeInferUnderSamePackageA").getRelations().size());
+        inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("x.TypeInferUnderSamePackageA").getRelations().size());
 	}
 }

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,68 +4,69 @@ import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.repo.EntityRepo;
+import depends.entity.JavaParserTest;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 
-public class JavaVarResolveTest {
+public class JavaVarResolveTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
 	@Test
 	public void test_field_var_should_be_parsed() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/FieldVar.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        Entity classEntity = repo.getEntity("FieldVar");
+        inferer.resolveAllBindings();
+        Entity classEntity = entityRepo.getEntity("FieldVar");
         assertEquals(3,((TypeEntity)classEntity).getVars().size()); 
 	}
 	
 	@Test
 	public void test_local_var_should_be_parsed() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/LocalVar.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(1,((TypeEntity)repo.getEntity("LocalVar")).getVars().size());
-        assertEquals(1,((FunctionEntity)repo.getEntity("LocalVar.foo")).getVars().size());
+        inferer.resolveAllBindings();
+        assertEquals(1,((TypeEntity)entityRepo.getEntity("LocalVar")).getVars().size());
+        assertEquals(1,((FunctionEntity)entityRepo.getEntity("LocalVar.foo")).getVars().size());
 	}
 	
 	@Test
 	public void test_local_var_type_could_be_inferred() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/LocalVarInferExample.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        ContainerEntity e = (ContainerEntity) repo.getEntity("LocalVarInferExample.setExample");
+        inferer.resolveAllBindings();
+        ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
         System.out.println(e.dumpExpressions());
-        assertEquals(15,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(15,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
 	}
 	
 	@Test
 	public void test_field_access_could_be_inferred() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/ComplexExpressionExample.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        assertEquals(20,repo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        inferer.resolveAllBindings();
+        assertEquals(20,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 	@Test
 	public void test_long_static_function_should_be_inferred() throws IOException {
-		EntityRepo repo = new EntityRepo();
         String src = "./src/test/resources/java-code-examples/LongExpressionWithAbsolutePath.java";
-        JavaFileParser parser = new JavaFileParser(src,repo);
+        JavaFileParser parser = createParser(src);
         parser.parse();
-        repo.resolveAllBindings();
-        System.out.println(((ContainerEntity)(repo.getEntity("x.LongExpressionWithAbsolutePath.setExample"))).dumpExpressions());
-        assertEquals(6,repo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
+        inferer.resolveAllBindings();
+        System.out.println(((ContainerEntity)(entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample"))).dumpExpressions());
+        assertEquals(6,entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
 	}
 	
 	

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,12 +1,8 @@
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
-import depends.util.Tuple;
 
 public class Expression {
 	public Integer id;
@@ -23,7 +19,6 @@ public class Expression {
 	public boolean isCreate = false;
 	public boolean isCast = false;
 	public boolean deriveTypeFromChild = true;
-	List<Tuple<String, String>> relations = new ArrayList<>();
 
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -4,7 +4,6 @@ import java.util.UUID;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.Inferer;
 
 public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock(Entity parent, Integer id) {

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,17 +1,12 @@
 package depends.entity.types;
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
 import java.util.List;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.Inferer;
-import depends.importtypes.ExactMatchImport;
-import depends.importtypes.FileImport;
 import depends.importtypes.Import;
-import depends.importtypes.PackageWildCardImport;
 
 public class FileEntity extends ContainerEntity {
 	private List<Import> importedNames = new ArrayList<>();

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -8,7 +8,6 @@ import depends.entity.Entity;
 import depends.entity.Inferer;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FileEntity;
-import depends.entity.types.TypeEntity;
 import depends.extractor.ImportLookupStrategy;
 import depends.importtypes.FileImport;
 import depends.importtypes.Import;
@@ -38,7 +37,7 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 					entity = inferer.resolveName(importedFile,nameWithPrefix, false);
 					if (entity!=null) return entity;				
 				}
-			}
+			}	
 		}		
 		return null;
 	}

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -9,8 +9,6 @@ import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
-import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
-import org.eclipse.cdt.core.dom.parser.c.GCCScannerExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
@@ -21,10 +19,10 @@ import org.eclipse.cdt.core.parser.ParserMode;
 import org.eclipse.cdt.core.parser.ScannerInfo;
 import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
 import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
-import org.eclipse.cdt.internal.core.dom.parser.c.GNUCSourceParser;
 import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 
+@SuppressWarnings("deprecation")
 public class CDTParser {
 	List<String> sysIncludePath = new ArrayList<>();
 
@@ -56,20 +54,6 @@ public class CDTParser {
 		return new CASTTranslationUnit();
 	}
 
-	private IASTTranslationUnit getTranslationUnitofC(String file, String content) {
-		IScannerExtensionConfiguration configuration = GCCScannerExtensionConfiguration
-				.getInstance();
-
-		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()),  new ScannerInfo(macroMap,sysIncludePath.toArray(new String[] {})), ParserLanguage.C,
-				NULL_LOG, configuration, null);
-		ANSICParserExtensionConfiguration conf = new ANSICParserExtensionConfiguration();
-		
-		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCSourceParser(
-				scanner, ParserMode.COMPLETE_PARSE, NULL_LOG,conf );
-		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
-		return astTranslationUnit;
-	}
 	
 	private IASTTranslationUnit getTranslationUnitofCPP(String file, String content) {
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,6 +1,5 @@
 package depends.extractor.cpp.cdt;
 import org.eclipse.cdt.core.dom.ast.IASTNode;
-import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroExpansion;
 import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
 import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
 import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -54,7 +54,6 @@ public class AnnotationProcessor {
 		Method m = getMethod(ctx,methodName);
 		if (m==null) return;
 		try {
-			@SuppressWarnings("unchecked")
 			List<?> modifiers = (List<?>) m.invoke(ctx);
 			for (Object modifier : modifiers) {
 				Method annotationMethod = modifier.getClass().getMethod("annotation");

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -4,11 +4,9 @@ import org.antlr.v4.runtime.RuleContext;
 
 import depends.entity.Expression;
 import depends.extractor.HandlerContext;
-import depends.javaextractor.JavaParser;
 import depends.javaextractor.JavaParser.ExpressionContext;
 import depends.javaextractor.JavaParser.MethodCallContext;
 import depends.javaextractor.JavaParser.PrimaryContext;
-import depends.util.Tuple;
 
 public class ExpressionUsage {
 	HandlerContext context;

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,7 +1,6 @@
 package depends.extractor.java.context;
 
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
 
 import org.antlr.v4.runtime.tree.TerminalNode;

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -3,8 +3,6 @@ package depends.extractor.java.context;
 import java.util.ArrayList;
 import java.util.List;
 
-import depends.entity.ContainerEntity;
-import depends.entity.IdGenerator;
 import depends.javaextractor.JavaParser.ConstantDeclaratorContext;
 import depends.javaextractor.JavaParser.VariableDeclaratorContext;
 import depends.javaextractor.JavaParser.VariableDeclaratorIdContext;

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -4,11 +4,8 @@ import java.util.ArrayList;
 
 import depends.entity.Entity;
 import depends.entity.Relation;
-import depends.entity.repo.EntityNotExistsException;
 import depends.entity.repo.EntityRepo;
-import depends.entity.repo.NoRequestedTypeOfAncestorExistsException;
 import depends.entity.types.FileEntity;
-import depends.util.Tuple;
 
 public class FileDependencyGenerator {
 	/**
@@ -29,7 +26,7 @@ public class FileDependencyGenerator {
         		if (relation.getEntity().getId()>=0) {
         			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
         			if (fileEntityTo==-1) continue;
-        			dependencyMatrix.addDependency(relation.getType(), new Tuple<Integer, Integer>(fileEntityFrom,fileEntityTo));
+        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo);
         		}
         	}
         }

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,4 +1,4 @@
-package depends.extractor.cpp.cdt;
+package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
@@ -8,7 +8,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.extractor.cpp.CppFileParser;
-import depends.extractor.cpp.CppParserTest;
 
 public class CppExpressionTest extends CppParserTest{
     @Before

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,4 +1,4 @@
-package depends.extractor.cpp.cdt;
+package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
@@ -8,7 +8,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.extractor.cpp.CppFileParser;
-import depends.extractor.cpp.CppParserTest;
 
 public class CppParameterParserTest extends CppParserTest{
     @Before

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,4 +1,4 @@
-package depends.extractor.cpp.cdt;
+package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.File;
@@ -9,7 +9,6 @@ import org.junit.Test;
 
 import depends.entity.Entity;
 import depends.extractor.cpp.CppFileParser;
-import depends.extractor.cpp.CppParserTest;
 import depends.format.matrix.DependencyMatrix;
 import depends.format.matrix.FileDependencyGenerator;
 

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,4 +1,4 @@
-package depends.extractor.cpp.cdt;
+package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.File;
@@ -11,7 +11,6 @@ import org.junit.Test;
 
 import depends.entity.types.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
-import depends.extractor.cpp.CppParserTest;
 
 public class IncludeRelationTest extends CppParserTest{
     @Before

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,4 +1,4 @@
-package depends.extractor.cpp.cdt;
+package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.File;
@@ -12,7 +12,6 @@ import org.junit.Test;
 import depends.entity.Entity;
 import depends.entity.types.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
-import depends.extractor.cpp.CppParserTest;
 
 public class UsingTest extends CppParserTest{
     @Before

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,4 +1,4 @@
-package depends.extractor.cpp.cdt;
+package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.File;
@@ -12,7 +12,6 @@ import org.junit.Test;
 import depends.entity.Entity;
 import depends.entity.types.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
-import depends.extractor.cpp.CppParserTest;
 
 public class extendsTest extends CppParserTest{
     @Before

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -6,7 +6,7 @@ import java.util.List;
 import org.antlr.v4.runtime.RuleContext;
 
 import depends.extractor.HandlerContext;
-import depends.javaextractor.JavaParser.AnnotationContext;
+import depends.extractor.java.JavaParser.AnnotationContext;
 
 public class AnnotationProcessor {
 	private HandlerContext context;

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -4,9 +4,9 @@ import org.antlr.v4.runtime.RuleContext;
 
 import depends.entity.Expression;
 import depends.extractor.HandlerContext;
-import depends.javaextractor.JavaParser.ExpressionContext;
-import depends.javaextractor.JavaParser.MethodCallContext;
-import depends.javaextractor.JavaParser.PrimaryContext;
+import depends.extractor.java.JavaParser.ExpressionContext;
+import depends.extractor.java.JavaParser.MethodCallContext;
+import depends.extractor.java.JavaParser.PrimaryContext;
 
 public class ExpressionUsage {
 	HandlerContext context;

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -8,12 +8,12 @@ import org.antlr.v4.runtime.tree.TerminalNode;
 import depends.entity.IdGenerator;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.VarEntity;
-import depends.javaextractor.JavaParser.FormalParameterContext;
-import depends.javaextractor.JavaParser.FormalParameterListContext;
-import depends.javaextractor.JavaParser.FormalParametersContext;
-import depends.javaextractor.JavaParser.LastFormalParameterContext;
-import depends.javaextractor.JavaParser.TypeTypeContext;
-import depends.javaextractor.JavaParser.VariableModifierContext;
+import depends.extractor.java.JavaParser.FormalParameterContext;
+import depends.extractor.java.JavaParser.FormalParameterListContext;
+import depends.extractor.java.JavaParser.FormalParametersContext;
+import depends.extractor.java.JavaParser.LastFormalParameterContext;
+import depends.extractor.java.JavaParser.TypeTypeContext;
+import depends.extractor.java.JavaParser.VariableModifierContext;
 
 public class FormalParameterListContextHelper {
 

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -3,8 +3,8 @@ package depends.extractor.java.context;
 import java.util.ArrayList;
 import java.util.List;
 
-import depends.javaextractor.JavaParser.TypeParameterContext;
-import depends.javaextractor.JavaParser.TypeParametersContext;
+import depends.extractor.java.JavaParser.TypeParameterContext;
+import depends.extractor.java.JavaParser.TypeParametersContext;
 
 public class TypeParameterContextHelper {
 

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -3,10 +3,10 @@ package depends.extractor.java.context;
 import java.util.ArrayList;
 import java.util.List;
 
-import depends.javaextractor.JavaParser.ConstantDeclaratorContext;
-import depends.javaextractor.JavaParser.VariableDeclaratorContext;
-import depends.javaextractor.JavaParser.VariableDeclaratorIdContext;
-import depends.javaextractor.JavaParser.VariableDeclaratorsContext;
+import depends.extractor.java.JavaParser.ConstantDeclaratorContext;
+import depends.extractor.java.JavaParser.VariableDeclaratorContext;
+import depends.extractor.java.JavaParser.VariableDeclaratorIdContext;
+import depends.extractor.java.JavaParser.VariableDeclaratorsContext;
 
 public class VariableDeclaratorsContextHelper {
 

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -21,7 +21,7 @@ public class CppExpressionTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(18,repo.getEntity("foo").getRelations().size());
+        assertEquals(19,repo.getEntity("foo").getRelations().size());
 	}
 
 }

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -26,7 +26,7 @@ public class MacroRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,repo.getEntity("foo").getRelations().size());
+        assertEquals(3,repo.getEntity("foo").getRelations().size());
 	}
 	
 	

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -7,7 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.JavaParserTest;
 import depends.entity.repo.EntityRepo;
 
 public class JavaAnnotationParserTest extends JavaParserTest {

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -8,7 +8,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.ContainerEntity;
-import depends.entity.JavaParserTest;
 
 public class JavaComplexExpressionTest extends JavaParserTest {
 	@Before

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -6,8 +6,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.JavaParserTest;
-
 public class JavaEmbededClassTest extends JavaParserTest{
 	@Before
 	public void setUp() {

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -6,8 +6,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.JavaParserTest;
-
 public class JavaGenericTypeTest extends JavaParserTest{
 	@Before
 	public void setUp() {

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -7,8 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.JavaParserTest;
-
 public class JavaInternalClassTest extends JavaParserTest{
 	@Before
 	public void setUp() {

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -7,7 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.JavaParserTest;
 import depends.entity.repo.EntityRepo;
 
 public class JavaParameterParserTest extends JavaParserTest {

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -1,11 +1,12 @@
-package depends.entity;
+package depends.extractor.java;
 
+import depends.entity.Inferer;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaFileParser;
 import depends.extractor.java.JavaImportLookupStrategy;
 
-public class JavaParserTest {
+public abstract class JavaParserTest {
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
 

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -7,8 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.JavaParserTest;
-
 public class JavaTypeInferUnderSamePackageTest extends JavaParserTest{
 	@Before
 	public void setUp() {

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -9,7 +9,6 @@ import org.junit.Test;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.JavaParserTest;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 
@@ -47,7 +46,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         inferer.resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
         System.out.println(e.dumpExpressions());
-        assertEquals(15,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(16,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
 	}
 	
 	@Test
@@ -56,7 +55,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(20,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        assertEquals(23,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 	@Test

00839bc62c41d134d4b8940df6cfdf9735b39d24
@@ -100,7 +100,6 @@ public class ExpressionUsage {
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly
 			expression.rawType = ASTStringUtil.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
-			System.out.println(expression.rawType);
 			//TODO: check
 		}
 	}

00839bc62c41d134d4b8940df6cfdf9735b39d24
@@ -45,7 +45,6 @@ public class JavaVarResolveTest extends JavaParserTest{
         parser.parse();
         inferer.resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
-        System.out.println(e.dumpExpressions());
         assertEquals(16,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
 	}
 	
@@ -64,7 +63,6 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        System.out.println(((ContainerEntity)(entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample"))).dumpExpressions());
         assertEquals(6,entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
 	}
 	

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,10 +1,7 @@
-package depends.entity.types;
+package depends.entity;
 
 import java.util.UUID;
 
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-
 public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock(Entity parent, Integer id) {
     	super(UUID.randomUUID().toString(),  parent, id);

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -5,9 +5,7 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.TypeEntity;
-import depends.entity.types.VarEntity;
+import depends.relations.Inferer;
 
 /**
  * ContainerEntity for example file, class, method, etc.

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,4 +1,4 @@
-package depends.entity.types;
+package depends.entity;
 
 public class EmptyTypeEntity extends TypeEntity {
 

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -4,7 +4,9 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
-import depends.entity.types.TypeEntity;
+
+import depends.relations.Inferer;
+import depends.relations.Relation;
 
 /**
  * Entity is the root of all entities, including file, package, module, 

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,8 +1,6 @@
 package depends.entity;
 
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.TypeEntity;
-import depends.entity.types.VarEntity;
+import depends.relations.Inferer;
 
 public class Expression {
 	public Integer id;

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,12 +1,10 @@
-package depends.entity.types;
+package depends.entity;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Inferer;
 import depends.importtypes.Import;
+import depends.relations.Inferer;
 
 public class FileEntity extends ContainerEntity {
 	private List<Import> importedNames = new ArrayList<>();

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,12 +1,10 @@
-package depends.entity.types;
+package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Inferer;
+import depends.relations.Inferer;
 
 public class FunctionEntity extends ContainerEntity{
 	private List<String> returnTypeIdentifiers = new ArrayList<>();

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -4,7 +4,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import depends.entity.types.TypeEntity;
+import depends.relations.Inferer;
 
 /**
  * MultiDeclareEntity is a special container, which is used as a wrapper

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,11 +1,9 @@
-package depends.entity.types;
+package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
 
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Inferer;
+import depends.relations.Inferer;
 
 public class TypeEntity extends ContainerEntity{
 	Collection<TypeEntity> inheritedTypes = new ArrayList<>();

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,8 +1,6 @@
-package depends.entity.types;
+package depends.entity;
 
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Inferer;
+import depends.relations.Inferer;
 
 public class VarEntity extends Entity {
 	private String rawType;

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -4,7 +4,6 @@ import java.util.Collection;
 import java.util.HashMap;
 
 import depends.entity.Entity;
-import depends.entity.IdGenerator;
 import depends.entity.MultiDeclareEntities;
 
 public class EntityRepo extends IdGenerator{

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -5,13 +5,13 @@ import java.util.Stack;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.IdGenerator;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeAliasEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
-import depends.entity.types.FileEntity;
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.TypeAliasEntity;
-import depends.entity.types.TypeEntity;
-import depends.entity.types.VarEntity;
+import depends.entity.repo.IdGenerator;
 import depends.importtypes.Import;
 
 public abstract class HandlerContext {

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,6 +1,6 @@
 package depends.extractor.cpp;
 
-import depends.extractor.BuiltInType;
+import depends.entity.repo.BuiltInType;
 
 public class CppBuiltInType extends BuiltInType {
 

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -5,12 +5,12 @@ import java.util.HashSet;
 import java.util.List;
 
 import depends.entity.Entity;
-import depends.entity.Inferer;
+import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
-import depends.entity.types.FileEntity;
-import depends.extractor.ImportLookupStrategy;
 import depends.importtypes.FileImport;
 import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
 	@Override

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,6 +1,6 @@
 package depends.extractor.java;
 
-import depends.extractor.BuiltInType;
+import depends.entity.repo.BuiltInType;
 
 public class JavaBuiltInType extends BuiltInType{
 	

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -4,12 +4,12 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.Entity;
-import depends.entity.Inferer;
+import depends.entity.FileEntity;
+import depends.entity.PackageEntity;
 import depends.entity.repo.EntityRepo;
-import depends.entity.types.FileEntity;
-import depends.entity.types.PackageEntity;
-import depends.extractor.ImportLookupStrategy;
 import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
 
 public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	@Override

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -5,9 +5,9 @@ import java.util.List;
 
 import org.antlr.v4.runtime.tree.TerminalNode;
 
-import depends.entity.IdGenerator;
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.VarEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.VarEntity;
+import depends.entity.repo.IdGenerator;
 import depends.extractor.java.JavaParser.FormalParameterContext;
 import depends.extractor.java.JavaParser.FormalParameterListContext;
 import depends.extractor.java.JavaParser.FormalParametersContext;

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,11 +1,11 @@
-package depends.format.matrix;
+package depends.matrix;
 
 import java.util.ArrayList;
 
 import depends.entity.Entity;
-import depends.entity.Relation;
+import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
-import depends.entity.types.FileEntity;
+import depends.relations.Relation;
 
 public class FileDependencyGenerator {
 	/**

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,4 +1,6 @@
-package depends.entity;
+package depends.relations;
+
+import depends.entity.Entity;
 
 /**
  * Dependency relation object

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,14 +1,17 @@
-package depends.entity;
+package depends.relations;
 
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 
 import depends.deptypes.DependencyType;
-import depends.entity.types.FileEntity;
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.TypeEntity;
-import depends.entity.types.VarEntity;
+import depends.entity.ContainerEntity;
+import depends.entity.Entity;
+import depends.entity.Expression;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
 
 public class RelationCounter {
 

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -2,10 +2,10 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 
-import depends.entity.Inferer;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
+import depends.relations.Inferer;
 
 public abstract class CppParserTest {
 	protected EntityRepo repo;

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -9,8 +9,8 @@ import org.junit.Test;
 
 import depends.entity.Entity;
 import depends.extractor.cpp.CppFileParser;
-import depends.format.matrix.DependencyMatrix;
-import depends.format.matrix.FileDependencyGenerator;
+import depends.matrix.DependencyMatrix;
+import depends.matrix.FileDependencyGenerator;
 
 public class ForwardDeclareTest extends CppParserTest{
     @Before

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -9,7 +9,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.types.TypeAliasEntity;
+import depends.entity.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
 
 public class IncludeRelationTest extends CppParserTest{

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -10,7 +10,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.entity.types.TypeAliasEntity;
+import depends.entity.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
 
 public class UsingTest extends CppParserTest{

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -10,7 +10,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.entity.types.TypeAliasEntity;
+import depends.entity.TypeAliasEntity;
 import depends.extractor.cpp.CppFileParser;
 
 public class extendsTest extends CppParserTest{

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,10 +1,10 @@
 package depends.extractor.java;
 
-import depends.entity.Inferer;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaFileParser;
 import depends.extractor.java.JavaImportLookupStrategy;
+import depends.relations.Inferer;
 
 public abstract class JavaParserTest {
 	protected  EntityRepo entityRepo ;

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -9,8 +9,8 @@ import org.junit.Test;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.TypeEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
 
 public class JavaVarResolveTest extends JavaParserTest{
 	@Before

4f0b1df3a334f787eb61192a37f3e287b119d4d6
@@ -26,7 +26,7 @@ public class FileDependencyGenerator {
         		if (relation.getEntity().getId()>=0) {
         			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
         			if (fileEntityTo==-1) continue;
-        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo);
+        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
         		}
         	}
         }

f1049dbfb62200c376b84dbba7a85bcfe4790c84
@@ -34,18 +34,7 @@ public class FileDependencyGenerator {
 		return dependencyMatrix;
 	}
 
-	/**
-	 * Build the dependency matrix (re-mapped all dependencies with 0-based values 
-	 * to align with node indexes)
-	 * @param entityRepo which contains entities and relations
-	 * @return the generated dependency matrix
-	 */
-	public DependencyMatrix buildWithRemap(EntityRepo repo) {
-		DependencyMatrix r = build(repo);
-		r.remapIds(repo);
-		return r;
-	}
-
+	
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null)

f1049dbfb62200c376b84dbba7a85bcfe4790c84
@@ -1,6 +1,4 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
 import java.io.File;
 import java.io.IOException;
 
@@ -8,7 +6,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.extractor.cpp.CppFileParser;
 import depends.matrix.DependencyMatrix;
 import depends.matrix.FileDependencyGenerator;
 
@@ -34,7 +31,7 @@ public class ForwardDeclareTest extends CppParserTest{
         File f = new File(srcs[0]);
         Entity e = repo.getEntity("App.foo");
         FileDependencyGenerator dependencyGenerator= new FileDependencyGenerator();
-        DependencyMatrix dependencyMatrix = dependencyGenerator.buildWithRemap(repo);
+        dependencyGenerator.build(repo);
 	}
 	
 }

5680591519e0ecdee063a350b54094fd4bc1be2e
@@ -0,0 +1,62 @@
+package depends;
+
+import picocli.CommandLine.Command;
+import picocli.CommandLine.Option;
+import picocli.CommandLine.Parameters;
+
+@Command(name = "Multi-Lanaguage Dependency Analyzer")
+public class DependsCommand {
+	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
+    private String lang;
+	@Parameters(index = "1", description = "The directory to be analyzed")
+    private String src;
+	@Parameters(index = "2",  description = "The output file name")
+	private String output;
+    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
+    private String[] format=new String[]{"json"};
+	@Option(names = {"-d", "--dir"},  description = "The output directory")
+	private String dir;
+	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
+    private boolean dv8map = true;
+    @Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
+    private String[] includes = new String[] {};
+    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+    boolean help;
+	public String getLang() {
+		return lang;
+	}
+	public void setLang(String lang) {
+		this.lang = lang;
+	}
+	public String getSrc() {
+		return src;
+	}
+	public void setSrc(String src) {
+		this.src = src;
+	}
+	public String getOutputName() {
+		return output;
+	}
+	public void setOutput(String output) {
+		this.output = output;
+	}
+	public String[] getFormat() {
+		return format;
+	}
+	public String getOutputDir() {
+		if (dir==null) {
+			dir = System.getProperty("user.dir");
+		}
+		return dir;
+	}
+	public boolean isDv8map() {
+		return dv8map;
+	}
+	public String[] getIncludes() {
+		return includes;
+	}
+	public boolean isHelp() {
+		return help;
+	}
+
+}

5680591519e0ecdee063a350b54094fd4bc1be2e
@@ -5,23 +5,26 @@ import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collection;
 
+import depends.format.AbstractFormatDependencyDumper;
 import depends.matrix.DependencyMatrix;
 import depends.matrix.DependencyPair;
 import depends.matrix.DependencyValue;
 
-public class DetailDataBuilder {
-	private DependencyMatrix matrix;
+public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDumper{
 	ArrayList<String> files;
-
-	public DetailDataBuilder(DependencyMatrix matrix) {
-		this.matrix = matrix;
+	@Override
+	public String getFormatName() {
+		return "detail";
 	}
-
-	public boolean output(String outputDotFile) {
+	public DetailTextFormatDependencyDumper(DependencyMatrix matrix, String name, String outputDir) {
+		super(matrix,name,outputDir);
+	}
+	@Override
+	public boolean output() {
 		PrintWriter writer;
 		try {
 			files = matrix.getNodes();
-			writer = new PrintWriter(outputDotFile);
+			writer = new PrintWriter(composeFilename() +".txt");
 	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
 	        addRelations(writer,dependencyPairs); 
 			writer.close();

5680591519e0ecdee063a350b54094fd4bc1be2e
@@ -5,21 +5,23 @@ import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collection;
 
+import depends.format.AbstractFormatDependencyDumper;
 import depends.matrix.DependencyMatrix;
 import depends.matrix.DependencyPair;
-import depends.matrix.DependencyValue;
 
-public class DotDataBuilder {
-	private DependencyMatrix matrix;
-
-	public DotDataBuilder(DependencyMatrix matrix) {
-		this.matrix = matrix;
+public class DotFormatDependencyDumper extends  AbstractFormatDependencyDumper{
+	@Override
+	public String getFormatName() {
+		return "dot";
 	}
-
-	public boolean output(String outputDotFile) {
+	public DotFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+	@Override
+	public boolean output() {
 		PrintWriter writer;
 		try {
-			writer = new PrintWriter(outputDotFile);
+			writer = new PrintWriter(composeFilename()+".dot");
 			ArrayList<String> files = matrix.getNodes();
 			
 			for (int i=0;i<files.size();i++) {

5680591519e0ecdee063a350b54094fd4bc1be2e
@@ -0,0 +1,39 @@
+package depends.format.xml;
+
+import java.io.FileOutputStream;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.Marshaller;
+
+import depends.format.AbstractFormatDependencyDumper;
+import depends.format.FileAttributes;
+import depends.matrix.DependencyMatrix;
+
+public class XmlFormatDependencyDumper extends AbstractFormatDependencyDumper{
+	@Override
+	public String getFormatName() {
+		return "xml";
+	}
+    public XmlFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+
+	private void toXml(XDepObject xDepObject, String xmlFileName)  {
+        try {
+            JAXBContext jaxbContext = JAXBContext.newInstance(XDepObject.class);
+            Marshaller marshaller = jaxbContext.createMarshaller();
+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
+            marshaller.marshal(xDepObject, new FileOutputStream(xmlFileName));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+	@Override
+	public boolean output() {
+        XDataBuilder xBuilder = new XDataBuilder();
+        XDepObject xDepObject = xBuilder.build(matrix,new FileAttributes(name));
+        toXml(xDepObject,composeFilename()+".xml");
+ 		return true;
+	}
+}

d75bb68166a3d2831a4cd3c2c2d1cb077a4d3c94
@@ -4,7 +4,7 @@ import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
-@Command(name = "Multi-Lanaguage Dependency Analyzer")
+@Command(name = "depends")
 public class DependsCommand {
 	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
     private String lang;

d75bb68166a3d2831a4cd3c2c2d1cb077a4d3c94
@@ -1,5 +1,6 @@
 package depends.entity;
 
+import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -135,6 +136,7 @@ public abstract class ContainerEntity extends Entity {
 						expression.setType(func.getType(),func,inferer);
 					}
 				}else {
+					
 					VarEntity varEntity = this.lookupVarsInVisibleScope(expression.identifier);
 					if (varEntity!=null) {
 						expression.setType( varEntity.getType(),varEntity,inferer);
@@ -202,6 +204,7 @@ public abstract class ContainerEntity extends Entity {
 	 * @return
 	 */
 	public VarEntity lookupVarsInVisibleScope(String varName) {
+		
 		ContainerEntity fromEntity = this;
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {

d75bb68166a3d2831a4cd3c2c2d1cb077a4d3c94
@@ -6,12 +6,17 @@ class ANSICParserExtensionConfigurationExtension extends ANSICParserExtensionCon
 
 	@Override
 	public boolean supportDeclspecSpecifiers() {
-		return true;
+		return false;
 	}
 
 	@Override
 	public boolean supportKnRC() {
-		return true;
+		return false;
+	}
+	
+	@Override
+	public boolean supportStatementsInExpressions() {
+		return false;
 	}
 
 }

d75bb68166a3d2831a4cd3c2c2d1cb077a4d3c94
@@ -5,6 +5,7 @@ import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
 import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
 import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
+import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
 import org.eclipse.cdt.core.dom.ast.IASTExpression;
 import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
 import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
@@ -19,6 +20,13 @@ public class ExpressionUsage {
 		this.context = context;
 	}
 
+	public void foundCallExpressionOfFunctionStyle(String functionName, IASTDeclaration ctx) {
+		/* create expression and link it with parent*/
+		Expression expression = new Expression(ctx.hashCode(),null);
+		context.lastContainer().addExpression(expression);
+		expression.isCall = true;
+		expression.identifier = functionName;
+	}
 	public void foundExpression(IASTExpression ctx) {
 		IASTNode parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
@@ -170,4 +178,6 @@ public class ExpressionUsage {
 		if (context.lastContainer().expressions().containsKey(ctx.getParent().hashCode())) return ctx.getParent();
 		return findParentInStack(ctx.getParent());
 	}
+
+
 }
\ No newline at end of file

d75bb68166a3d2831a4cd3c2c2d1cb077a4d3c94
@@ -6,12 +6,17 @@ class GPPParserExtensionConfigurationExtension extends GPPParserExtensionConfigu
 
 	@Override
 	public boolean supportKnRC() {
-		return true;
+		return false;
 	}
 
 	@Override
 	public boolean supportParameterInfoBlock() {
-		return true;
+		return false;
+	}
+	
+	@Override
+	public boolean supportStatementsInExpressions() {
+		return false;
 	}
 
 }

d75bb68166a3d2831a4cd3c2c2d1cb077a4d3c94
@@ -0,0 +1,45 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.cpp.cdt.CdtCppFileParser;
+
+public class ConstructFunctionReturnValueTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void test_constructor() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/ConstructFunction.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        //assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
+	}
+	
+	@Test
+	public void test_empty_contains() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/EmptyContains.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        //assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
+	}
+		
+}
\ No newline at end of file

29fb9ac38c0b9c83ed8f93a08d59115e196d7c47
@@ -0,0 +1,38 @@
+package depends.extractor.ruby;
+
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.repo.EntityRepo;
+import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
+
+public class RubyImportLookupStrategy implements ImportLookupStrategy {
+
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+}

c959bbff1e112d5ea1fbb8fa3122ebe247020799
@@ -18,7 +18,9 @@ public class DependsCommand {
 	private String dir;
 	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
     private boolean dv8map = true;
-    @Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
+    private String granularity="file";
+	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
@@ -58,5 +60,8 @@ public class DependsCommand {
 	public boolean isHelp() {
 		return help;
 	}
+    public String getGranularity() {
+		return granularity;
+	}
 
 }

c959bbff1e112d5ea1fbb8fa3122ebe247020799
@@ -7,12 +7,13 @@ import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
 
-public class FileDependencyGenerator {
+public class FileDependencyGenerator implements DependencyGenerator{
 	/**
 	 * Build the dependency matrix (without re-mapping file id)
 	 * @param entityRepo which contains entities and relations
 	 * @return the generated dependency matrix
 	 */
+	@Override
 	public DependencyMatrix build(EntityRepo entityRepo) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix();
         ArrayList<String> files = new ArrayList<String>();

f428f1b0d12cd8121dcbe98a558d7ddddd7e59cd
@@ -0,0 +1,56 @@
+package depends.matrix;
+
+import java.util.ArrayList;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.repo.EntityRepo;
+import depends.relations.Relation;
+
+public class FunctionDependencyGenerator implements DependencyGenerator {
+	/**
+	 * Build the dependency matrix (without re-mapping file id)
+	 * 
+	 * @param entityRepo which contains entities and relations
+	 * @return the generated dependency matrix
+	 */
+	@Override
+	public DependencyMatrix build(EntityRepo entityRepo) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix();
+		ArrayList<String> elements = new ArrayList<String>();
+		for (Entity entity : entityRepo.getEntities()) {
+			if (entity instanceof FunctionEntity) {
+				elements.add(entity.getRawName());
+			}
+			int fileEntityFrom = getFunctionEntityIdNoException(entity);
+			if (fileEntityFrom == -1)
+				continue;
+			for (Relation relation : entity.getRelations()) {
+				if (relation.getEntity().getId() >= 0) {
+					int fileEntityTo = getFunctionEntityIdNoException(relation.getEntity());
+					if (fileEntityTo == -1)
+						continue;
+					dependencyMatrix.addDependency(relation.getType(), fileEntityFrom, fileEntityTo, entity,
+							relation.getEntity());
+				}
+			}
+		}
+		dependencyMatrix.setNodes(elements);
+		return dependencyMatrix;
+	}
+
+	private String getFileNameNoException(Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
+		if (ancestor == null)
+			return "";
+		return ancestor.getRawName();
+	}
+
+	private int getFunctionEntityIdNoException(Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
+		if (ancestor == null)
+			return -1;
+		return ancestor.getId();
+	}
+}

71c2604390fa83b01f05f532a4bd517954cf9291
@@ -21,7 +21,7 @@ public class CppExpressionTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(19,repo.getEntity("foo").getRelations().size());
+        assertEquals(21,repo.getEntity("foo").getRelations().size());
 	}
 
 }

71c2604390fa83b01f05f532a4bd517954cf9291
@@ -25,7 +25,7 @@ public class DuplicateDeclarationTest extends CppParserTest {
 				    parser.parse();
 			    }
 			    inferer.resolveAllBindings();
-		        assertEquals(6,repo.getEntity("X.invoke").getRelations().size());
+		        assertEquals(7,repo.getEntity("X.invoke").getRelations().size());
 		}
 
 

992902c9aae4fd38c81ec8de2339201d5713c288
@@ -1,11 +1,13 @@
 package depends.entity;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import depends.relations.Inferer;
 
 /**
@@ -13,6 +15,8 @@ import depends.relations.Inferer;
  * they could contain vars, functions, ecpressions, type parameters, etc.
  */
 public abstract class ContainerEntity extends Entity {
+	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
+
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Integer, Expression> expressions;
@@ -42,6 +46,9 @@ public abstract class ContainerEntity extends Entity {
 	}
 
 	public void addVar(VarEntity var) {
+		if (logger.isDebugEnabled()) {
+			logger.debug("var found: "+var.getRawName() +  ":" + var.getRawType());
+		}
 		this.vars.add(var);
 	}
 

33164746577c8f86213410cf8db64a6def541cbd
@@ -19,7 +19,7 @@ public abstract class ContainerEntity extends Entity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	private HashMap<Integer, Expression> expressions;
+	private HashMap<Object, Expression> expressions;
 	private Collection<String> typeParameters; // Generic type parameters like <T>, <String>, <? extends Object>
 	private Collection<String> annotations = new ArrayList<>();
 	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
@@ -64,7 +64,7 @@ public abstract class ContainerEntity extends Entity {
 		return this.functions;
 	}
 
-	public HashMap<Integer, Expression> expressions() {
+	public HashMap<Object, Expression> expressions() {
 		return expressions;
 	}
 

33164746577c8f86213410cf8db64a6def541cbd
@@ -12,29 +12,32 @@ import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
 import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
 
 import depends.entity.Expression;
+import depends.entity.repo.IdGenerator;
 import depends.extractor.HandlerContext;
 
 public class ExpressionUsage {
 	HandlerContext context;
-	public ExpressionUsage(HandlerContext context) {
+	IdGenerator idGenerator;
+	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator) {
 		this.context = context;
+		this.idGenerator = idGenerator;
 	}
 
-	public void foundCallExpressionOfFunctionStyle(String functionName, IASTDeclaration ctx) {
+	public void foundCallExpressionOfFunctionStyle(String functionName) {
 		/* create expression and link it with parent*/
-		Expression expression = new Expression(ctx.hashCode(),null);
+		Expression expression = new Expression(idGenerator.generateId(),null);
 		context.lastContainer().addExpression(expression);
 		expression.isCall = true;
 		expression.identifier = functionName;
 	}
+	
 	public void foundExpression(IASTExpression ctx) {
-		IASTNode parent = findParentInStack(ctx);
+		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
-		Expression expression = new Expression(ctx.hashCode(),parent==null?null:parent.hashCode());
+		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
 		if (parent!=null) {
-			Expression parentExpression = context.lastContainer().expressions().get(parent.hashCode());
-			if (parentExpression.firstChildId==null) parentExpression.firstChildId = expression.id;
-			expression.parent = parentExpression;
+			if (parent.firstChildId==null) parent.firstChildId = expression.id;
+			expression.parent = parent;
 		}
 		
 		context.lastContainer().addExpression(expression);
@@ -169,13 +172,13 @@ public class ExpressionUsage {
 	}
 	
 
-	private IASTNode findParentInStack(IASTNode ctx) {
+	private Expression findParentInStack(IASTNode ctx) {
 		if (ctx==null) return null;
 		if (ctx.getParent()==null) return null;
 		if (context.lastContainer()==null) {
 			return null;
 		}
-		if (context.lastContainer().expressions().containsKey(ctx.getParent().hashCode())) return ctx.getParent();
+		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
 		return findParentInStack(ctx.getParent());
 	}
 

33164746577c8f86213410cf8db64a6def541cbd
@@ -3,6 +3,7 @@ package depends.extractor.java.context;
 import org.antlr.v4.runtime.RuleContext;
 
 import depends.entity.Expression;
+import depends.entity.repo.IdGenerator;
 import depends.extractor.HandlerContext;
 import depends.extractor.java.JavaParser.ExpressionContext;
 import depends.extractor.java.JavaParser.MethodCallContext;
@@ -10,19 +11,20 @@ import depends.extractor.java.JavaParser.PrimaryContext;
 
 public class ExpressionUsage {
 	HandlerContext context;
-	public ExpressionUsage(HandlerContext context) {
+	IdGenerator idGenerator;
+	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator) {
 		this.context = context;
+		this.idGenerator = idGenerator;
 	}
 
 	public void foundExpression(ExpressionContext ctx) {
-		RuleContext parent = findParentInStack(ctx);
+		Expression parent = findParentInStack(ctx);
 
 		/* create expression and link it with parent*/
-		Expression expression = new Expression(ctx.hashCode(),parent==null?null:parent.hashCode());
+		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
 		if (parent!=null) {
-			Expression parentExpression = context.lastContainer().expressions().get(parent.hashCode());
-			if (parentExpression.firstChildId==null) parentExpression.firstChildId = expression.id;
-			expression.parent = parentExpression;
+			if (parent.firstChildId==null) parent.firstChildId = expression.id;
+			expression.parent = parent;
 		}
 		
 		context.lastContainer().addExpression(expression);
@@ -157,13 +159,13 @@ public class ExpressionUsage {
 		}
 	}
 
-	private RuleContext findParentInStack(RuleContext ctx) {
+	private Expression findParentInStack(RuleContext ctx) {
 		if (ctx==null) return null;
 		if (ctx.parent==null) return null;
 		if (context.lastContainer()==null) {
 			return null;
 		}
-		if (context.lastContainer().expressions().containsKey(ctx.parent.hashCode())) return ctx.parent;
+		if (context.lastContainer().expressions().containsKey(ctx.parent)) return context.lastContainer().expressions().get(ctx.parent);
 		return findParentInStack(ctx.parent);
 	}
 }

33164746577c8f86213410cf8db64a6def541cbd
@@ -67,4 +67,15 @@ public class JavaVarResolveTest extends JavaParserTest{
 	}
 	
 	
+	
+	@Test
+	public void test_call_should_be_referred() throws IOException {
+        String src = "./src/test/resources/java-code-examples/ExpressionCallTest.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertEquals(16,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
+	}
+	
+	
 }

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -8,6 +8,7 @@ import java.util.List;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import depends.extractor.java.JavaParser.ExpressionContext;
 import depends.relations.Inferer;
 
 /**
@@ -68,8 +69,8 @@ public abstract class ContainerEntity extends Entity {
 		return expressions;
 	}
 
-	public void addExpression(Expression expression) {
-		expressions.put(expression.id, expression);
+	public void addExpression(Object key, Expression expression) {
+		expressions.put(key, expression);
 	}
 
 	/**

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -5,7 +5,7 @@ import depends.relations.Inferer;
 public class Expression {
 	public Integer id;
 	public Integer parentId;
-	public Integer firstChildId; //by default, parent expression type determined by most left child
+	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;
 	public String text; // for debug purpose
 	public String rawType; //the raw type name
@@ -64,9 +64,9 @@ public class Expression {
 		if (this.parent==null) return;
 		Expression parent = this.parent;
 		if (parent.type != null)return;
-		
+		if (!parent.deriveTypeFromChild) return;
 		//parent's type depends on first child's type
-		if (parent.firstChildId!=this.id) return;
+		if (parent.deduceTypeBasedId!=this.id) return;
 		
 		//if child is a built-in/external type, then parent must also a built-in/external type
 		if (this.type.equals(Inferer.buildInType)) {

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -6,6 +6,7 @@ import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
 import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
 import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
+import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
 import org.eclipse.cdt.core.dom.ast.IASTExpression;
 import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
 import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
@@ -23,10 +24,10 @@ public class ExpressionUsage {
 		this.idGenerator = idGenerator;
 	}
 
-	public void foundCallExpressionOfFunctionStyle(String functionName) {
+	public void foundCallExpressionOfFunctionStyle(String functionName, IASTDeclarator declarator) {
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId(),null);
-		context.lastContainer().addExpression(expression);
+		context.lastContainer().addExpression(declarator,expression);
 		expression.isCall = true;
 		expression.identifier = functionName;
 	}
@@ -36,11 +37,11 @@ public class ExpressionUsage {
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
 		if (parent!=null) {
-			if (parent.firstChildId==null) parent.firstChildId = expression.id;
+			if (parent.deduceTypeBasedId==null) parent.deduceTypeBasedId = expression.id;
 			expression.parent = parent;
 		}
 		
-		context.lastContainer().addExpression(expression);
+		context.lastContainer().addExpression(ctx,expression);
 		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
 		
 		if (isTerminalExpression(ctx)) {

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -19,16 +19,17 @@ public class ExpressionUsage {
 
 	public void foundExpression(ExpressionContext ctx) {
 		Expression parent = findParentInStack(ctx);
-
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
-		if (parent!=null) {
-			if (parent.firstChildId==null) parent.firstChildId = expression.id;
-			expression.parent = parent;
+		context.lastContainer().addExpression(ctx,expression);
+
+		expression.text = ctx.getText(); //for debug purpose. no actual effect
+		expression.parent = parent;
+		if (expression.parent!=null) {
+			if (expression.parent.deduceTypeBasedId==null) 
+				expression.parent.deduceTypeBasedId = expression.id;
 		}
 		
-		context.lastContainer().addExpression(expression);
-		expression.text = ctx.getText(); //for debug purpose. no actual effect
 		if (ctx.primary()!=null) {
 			tryFillExpressionTypeAndIdentifier(ctx.primary(),expression);
 			return;
@@ -37,6 +38,7 @@ public class ExpressionUsage {
 		expression.isSet = isSet(ctx);
 		expression.isCall = ctx.methodCall()==null?false:true;
 		expression.isLogic = isLogic(ctx);
+		expression.isDot = isDot(ctx);
 		if (ctx.creator()!=null ||ctx.innerCreator()!=null){
 			expression.isCreate = true;
 		}		
@@ -50,38 +52,46 @@ public class ExpressionUsage {
       | explicitGenericInvocation
       )
  */
-		expression.isDot = isDot(ctx);
-		if (expression.isDot) {
-			if (ctx.IDENTIFIER()!=null)
-				expression.identifier = ctx.IDENTIFIER().getText();
-			else if (ctx.methodCall()!=null)
-				expression.identifier = getMethodCallIdentifier(ctx.methodCall());
-			else if (ctx.THIS()!=null)
-				expression.identifier = "this";
-			else if (ctx.innerCreator()!=null) //innner creator like new List(){}
-				expression.identifier =  ctx.innerCreator().IDENTIFIER().getText();
-			else if (ctx.SUPER()!=null)
-				expression.identifier = "super";
-			return;
-		}
 		//method call
 		if (ctx.methodCall()!=null) {
 			expression.identifier = getMethodCallIdentifier(ctx.methodCall());
-			expression.isCall = true;
 		}
 		//new 
-		if (ctx.NEW()!=null & ctx.creator()!=null) {
+		if (ctx.NEW()!=null && ctx.creator()!=null) {
 			expression.rawType = CreatorContextHelper.getCreatorType(ctx.creator());
 			expression.isCall = true;
+			expression.deriveTypeFromChild = false;
 		}
-
+		
 		if (ctx.typeCast()!=null) {
 			expression.isCast=true;
 			expression.rawType = ctx.typeCast().typeType().getText();
+			expression.deriveTypeFromChild = false;
 		}
-		if (ctx.creator()!=null ||ctx.methodCall()!=null) {
+		
+		if (ctx.bop!=null && ctx.bop.getText().equals("instanceof")) {
+			expression.isCast=true;
+			expression.rawType = ctx.typeType().getText();
 			expression.deriveTypeFromChild = false;
 		}
+		
+		if (ctx.creator()!=null) {
+			expression.deriveTypeFromChild = false;
+		}
+		
+		if (expression.isDot) {
+			if (ctx.IDENTIFIER()!=null)
+				expression.identifier = ctx.IDENTIFIER().getText();
+			else if (ctx.methodCall()!=null)
+				expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+			else if (ctx.THIS()!=null)
+				expression.identifier = "this";
+			else if (ctx.innerCreator()!=null) //innner creator like new List(){}
+				expression.identifier =  ctx.innerCreator().IDENTIFIER().getText();
+			else if (ctx.SUPER()!=null)
+				expression.identifier = "super";
+			return;
+		}
 	}
 
 	private String getMethodCallIdentifier(MethodCallContext methodCall) {
@@ -145,7 +155,7 @@ public class ExpressionUsage {
 		if (ctx.literal()!=null) {
 		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
 			expression.rawType = "<Built-in>";
-			expression.identifier = ctx.literal().getText();
+			expression.identifier = "<Literal>";
 		}else if (ctx.IDENTIFIER()!=null) {
 		//2. if it is a var name, dertermine the type based on context.
 			expression.identifier = ctx.IDENTIFIER().getText();

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -27,6 +27,10 @@ public class FileDependencyGenerator implements DependencyGenerator{
         		if (relation.getEntity().getId()>=0) {
         			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
         			if (fileEntityTo==-1) continue;
+        			if (relation.getEntity().getRawName().contains("GenericRequestor") && 
+        					entity.getRawName().contains("sendRpcs")) {
+        				System.out.println("helo");
+        			}
         			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
         		}
         	}

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -64,12 +64,13 @@ public class RelationCounter {
 			if (expression.isCreate) {
 				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
 			}
-			else if (expression.isSet) { //SET is merged with USE
+			if (expression.isSet) { //SET is merged with USE
 				entity.addRelation(new Relation(DependencyType.USE,referredEntity));
 			}
-			else if (expression.isCast) { 
+			if (expression.isCast) { 
 				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
-			}else {
+			}
+			if (!expression.isCall && !expression.isCreate && !expression.isCast) {
 				usedEntities.add(expression.getReferredEntity());
 			}
 		}

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -74,7 +74,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(16,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
+        assertEquals(17,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
 	

01385475c619bd05e7e24f43d0ccb0ef5ced69cc
@@ -36,13 +36,14 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
+		context.lastContainer().addExpression(ctx,expression);
+
 		if (parent!=null) {
 			if (parent.deduceTypeBasedId==null) parent.deduceTypeBasedId = expression.id;
 			expression.parent = parent;
 		}
 		
-		context.lastContainer().addExpression(ctx,expression);
-		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
 		
 		if (isTerminalExpression(ctx)) {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);
@@ -55,23 +56,15 @@ public class ExpressionUsage {
 		if (ctx instanceof ICPPASTNewExpression){
 			expression.isCreate = true;
 		}		
-/**
+		expression.isDot = isDot(ctx);
+
+		/**
  *    | expression bop='.'
       ( IDENTIFIER
       | methodCall
       )
  */
-		expression.isDot = isDot(ctx);
-		if (expression.isDot) {
-			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
-			if (op2 instanceof IASTIdExpression)
-				expression.identifier = ((IASTIdExpression)op2).getName().toString();
-			else if (op2 instanceof IASTLiteralExpression)
-				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
-			else if (op2 instanceof IASTFunctionCallExpression)
-				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
-			return;
-		}
+
 		//method call
 		if (ctx instanceof IASTFunctionCallExpression) {
 			expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)ctx);
@@ -80,15 +73,25 @@ public class ExpressionUsage {
 		if (ctx instanceof ICPPASTNewExpression) {
 			expression.rawType = ASTStringUtil.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
 			expression.isCall = true;
+			expression.deriveTypeFromChild = false;
 		}
 
 		if (ctx instanceof IASTCastExpression) {
 			expression.isCast=true;
 			expression.rawType = ASTStringUtil.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
-		}
-		if ((ctx instanceof ICPPASTNewExpression) ||(ctx instanceof IASTFunctionCallExpression)) {
 			expression.deriveTypeFromChild = false;
+
 		}
+		if (expression.isDot) {
+			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
+			if (op2 instanceof IASTIdExpression)
+				expression.identifier = ((IASTIdExpression)op2).getName().toString();
+			else if (op2 instanceof IASTLiteralExpression)
+				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
+			else if (op2 instanceof IASTFunctionCallExpression)
+				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
+			return;
+		}		
 	}
 
 	private boolean isTerminalExpression(IASTExpression ctx) {
@@ -107,7 +110,7 @@ public class ExpressionUsage {
 			expression.identifier = ((IASTIdExpression) ctx).getName().toString();
 		}else if (ctx instanceof IASTLiteralExpression) {
 		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = new String(((IASTLiteralExpression)ctx).getValue());
+			expression.identifier = "<Literal>";
 			expression.rawType =  "<Built-in>";
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly

74be84011aa607adf99655b976158488ddd825f9
@@ -27,10 +27,6 @@ public class FileDependencyGenerator implements DependencyGenerator{
         		if (relation.getEntity().getId()>=0) {
         			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
         			if (fileEntityTo==-1) continue;
-        			if (relation.getEntity().getRawName().contains("GenericRequestor") && 
-        					entity.getRawName().contains("sendRpcs")) {
-        				System.out.println("helo");
-        			}
         			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
         		}
         	}

ffd57d6b1d341f520535dc5c074c6ed7bfe8de20
@@ -145,5 +145,8 @@ public abstract class Entity {
 	public TypeEntity getType() {
 		return null;
 	}
-	
+
+	public String getDisplayName() {
+		return getRawName();
+	}
 }

ffd57d6b1d341f520535dc5c074c6ed7bfe8de20
@@ -70,5 +70,9 @@ public class FunctionEntity extends ContainerEntity{
 	public void setReturnType(TypeEntity returnType) {
 		this.returnType = returnType;
 	}
-
+	@Override
+	public String getDisplayName() {
+		FileEntity f = (FileEntity) this.getAncestorOfType(FileEntity.class);
+		return f.getRawName()+"("+getRawName()+")";
+	}
 }

ffd57d6b1d341f520535dc5c074c6ed7bfe8de20
@@ -55,6 +55,7 @@ public class ExpressionUsage {
 		//method call
 		if (ctx.methodCall()!=null) {
 			expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+			expression.isCall = true;
 		}
 		//new 
 		if (ctx.NEW()!=null && ctx.creator()!=null) {

ffd57d6b1d341f520535dc5c074c6ed7bfe8de20
@@ -19,7 +19,7 @@ public class FileDependencyGenerator implements DependencyGenerator{
         ArrayList<String> files = new ArrayList<String>();
 		for (Entity entity:entityRepo.getEntities()) {
         	if (entity instanceof FileEntity){
-        		files.add( entity.getRawName());
+        		files.add( entity.getDisplayName());
         	}
         	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
         	if (fileEntityFrom==-1) continue;

ffd57d6b1d341f520535dc5c074c6ed7bfe8de20
@@ -9,19 +9,13 @@ import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
 
 public class FunctionDependencyGenerator implements DependencyGenerator {
-	/**
-	 * Build the dependency matrix (without re-mapping file id)
-	 * 
-	 * @param entityRepo which contains entities and relations
-	 * @return the generated dependency matrix
-	 */
 	@Override
 	public DependencyMatrix build(EntityRepo entityRepo) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix();
 		ArrayList<String> elements = new ArrayList<String>();
 		for (Entity entity : entityRepo.getEntities()) {
 			if (entity instanceof FunctionEntity) {
-				elements.add(entity.getRawName());
+				elements.add(entity.getDisplayName());
 			}
 			int fileEntityFrom = getFunctionEntityIdNoException(entity);
 			if (fileEntityFrom == -1)

a7a5e763fe8b8606f488857d214fb2f17de8880a
@@ -18,8 +18,12 @@ public class DependsCommand {
 	private String dir;
 	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
     private boolean dv8map = true;
+	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
+    private boolean stripLeadingPath = false;
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
     private String granularity="file";
+	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
+    private String namePathPattern="default";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
@@ -63,5 +67,10 @@ public class DependsCommand {
     public String getGranularity() {
 		return granularity;
 	}
-
+	public String getNamePathPattern() {
+		return namePathPattern;
+	}
+	public boolean isStripLeadingPath() {
+		return stripLeadingPath;
+	}
 }

7ea8a6451225bdda69b798d122f345ac715d6dbc
@@ -15,36 +15,22 @@ import depends.relations.Inferer;
  * ContainerEntity for example file, class, method, etc.
  * they could contain vars, functions, ecpressions, type parameters, etc.
  */
-public abstract class ContainerEntity extends Entity {
+public abstract class ContainerEntity extends DecoratedEntity {
 	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Object, Expression> expressions;
-	private Collection<String> typeParameters; // Generic type parameters like <T>, <String>, <? extends Object>
-	private Collection<String> annotations = new ArrayList<>();
-	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
-	private Collection<TypeEntity> resolvedAnnotations = new ArrayList<>();
+
 
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
 		functions = new ArrayList<>();
 		expressions = new HashMap<>();
-		typeParameters = new ArrayList<>();
-	}
-	
-	public void addAnnotation(String name) {
-		this.annotations.add(name);
-	}
-	
-	public void addTypeParameter(String typeName) {
-		this.typeParameters.add(typeName);
 	}
 	
-	public void addTypeParameter(List<String> parameters) {
-		this.typeParameters.addAll(parameters);
-	}
+
 
 	public void addVar(VarEntity var) {
 		if (logger.isDebugEnabled()) {
@@ -73,35 +59,14 @@ public abstract class ContainerEntity extends Entity {
 		expressions.put(key, expression);
 	}
 
-	/**
-	 * A common utility function used to transfer the identifiers 
-	 * to types.
-	 * @param inferer - the inferer object 
-	 * @param identifiers - the identifiers will be translated
-	 * @return The translated Types
-	 */
-	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
-		ArrayList<TypeEntity> r = new ArrayList<>();
-		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = inferer.inferTypeFromName(this, typeParameter);
-			if (typeEntity==null) {
-				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
-					typeEntity = Inferer.genericParameterType;
-				}
-			}
-			if (typeEntity != null)
-				r.add(typeEntity);
-		}
-		return r;
-	}
+	
 
 	/**
 	 * For all data in the class, infer their types.
 	 * Should be override in sub-classes 
 	 */
 	public void inferLocalLevelEntities(Inferer inferer) {
-		resolvedTypeParameters = identiferToTypes(inferer, typeParameters);
-		resolvedAnnotations = identiferToTypes(inferer, annotations);
+		super.inferLocalLevelEntities(inferer);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelEntities(inferer);
 		}
@@ -157,14 +122,6 @@ public abstract class ContainerEntity extends Entity {
 
 	
 
-	public Collection<TypeEntity> getResolvedTypeParameters() {
-		return resolvedTypeParameters;
-	}
-
-
-	public Collection<TypeEntity> getResolvedAnnotations() {
-		return resolvedAnnotations;
-	}
 
 
 	public String dumpExpressions() {
@@ -177,13 +134,6 @@ public abstract class ContainerEntity extends Entity {
 	
 
 
-	public boolean isGenericTypeParameter(String rawType) {
-		if (this.typeParameters.contains(rawType)) return true;
-		if (this.getParent()==null || !(this.getParent() instanceof ContainerEntity))
-			return false;
-		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
-	}
-
 	protected FunctionEntity lookupFunctionLocally(String functionName) {
 		for (FunctionEntity func : getFunctions()) {
 			if (func.getRawName().equals(functionName))

7ea8a6451225bdda69b798d122f345ac715d6dbc
@@ -1,10 +1,15 @@
 package depends.entity;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
 import depends.relations.Inferer;
 
-public class VarEntity extends Entity {
+public class VarEntity extends DecoratedEntity {
 	private String rawType;
 	private TypeEntity type;
+
 	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
 		super(simpleName,  parent,id);
 		this.rawType = rawType;
@@ -25,6 +30,7 @@ public class VarEntity extends Entity {
 
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
+		super.inferLocalLevelEntities(inferer);
 		Entity entity = inferer.resolveName(this, rawType, true);
 		if (entity==null) return;
 		type = entity.getType();
@@ -34,4 +40,6 @@ public class VarEntity extends Entity {
 			}
 		}
 	}
+
+	
 }

7ea8a6451225bdda69b798d122f345ac715d6dbc
@@ -1,5 +1,6 @@
 package depends.extractor;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Stack;
 
@@ -147,21 +148,22 @@ public abstract class HandlerContext {
 	}
 
 
-	public void foundVarDefinition(List<String> varNames, String type) {
+	public void foundVarDefinition(List<String> varNames, String type, List<String> typeArguments) {
 		for (String varName : varNames) {
-			foundVarDefintion(varName,type);
+			foundVarDefintion(varName,type,typeArguments);
 		}
 	}
 
 
-	public void foundVarDefintion(String varName, String type) {
+	public void foundVarDefintion(String varName, String type, List<String> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
+		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);		
 	}
 
 	public void foundEnumConstDefinition(String varName) {
 		String type = lastContainer().getRawName();
-		foundVarDefintion(varName,type);
+		foundVarDefintion(varName,type,new ArrayList<>());
 	}
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();

7ea8a6451225bdda69b798d122f345ac715d6dbc
@@ -43,6 +43,9 @@ public class RelationCounter {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
+			for (TypeEntity type:var.getResolvedTypeParameters()) {
+				entity.addRelation(new Relation(DependencyType.USE,type));
+			}
 		}
 		for (TypeEntity type:entity.getResolvedAnnotations()) {
 			entity.addRelation(new Relation(DependencyType.USE,type));

7ea8a6451225bdda69b798d122f345ac715d6dbc
@@ -77,5 +77,13 @@ public class JavaVarResolveTest extends JavaParserTest{
         assertEquals(17,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
+	@Test
+	public void test_could_detect_type_argument_in_field() throws IOException {
+        String src = "./src/test/resources/java-code-examples/TypeArgument.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertEquals(17,entityRepo.getEntity("JDepObject").getRelations().size());
+	}
 	
 }

ee0e52e9660cf74e666fcb750c65ab0c637b4232
@@ -26,6 +26,8 @@ public class DependsCommand {
     private String namePathPattern="default";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
+	@Option(names = {"--auto-include"},split=",", description = "auto include all paths under the source path (please notice the potential side effect)")
+	private boolean autoInclude = false;
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public String getLang() {
@@ -73,4 +75,8 @@ public class DependsCommand {
 	public boolean isStripLeadingPath() {
 		return stripLeadingPath;
 	}
+	
+	public boolean isAutoInclude () {
+		return autoInclude;
+	}
 }

ee0e52e9660cf74e666fcb750c65ab0c637b4232
@@ -16,6 +16,7 @@ public class FileEntity extends ContainerEntity {
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
 		super(fullName, null, fileId);
 		setQualifiedName(fullName);
+		this.isInProjectScope = isInProjectScope;
 	}
 
 	public FileEntity(String fullName, int fileId) {

b6482121d64539287ee517968758b6182048d7c5
@@ -1,16 +1,15 @@
 package depends.extractor.cpp.cdt;
-import org.eclipse.cdt.core.dom.ast.IASTNode;
-import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
-import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
 import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
-import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
 import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
 import org.eclipse.cdt.core.dom.ast.IASTExpression;
 import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
 import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
 import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
+import org.eclipse.cdt.core.dom.ast.IASTNode;
+import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
+import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 
 import depends.entity.Expression;
 import depends.entity.repo.IdGenerator;

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,76 @@
+package depends;
+
+import picocli.CommandLine.Command;
+import picocli.CommandLine.Option;
+import picocli.CommandLine.Parameters;
+
+@Command(name = "depends")
+public class DependsCommand {
+	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
+    private String lang;
+	@Parameters(index = "1", description = "The directory to be analyzed")
+    private String src;
+	@Parameters(index = "2",  description = "The output file name")
+	private String output;
+    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
+    private String[] format=new String[]{"json"};
+	@Option(names = {"-d", "--dir"},  description = "The output directory")
+	private String dir;
+	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
+    private boolean dv8map = true;
+	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
+    private boolean stripLeadingPath = false;
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
+    private String granularity="file";
+	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
+    private String namePathPattern="default";
+	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
+    private String[] includes = new String[] {};
+    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+    boolean help;
+	public String getLang() {
+		return lang;
+	}
+	public void setLang(String lang) {
+		this.lang = lang;
+	}
+	public String getSrc() {
+		return src;
+	}
+	public void setSrc(String src) {
+		this.src = src;
+	}
+	public String getOutputName() {
+		return output;
+	}
+	public void setOutput(String output) {
+		this.output = output;
+	}
+	public String[] getFormat() {
+		return format;
+	}
+	public String getOutputDir() {
+		if (dir==null) {
+			dir = System.getProperty("user.dir");
+		}
+		return dir;
+	}
+	public boolean isDv8map() {
+		return dv8map;
+	}
+	public String[] getIncludes() {
+		return includes;
+	}
+	public boolean isHelp() {
+		return help;
+	}
+    public String getGranularity() {
+		return granularity;
+	}
+	public String getNamePathPattern() {
+		return namePathPattern;
+	}
+	public boolean isStripLeadingPath() {
+		return stripLeadingPath;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,39 @@
+package depends.deptypes;
+
+import java.util.ArrayList;
+
+public class DependencyType {
+	public static final String IMPORT = "Import";
+	public static final String CONTAIN = "Contain";
+	public static final String IMPLEMENT = "Implement";
+	public static final String INHERIT = "Extend";
+	public static final String CALL = "Call";
+	public static final String PARAMETER = "Parameter";
+	public static final String RETURN = "Return";
+	public static final String SET = "Set";
+	public static final String USE = "Use";
+	public static final String RECEIVE = "Receive";
+	public static final String CREATE = "Create";
+	public static final String CAST = "Cast";
+	public static final String THROW = "Throw";
+	public static final String ANNOTATION = "Annotation";
+
+	public static ArrayList<String> allDependencies() {
+		ArrayList<String> depedencyTypes = new ArrayList<String>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(CONTAIN);
+		depedencyTypes.add(IMPLEMENT);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(RECEIVE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		depedencyTypes.add(ANNOTATION);
+		return depedencyTypes;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,9 @@
+package depends.entity;
+
+import java.util.UUID;
+
+public class AnonymousBlock extends ContainerEntity{
+    public AnonymousBlock(Entity parent, Integer id) {
+    	super(UUID.randomUUID().toString(),  parent, id);
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,235 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import depends.extractor.java.JavaParser.ExpressionContext;
+import depends.relations.Inferer;
+
+/**
+ * ContainerEntity for example file, class, method, etc.
+ * they could contain vars, functions, ecpressions, type parameters, etc.
+ */
+public abstract class ContainerEntity extends Entity {
+	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
+
+	private ArrayList<VarEntity> vars;
+	private ArrayList<FunctionEntity> functions;
+	private HashMap<Object, Expression> expressions;
+	private Collection<String> typeParameters; // Generic type parameters like <T>, <String>, <? extends Object>
+	private Collection<String> annotations = new ArrayList<>();
+	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
+	private Collection<TypeEntity> resolvedAnnotations = new ArrayList<>();
+
+	public ContainerEntity(String rawName, Entity parent, Integer id) {
+		super(rawName, parent, id);
+		vars = new ArrayList<>();
+		functions = new ArrayList<>();
+		expressions = new HashMap<>();
+		typeParameters = new ArrayList<>();
+	}
+	
+	public void addAnnotation(String name) {
+		this.annotations.add(name);
+	}
+	
+	public void addTypeParameter(String typeName) {
+		this.typeParameters.add(typeName);
+	}
+	
+	public void addTypeParameter(List<String> parameters) {
+		this.typeParameters.addAll(parameters);
+	}
+
+	public void addVar(VarEntity var) {
+		if (logger.isDebugEnabled()) {
+			logger.debug("var found: "+var.getRawName() +  ":" + var.getRawType());
+		}
+		this.vars.add(var);
+	}
+
+	public ArrayList<VarEntity> getVars() {
+		return this.vars;
+	}
+
+	public void addFunction(FunctionEntity functionEntity) {
+		this.functions.add(functionEntity);
+	}
+
+	public ArrayList<FunctionEntity> getFunctions() {
+		return this.functions;
+	}
+
+	public HashMap<Object, Expression> expressions() {
+		return expressions;
+	}
+
+	public void addExpression(Object key, Expression expression) {
+		expressions.put(key, expression);
+	}
+
+	/**
+	 * A common utility function used to transfer the identifiers 
+	 * to types.
+	 * @param inferer - the inferer object 
+	 * @param identifiers - the identifiers will be translated
+	 * @return The translated Types
+	 */
+	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
+		ArrayList<TypeEntity> r = new ArrayList<>();
+		for (String typeParameter : identifiers) {
+			TypeEntity typeEntity = inferer.inferTypeFromName(this, typeParameter);
+			if (typeEntity==null) {
+				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
+					typeEntity = Inferer.genericParameterType;
+				}
+			}
+			if (typeEntity != null)
+				r.add(typeEntity);
+		}
+		return r;
+	}
+
+	/**
+	 * For all data in the class, infer their types.
+	 * Should be override in sub-classes 
+	 */
+	public void inferLocalLevelEntities(Inferer inferer) {
+		resolvedTypeParameters = identiferToTypes(inferer, typeParameters);
+		resolvedAnnotations = identiferToTypes(inferer, annotations);
+		for (VarEntity var : this.vars) {
+			var.inferLocalLevelEntities(inferer);
+		}
+		for (FunctionEntity func:this.functions) {
+			func.inferLocalLevelEntities(inferer);
+		}
+	}
+
+	/**
+	 * Resolve all expression's type
+	 * @param inferer
+	 */
+	public void resolveExpressions(Inferer inferer) {
+		for (Expression expression : expressions.values()) {
+			//1. if expression's type existed, break;
+			if (expression.getType() != null)
+				continue;
+			
+			//2. if expression's rawType existed, directly infer type by rawType
+			//   if expression's rawType does not existed, infer type based on identifiers
+			if (expression.rawType != null) {
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
+			}else if (expression.isDot){ //wait for previous
+				continue;
+			} else if (expression.rawType!=null) {
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
+				if (expression.getType() !=null) {
+					 continue;
+				}
+			}
+			if (expression.identifier!=null) { 
+				Entity entity = inferer.resolveName(this, expression.identifier, true);
+				if (entity!=null) {
+					expression.setType(entity.getType(),entity,inferer);
+					continue;
+				}
+				if (expression.isCall) {
+					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
+					if (func!=null) {
+						expression.setType(func.getType(),func,inferer);
+					}
+				}else {
+					
+					VarEntity varEntity = this.lookupVarsInVisibleScope(expression.identifier);
+					if (varEntity!=null) {
+						expression.setType( varEntity.getType(),varEntity,inferer);
+					}
+				}
+			}
+		}
+	}
+
+
+	
+
+	public Collection<TypeEntity> getResolvedTypeParameters() {
+		return resolvedTypeParameters;
+	}
+
+
+	public Collection<TypeEntity> getResolvedAnnotations() {
+		return resolvedAnnotations;
+	}
+
+
+	public String dumpExpressions() {
+		StringBuilder sb = new StringBuilder();
+		for (Expression exp:expressions.values()) {
+			sb.append(exp.toString()).append("\n");
+		}
+		return sb.toString();
+	}
+	
+
+
+	public boolean isGenericTypeParameter(String rawType) {
+		if (this.typeParameters.contains(rawType)) return true;
+		if (this.getParent()==null || !(this.getParent() instanceof ContainerEntity))
+			return false;
+		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
+	}
+
+	protected FunctionEntity lookupFunctionLocally(String functionName) {
+		for (FunctionEntity func : getFunctions()) {
+			if (func.getRawName().equals(functionName))
+				return func;
+		}
+		return null;
+	}
+	
+	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+		ContainerEntity fromEntity = this;
+		while (fromEntity != null) {
+			if (fromEntity instanceof ContainerEntity) {
+				FunctionEntity func = ((ContainerEntity) fromEntity).lookupFunctionLocally(functionName);
+				if (func != null)
+					return func;
+			}
+			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
+		}
+		return null;
+	}
+	
+	/**
+	 * To found the var. Must be invoked after all entities var binding solved
+	 * @param fromEntity
+	 * @param varName
+	 * @return
+	 */
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		
+		ContainerEntity fromEntity = this;
+		while (fromEntity != null) {
+			if (fromEntity instanceof ContainerEntity) {
+				VarEntity var = ((ContainerEntity) fromEntity).lookupVarLocally(varName);
+				if (var != null)
+					return var;
+			}
+			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
+		}
+		return null;
+	}
+
+	private VarEntity lookupVarLocally(String varName) {
+		for (VarEntity var:getVars()) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		return null;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,9 @@
+package depends.entity;
+
+public class EmptyTypeEntity extends TypeEntity {
+
+	public EmptyTypeEntity() {
+		super("", null, -1);
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,152 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import depends.relations.Inferer;
+import depends.relations.Relation;
+
+/**
+ * Entity is the root of all entities, including file, package, module, 
+ * class, method/function etc.
+ * Each entity has unique id, name,qualifiedName, parent, children
+ * We also use entity to record relations 
+ */
+public abstract class Entity {
+	int id=-1;
+	String qualifiedName = null;
+	String rawName = "";
+	Entity parent;
+	Set<Entity> children = new HashSet<>();
+    ArrayList<Relation> relations = new ArrayList<>();
+
+	
+    public Entity(String rawName, Entity parent, Integer id) {
+		this.qualifiedName = null;
+		this.rawName = rawName;
+		this.parent = parent;
+		this.id = id;
+		if (parent!=null)
+			parent.children.add(this);
+		deduceQualifiedName();
+	}
+
+    /**
+     * Rule 1: if it contains '.' , then the name is equal to raw name
+     * Rule 2: if parent not exists, the name is equal to raw name
+     * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
+     * Rule 4: otherwise, qualified name = parent_qualfied_name + "."+rawName
+     * Rule 5: make sure the qualified name do not start with '.'
+     * TODO: the Rule 1 should be further check. Maybe issue exists - (C++中的ClassName::MethodName()会不会有问题？
+     */
+	private void deduceQualifiedName() {
+		rawName = rawName.replace("::","." );
+		if (this.rawName.contains(".")) {
+			this.qualifiedName = this.rawName;
+			return; //already qualified
+		}
+		if (parent==null) {
+			this.qualifiedName = this.rawName;
+			return;
+		}
+		if (parent.getQualifiedName()==null) {
+			this.qualifiedName = this.rawName;
+			return;
+		}
+		if (parent.getQualifiedName().isEmpty()) {
+			this.qualifiedName = rawName;
+			return;
+		}
+		this.qualifiedName= parent.getQualifiedName()+"." + rawName;
+		if (rawName.startsWith(".")) {
+			rawName = rawName.substring(2);
+		}
+	}
+
+
+	public String getRawName() {
+		return rawName;
+	}
+
+	public int getId() {
+        return id;
+    }
+
+    public void addRelation(Relation relation) {
+        relations.add(relation);
+    }
+
+    public ArrayList<Relation> getRelations() {
+        return relations;
+    }
+
+    public void addChild(Entity child) {
+        children.add(child);
+    }
+
+	public Entity getParent() {
+		return parent;
+	}
+
+	public void setParent(Entity parent) {
+		this.parent = parent;
+	}
+	
+	public Collection<Entity> getChildren() {
+		return children;
+	}
+	
+	public void setQualifiedName(String qualifiedName) {
+		this.qualifiedName = qualifiedName;
+	}
+
+	public void setRawName(String rawName) {
+		this.rawName = rawName;
+	}
+	
+	public String getQualifiedName() {
+		return qualifiedName;
+	}
+
+	@Override
+	public String toString() {
+		return "Entity [id=" + id + ", qualifiedName=" + qualifiedName + ", rawName=" + rawName + "]";
+	}
+
+	/**
+	 * Get ancestor of type.  
+	 * @param classType
+	 * @return null (if not exist) or the type
+	 */
+	public Entity getAncestorOfType(@SuppressWarnings("rawtypes") Class classType) {
+		Entity fromEntity = this;
+		while(fromEntity!=null) {
+			if (fromEntity.getClass().equals(classType))
+				return fromEntity;
+			if (fromEntity.getParent()==null) return null;
+			fromEntity = fromEntity.getParent();
+		}
+		return null;
+	}
+
+	/**
+	 * Invoke inferer to resolve the entity type etc. 
+	 * */
+	public void inferEntities(Inferer inferer) {
+		inferLocalLevelEntities(inferer);
+		for (Entity child:children) {
+			child.inferEntities(inferer);
+		}
+	}
+	public abstract void inferLocalLevelEntities(Inferer inferer);
+	
+	public TypeEntity getType() {
+		return null;
+	}
+
+	public String getDisplayName() {
+		return getRawName();
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,107 @@
+package depends.entity;
+
+import depends.relations.Inferer;
+
+public class Expression {
+	public Integer id;
+	public Integer parentId;
+	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
+	public Expression parent;
+	public String text; // for debug purpose
+	public String rawType; //the raw type name
+	public String identifier; // the varName, or method name, etc.
+	public boolean isSet = false; // is a set relation from right to leftHand
+	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
+	public boolean isCall = false;
+	public boolean isLogic = false;
+	public boolean isCreate = false;
+	public boolean isCast = false;
+	public boolean deriveTypeFromChild = true;
+
+	private TypeEntity type; // the type we care - for relation calculation. 
+	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
+	private Entity referredEntity;
+	public TypeEntity getType() {
+		return type;
+	}
+
+	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
+		if (this.type!=null) return;
+		this.type = type;
+		this.referredEntity  = referredEntity;
+		if (this.referredEntity==null)
+			this.referredEntity = type;
+		deduceParentType(inferer);
+	}
+	
+	public Expression(Integer id, Integer parentId) {
+		this.id = id;
+		this.parentId = parentId;
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder s = new StringBuilder();
+		s.append("[").append(text).append("]").append("|")
+			.append("rawType:").append(rawType).append("|")
+			.append("identifier:").append(identifier).append("|")
+		    .append("prop:").append(isDot?"[dot]":"")
+		                      .append(isSet?"[set]":"")
+		                      .append(isLogic?"[bool]":"")
+		                      .append(isCall?"[call]":"").append("|")
+		    .append("parent:").append(parent==null?"none":parent.text)
+			.append("type:").append(type).append("|");
+		return s.toString();
+	}
+
+	/**
+	 * deduce type of parent based on child's type
+	 * @param expressionList
+	 * @param inferer
+	 */
+	public void deduceParentType(Inferer inferer) {
+		if (this.type==null) return;
+		if (this.parent==null) return;
+		Expression parent = this.parent;
+		if (parent.type != null)return;
+		if (!parent.deriveTypeFromChild) return;
+		//parent's type depends on first child's type
+		if (parent.deduceTypeBasedId!=this.id) return;
+		
+		//if child is a built-in/external type, then parent must also a built-in/external type
+		if (this.type.equals(Inferer.buildInType)) {
+			parent.setType(Inferer.buildInType,Inferer.buildInType,inferer);
+			return;
+		}else if (this.type.equals(Inferer.externalType)){
+			parent.setType(Inferer.externalType,Inferer.externalType,inferer);
+			return;
+		}
+		
+		/* if it is a logic expression, the return type/type is boolean. */
+		if (parent.isLogic) {
+			parent.setType(Inferer.buildInType,null,inferer);
+		}
+		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
+		else if (parent.isDot) {
+			if (parent.isCall) {
+				FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
+				if (func!=null)
+					parent.setType(func.getType(), func,inferer);
+			}else {
+				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
+				if (parent.type!=null) return;
+				VarEntity var = this.getType().lookupVarsInVisibleScope(parent.identifier);
+				if (var!=null)
+					parent.setType(var.getType(),var, inferer);
+			}
+		}
+		/* if other situation, simple make the parent and child type same */
+		else {
+			parent.setType(type, null, inferer);
+		}
+	}
+
+	public Entity getReferredEntity() {
+		return referredEntity;
+	}
+}
\ No newline at end of file

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,89 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.importtypes.Import;
+import depends.relations.Inferer;
+
+public class FileEntity extends ContainerEntity {
+	private List<Import> importedNames = new ArrayList<>();
+	private boolean isInProjectScope = false;
+	private List<Entity> importedRelationEntities = new ArrayList<>();
+	private List<Entity> importedFiles = new ArrayList<>();
+	private List<Entity> importedTypes = new ArrayList<>();
+
+	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
+		super(fullName, null, fileId);
+		setQualifiedName(fullName);
+	}
+
+	public FileEntity(String fullName, int fileId) {
+		this(fullName, fileId, true);
+	}
+
+	public void addImport(Import imported) {
+		importedNames.add(imported);
+	}
+	
+	/**
+	 * To match the imported name by suffix
+	 * for example:
+	 *    import a.b.ClassX;
+	 * the b.ClassX, ClassX , a.b.classX should be matched
+	 * @param lastName
+	 * @return
+	 */
+	public String importedSuffixMatch(String lastName) {
+		if (!lastName.startsWith("."))
+			lastName = "." + lastName;
+		for (Entity imported : this.importedTypes) {
+			String name = imported.getQualifiedName();
+			if (!name.startsWith("."))
+				name = "." + name;
+			if (imported.getQualifiedName().endsWith(lastName))
+				return imported.getQualifiedName();
+		}
+		return null;
+	}
+	
+	@Override
+	public String getQualifiedName() {
+		if (this.getParent() == null) {
+			return "";
+		}
+		if (this.getParent() instanceof PackageEntity)
+			return this.getParent().getQualifiedName();
+		else
+			return super.getQualifiedName();
+	}
+
+	@Override
+	public void inferLocalLevelEntities(Inferer inferer) {
+		this.importedRelationEntities = inferer.getImportedRelationEntities(importedNames);
+		this.importedTypes = inferer.getImportedTypes(importedNames);
+		this.importedFiles = inferer.getImportedFiles(importedNames);
+		super.inferLocalLevelEntities(inferer);
+	}
+
+	public boolean isInProjectScope() {
+		return isInProjectScope;
+	}
+
+	public void setInProjectScope(boolean isInProjectScope) {
+		this.isInProjectScope = isInProjectScope;
+	}
+
+	public List<Entity> getImportedRelationEntities() {
+		return importedRelationEntities;
+	}
+
+	public List<Entity> getImportedFiles() {
+		return importedFiles;
+	}
+
+	public List<Entity> getImportedTypes() {
+		return importedTypes;
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,78 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import depends.relations.Inferer;
+
+public class FunctionEntity extends ContainerEntity{
+	private List<String> returnTypeIdentifiers = new ArrayList<>();
+	Collection<VarEntity> parameters;
+    Collection<String> throwTypesIdentifiers = new ArrayList<>(); 
+	private Collection<TypeEntity> returnTypes = new ArrayList<>();
+	private TypeEntity returnType;
+	private Collection<TypeEntity> throwTypes = new ArrayList<>();
+    public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
+		super(simpleName, parent,id);
+		this.returnTypes = new ArrayList<>();
+		returnTypeIdentifiers = new ArrayList<>();
+		this.parameters = new ArrayList<>();
+		throwTypesIdentifiers = new ArrayList<>();
+		addReturnType(returnType);
+	}
+	public Collection<TypeEntity> getReturnTypes() {
+		return returnTypes;
+	}
+	
+	@Override
+	public TypeEntity getType() {
+		return returnType;
+	}
+
+	public void addReturnType(String returnType) {
+		this.returnTypeIdentifiers.add(returnType);
+	}
+	public void addThrowTypes(List<String> throwedType) {
+		throwTypesIdentifiers.addAll(throwedType);
+	}
+	
+	@Override
+	public void inferLocalLevelEntities(Inferer inferer) {
+		for (VarEntity param:parameters) {
+			param.inferLocalLevelEntities(inferer);
+		}
+		returnTypes= identiferToTypes(inferer,this.returnTypeIdentifiers);
+		if (returnTypes.size()>0)
+			returnType = returnTypes.iterator().next();
+
+		throwTypes= identiferToTypes(inferer,this.throwTypesIdentifiers);
+		super.inferLocalLevelEntities(inferer);
+	}
+	public Collection<VarEntity> getParameters() {
+		return parameters;
+	}
+	public Collection<TypeEntity> getThrowTypes() {
+		return throwTypes;
+	}
+	@Override
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		for (VarEntity param:parameters) {
+			if (varName.equals(param.getRawName())) {
+				return param;
+			}
+		}
+		return super.lookupVarsInVisibleScope(varName);
+	}
+	public void addParameter(VarEntity var) {
+		this.parameters.add(var);
+	}
+	public void setReturnType(TypeEntity returnType) {
+		this.returnType = returnType;
+	}
+	@Override
+	public String getDisplayName() {
+		FileEntity f = (FileEntity) this.getAncestorOfType(FileEntity.class);
+		return f.getRawName()+"("+getRawName()+")";
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,55 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import depends.relations.Inferer;
+
+/**
+ * MultiDeclareEntity is a special container, which is used as a wrapper
+ * of multi-declaration. for example, 
+ * in C++, a function could be declared in different place with the same signature.
+ */
+public class MultiDeclareEntities extends ContainerEntity {
+	List<ContainerEntity> entities = new ArrayList<>();
+	public MultiDeclareEntities(Entity entity, int id ) {
+		super(entity.getRawName(), entity.getParent(), id);
+		if (entity instanceof ContainerEntity)
+			entities.add((ContainerEntity)entity);
+	}
+
+	@Override
+	public void inferLocalLevelEntities(Inferer inferer) {
+		for (Entity entity:entities) {
+			entity.inferLocalLevelEntities(inferer);
+		}
+	}
+
+	public void add(Entity entity) {
+		if (entity instanceof ContainerEntity)
+			entities.add((ContainerEntity)entity);
+	}
+
+	public List<ContainerEntity> getEntities() {
+		return entities;
+	}
+
+	@Override
+	public Collection<Entity> getChildren() {
+		List<Entity> children = new ArrayList<>();
+		for (Entity entity:entities) {
+			children.addAll(entity.getChildren());
+		}
+		return children;
+	}
+
+	@Override
+	public TypeEntity getType() {
+		for (Entity entity:entities) {
+			if(entity.getType()!=null);
+				return entity.getType();
+		}
+		return null;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,72 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+import depends.relations.Inferer;
+
+public class TypeEntity extends ContainerEntity{
+	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
+	Collection<TypeEntity> implementedTypes = new ArrayList<>();
+	Collection<String> inhertedTypeIdentifiers;
+	Collection<String> implementedIdentifiers;
+	TypeEntity inheritedType;
+
+	public TypeEntity(String simpleName, Entity parent, Integer id) {
+		super(simpleName,parent,id);
+		inhertedTypeIdentifiers = new ArrayList<>();
+		implementedIdentifiers = new ArrayList<>();
+	}
+	@Override
+	public void inferLocalLevelEntities(Inferer inferer) {
+		inheritedTypes= identiferToTypes(inferer,this.inhertedTypeIdentifiers);
+		implementedTypes= identiferToTypes(inferer,this.implementedIdentifiers);
+		if (inheritedTypes.size()>0)
+			inheritedType = inheritedTypes.iterator().next();
+		super.inferLocalLevelEntities(inferer);
+	}
+	public void addImplements(String typeName) {
+		if (typeName.equals(this.getRawName())) return;
+		if (implementedIdentifiers.contains(typeName)) return;
+		this.implementedIdentifiers.add(typeName);
+	}
+	public void addExtends(String typeName) {
+		if (typeName.equals(this.getRawName())) return;
+		if (inhertedTypeIdentifiers.contains(typeName)) return;
+		this.inhertedTypeIdentifiers.add(typeName);
+	}
+	public Collection<TypeEntity> getInheritedTypes() {
+		return inheritedTypes;
+	}
+	
+	public Collection<TypeEntity> getImplementedTypes() {
+		return implementedTypes;
+	}
+	
+ 	public TypeEntity getInheritedType() {
+		return inheritedType;
+	}
+ 	
+ 	@Override
+ 	protected FunctionEntity lookupFunctionLocally(String functionName) {
+		FunctionEntity funcType = super.lookupFunctionLocally(functionName);
+		if (funcType!=null) return funcType;
+		for (TypeEntity inhertedType : getInheritedTypes()) {
+			funcType = inhertedType.lookupFunctionLocally(functionName);
+			if (funcType == null)
+				break;
+		}
+		if (funcType != null)
+			return funcType;
+		for (TypeEntity implType : getImplementedTypes()) {
+			funcType = implType.lookupFunctionLocally( functionName);
+			if (funcType == null)
+				break;
+		}
+		return funcType;
+ 	}
+ 	@Override
+ 	public TypeEntity getType() {
+		return this;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,37 @@
+package depends.entity;
+
+import depends.relations.Inferer;
+
+public class VarEntity extends Entity {
+	private String rawType;
+	private TypeEntity type;
+	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
+		super(simpleName,  parent,id);
+		this.rawType = rawType;
+	}
+
+	public String getRawType() {
+		return rawType;
+	}
+
+	@Override
+	public TypeEntity getType() {
+		return type;
+	}
+
+	public void setType(TypeEntity type) {
+		this.type = type;
+	}
+
+	@Override
+	public void inferLocalLevelEntities(Inferer inferer) {
+		Entity entity = inferer.resolveName(this, rawType, true);
+		if (entity==null) return;
+		type = entity.getType();
+		if (type==null) {
+			if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
+				type = Inferer.genericParameterType;
+			}
+		}
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,54 @@
+package depends.entity.repo;
+
+import java.util.Collection;
+import java.util.HashMap;
+
+import depends.entity.Entity;
+import depends.entity.MultiDeclareEntities;
+
+public class EntityRepo extends IdGenerator{
+	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
+	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
+
+	public EntityRepo() {
+	}
+	
+	public Entity getEntity(String entityName) {
+		return allEntieisByName.get(entityName);
+	}
+	
+	public Entity getEntity(Integer entityId) {
+		return allEntitiesById.get(entityId);
+	}
+	
+	public void add(Entity entity) {
+		allEntitiesById.put(entity.getId(), entity);
+		String name = entity.getRawName();
+		if (entity.getQualifiedName()!=null && !(entity.getQualifiedName().isEmpty()) ) {
+			name = entity.getQualifiedName();
+		}
+		if (allEntieisByName.containsKey(name)) {
+			Entity existedEntity = allEntieisByName.get(name);
+			if (existedEntity instanceof MultiDeclareEntities) {
+				((MultiDeclareEntities)existedEntity).add(entity);
+			}else {
+				MultiDeclareEntities eMultiDeclare = new MultiDeclareEntities(existedEntity,this.generateId());
+				eMultiDeclare.add(entity);
+				allEntieisByName.put(name, eMultiDeclare);
+			}
+		}else {
+			allEntieisByName.put(name, entity);
+		}
+		if (entity.getParent()!=null)
+			this.setParent(entity, entity.getParent());
+	}
+		
+	public Collection<Entity> getEntities() {
+		return allEntitiesById.values();
+	}
+	
+	public void setParent(Entity child, Entity parent) {
+		child.setParent(parent);
+		parent.addChild(child);
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,178 @@
+package depends.extractor;
+
+import java.util.List;
+import java.util.Stack;
+
+import depends.entity.ContainerEntity;
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeAliasEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.entity.repo.EntityRepo;
+import depends.entity.repo.IdGenerator;
+import depends.importtypes.Import;
+
+public abstract class HandlerContext {
+	protected EntityRepo entityRepo;
+	protected IdGenerator idGenerator;
+
+	protected FileEntity currentFileEntity;
+
+	
+	public HandlerContext(EntityRepo entityRepo) {
+		this.entityRepo = entityRepo;
+		this.idGenerator = entityRepo;
+		entityStack = new Stack<Entity>();
+	}
+
+	public FileEntity startFile(String fileName) {
+		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
+		pushToStack(currentFileEntity);
+		entityRepo.add(currentFileEntity);
+		return currentFileEntity;
+	}
+
+	
+
+	public Entity foundNewType(String classOrInterfaceName) {
+		TypeEntity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
+			idGenerator.generateId());
+		pushToStack(currentTypeEntity);
+	 	entityRepo.add(currentTypeEntity);
+		return currentTypeEntity;
+	}
+
+	public void foundNewTypeAlias(String aliasName, String originalName) {
+		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
+		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
+		TypeAliasEntity currentTypeEntity = new TypeAliasEntity(aliasName, this.latestValidContainer(),
+				idGenerator.generateId(),originalName );
+	 	entityRepo.add(currentTypeEntity);
+		return ;		
+	}
+	
+	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
+		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
+				idGenerator.generateId(),returnType);
+		entityRepo.add(functionEntity);
+		this.typeOrFileContainer().addFunction(functionEntity);
+		pushToStack(functionEntity);
+		functionEntity.addThrowTypes(throwedType);
+		return functionEntity;
+	}
+	
+
+
+	public void foundNewImport(Import imported) {
+		currentFileEntity.addImport(imported);
+	}
+
+	public TypeEntity currentType() {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof TypeEntity)
+				return (TypeEntity) t;
+		}
+		return null;
+	}
+	
+	public ContainerEntity typeOrFileContainer() {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof TypeEntity)
+				return (ContainerEntity) t;
+			if (t instanceof FileEntity) {
+				return (ContainerEntity)t;
+			}
+		}
+		return null;
+	}
+
+
+	public FunctionEntity currentFunction() {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof FunctionEntity)
+				return (FunctionEntity) t;
+		}
+		return null;
+	}
+
+	public FileEntity currentFile() {
+		return currentFileEntity;
+	}
+
+	public Entity latestValidContainer() {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof FunctionEntity)
+				return t;
+			if (t instanceof TypeEntity)
+				return t;
+			if (t instanceof FileEntity)
+				return t;
+		}
+		return null;
+	}
+
+	public ContainerEntity lastContainer() {
+		for (int i = entityStack.size() - 1; i >= 0; i--) {
+			Entity t = entityStack.get(i);
+			if (t instanceof ContainerEntity)
+				return (ContainerEntity) t;
+		}
+		return null;
+	}
+
+	public void foundAnnotation(String name) {
+		lastContainer().addAnnotation(name);
+	}
+
+	public void foundImplements(String typeName) {
+		currentType().addImplements(typeName);
+	}
+
+	public void foundExtends(String typeName) {
+		if (currentType()==null) {
+			System.out.println("error: type do not exist");
+		}
+		currentType().addExtends(typeName);
+	}
+
+
+	public void foundTypeParametes(String typeName) {
+		lastContainer().addTypeParameter(typeName);
+	}
+
+
+	public void foundVarDefinition(List<String> varNames, String type) {
+		for (String varName : varNames) {
+			foundVarDefintion(varName,type);
+		}
+	}
+
+
+	public void foundVarDefintion(String varName, String type) {
+		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
+		lastContainer().addVar(var);		
+	}
+
+	public void foundEnumConstDefinition(String varName) {
+		String type = lastContainer().getRawName();
+		foundVarDefintion(varName,type);
+	}
+	
+	protected Stack<Entity> entityStack = new Stack<Entity>();
+
+	private void pushToStack(Entity entity) {
+		entityStack.push(entity);
+	}
+	
+	
+	public void exitLastedEntity() {
+		entityStack.pop();
+	}
+	
+}
\ No newline at end of file

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,47 @@
+package depends.extractor.cpp;
+
+import depends.entity.repo.BuiltInType;
+
+public class CppBuiltInType extends BuiltInType {
+
+	public CppBuiltInType() {
+		super.createBuiltInTypes();
+	}
+
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[] { "alignas", "alignof", "asm", "auto", "bool", "break", "case", "catch", "char",
+				"char16_t", "char32_t", "class", "const", "constexpr", "const_cast", "continue", "decltype",
+				"default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
+				"false", "final", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
+				"namespace", "new", "noexcept", "nullptr", "operator", "override", "private", "protected", "public",
+				"register", "reinterpret_cast", "return", "short", "signed", "sizeof", "static", "static_assert",
+				"static_cast", "struct", "switch", "template", "this", "thread_local", "throw", "true", "try",
+				"typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "volatile",
+				"wchar_t", "while", "<Built-in>",
+				"__cplusplus","_cpp_aggregate_bases","__cpp_aggregate_nsdmi","__cpp_alias_templates","__cpp_aligned_new",
+				"__cpp_attributes","__cpp_binary_literals","__cpp_capture_star_this","__cpp_constexpr","__cpp_decltype",
+				"__cpp_decltype_auto","__cpp_deduction_guides","__cpp_delegating_constructors",
+				"__cpp_enumerator_attributes","__cpp_explicit_bool","__cpp_fold_expressions","__cpp_generic_lambdas",
+				"__cpp_guaranteed_copy_elision","__cpp_hex_float","__cpp_if_constexpr","__cpp_inheriting_constructors",
+				"__cpp_init_captures","__cpp_initializer_lists","__cpp_inline_variables","__cpp_lambdas",
+				"__cpp_namespace_attributes","__cpp_noexcept_function_type","__cpp_nontype_template_args",
+				"__cpp_nontype_template_parameter_auto","__cpp_nontype_template_parameter_class","__cpp_nsdmi"
+						+ "","__cpp_range_based_for","__cpp_raw_strings","__cpp_ref_qualifiers","__cpp_return_type_deduction"
+						,"__cpp_rvalue_references","__cpp_sized_deallocation","__cpp_static_assert","__cpp_structured_bindings",
+						"__cpp_template_template_args","__cpp_threadsafe_static_init","__cpp_unicode_characters","__cpp_unicode_literals",
+						"__cpp_user_defined_literals","__cpp_variable_templates","__cpp_variadic_templates","__cpp_variadic_using",
+						"__DATE__","__FILE__","__LINE__","__STDC__","__STDC_ANALYZABLE__","__STDC_HOSTED__","__STDC_IEC_559__",
+						"__STDC_IEC_559_COMPLEX__","__STDC_ISO_10646__","__STDC_LIB_EXT1__","__STDC_MB_MIGHT_NEQ_WC__",
+						"__STDC_NO_ATOMICS__","__STDC_NO_COMPLEX__","__STDC_NO_THREADS__","__STDC_NO_VLA__",
+						"__STDCPP_DEFAULT_NEW_ALIGNMENT__","__STDCPP_STRICT_POINTER_SAFETY__","__STDCPP_THREADS__",
+						"__STDC_UTF_16__","__STDC_UTF_32__","__STDC_VERSION__","__TIME__"
+				};
+	}
+
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[] {"__"};
+	}
+
+}
\ No newline at end of file

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,87 @@
+package depends.extractor.cpp;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.repo.EntityRepo;
+import depends.importtypes.FileImport;
+import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
+
+public class CppImportLookupStrategy implements ImportLookupStrategy {
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+		String importedString = fileEntity.importedSuffixMatch(name);
+		if (importedString!=null) {
+			Entity r = repo.getEntity(importedString);
+			if (r!=null) return r;
+		}
+		
+		HashSet<String> fileSet = new HashSet<>();
+		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
+		
+		for (String file:fileSet) {
+			Entity importedItem = repo.getEntity(file);
+			if (importedItem instanceof FileEntity) {
+				FileEntity importedFile = (FileEntity) repo.getEntity(file);
+				if (importedFile==null) continue;
+				 Entity entity = inferer.resolveName(importedFile,name, false);
+				if (entity!=null) return entity;
+				 List<Entity> namespaces = fileEntity.getImportedTypes();
+				for (Entity ns:namespaces) {
+					String nameWithPrefix = ns.getQualifiedName() + "." + name;
+					entity = inferer.resolveName(importedFile,nameWithPrefix, false);
+					if (entity!=null) return entity;				
+				}
+			}	
+		}		
+		return null;
+	}
+
+	private void foundIncludedFiles(HashSet<String> fileSet, List<Entity> importedFiles, EntityRepo repo) {
+		for (Entity file:importedFiles) {
+			if (file==null ) continue;
+			if (!(file instanceof FileEntity)) continue;
+			if (fileSet.contains(file.getRawName())) continue;
+			fileSet.add(file.getRawName());
+			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles(),repo);
+		}
+	}
+	
+	
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			if (importedItem instanceof FileImport) {
+				Entity imported = repo.getEntity(importedItem.getContent());
+				if (imported==null) continue;
+				result.add(imported);
+			}
+		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			if (!(importedItem instanceof FileImport)) {
+				Entity imported = repo.getEntity(importedItem.getContent());
+				if (imported==null) continue;
+				result.add(imported);
+			}
+		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+		return getImportedRelationEntities(importedList,repo);
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,22 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
+
+class ANSICParserExtensionConfigurationExtension extends ANSICParserExtensionConfiguration {
+
+	@Override
+	public boolean supportDeclspecSpecifiers() {
+		return false;
+	}
+
+	@Override
+	public boolean supportKnRC() {
+		return false;
+	}
+	
+	@Override
+	public boolean supportStatementsInExpressions() {
+		return false;
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,71 @@
+package depends.extractor.cpp.cdt;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
+import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
+import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
+import org.eclipse.cdt.core.parser.CodeReader;
+import org.eclipse.cdt.core.parser.FileContent;
+import org.eclipse.cdt.core.parser.IScanner;
+import org.eclipse.cdt.core.parser.NullLogService;
+import org.eclipse.cdt.core.parser.ParserLanguage;
+import org.eclipse.cdt.core.parser.ParserMode;
+import org.eclipse.cdt.core.parser.ScannerInfo;
+import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
+import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
+import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
+import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
+
+@SuppressWarnings("deprecation")
+public class CDTParser {
+	List<String> sysIncludePath = new ArrayList<>();
+
+	public CDTParser() {
+	}
+	
+	public CDTParser(List<String> includesPath) {
+		for (String f:includesPath) {
+			File file = new File(f);
+			if (file.exists()) {
+				try {
+					sysIncludePath.add(file.getCanonicalPath());
+				} catch (IOException e) {
+				}
+			}else {
+				//System.err.println("include path " + f + " does not exist!");
+			}
+		}
+	}
+	NullLogService NULL_LOG = new NullLogService();
+	Map<String, String> macroMap = new HashMap<>();
+	public IASTTranslationUnit parse(String file   ) {
+		CodeReader cr;
+		try {
+			cr = new CodeReader(file);
+			return getTranslationUnitofCPP(file,new String(cr.buffer));
+		} catch (IOException e) {
+		}
+		return new CASTTranslationUnit();
+	}
+
+	
+	private IASTTranslationUnit getTranslationUnitofCPP(String file, String content) {
+		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
+				.getInstance();
+		IScanner scanner = new CPreprocessor(FileContent.create(file,
+				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath.toArray(new String[] {})), ParserLanguage.CPP,
+				new NullLogService(), configuration, null);
+		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
+				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),
+				new GPPParserExtensionConfigurationExtension(), null);
+		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
+		return astTranslationUnit;
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,61 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.ast.IASTComment;
+import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
+import org.eclipse.cdt.internal.core.dom.parser.ASTTranslationUnit;
+
+public class CommentManager {
+
+	private IASTTranslationUnit translationUnit;
+	IASTComment[] comments;
+	boolean[] joinWithNext;
+	public CommentManager(IASTTranslationUnit translationUnit) {
+		this.translationUnit = translationUnit;
+		comments = ((ASTTranslationUnit) translationUnit).getComments();
+		joinWithNext = new boolean[comments.length];
+		
+		
+		for (int i=1;i<comments.length;i++) {
+			IASTComment previous = comments[i-1];
+			int previousEnd = (previous.getFileLocation().getNodeOffset()+
+					previous.getFileLocation().getNodeLength());
+			IASTComment current = comments[i];
+			if (current.getFileLocation().getNodeOffset()-previousEnd<5)
+				joinWithNext[i-1] = true;
+			else
+				joinWithNext[i-1] = false;
+		}
+		joinWithNext[comments.length-1] = false;
+	}
+
+	public String getLeadingCommentText(int startOffset) {
+		int adjacent = findCommentIndex(startOffset);
+		if (adjacent==-1) return "";
+		String comment = new String( comments[adjacent].getComment());
+		int i=adjacent-1;
+		while(i>=0) {
+			if (joinWithNext[i]) {
+				comment = new String(comments[i].getComment())+comment;
+				i--;
+			}else {
+				break;
+			}
+		}
+		return comment;
+	}
+	private int findCommentIndex(int startOffset) {
+		
+		IASTComment[] comments = ((ASTTranslationUnit) translationUnit).getComments();
+		int i=0;
+		for (;i<comments.length;i++) {
+			IASTComment c = comments[i];
+			int gap = startOffset-(c.getFileLocation().getNodeOffset()+
+					c.getFileLocation().getNodeLength());
+			if (gap>0 && gap<10) {
+				break;
+			}
+			if (gap<0) return -1;
+		}
+		return i>=comments.length?-1:i;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,190 @@
+package depends.extractor.cpp.cdt;
+import org.eclipse.cdt.core.dom.ast.IASTNode;
+import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
+import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
+import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
+import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
+import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
+import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
+import org.eclipse.cdt.core.dom.ast.IASTExpression;
+import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
+import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
+
+import depends.entity.Expression;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.HandlerContext;
+
+public class ExpressionUsage {
+	HandlerContext context;
+	IdGenerator idGenerator;
+	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator) {
+		this.context = context;
+		this.idGenerator = idGenerator;
+	}
+
+	public void foundCallExpressionOfFunctionStyle(String functionName, IASTDeclarator declarator) {
+		/* create expression and link it with parent*/
+		Expression expression = new Expression(idGenerator.generateId(),null);
+		context.lastContainer().addExpression(declarator,expression);
+		expression.isCall = true;
+		expression.identifier = functionName;
+	}
+	
+	public void foundExpression(IASTExpression ctx) {
+		Expression parent = findParentInStack(ctx);
+		/* create expression and link it with parent*/
+		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
+		context.lastContainer().addExpression(ctx,expression);
+
+		if (parent!=null) {
+			if (parent.deduceTypeBasedId==null) parent.deduceTypeBasedId = expression.id;
+			expression.parent = parent;
+		}
+		
+		
+		if (isTerminalExpression(ctx)) {
+			tryFillExpressionTypeAndIdentifier(ctx,expression);
+			return;
+		}
+		
+		expression.isSet = isSet(ctx);
+		expression.isCall = (ctx instanceof IASTFunctionCallExpression)?true:false;
+		expression.isLogic = isLogic(ctx);
+		if (ctx instanceof ICPPASTNewExpression){
+			expression.isCreate = true;
+		}		
+		expression.isDot = isDot(ctx);
+
+		/**
+ *    | expression bop='.'
+      ( IDENTIFIER
+      | methodCall
+      )
+ */
+
+		//method call
+		if (ctx instanceof IASTFunctionCallExpression) {
+			expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)ctx);
+			expression.isCall = true;
+		}
+		if (ctx instanceof ICPPASTNewExpression) {
+			expression.rawType = ASTStringUtil.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
+			expression.isCall = true;
+			expression.deriveTypeFromChild = false;
+		}
+
+		if (ctx instanceof IASTCastExpression) {
+			expression.isCast=true;
+			expression.rawType = ASTStringUtil.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
+			expression.deriveTypeFromChild = false;
+
+		}
+		if (expression.isDot) {
+			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
+			if (op2 instanceof IASTIdExpression)
+				expression.identifier = ((IASTIdExpression)op2).getName().toString();
+			else if (op2 instanceof IASTLiteralExpression)
+				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
+			else if (op2 instanceof IASTFunctionCallExpression)
+				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
+			return;
+		}		
+	}
+
+	private boolean isTerminalExpression(IASTExpression ctx) {
+		if(ctx instanceof IASTIdExpression) return true;
+		if(ctx instanceof IASTLiteralExpression) return true;
+		if(ctx instanceof IASTTypeIdExpression) return true;
+		//TODO: add others
+		return false;
+	}
+	
+	private void tryFillExpressionTypeAndIdentifier(IASTExpression ctx, Expression expression) {
+		
+		//1. we only handle leaf node. if there is still expression,
+		//   the type will be determined by child node in the expression
+		if (ctx instanceof IASTIdExpression){
+			expression.identifier = ((IASTIdExpression) ctx).getName().toString();
+		}else if (ctx instanceof IASTLiteralExpression) {
+		//2. if it is a var name, dertermine the type based on context.
+			expression.identifier = "<Literal>";
+			expression.rawType =  "<Built-in>";
+		}else if (ctx instanceof IASTTypeIdExpression) {
+		//3. if given type directly
+			expression.rawType = ASTStringUtil.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
+			//TODO: check
+		}
+	}
+
+	private String getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
+		IASTExpression f = methodCall.getFunctionNameExpression();
+		if (f instanceof IASTIdExpression) {
+			return ((IASTIdExpression)f).getName().toString();
+		}
+		return null;
+	}
+
+	private boolean isDot(IASTExpression ctx) {
+		if (ctx instanceof IASTBinaryExpression) {
+			int op = ((IASTBinaryExpression)ctx).getOperator();
+			if (op==IASTBinaryExpression.op_pmdot ||
+					op==IASTBinaryExpression.op_pmarrow	) return true;
+		}
+		return false;
+	}
+	
+	private boolean isLogic(IASTExpression ctx) {
+		if (ctx instanceof IASTBinaryExpression) {
+			 int op = ((IASTBinaryExpression)ctx).getOperator();
+			 
+			if (op == IASTBinaryExpression.op_equals ||
+					op == IASTBinaryExpression.op_notequals ||
+					op == IASTBinaryExpression.op_lessThan ||
+					op == IASTBinaryExpression.op_lessEqual ||
+					op == IASTBinaryExpression.op_greaterThan ||
+					op == IASTBinaryExpression.op_greaterEqual ||
+					op == IASTBinaryExpression.op_logicalAnd ||
+					op == IASTBinaryExpression.op_logicalOr 
+					) {
+				return true;
+			}
+		}
+		return false;
+	}
+	
+	public boolean isSet(IASTExpression ctx) {
+		if (ctx instanceof IASTBinaryExpression) {
+			 int op = ((IASTBinaryExpression)ctx).getOperator();
+			if (op>=IASTBinaryExpression.op_assign &&
+					op<=IASTBinaryExpression.op_binaryOrAssign) {
+				return true;
+			}
+		}
+		if (ctx instanceof IASTUnaryExpression) {
+			 int op = ((IASTUnaryExpression)ctx).getOperator();
+			 if (op == IASTUnaryExpression.op_prefixIncr ||
+					 op == IASTUnaryExpression.op_prefixDecr ||
+					 op == IASTUnaryExpression.op_postFixIncr ||
+					 op == IASTUnaryExpression.op_postFixIncr
+					 )
+				return true;
+			}
+		return false;
+	}
+	
+
+	private Expression findParentInStack(IASTNode ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
+		return findParentInStack(ctx.getParent());
+	}
+
+
+}
\ No newline at end of file

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,22 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
+
+class GPPParserExtensionConfigurationExtension extends GPPParserExtensionConfiguration {
+
+	@Override
+	public boolean supportKnRC() {
+		return false;
+	}
+
+	@Override
+	public boolean supportParameterInfoBlock() {
+		return false;
+	}
+	
+	@Override
+	public boolean supportStatementsInExpressions() {
+		return false;
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,64 @@
+package depends.extractor.java;
+
+import depends.entity.repo.BuiltInType;
+
+public class JavaBuiltInType extends BuiltInType{
+	
+	public JavaBuiltInType() {
+        super.createBuiltInTypes();
+	}
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[]{
+				"void","int","double","char","byte","boolean","long","short","float",
+				"BigDecimal","Integer","Double","Char","Byte","Boolean","Long","Short","Float",
+				"String","Object","Class","Exception","StringBuilder",
+				"Appendable","AutoCloseable","Cloneable","Comparable","Iterable","Readable",
+				"Runnable","Thread.UncaughtExceptionHandler","Boolean","Byte","Character","Character.Subset",
+				"Character.UnicodeBlock","ClassLoader","ClassValue","Compiler","Double","Enum",
+				"InheritableThreadLocal","Math","Number","Package","Process",
+				"ProcessBuilder","ProcessBuilder.Redirect","Runtime","RuntimePermission",
+				"SecurityManager","StackTraceElement","StrictMath","StringBuffer",
+				"System","Thread","ThreadGroup","ThreadLocal","Throwable","Void","ProcessBuilder.Redirect.Type",
+				"Thread.State","ArithmeticException","ArrayIndexOutOfBoundsException",
+				"ArrayStoreException","ClassCastException","ClassNotFoundException","CloneNotSupportedException",
+				"EnumConstantNotPresentException","Exception","IllegalAccessException","IllegalArgumentException",
+				"IllegalMonitorStateException","IllegalStateException","IllegalThreadStateException",
+				"IndexOutOfBoundsException","InstantiationException","InterruptedException",
+				"NegativeArraySizeException","NoSuchFieldException","NoSuchMethodException","NullPointerException",
+				"NumberFormatException","ReflectiveOperationException","RuntimeException","SecurityException",
+				"StringIndexOutOfBoundsException","TypeNotPresentException","UnsupportedOperationException","AbstractMethodError",
+				"AssertionError","BootstrapMethodError","ClassCircularityError","ClassFormatError","Error","ExceptionInInitializerError",
+				"IllegalAccessError","IncompatibleClassChangeError","InstantiationError","InternalError","LinkageError","NoClassDefFoundError"
+				,"NoSuchFieldError","NoSuchMethodError","OutOfMemoryError","StackOverflowError","ThreadDeath","UnknownError",
+				"UnsatisfiedLinkError","UnsupportedClassVersionError","VerifyError","VirtualMachineError","Deprecated","Override",
+				"SafeVarargs","SuppressWarnings",
+				"Collection","Comparator","Deque","Enumeration","EventListener","Formattable","Iterator","List",
+				"ListIterator","Map","Map.Entry","NavigableMap","NavigableSet","Observer","Queue","RandomAccess",
+				"Set","SortedMap","SortedSet","AbstractCollection","AbstractList","AbstractMap","AbstractMap.SimpleEntry",
+				"AbstractMap.SimpleImmutableEntry","AbstractQueue","AbstractSequentialList","AbstractSet","ArrayDeque",
+				"ArrayList","Arrays","BitSet","Calendar","Collections","Currency","Date","Dictionary","EnumMap","EnumSet",
+				"EventListenerProxy","EventObject","FormattableFlags","Formatter","GregorianCalendar","HashMap","HashSet",
+				"Hashtable","IdentityHashMap","LinkedHashMap","LinkedHashSet","LinkedList","ListResourceBundle","Locale",
+				"Locale.Builder","Objects","Observable","PriorityQueue","Properties","PropertyPermission",
+				"PropertyResourceBundle","Random","ResourceBundle","ResourceBundle.Control","Scanner",
+				"ServiceLoader","SimpleTimeZone","Stack","StringTokenizer","Timer","TimerTask","TimeZone",
+				"TreeMap","TreeSet","UUID","Vector","WeakHashMap","Formatter.BigDecimalLayoutForm",
+				"Locale.Category","ConcurrentModificationException","DuplicateFormatFlagsException",
+				"EmptyStackException","FormatFlagsConversionMismatchException","FormatterClosedException",
+				"IllegalFormatCodePointException","IllegalFormatConversionException","IllegalFormatException",
+				"IllegalFormatFlagsException","IllegalFormatPrecisionException","IllegalFormatWidthException",
+				"IllformedLocaleException","InputMismatchException","InvalidPropertiesFormatException","MissingFormatArgumentException",
+				"MissingFormatWidthException","MissingResourceException","NoSuchElementException","TooManyListenersException",
+				"UnknownFormatConversionException","UnknownFormatFlagsException","ServiceConfigurationError",
+				"<Built-in>"
+		};
+	}
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[]{
+				"java.","javax.","com.sun."
+		};
+	}
+	
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,54 @@
+package depends.extractor.java;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.PackageEntity;
+import depends.entity.repo.EntityRepo;
+import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
+
+public class JavaImportLookupStrategy implements ImportLookupStrategy{
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+		//Java Strategy
+		String importedString = fileEntity.importedSuffixMatch(name);
+		if (importedString==null) return null;	
+		return repo.getEntity(importedString);
+	}
+
+
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) continue;
+			if (imported instanceof PackageEntity) { 
+				//expand import of package to all classes under the package due to we dis-courage the behavior
+				for (Entity child:imported.getChildren()) {
+					result.add(child);
+				}
+			}else {
+				result.add(imported);
+			}
+		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
+		return getImportedRelationEntities(importedList,repo);
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+		return new ArrayList<Entity>();
+	}
+
+
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,70 @@
+package depends.extractor.java.context;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+import org.antlr.v4.runtime.RuleContext;
+
+import depends.extractor.HandlerContext;
+import depends.extractor.java.JavaParser.AnnotationContext;
+
+public class AnnotationProcessor {
+	private HandlerContext context;
+
+	public AnnotationProcessor(HandlerContext context) {
+		this.context = context;
+	}
+	/**
+	 * for any elements who with modifiers like 'public/static/... @Annotation‘，
+	 * process annotations as "USE"
+	 * 
+	 * @param ctx
+	 * @param class1
+	 */
+	
+	private boolean containsMethod(RuleContext ctx,String methodName) {
+		try {
+			Method m = ctx.getClass().getMethod(methodName);
+			if (m!=null) return true;
+		} catch (Exception e) {
+			return false;
+		}
+		return true;
+	}
+	private Method getMethod(RuleContext ctx, String methodName) {
+		try {
+			Method m = ctx.getClass().getMethod(methodName);
+			if (m!=null) return m;
+		} catch (Exception e) {
+			return null;
+		}
+		return null;	
+	}
+	
+	public void processAnnotationModifier(RuleContext ctx, String methodName) {
+		while (true) {
+			if (ctx == null)
+				break;
+			if (containsMethod(ctx,methodName))
+				break;
+			ctx = ctx.parent;
+		}
+		if (ctx==null)return;
+			
+		Method m = getMethod(ctx,methodName);
+		if (m==null) return;
+		try {
+			List<?> modifiers = (List<?>) m.invoke(ctx);
+			for (Object modifier : modifiers) {
+				Method annotationMethod = modifier.getClass().getMethod("annotation");
+				AnnotationContext annotation = (AnnotationContext) (annotationMethod.invoke(modifier));
+				if (annotation == null)
+					return;
+				String name = QualitiedNameContextHelper.getName(annotation.qualifiedName());
+				context.foundAnnotation(name);
+			}
+		} catch (Exception e) {
+			return;
+		}
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,182 @@
+package depends.extractor.java.context;
+
+import org.antlr.v4.runtime.RuleContext;
+
+import depends.entity.Expression;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.HandlerContext;
+import depends.extractor.java.JavaParser.ExpressionContext;
+import depends.extractor.java.JavaParser.MethodCallContext;
+import depends.extractor.java.JavaParser.PrimaryContext;
+
+public class ExpressionUsage {
+	HandlerContext context;
+	IdGenerator idGenerator;
+	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator) {
+		this.context = context;
+		this.idGenerator = idGenerator;
+	}
+
+	public void foundExpression(ExpressionContext ctx) {
+		Expression parent = findParentInStack(ctx);
+		/* create expression and link it with parent*/
+		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		context.lastContainer().addExpression(ctx,expression);
+
+		expression.text = ctx.getText(); //for debug purpose. no actual effect
+		expression.parent = parent;
+		if (expression.parent!=null) {
+			if (expression.parent.deduceTypeBasedId==null) 
+				expression.parent.deduceTypeBasedId = expression.id;
+		}
+		
+		if (ctx.primary()!=null) {
+			tryFillExpressionTypeAndIdentifier(ctx.primary(),expression);
+			return;
+		}
+		
+		expression.isSet = isSet(ctx);
+		expression.isCall = ctx.methodCall()==null?false:true;
+		expression.isLogic = isLogic(ctx);
+		expression.isDot = isDot(ctx);
+		if (ctx.creator()!=null ||ctx.innerCreator()!=null){
+			expression.isCreate = true;
+		}		
+/**
+ *    | expression bop='.'
+      ( IDENTIFIER
+      | methodCall
+      | THIS
+      | NEW nonWildcardTypeArguments? innerCreator
+      | SUPER superSuffix
+      | explicitGenericInvocation
+      )
+ */
+		//method call
+		if (ctx.methodCall()!=null) {
+			expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+			expression.isCall = true;
+		}
+		//new 
+		if (ctx.NEW()!=null && ctx.creator()!=null) {
+			expression.rawType = CreatorContextHelper.getCreatorType(ctx.creator());
+			expression.isCall = true;
+			expression.deriveTypeFromChild = false;
+		}
+		
+		if (ctx.typeCast()!=null) {
+			expression.isCast=true;
+			expression.rawType = ctx.typeCast().typeType().getText();
+			expression.deriveTypeFromChild = false;
+		}
+		
+		if (ctx.bop!=null && ctx.bop.getText().equals("instanceof")) {
+			expression.isCast=true;
+			expression.rawType = ctx.typeType().getText();
+			expression.deriveTypeFromChild = false;
+		}
+		
+		if (ctx.creator()!=null) {
+			expression.deriveTypeFromChild = false;
+		}
+		
+		if (expression.isDot) {
+			if (ctx.IDENTIFIER()!=null)
+				expression.identifier = ctx.IDENTIFIER().getText();
+			else if (ctx.methodCall()!=null)
+				expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+			else if (ctx.THIS()!=null)
+				expression.identifier = "this";
+			else if (ctx.innerCreator()!=null) //innner creator like new List(){}
+				expression.identifier =  ctx.innerCreator().IDENTIFIER().getText();
+			else if (ctx.SUPER()!=null)
+				expression.identifier = "super";
+			return;
+		}
+	}
+
+	private String getMethodCallIdentifier(MethodCallContext methodCall) {
+		if (methodCall.THIS()!=null) {
+			return "this";
+		}else if (methodCall.SUPER()!=null) {
+			return "super";
+		}else {
+			return methodCall.IDENTIFIER().getText();
+		}
+	}
+
+	private boolean isDot(ExpressionContext ctx) {
+		if (ctx.bop!=null)
+			if (ctx.bop.getText().equals(".")) return true;
+		return false;
+	}
+	
+	private boolean isLogic(ExpressionContext ctx) {
+		if (ctx.bop != null) {
+			if (OpHelper.isLogic(ctx.bop.getText())) {
+				return true;
+			}
+		}
+		return false;
+	}
+	
+	public boolean isSet(ExpressionContext ctx) {
+		if (ctx.bop != null) {
+			if (OpHelper.isAssigment(ctx.bop.getText())) {
+				return true;
+			}
+		}
+		if (ctx.prefix != null) {
+			if (OpHelper.isIncrementalDecremental(ctx.prefix.getText())) {
+				return true;
+			}
+		}
+		if (ctx.postfix != null) {
+			if (OpHelper.isIncrementalDecremental(ctx.postfix.getText())) {
+				return true;
+			}
+		}
+		
+		return false;
+	}
+	
+//  primary
+//    : '(' expression ')'
+//    | THIS
+//    | SUPER
+//    | literal
+//    | IDENTIFIER
+//    | typeTypeOrVoid '.' CLASS
+//    | nonWildcardTypeArguments (explicitGenericInvocationSuffix | THIS arguments) //Just USE relation
+//    
+	private void tryFillExpressionTypeAndIdentifier(PrimaryContext ctx, Expression expression) {
+		if (ctx.expression()!=null) return; 
+		//1. we only handle leaf node. if there is still expression,
+		//   the type will be determined by child node in the expression
+		if (ctx.literal()!=null) {
+		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
+			expression.rawType = "<Built-in>";
+			expression.identifier = "<Literal>";
+		}else if (ctx.IDENTIFIER()!=null) {
+		//2. if it is a var name, dertermine the type based on context.
+			expression.identifier = ctx.IDENTIFIER().getText();
+		}else if (ctx.typeTypeOrVoid()!=null) {
+		//3. if given type directly
+			expression.rawType = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
+		}else if (ctx.THIS()!=null){
+			expression.identifier = "this";
+		}else if (ctx.SUPER()!=null){
+			expression.identifier = "super";
+		}
+	}
+
+	private Expression findParentInStack(RuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.parent==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.parent)) return context.lastContainer().expressions().get(ctx.parent);
+		return findParentInStack(ctx.parent);
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,74 @@
+package depends.extractor.java.context;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.antlr.v4.runtime.tree.TerminalNode;
+
+import depends.entity.FunctionEntity;
+import depends.entity.VarEntity;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.java.JavaParser.FormalParameterContext;
+import depends.extractor.java.JavaParser.FormalParameterListContext;
+import depends.extractor.java.JavaParser.FormalParametersContext;
+import depends.extractor.java.JavaParser.LastFormalParameterContext;
+import depends.extractor.java.JavaParser.TypeTypeContext;
+import depends.extractor.java.JavaParser.VariableModifierContext;
+
+public class FormalParameterListContextHelper {
+
+	FormalParameterListContext context;
+	private IdGenerator idGenerator;
+	private List<String> annotations;
+	private FunctionEntity container;
+
+	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext,FunctionEntity container, IdGenerator idGenerator) {
+		this.context = formalParameterListContext;
+		this.container = container;
+		annotations = new ArrayList<>();
+		this.idGenerator = idGenerator;
+		if (context!=null)
+			extractParameterTypeList();
+	}
+
+	public FormalParameterListContextHelper(FormalParametersContext formalParameters,FunctionEntity container, IdGenerator idGenerator) {
+		this(formalParameters.formalParameterList(),container,idGenerator);
+	}
+
+
+
+	public void extractParameterTypeList() {
+		if (context != null) {
+			if (context.formalParameter() != null) {
+				for (FormalParameterContext p : context.formalParameter()) {
+					foundParameterDefintion(p.typeType(),p.variableDeclaratorId().IDENTIFIER(),p.variableModifier());
+				}
+				if (context.lastFormalParameter()!=null) {
+					LastFormalParameterContext p = context.lastFormalParameter();
+					foundParameterDefintion(p.typeType(),p.variableDeclaratorId().IDENTIFIER(),p.variableModifier());
+				}
+			}
+		}
+		return;
+	}
+
+	private void foundParameterDefintion(TypeTypeContext typeType, TerminalNode identifier, List<VariableModifierContext> variableModifier) {
+		String type = ClassTypeContextHelper.getClassName(typeType);
+		String varName = identifier.getText();
+		VarEntity varEntity = new VarEntity(varName,type,container,idGenerator.generateId());
+		container.addParameter(varEntity);
+		
+		for ( VariableModifierContext modifier:variableModifier) {
+			if (modifier.annotation()!=null) {
+				this.annotations.add(QualitiedNameContextHelper.getName(modifier.annotation().qualifiedName()));
+			}
+		}
+
+	}
+
+	public List<String> getAnnotations() {
+		return annotations;
+	}
+
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,16 @@
+package depends.extractor.java.context;
+
+import java.util.List;
+
+import org.antlr.v4.runtime.tree.TerminalNode;
+
+public class IdentifierContextHelper {
+	public static String getName(List<TerminalNode> identifiers) {
+		String r = "";
+		for (TerminalNode id:identifiers) {
+			String dot = r.isEmpty()?"":".";
+			r = r + dot + id.getText();
+		}
+		return r;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,19 @@
+package depends.extractor.java.context;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.extractor.java.JavaParser.TypeParameterContext;
+import depends.extractor.java.JavaParser.TypeParametersContext;
+
+public class TypeParameterContextHelper {
+
+	public static List<String> getTypeParameters(TypeParametersContext typeParameters) {
+		ArrayList<String> r = new ArrayList<>();
+		for(TypeParameterContext param:typeParameters.typeParameter()) {
+			r.add(param.IDENTIFIER().getText());
+		}
+		return r;
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,40 @@
+package depends.extractor.java.context;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.extractor.java.JavaParser.ConstantDeclaratorContext;
+import depends.extractor.java.JavaParser.VariableDeclaratorContext;
+import depends.extractor.java.JavaParser.VariableDeclaratorIdContext;
+import depends.extractor.java.JavaParser.VariableDeclaratorsContext;
+
+public class VariableDeclaratorsContextHelper {
+
+	public static List<String> getVariables(VariableDeclaratorsContext variableDeclarators) {
+		List<String> vars = new ArrayList<>();
+		if (variableDeclarators==null) return vars; 
+		for (VariableDeclaratorContext vContext:variableDeclarators.variableDeclarator()) {
+			vars.add(vContext.variableDeclaratorId().IDENTIFIER().getText());
+		}
+		return vars;
+	}
+
+	public static List<String> getVariables(List<ConstantDeclaratorContext> constantDeclarator) {
+		List<String> vars = new ArrayList<>();
+		if (constantDeclarator==null) return vars; 
+		for (ConstantDeclaratorContext vContext:constantDeclarator) {
+			vars.add(vContext.IDENTIFIER().getText());
+		}
+		return vars;
+	}
+
+	public static List<String> getVariable(VariableDeclaratorIdContext variableDeclaratorIdContext) {
+		List<String> vars = new ArrayList<>();
+		if (variableDeclaratorIdContext==null) return vars; 
+		vars.add(variableDeclaratorIdContext.IDENTIFIER().getText());
+		return vars;
+	}
+
+
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,38 @@
+package depends.extractor.ruby;
+
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.repo.EntityRepo;
+import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
+
+public class RubyImportLookupStrategy implements ImportLookupStrategy {
+
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,48 @@
+package depends.format.detail;
+
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+
+import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.DependencyMatrix;
+import depends.matrix.DependencyPair;
+import depends.matrix.DependencyValue;
+
+public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDumper{
+	ArrayList<String> files;
+	@Override
+	public String getFormatName() {
+		return "detail";
+	}
+	public DetailTextFormatDependencyDumper(DependencyMatrix matrix, String name, String outputDir) {
+		super(matrix,name,outputDir);
+	}
+	@Override
+	public boolean output() {
+		PrintWriter writer;
+		try {
+			files = matrix.getNodes();
+			writer = new PrintWriter(composeFilename() +".txt");
+	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
+	        addRelations(writer,dependencyPairs); 
+			writer.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
+		for (DependencyPair dependencyPair:dependencyPairs) {
+            int src = dependencyPair.getFrom();
+            int dst = dependencyPair.getTo();
+        	writer.println("======="+files.get(src) + " -> " + files.get(dst) + "=========");
+        	for (DependencyValue dependency:dependencyPair.getDependencies()) {
+        	writer.println(dependency.getDetails());
+        	}
+        }		
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,52 @@
+package depends.format.dot;
+
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+
+import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.DependencyMatrix;
+import depends.matrix.DependencyPair;
+
+public class DotFormatDependencyDumper extends  AbstractFormatDependencyDumper{
+	@Override
+	public String getFormatName() {
+		return "dot";
+	}
+	public DotFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+	@Override
+	public boolean output() {
+		PrintWriter writer;
+		try {
+			writer = new PrintWriter(composeFilename()+".dot");
+			ArrayList<String> files = matrix.getNodes();
+			
+			for (int i=0;i<files.size();i++) {
+				String file = files.get(i);
+				writer.println("// "+i + ":"+file);
+			}
+			writer.println("digraph");
+			writer.println("{");
+	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
+
+	        addRelations(writer,dependencyPairs); 
+			writer.println("}");
+			writer.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
+		for (DependencyPair dependencyPair:dependencyPairs) {
+            int src = dependencyPair.getFrom();
+            int dst = dependencyPair.getTo();
+        	writer.println("\t"+src + " -> " + dst + ";");
+        }		
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,41 @@
+package depends.format.json;
+
+
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.util.Map;
+
+@XmlRootElement(name = "cell")
+public class JCellObject {
+    private int src;
+    private int dest;
+    private Map<String, Float> values;
+
+    public int getSrc() {
+        return src;
+    }
+
+    @XmlAttribute(name = "src")
+    public void setSrc(int src) {
+        this.src = src;
+    }
+
+    public int getDest() {
+        return dest;
+    }
+
+    @XmlAttribute(name = "dest")
+    public void setDest(int dest) {
+        this.dest = dest;
+    }
+
+    public void setValues(Map<String, Float> values) {
+        this.values = values;
+    }
+
+    @XmlElement
+    public Map<String, Float> getValues() {
+        return values;
+    }
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,50 @@
+package depends.format.json;
+
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.util.ArrayList;
+
+@XmlRootElement(name = "matrix")
+public class JDepObject {
+    private String schemaVersion;
+    private String name;
+    private ArrayList<String> variables;
+    private ArrayList<JCellObject> cells;
+
+    public String getName() {
+        return name;
+    }
+
+    @XmlAttribute(name = "name")
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getSchemaVersion() {
+        return schemaVersion;
+    }
+
+    @XmlAttribute(name = "schema-version")
+    public void setSchemaVersion(String schemaVersion) {
+        this.schemaVersion = schemaVersion;
+    }
+
+    public ArrayList<String> getVariables() {
+        return variables;
+    }
+
+    @XmlElement
+    public void setVariables(ArrayList<String> variables) {
+        this.variables = variables;
+    }
+
+    public ArrayList<JCellObject> getCells() {
+        return cells;
+    }
+
+    @XmlElement
+    public void setCells(ArrayList<JCellObject> cells) {
+        this.cells = cells;
+    }
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,39 @@
+package depends.format.xml;
+
+import java.io.FileOutputStream;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.Marshaller;
+
+import depends.format.AbstractFormatDependencyDumper;
+import depends.format.FileAttributes;
+import depends.matrix.DependencyMatrix;
+
+public class XmlFormatDependencyDumper extends AbstractFormatDependencyDumper{
+	@Override
+	public String getFormatName() {
+		return "xml";
+	}
+    public XmlFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+
+	private void toXml(XDepObject xDepObject, String xmlFileName)  {
+        try {
+            JAXBContext jaxbContext = JAXBContext.newInstance(XDepObject.class);
+            Marshaller marshaller = jaxbContext.createMarshaller();
+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
+            marshaller.marshal(xDepObject, new FileOutputStream(xmlFileName));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+	@Override
+	public boolean output() {
+        XDataBuilder xBuilder = new XDataBuilder();
+        XDepObject xDepObject = xBuilder.build(matrix,new FileAttributes(name));
+        toXml(xDepObject,composeFilename()+".xml");
+ 		return true;
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,7 @@
+package depends.importtypes;
+
+public class ExactMatchImport extends Import{
+	public ExactMatchImport(String content) {
+		super(content);
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,7 @@
+package depends.importtypes;
+
+public class FileImport extends Import{
+	public FileImport(String content) {
+		super(content);
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,7 @@
+package depends.importtypes;
+
+public class PackageWildCardImport extends Import{
+	public PackageWildCardImport(String content) {
+		super(content);
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,45 @@
+package depends.matrix;
+
+import java.util.ArrayList;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.repo.EntityRepo;
+import depends.relations.Relation;
+
+public class FileDependencyGenerator implements DependencyGenerator{
+	/**
+	 * Build the dependency matrix (without re-mapping file id)
+	 * @param entityRepo which contains entities and relations
+	 * @return the generated dependency matrix
+	 */
+	@Override
+	public DependencyMatrix build(EntityRepo entityRepo) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix();
+        ArrayList<String> files = new ArrayList<String>();
+		for (Entity entity:entityRepo.getEntities()) {
+        	if (entity instanceof FileEntity){
+        		files.add( entity.getDisplayName());
+        	}
+        	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
+        	if (fileEntityFrom==-1) continue;
+        	for (Relation relation:entity.getRelations()) {
+        		if (relation.getEntity().getId()>=0) {
+        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
+        			if (fileEntityTo==-1) continue;
+        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
+        		}
+        	}
+        }
+		dependencyMatrix.setNodes(files);
+		return dependencyMatrix;
+	}
+
+	
+	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
+		if (ancestor==null)
+			return -1;
+		return ancestor.getId();
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,50 @@
+package depends.matrix;
+
+import java.util.ArrayList;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.repo.EntityRepo;
+import depends.relations.Relation;
+
+public class FunctionDependencyGenerator implements DependencyGenerator {
+	@Override
+	public DependencyMatrix build(EntityRepo entityRepo) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix();
+		ArrayList<String> elements = new ArrayList<String>();
+		for (Entity entity : entityRepo.getEntities()) {
+			if (entity instanceof FunctionEntity) {
+				elements.add(entity.getDisplayName());
+			}
+			int fileEntityFrom = getFunctionEntityIdNoException(entity);
+			if (fileEntityFrom == -1)
+				continue;
+			for (Relation relation : entity.getRelations()) {
+				if (relation.getEntity().getId() >= 0) {
+					int fileEntityTo = getFunctionEntityIdNoException(relation.getEntity());
+					if (fileEntityTo == -1)
+						continue;
+					dependencyMatrix.addDependency(relation.getType(), fileEntityFrom, fileEntityTo, entity,
+							relation.getEntity());
+				}
+			}
+		}
+		dependencyMatrix.setNodes(elements);
+		return dependencyMatrix;
+	}
+
+	private String getFileNameNoException(Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
+		if (ancestor == null)
+			return "";
+		return ancestor.getRawName();
+	}
+
+	private int getFunctionEntityIdNoException(Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
+		if (ancestor == null)
+			return -1;
+		return ancestor.getId();
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,28 @@
+package depends.relations;
+
+import depends.entity.Entity;
+
+/**
+ * Dependency relation object
+ */
+public class Relation {
+	private String type;
+	private Entity toEntity;
+	
+	public Relation(String type, Entity toEntity) {
+		this.toEntity = toEntity;
+		this.type = type;
+	}
+	public String getType() {
+		return type;
+	}
+
+	@Override
+	public String toString() {
+		return "Relation[" + type + "]-->" + toEntity.getId() + "(" + toEntity.getQualifiedName() + ")";
+	}
+	public Entity getEntity() {
+		return toEntity;
+	}
+	
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,118 @@
+package depends.relations;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+import depends.deptypes.DependencyType;
+import depends.entity.ContainerEntity;
+import depends.entity.Entity;
+import depends.entity.Expression;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+
+public class RelationCounter {
+
+	private Collection<Entity> entities;
+
+	public RelationCounter(Collection<Entity> entities) {
+		this.entities = entities;
+	}
+	
+	public void computeRelations() {
+		for (Entity entity:entities) {
+			if (entity instanceof FileEntity) {
+				computeImports((FileEntity)entity);
+			}
+			if (entity instanceof FunctionEntity) {
+				computeFunctionRelations((FunctionEntity)entity);
+			}
+			if (entity instanceof TypeEntity) {
+				computeTypeRelations((TypeEntity)entity);
+			}
+			if (entity instanceof ContainerEntity) {
+				computeContainerRelations((ContainerEntity)entity);
+			}
+		}
+	}
+
+	
+	private void computeContainerRelations(ContainerEntity entity) {
+		for (VarEntity var:entity.getVars()) {
+			if (var.getType()!=null)
+				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
+		}
+		for (TypeEntity type:entity.getResolvedAnnotations()) {
+			entity.addRelation(new Relation(DependencyType.USE,type));
+		}
+		for (TypeEntity type:entity.getResolvedTypeParameters()) {
+			entity.addRelation(new Relation(DependencyType.USE,type));
+		}
+		
+		HashSet<Entity> usedEntities = new HashSet<>();
+		for (Expression expression:entity.expressions().values()){
+			Entity referredEntity = expression.getReferredEntity();
+			if (referredEntity==null) {
+				continue;
+			}
+			
+			if (expression.isCall) {
+				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
+			}
+			if (expression.isCreate) {
+				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
+			}
+			if (expression.isSet) { //SET is merged with USE
+				entity.addRelation(new Relation(DependencyType.USE,referredEntity));
+			}
+			if (expression.isCast) { 
+				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
+			}
+			if (!expression.isCall && !expression.isCreate && !expression.isCast) {
+				usedEntities.add(expression.getReferredEntity());
+			}
+		}
+		
+		for (Entity usedEntity:usedEntities) {
+			entity.addRelation(new Relation(DependencyType.USE,usedEntity));
+		}
+	}
+
+	private void computeTypeRelations(TypeEntity type) {
+		for (TypeEntity superType:type.getInheritedTypes()) {
+			type.addRelation(new Relation(DependencyType.INHERIT,superType));
+		}
+		for (TypeEntity interfaceType:type.getImplementedTypes()) {
+			type.addRelation(new Relation(DependencyType.IMPLEMENT,interfaceType));
+		}
+	}
+
+	private void computeFunctionRelations(FunctionEntity func) {
+		for (TypeEntity returnType:func.getReturnTypes()) {
+			func.addRelation(new Relation(DependencyType.RETURN,returnType));
+		}
+		for (VarEntity parameter:func.getParameters()) {
+			if (parameter.getType()!=null) 
+				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType()));
+		}
+		for (TypeEntity throwType:func.getThrowTypes()) {
+			func.addRelation(new Relation(DependencyType.THROW,throwType));
+		}
+	}
+
+	private void computeImports(FileEntity file) {
+		List<Entity> imports = file.getImportedRelationEntities();
+		for (Entity imported:imports) {
+			if (imported instanceof FileEntity)
+			{
+				if (((FileEntity)imported).isInProjectScope())
+					file.addRelation(new Relation(DependencyType.IMPORT,imported));
+			}else {
+				file.addRelation(new Relation(DependencyType.IMPORT,imported));
+			}
+		}
+	}
+
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -21,12 +21,15 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Object, Expression> expressions;
-
+	private Collection<String> mixins;
+	private Collection<ContainerEntity> resolvedMixins;
 
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
 		functions = new ArrayList<>();
+		mixins = new ArrayList<>();
+		resolvedMixins = new ArrayList<>();
 		expressions = new HashMap<>();
 	}
 	
@@ -73,6 +76,20 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelEntities(inferer);
 		}
+		resolvedMixins = identiferToContainerEntity(inferer, mixins);
+	}
+
+	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<String> identifiers) {
+		ArrayList<ContainerEntity> r = new ArrayList<>();
+		for (String identifier : identifiers) {
+			Entity entity = inferer.resolveName(this, identifier, true);
+			if (entity==null) {
+				continue;
+			}
+			if (entity instanceof ContainerEntity)
+				r.add((ContainerEntity)entity);
+		}
+		return r;
 	}
 
 	/**
@@ -182,4 +199,10 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 		return null;
 	}
+
+
+
+	public void addMixin(String moduleName) {
+		mixins.add(moduleName);
+	}
 }

1effdf25316aca0758babce13f917c853722dda9
@@ -1,12 +1,8 @@
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
 import depends.relations.Inferer;
 
-public class VarEntity extends DecoratedEntity {
+public class VarEntity extends ContainerEntity {
 	private String rawType;
 	private TypeEntity type;
 

1effdf25316aca0758babce13f917c853722dda9
@@ -138,10 +138,15 @@ public abstract class HandlerContext {
 	public void foundExtends(String typeName) {
 		if (currentType()==null) {
 			System.out.println("error: type do not exist");
+			return ;
 		}
 		currentType().addExtends(typeName);
 	}
 
+	public void foundMixin(String moduleName) {
+		lastContainer().addMixin(moduleName);
+		
+	}
 
 	public void foundTypeParametes(String typeName) {
 		lastContainer().addTypeParameter(typeName);

1effdf25316aca0758babce13f917c853722dda9
@@ -1,10 +1,12 @@
 package depends.extractor.ruby;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
+import depends.importtypes.FileImport;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
@@ -18,21 +20,27 @@ public class RubyImportLookupStrategy implements ImportLookupStrategy {
 	}
 
 	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedNames, EntityRepo repo) {
-		// TODO Auto-generated method stub
-		return null;
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			if (importedItem instanceof FileImport) {
+				Entity imported = repo.getEntity(importedItem.getContent());
+				if (imported==null) continue;
+				result.add(imported);
+			}
+		}
+		return result;
 	}
 
 	@Override
 	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
 		// TODO Auto-generated method stub
-		return null;
+		return new ArrayList<>();
 	}
 
 	@Override
-	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
-		// TODO Auto-generated method stub
-		return null;
+	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+		return getImportedRelationEntities(importedList,repo);
 	}
 
 }

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,28 @@
+package depends.extractor.ruby;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import depends.entity.repo.EntityRepo;
+import depends.relations.Inferer;
+
+public abstract class RubyParserTest {
+	protected  EntityRepo entityRepo ;
+	protected Inferer inferer ;
+
+	public void init() {
+		entityRepo = new EntityRepo();
+		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType());
+	}
+	
+	public RubyFileParser createParser(String src) {
+		ExecutorService executor = Executors.newSingleThreadExecutor();
+		return new RubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()));
+	}
+
+	private List<String> includePaths() {
+		return new ArrayList<>();
+	}
+}

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,31 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+public class RubyRequireTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test_require_relation() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/require_1.rb",
+	    		"./src/test/resources/ruby-code-examples/require_2.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        File f = new File(srcs[0]);
+        assertEquals(1,entityRepo.getEntity(f.getCanonicalPath()).getRelations().size());
+	}
+}

87a6d02899f1384696c1d002491b1590209d4f1d
@@ -17,6 +17,7 @@ public class DependencyType {
 	public static final String CAST = "Cast";
 	public static final String THROW = "Throw";
 	public static final String ANNOTATION = "Annotation";
+	public static final String MIXIN = "MixIn";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();
@@ -34,6 +35,7 @@ public class DependencyType {
 		depedencyTypes.add(CAST);
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
+		depedencyTypes.add(MIXIN);
 		return depedencyTypes;
 	}
 }

87a6d02899f1384696c1d002491b1590209d4f1d
@@ -205,4 +205,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public void addMixin(String moduleName) {
 		mixins.add(moduleName);
 	}
+
+
+
+	public Collection<ContainerEntity> getResolvedMixins() {
+		return resolvedMixins;
+	}
+
 }

87a6d02899f1384696c1d002491b1590209d4f1d
@@ -53,6 +53,9 @@ public class RelationCounter {
 		for (TypeEntity type:entity.getResolvedTypeParameters()) {
 			entity.addRelation(new Relation(DependencyType.USE,type));
 		}
+		for (ContainerEntity mixin:entity.getResolvedMixins()) {
+			entity.addRelation(new Relation(DependencyType.MIXIN,mixin));
+		}
 		
 		HashSet<Entity> usedEntities = new HashSet<>();
 		for (Expression expression:entity.expressions().values()){

87a6d02899f1384696c1d002491b1590209d4f1d
@@ -0,0 +1,35 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.relations.Relation;
+
+public class RubyMixinTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test_mixin_relation() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/mix_in.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("MixedIn").getRelations().size());
+        Relation r = entityRepo.getEntity("MixedIn").getRelations().get(0);
+        assertEquals(DependencyType.MIXIN,r.getType());
+        assertEquals("ToBeMixin",r.getEntity().getRawName());
+	}
+}

87a6d02899f1384696c1d002491b1590209d4f1d
@@ -19,7 +19,7 @@ public abstract class RubyParserTest {
 	
 	public RubyFileParser createParser(String src) {
 		ExecutorService executor = Executors.newSingleThreadExecutor();
-		return new RubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()));
+		return new RubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()), inferer);
 	}
 
 	private List<String> includePaths() {

87a6d02899f1384696c1d002491b1590209d4f1d
@@ -26,6 +26,6 @@ public class RubyRequireTest extends RubyParserTest {
 	    }
 	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals(1,entityRepo.getEntity(f.getCanonicalPath()).getRelations().size());
+        assertEquals(2,entityRepo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
 }

3fb5e986c116063bafa36b46f00c4b85709778b0
@@ -1,46 +1,8 @@
 package depends.extractor.ruby;
 
-import java.util.ArrayList;
-import java.util.List;
+import depends.extractor.cpp.CppImportLookupStrategy;
 
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.repo.EntityRepo;
-import depends.importtypes.FileImport;
-import depends.importtypes.Import;
-import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
+public class RubyImportLookupStrategy extends  CppImportLookupStrategy {
 
-public class RubyImportLookupStrategy implements ImportLookupStrategy {
-
-	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
-		ArrayList<Entity> result = new ArrayList<>();
-		for (Import importedItem:importedList) {
-			if (importedItem instanceof FileImport) {
-				Entity imported = repo.getEntity(importedItem.getContent());
-				if (imported==null) continue;
-				result.add(imported);
-			}
-		}
-		return result;
-	}
-
-	@Override
-	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
-		// TODO Auto-generated method stub
-		return new ArrayList<>();
-	}
-
-	@Override
-	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
-		return getImportedRelationEntities(importedList,repo);
-	}
 
 }

3fb5e986c116063bafa36b46f00c4b85709778b0
@@ -0,0 +1,123 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.relations.Relation;
+
+public class RubyInheritTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test_relation() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/extends.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
+        Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
+        assertEquals(DependencyType.INHERIT,r.getType());
+        assertEquals("Animal",r.getEntity().getRawName());
+	}
+	
+	@Test
+	public void test_relation_of_included_file() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/extends_animal.rb",
+	    		"./src/test/resources/ruby-code-examples/extends_cat.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
+        Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
+        assertEquals(DependencyType.INHERIT,r.getType());
+        assertEquals("Animal",r.getEntity().getRawName());
+	}
+	
+	
+	@Test
+	public void test_relation_with_cpath_1() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/extends_with_cpath.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
+        Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
+        assertEquals(DependencyType.INHERIT,r.getType());
+        assertEquals("Animal",r.getEntity().getQualifiedName());
+	}
+	
+	@Test
+	public void test_relation_with_cpath_2() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/extends_with_cpath.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("ZooCat").getRelations().size());
+        Relation r = entityRepo.getEntity("ZooCat").getRelations().get(0);
+        assertEquals(DependencyType.INHERIT,r.getType());
+        assertEquals("Zoo.Animal",r.getEntity().getQualifiedName());
+	}
+	
+	@Test
+	public void test_relation_with_cpath_3() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/extends_with_cpath.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("Zoo.Cow").getRelations().size());
+        Relation r = entityRepo.getEntity("Zoo.Cow").getRelations().get(0);
+        assertEquals(DependencyType.INHERIT,r.getType());
+        assertEquals("Zoo.Animal",r.getEntity().getQualifiedName());
+	}
+	
+	
+	@Test
+	public void test_relation_with_alias() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/extends_with_alias.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
+        Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
+        assertEquals(DependencyType.INHERIT,r.getType());
+        assertEquals("Zoo_Animal",r.getEntity().getQualifiedName());
+	}
+}

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -0,0 +1,131 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+import depends.relations.Inferer;
+
+public class AliasEntity extends Entity {
+	private Entity referToEntity = new EmptyTypeEntity();
+	private String originName;
+
+	public AliasEntity(String simpleName, Entity parent, Integer id, String originTypeName) {
+		super(simpleName, parent, id);
+		this.originName = originTypeName;
+	}
+
+	public void inferLocalLevelEntities(Inferer inferer) {
+		Entity entity = inferer.resolveName(this, originName, true);
+		if (entity != null)
+			referToEntity = entity;
+		if (entity.equals(this)) {
+			referToEntity = new EmptyTypeEntity();
+		}
+		referToEntity.inferLocalLevelEntities(inferer);
+	}
+
+	public Collection<TypeEntity> getResolvedTypeParameters() {
+		if (!(referToEntity instanceof DecoratedEntity))
+			return new ArrayList<>();
+		DecoratedEntity origin = (DecoratedEntity) referToEntity;
+		return origin.getResolvedTypeParameters();
+	}
+
+	public Collection<TypeEntity> getResolvedAnnotations() {
+		if (!(referToEntity instanceof DecoratedEntity))
+			return new ArrayList<>();
+		DecoratedEntity origin = (DecoratedEntity) referToEntity;
+		return origin.getResolvedAnnotations();
+	}
+
+	public ArrayList<VarEntity> getVars() {
+		if (!(referToEntity instanceof ContainerEntity))
+			return new ArrayList<>();
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.getVars();
+	}
+
+	public ArrayList<FunctionEntity> getFunctions() {
+		if (!(referToEntity instanceof ContainerEntity))
+			return new ArrayList<>();
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.getFunctions();
+	}
+
+	protected FunctionEntity lookupFunctionLocally(String functionName) {
+		if (!(referToEntity instanceof ContainerEntity))
+			return null;
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.lookupFunctionLocally(functionName);
+	}
+
+	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+		if (!(referToEntity instanceof ContainerEntity))
+			return null;
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.lookupFunctionInVisibleScope(functionName);
+	}
+
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		if (!(referToEntity instanceof ContainerEntity))
+			return null;
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.lookupVarsInVisibleScope(varName);
+	}
+
+	public Collection<ContainerEntity> getResolvedMixins() {
+		if (!(referToEntity instanceof ContainerEntity))
+			return new ArrayList<>();
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.getResolvedMixins();
+	}
+
+	public Collection<TypeEntity> getInheritedTypes() {
+		if (referToEntity instanceof TypeEntity)
+			return ((TypeEntity) referToEntity).getInheritedTypes();
+		return new ArrayList<>();
+	}
+
+	public Collection<TypeEntity> getImplementedTypes() {
+		if (referToEntity instanceof TypeEntity)
+			return ((TypeEntity) referToEntity).getImplementedTypes();
+		return new ArrayList<>();
+	}
+
+	public TypeEntity getInheritedType() {
+		if (referToEntity instanceof TypeEntity)
+			return ((TypeEntity) referToEntity).getInheritedType();
+		return null;
+	}
+
+	public Collection<TypeEntity> getReturnTypes() {
+		if (!(referToEntity instanceof FunctionEntity))
+			return new ArrayList<>();
+		FunctionEntity origin = (FunctionEntity) referToEntity;
+		return origin.getReturnTypes();
+	}
+
+	public TypeEntity getType() {
+		return referToEntity.getType();
+	}
+
+	public Collection<VarEntity> getParameters() {
+		if (!(referToEntity instanceof FunctionEntity))
+			return new ArrayList<>();
+		FunctionEntity origin = (FunctionEntity) referToEntity;
+		return origin.getParameters();
+	}
+
+	public Collection<TypeEntity> getThrowTypes() {
+		if (!(referToEntity instanceof FunctionEntity))
+			return new ArrayList<>();
+		FunctionEntity origin = (FunctionEntity) referToEntity;
+		return origin.getThrowTypes();
+	}
+
+	public Entity getOriginType() {
+		return referToEntity;
+	}
+	
+
+}

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -8,7 +8,7 @@ import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
-import depends.entity.TypeAliasEntity;
+import depends.entity.AliasEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
@@ -48,7 +48,7 @@ public abstract class HandlerContext {
 	public void foundNewTypeAlias(String aliasName, String originalName) {
 		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
 		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
-		TypeAliasEntity currentTypeEntity = new TypeAliasEntity(aliasName, this.latestValidContainer(),
+		AliasEntity currentTypeEntity = new AliasEntity(aliasName, this.latestValidContainer(),
 				idGenerator.generateId(),originalName );
 	 	entityRepo.add(currentTypeEntity);
 		return ;		

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -9,7 +9,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.TypeAliasEntity;
+import depends.entity.AliasEntity;
 import depends.extractor.cpp.CppFileParser;
 
 public class IncludeRelationTest extends CppParserTest{
@@ -37,22 +37,7 @@ public class IncludeRelationTest extends CppParserTest{
         assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
 	
-	@Test
-	public void test_includefiles_outside_project_will_not_count() throws IOException {
-	    String[] srcs = new String[] {
-	    		"./src/test/resources/cpp-code-examples/includesTest/EntryFile.cpp",
-	    		"./src/test/resources/cpp-code-examples/includesTest/LocalHeader.h",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-        File f = new File(srcs[0]);
-        assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
-	}
-
+	
 	@Test
 	public void test_could_found_files_in_include_path() throws IOException {
 	    String[] srcs = new String[] {
@@ -84,7 +69,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals("abc",((TypeAliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName());
+        assertEquals("abc",((AliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName());
         
 	}
 }

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -10,7 +10,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.entity.TypeAliasEntity;
+import depends.entity.AliasEntity;
 import depends.extractor.cpp.CppFileParser;
 
 public class UsingTest extends CppParserTest{

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -10,7 +10,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.entity.TypeAliasEntity;
+import depends.entity.AliasEntity;
 import depends.extractor.cpp.CppFileParser;
 
 public class extendsTest extends CppParserTest{

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -18,6 +18,6 @@ public class JavaGenericTypeTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("x.GenericTypeTest").getRelations().size());
+        assertEquals(2,entityRepo.getEntity("x.GenericTypeTest").getRelations().size());
 	}
 }

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -45,7 +45,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         parser.parse();
         inferer.resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
-        assertEquals(16,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(17,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
 	}
 	
 	@Test
@@ -54,7 +54,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(23,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        assertEquals(22,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 	@Test
@@ -63,7 +63,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(6,entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
+        assertEquals(5,entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
 	}
 	
 	
@@ -74,7 +74,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(17,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
+        assertEquals(16,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
 	@Test
@@ -83,7 +83,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(17,entityRepo.getEntity("JDepObject").getRelations().size());
+        assertEquals(2,entityRepo.getEntity("JDepObject").getRelations().size());
 	}
 	
 }

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -118,6 +118,6 @@ public class RubyInheritTest extends RubyParserTest {
         assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
         Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
         assertEquals(DependencyType.INHERIT,r.getType());
-        assertEquals("Zoo_Animal",r.getEntity().getQualifiedName());
+        assertEquals("Zoo.Animal",r.getEntity().getQualifiedName());
 	}
 }

63b19f145358c14da429e75fb9e3a00367915ec8
@@ -1,5 +1,8 @@
 package depends.entity;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import depends.relations.Inferer;
 
 public class Expression {
@@ -7,6 +10,7 @@ public class Expression {
 	public Integer parentId;
 	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;
+	private List<Expression> deduceTypeChildren = new ArrayList<>();
 	public String text; // for debug purpose
 	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
@@ -16,8 +20,8 @@ public class Expression {
 	public boolean isLogic = false;
 	public boolean isCreate = false;
 	public boolean isCast = false;
+	public boolean autoVar = false;
 	public boolean deriveTypeFromChild = true;
-
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
 	private Entity referredEntity;
@@ -49,7 +53,7 @@ public class Expression {
 		                      .append(isSet?"[set]":"")
 		                      .append(isLogic?"[bool]":"")
 		                      .append(isCall?"[call]":"").append("|")
-		    .append("parent:").append(parent==null?"none":parent.text)
+		    .append("parent:").append(parent==null?"nil":parent.text).append("|")
 			.append("type:").append(type).append("|");
 		return s.toString();
 	}
@@ -61,6 +65,17 @@ public class Expression {
 	 */
 	public void deduceParentType(Inferer inferer) {
 		if (this.type==null) return;
+		deduceChildrenType(inferer);
+		deduceTheParentType(inferer);
+	}
+
+	private void deduceChildrenType(Inferer inferer) {
+		for (Expression child:this.deduceTypeChildren) {
+			child.setType(type, type, inferer);
+		}
+	}
+
+	private void deduceTheParentType(Inferer inferer) {
 		if (this.parent==null) return;
 		Expression parent = this.parent;
 		if (parent.type != null)return;
@@ -104,4 +119,8 @@ public class Expression {
 	public Entity getReferredEntity() {
 		return referredEntity;
 	}
+
+	public void addDeduceTypeChild(Expression expression) {
+		deduceTypeChildren.add(expression);
+	}
 }
\ No newline at end of file

63b19f145358c14da429e75fb9e3a00367915ec8
@@ -0,0 +1,110 @@
+package depends.extractor.ruby;
+
+import org.antlr.v4.runtime.ParserRuleContext;
+import org.antlr.v4.runtime.RuleContext;
+
+import depends.entity.Entity;
+import depends.entity.Expression;
+import depends.entity.VarEntity;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.HandlerContext;
+import depends.extractor.ruby.RubyParser.ExprAssignContext;
+import depends.extractor.ruby.RubyParser.ExprBatchAssignContext;
+import depends.extractor.ruby.RubyParser.ExprContext;
+import depends.extractor.ruby.RubyParser.ExprListContext;
+import depends.extractor.ruby.RubyParser.ExprPrimaryContext;
+import depends.extractor.ruby.RubyParser.PrimaryVarPathContext;
+import depends.extractor.ruby.RubyParser.VarPathLiteralContext;
+import depends.extractor.ruby.RubyParser.Variable_pathContext;
+import depends.relations.Inferer;
+
+public class ExpressionUsage {
+	HandlerContext context;
+	IdGenerator idGenerator;
+	private RubyParserHelper helper;
+	Inferer inferer;
+	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator, RubyParserHelper helper,Inferer inferer) {
+		this.context = context;
+		this.idGenerator = idGenerator;
+		this.helper = helper;
+		this.inferer = inferer;
+	}
+	public Expression foundExpression(ParserRuleContext ctx) {
+		Expression expression = findExpression(ctx);
+		if (expression!=null) return expression;
+		Expression parent = findParentInStack(ctx);
+		System.out.println("expr " + ctx.getText());
+		/* create expression and link it with parent*/
+		expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		expression.parent = parent;
+		expression.text = ctx.getText();
+		if (expression.parent!=null) {
+			if (expression.parent.deduceTypeBasedId==null) 
+				expression.parent.deduceTypeBasedId = expression.id;
+			/* Set operation always use the 2nd expr's type*/
+			if (expression.parent.isSet) {
+				expression.parent.deduceTypeBasedId = expression.id;
+				parent.addDeduceTypeChild(expression);
+			}
+		}
+		context.lastContainer().addExpression(ctx,expression);
+		if (ctx instanceof PrimaryVarPathContext) {
+			Variable_pathContext variable_path = ((PrimaryVarPathContext)ctx).variable_path();
+			expression.identifier = helper.getName(variable_path);
+			if (variable_path instanceof VarPathLiteralContext) {
+				expression.rawType =Inferer.buildInType.getDisplayName();
+			}else  {
+				//to be deduced
+			}
+		}
+		if (ctx instanceof ExprBatchAssignContext) {
+			expression.isSet = true;
+  		    ExprContext left = ((ExprBatchAssignContext) ctx).expr(0);
+			ExprContext right = ((ExprBatchAssignContext) ctx).expr(1);
+			if (left instanceof ExprListContext) {
+				
+			}else if (left instanceof ExprPrimaryContext) {
+				expression.identifier = helper.getName(((ExprPrimaryContext)left).primary());
+				expression.rawType = null;//need deduce from right type
+				expression.autoVar = true;
+				Entity var = inferer.resolveName(context.lastContainer(), left.getText(), true);
+				if (var==null) {
+					VarEntity varEntity = new VarEntity(left.getText(),null,context.lastContainer(),idGenerator.generateId());
+					context.lastContainer().addVar(varEntity );
+				}else  {
+					if (var.equals(Inferer.externalType)){
+						VarEntity varEntity = new VarEntity(left.getText(),null,context.lastContainer(),idGenerator.generateId());
+						context.lastContainer().addVar(varEntity );						
+					}
+				}
+			}
+		}
+		if (ctx instanceof ExprAssignContext) {
+			expression.isSet = true;
+		}
+		if (ctx instanceof ExprPrimaryContext) {
+			
+		}
+		return expression;
+	}
+	
+	private Expression findParentInStack(RuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
+		return findParentInStack(ctx.getParent());
+	}
+	
+	private Expression findExpression(RuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		return context.lastContainer().expressions().get(ctx.getParent());
+	}
+
+}
\ No newline at end of file

63b19f145358c14da429e75fb9e3a00367915ec8
@@ -0,0 +1,35 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.FileEntity;
+import depends.util.FileUtil;
+
+public class RubyVarTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test_var_should_be_created_if_not_declared() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    RubyFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        FileEntity f = (FileEntity) (entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
+        assertEquals(1,f.getVars().size());
+        assertEquals("var_1",f.getVars().get(0).getRawName());
+	}
+	
+}

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -3,12 +3,10 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.List;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import depends.extractor.java.JavaParser.ExpressionContext;
 import depends.relations.Inferer;
 
 /**
@@ -101,15 +99,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
 				continue;
+			if (expression.isDot){ //wait for previous
+				continue;
+			}
+			if (expression.rawType==null && expression.identifier ==null)
+				continue;
 			
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
 				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
-			}else if (expression.isDot){ //wait for previous
-				continue;
-			} else if (expression.rawType!=null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
 				if (expression.getType() !=null) {
 					 continue;
 				}

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -65,7 +65,7 @@ public class Expression {
 	 */
 	public void deduceParentType(Inferer inferer) {
 		if (this.type==null) return;
-		deduceChildrenType(inferer);
+		//deduceChildrenType(inferer);
 		deduceTheParentType(inferer);
 	}
 

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -1,11 +1,9 @@
-package depends.extractor.ruby;
+package depends.extractor.ruby.antlr;
 
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.RuleContext;
 
-import depends.entity.Entity;
 import depends.entity.Expression;
-import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.HandlerContext;
 import depends.extractor.ruby.RubyParser.ExprAssignContext;
@@ -67,16 +65,6 @@ public class ExpressionUsage {
 				expression.identifier = helper.getName(((ExprPrimaryContext)left).primary());
 				expression.rawType = null;//need deduce from right type
 				expression.autoVar = true;
-				Entity var = inferer.resolveName(context.lastContainer(), left.getText(), true);
-				if (var==null) {
-					VarEntity varEntity = new VarEntity(left.getText(),null,context.lastContainer(),idGenerator.generateId());
-					context.lastContainer().addVar(varEntity );
-				}else  {
-					if (var.equals(Inferer.externalType)){
-						VarEntity varEntity = new VarEntity(left.getText(),null,context.lastContainer(),idGenerator.generateId());
-						context.lastContainer().addVar(varEntity );						
-					}
-				}
 			}
 		}
 		if (ctx instanceof ExprAssignContext) {

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -0,0 +1,100 @@
+package depends.extractor.ruby.jruby;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.jrubyparser.ast.AssignableNode;
+import org.jrubyparser.ast.CallNode;
+import org.jrubyparser.ast.ClassVarAsgnNode;
+import org.jrubyparser.ast.ClassVarDeclNode;
+import org.jrubyparser.ast.ConstDeclNode;
+import org.jrubyparser.ast.DAsgnNode;
+import org.jrubyparser.ast.FCallNode;
+import org.jrubyparser.ast.GlobalAsgnNode;
+import org.jrubyparser.ast.ILiteralNode;
+import org.jrubyparser.ast.InstAsgnNode;
+import org.jrubyparser.ast.ListNode;
+import org.jrubyparser.ast.LocalAsgnNode;
+import org.jrubyparser.ast.MultipleAsgnNode;
+import org.jrubyparser.ast.Node;
+import org.jrubyparser.ast.UnaryCallNode;
+import org.jrubyparser.ast.VCallNode;
+
+import depends.entity.Expression;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.HandlerContext;
+import depends.relations.Inferer;
+
+public class ExpressionUsage {
+	HandlerContext context;
+	IdGenerator idGenerator;
+	Inferer inferer;
+	private RubyParserHelper helper;
+	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator, RubyParserHelper helper, Inferer inferer) {
+		this.context = context;
+		this.idGenerator = idGenerator;
+		this.inferer = inferer;
+		this.helper = helper;
+	}
+	public Expression foundExpression(Node ctx) {
+		Expression expression = findExpression(ctx);
+		if (expression!=null) return expression;
+		Expression parent = findParentInStack(ctx);
+		System.out.println("expr " + ctx.toString());
+		/* create expression and link it with parent*/
+		expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		expression.parent = parent;
+		if (expression.parent!=null) {
+			if (expression.parent.deduceTypeBasedId==null) 
+				expression.parent.deduceTypeBasedId = expression.id;
+			/* Set operation always use the 2nd expr's type*/
+			if (expression.parent.isSet) {
+				expression.parent.deduceTypeBasedId = expression.id;
+				parent.addDeduceTypeChild(expression);
+			}
+		}
+		context.lastContainer().addExpression(ctx,expression);
+		if (ctx instanceof ILiteralNode) {
+			expression.identifier = ((ILiteralNode)ctx).toString();
+			expression.rawType = Inferer.buildInType.getQualifiedName();
+		}else if (ctx instanceof AssignableNode) {
+			expression.isSet = true;
+			Node valueNode = ((AssignableNode)ctx).getValue();
+			List<String> names = helper.getName((AssignableNode)ctx);
+			if (names.size()==1) {
+				expression.autoVar = true;
+				expression.identifier = names.get(0);
+			}else {
+			}
+		}else if (helper.isFunctionCall(ctx)) {
+			String name = helper.getName(ctx);
+			if (name.equals("new")) {
+				expression.isCreate = true;
+				expression.identifier = helper.getName(ctx.childNodes().get(0));
+				expression.rawType = expression.identifier ;
+				expression.deriveTypeFromChild  = false;
+			}
+		}
+		return expression;
+	}
+	
+	private Expression findParentInStack(Node ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
+		return findParentInStack(ctx.getParent());
+	}
+	
+	private Expression findExpression(Node ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		return context.lastContainer().expressions().get(ctx);
+	}
+
+}
\ No newline at end of file

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -0,0 +1,65 @@
+package depends.extractor.ruby.jruby;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.concurrent.ExecutorService;
+
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.CharStreams;
+import org.jrubyparser.CompatVersion;
+import org.jrubyparser.Parser;
+import org.jrubyparser.ast.Node;
+import org.jrubyparser.parser.ParserConfiguration;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.extractor.ParserCreator;
+import depends.extractor.ruby.IncludedFileLocator;
+import depends.extractor.ruby.antlr.RubyFileAntlrParser;
+import depends.relations.Inferer;
+import depends.util.FileUtil;
+public class JRubyFileParser implements FileParser {
+	private static final long MAX_PARSE_TIME_PER_FILE = 180000L;
+	private String fileFullPath;
+	private EntityRepo entityRepo;
+	private ExecutorService executor;
+	private IncludedFileLocator includesFileLocator;
+	private Inferer inferer;
+	private ParserCreator parserCreator;
+
+	public JRubyFileParser(String fileFullPath, EntityRepo entityRepo, 
+			ExecutorService executorService, 
+			IncludedFileLocator includesFileLocator, 
+			Inferer inferer, ParserCreator parserCreator) {
+        this.fileFullPath  = FileUtil.uniqFilePath(fileFullPath);
+        this.entityRepo = entityRepo;
+        this.executor = executorService;
+        this.includesFileLocator = includesFileLocator;
+        this.inferer = inferer;
+        this.parserCreator = parserCreator;
+    }
+
+	@Override
+	public void parse() throws IOException {
+		/** If file already exist, skip it */
+		Entity fileEntity = entityRepo.getEntity(fileFullPath);
+		if (fileEntity!=null && fileEntity instanceof FileEntity) {
+			return;
+		}
+		
+        CharStream input = CharStreams.fromFileName(fileFullPath);
+		Parser rubyParser = new Parser();
+		StringReader in = new StringReader(input.toString());
+		CompatVersion version = CompatVersion.RUBY2_3;
+		ParserConfiguration config = new ParserConfiguration(0, version);
+		Node node = rubyParser.parse("<code>", in, config);
+		node.accept(new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator));
+		fileEntity = entityRepo.getEntity(fileFullPath);
+		if (fileEntity!=null) {
+			fileEntity.inferEntities(inferer);
+		}
+	}
+
+}

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -0,0 +1,237 @@
+package depends.extractor.ruby.jruby;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.ExecutorService;
+
+import org.jrubyparser.ast.AliasNode;
+import org.jrubyparser.ast.ArrayNode;
+import org.jrubyparser.ast.CallNode;
+import org.jrubyparser.ast.ClassNode;
+import org.jrubyparser.ast.Colon2ConstNode;
+import org.jrubyparser.ast.ConstNode;
+import org.jrubyparser.ast.DAsgnNode;
+import org.jrubyparser.ast.DVarNode;
+import org.jrubyparser.ast.DefnNode;
+import org.jrubyparser.ast.DefsNode;
+import org.jrubyparser.ast.FCallNode;
+import org.jrubyparser.ast.GlobalAsgnNode;
+import org.jrubyparser.ast.GlobalVarNode;
+import org.jrubyparser.ast.IArgumentNode;
+import org.jrubyparser.ast.INameNode;
+import org.jrubyparser.ast.InstAsgnNode;
+import org.jrubyparser.ast.InstVarNode;
+import org.jrubyparser.ast.LocalAsgnNode;
+import org.jrubyparser.ast.LocalVarNode;
+import org.jrubyparser.ast.ModuleNode;
+import org.jrubyparser.ast.Node;
+import org.jrubyparser.ast.RootNode;
+import org.jrubyparser.ast.StrNode;
+import org.jrubyparser.ast.SymbolNode;
+import org.jrubyparser.ast.UnaryCallNode;
+import org.jrubyparser.ast.VCallNode;
+import org.jrubyparser.util.NoopVisitor;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.ParserCreator;
+import depends.extractor.ruby.IncludedFileLocator;
+import depends.extractor.ruby.RubyHandlerContext;
+import depends.relations.Inferer;
+
+public class JRubyVisitor extends NoopVisitor {
+
+	private RubyHandlerContext context;
+	private EntityRepo entityRepo;
+	RubyParserHelper helper = new RubyParserHelper();
+	private ExpressionUsage expressionUsage;
+
+	public JRubyVisitor(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
+			ExecutorService executorService, Inferer inferer, ParserCreator parserCreator) {
+		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, inferer,parserCreator);
+		this.entityRepo = entityRepo;
+		expressionUsage = new ExpressionUsage(context, entityRepo, helper,inferer);
+		context.startFile(fileFullPath);
+	}
+
+
+	@Override
+	public Object visitAliasNode(AliasNode node) {
+		context.foundNewTypeAlias(node.getNewNameString(),
+				node.getOldNameString());
+		return super.visitAliasNode(node);
+	}
+	
+	@Override
+	public Object visitModuleNode(ModuleNode node) {
+		String name = helper.getName(node.getCPath());
+		context.foundNamespace(name);
+		super.visitModuleNode(node);
+		context.exitLastedEntity();
+		return null;
+	}
+
+	@Override
+	public Object visitClassNode(ClassNode node) {
+		context.foundNewType(node.getCPath().getName());
+		Node superNode = node.getSuper();
+		if (superNode instanceof ConstNode) {
+			String superName = ((ConstNode)superNode).getName();
+			context.foundExtends(superName);
+		}else if (superNode instanceof SymbolNode) {
+			String superName = ((SymbolNode)superNode).getName();
+			context.foundExtends(superName);
+		}else if (superNode instanceof Colon2ConstNode) {
+			Colon2ConstNode colon2ConstNode = (Colon2ConstNode)superNode;
+			String name1 = helper.getName(colon2ConstNode.getLeftNode());
+			String superName = colon2ConstNode.getName();
+			context.foundExtends(name1 + "."+superName);
+		}
+		
+		super.visitClassNode(node);
+		
+		context.exitLastedEntity();
+		return null;
+	}
+
+	
+	@Override
+	public Object visitRootNode(RootNode node) {
+		System.out.println(node);
+		return super.visitRootNode(node);
+	}
+
+	@Override
+	public Object visitFCallNode(FCallNode node) {
+		String fname  = helper.getName(node);
+		Collection<String> params = getParams(node);
+		context.processSpecialFuncCall(fname, params);
+		return super.visitFCallNode(node);
+	}
+
+
+	private Collection<String> getParams(IArgumentNode node) {
+		Node args = node.getArgs();
+		Collection<String> params = new ArrayList<>();
+		if (args instanceof ArrayNode) {
+			ArrayNode argArray = (ArrayNode)args;
+			for (Node arg:argArray.childNodes()) {
+				if (arg instanceof StrNode) {
+					params.add(((StrNode)arg).getValue());
+				}else if (arg instanceof ConstNode) {
+					params.add(((ConstNode)arg).getName());
+				}
+			}
+		}
+		return params;
+	}
+	
+	@Override
+	public Object visitCallNode(CallNode node) {
+		String fname  = helper.getName(node);
+		Collection<String> params = getParams(node);
+		context.processSpecialFuncCall(fname, params);
+		return super.visitCallNode(node);
+	}
+
+
+	@Override
+	public Object visitUnaryCallNode(UnaryCallNode node) {
+		String fname  = helper.getName(node);
+		Collection<String> params = new ArrayList<>();
+		context.processSpecialFuncCall(fname, params);
+		return super.visitUnaryCallNode(node);
+	}
+
+
+	@Override
+	public Object visitVCallNode(VCallNode node) {
+		String fname  = helper.getName(node);
+		Collection<String> params = new ArrayList<>();
+		context.processSpecialFuncCall(fname, params);
+		return super.visitVCallNode(node);
+	}
+	
+
+	@Override
+	public Object visitDefnNode(DefnNode node) {
+		context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
+
+		super.visitDefnNode(node);
+		context.exitLastedEntity();
+		return null;
+	}
+
+	@Override
+	public Object visitDefsNode(DefsNode node) {
+		//TODO: should add the method to the concrete variable
+		//
+		context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
+		super.visitDefsNode(node);
+		context.exitLastedEntity();
+		return null;
+	}
+
+
+	@Override
+	public Object visitGlobalVarNode(GlobalVarNode node) {
+		// TODO Auto-generated method stub
+		return super.visitGlobalVarNode(node);
+	}
+
+
+	@Override
+	public Object visitInstVarNode(InstVarNode node) {
+		// TODO Auto-generated method stub
+		return super.visitInstVarNode(node);
+	}
+
+
+	@Override
+	public Object visitLocalVarNode(LocalVarNode node) {
+		//System.out.println("visitLocalVarNode"+node.getName());
+		return super.visitLocalVarNode(node);
+	}
+
+
+	@Override
+	public Object visitDVarNode(DVarNode node) {
+		// TODO Auto-generated method stub
+		return super.visitDVarNode(node);
+	}
+
+
+	@Override
+	public Object visitDAsgnNode(DAsgnNode node) {
+		// TODO Auto-generated method stub
+		return super.visitDAsgnNode(node);
+	}
+
+
+	@Override
+	public Object visitGlobalAsgnNode(GlobalAsgnNode node) {
+		// TODO Auto-generated method stub
+		return super.visitGlobalAsgnNode(node);
+	}
+
+
+	@Override
+	public Object visitInstAsgnNode(InstAsgnNode node) {
+		// TODO Auto-generated method stub
+		return super.visitInstAsgnNode(node);
+	}
+
+
+	@Override
+	public Object visitLocalAsgnNode(LocalAsgnNode node) {
+		//System.out.println("visitLocalAsgnNode"+node.getName());
+		Node right = node.getValue();
+		return super.visitLocalAsgnNode(node);
+	}
+
+	@Override
+	protected Object visit(Node node) {
+		expressionUsage.foundExpression(node);
+		return super.visit(node);
+	}
+
+}

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -6,9 +6,11 @@ import java.io.IOException;
 import java.util.ArrayList;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.extractor.FileParser;
 import depends.relations.Relation;
 
 public class RubyInheritTest extends RubyParserTest {
@@ -23,7 +25,7 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -41,7 +43,7 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -59,7 +61,7 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -76,7 +78,7 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -93,7 +95,7 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -103,15 +105,14 @@ public class RubyInheritTest extends RubyParserTest {
         assertEquals("Zoo.Animal",r.getEntity().getQualifiedName());
 	}
 	
-	
-	@Test
+	@Ignore
 	public void test_relation_with_alias() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/ruby-code-examples/extends_with_alias.rb",
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -3,12 +3,12 @@ package depends.extractor.ruby;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
-import java.util.ArrayList;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.extractor.FileParser;
 import depends.relations.Relation;
 
 public class RubyMixinTest extends RubyParserTest {
@@ -23,7 +23,7 @@ public class RubyMixinTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -0,0 +1,37 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.extractor.FileParser;
+import depends.relations.Relation;
+
+public class RubyObjectCreationTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test_relation() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/object_creation.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("T.foo").getRelations().size());
+        Relation r = entityRepo.getEntity("T.foo").getRelations().get(0);
+        assertEquals(DependencyType.INHERIT,r.getType());
+        assertEquals("Animal",r.getEntity().getRawName());
+	}
+	
+
+}

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -6,9 +6,11 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.extractor.ParserCreator;
+import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
-
-public abstract class RubyParserTest {
+public abstract class RubyParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
 
@@ -17,9 +19,9 @@ public abstract class RubyParserTest {
 		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType());
 	}
 	
-	public RubyFileParser createParser(String src) {
+	public FileParser createFileParser(String src) {
 		ExecutorService executor = Executors.newSingleThreadExecutor();
-		return new RubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()), inferer);
+		return new JRubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()), inferer, this);
 	}
 
 	private List<String> includePaths() {

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -8,6 +8,8 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.extractor.FileParser;
+
 public class RubyRequireTest extends RubyParserTest {
 	@Before
 	public void setUp() {
@@ -21,7 +23,7 @@ public class RubyRequireTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -1,7 +1,6 @@
 package depends.extractor.ruby;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
 
@@ -9,6 +8,9 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.FileEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+import depends.relations.Inferer;
 import depends.util.FileUtil;
 
 public class RubyVarTest extends RubyParserTest {
@@ -23,13 +25,15 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    RubyFileParser parser = createParser(src);
+		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
         FileEntity f = (FileEntity) (entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
         assertEquals(1,f.getVars().size());
-        assertEquals("var_1",f.getVars().get(0).getRawName());
+        VarEntity var = f.getVars().get(0);
+		assertEquals("var_1",var.getRawName());
+		assertEquals(Inferer.buildInType,var.getType());
 	}
 	
 }

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -51,15 +51,15 @@ public abstract class Entity {
 			this.qualifiedName = this.rawName;
 			return;
 		}
-		if (parent.getQualifiedName()==null) {
+		if (parent.getQualifiedName(true)==null) {
 			this.qualifiedName = this.rawName;
 			return;
 		}
-		if (parent.getQualifiedName().isEmpty()) {
+		if (parent.getQualifiedName(true).isEmpty()) {
 			this.qualifiedName = rawName;
 			return;
 		}
-		this.qualifiedName= parent.getQualifiedName()+"." + rawName;
+		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName;
 		if (rawName.startsWith(".")) {
 			rawName = rawName.substring(2);
 		}
@@ -106,7 +106,11 @@ public abstract class Entity {
 		this.rawName = rawName;
 	}
 	
-	public String getQualifiedName() {
+	public final String getQualifiedName() {
+		return qualifiedName;
+	}
+
+	public String getQualifiedName(boolean overrideFileWithPackage) {
 		return qualifiedName;
 	}
 

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -39,17 +39,21 @@ public class FileEntity extends ContainerEntity {
 		if (!lastName.startsWith("."))
 			lastName = "." + lastName;
 		for (Entity imported : this.importedTypes) {
-			String name = imported.getQualifiedName();
+			String name = imported.getQualifiedName(true);
 			if (!name.startsWith("."))
 				name = "." + name;
-			if (imported.getQualifiedName().endsWith(lastName))
-				return imported.getQualifiedName();
+			if (imported.getQualifiedName(true).endsWith(lastName))
+				return imported.getQualifiedName(true);
 		}
 		return null;
 	}
 	
+
 	@Override
-	public String getQualifiedName() {
+	public String getQualifiedName(boolean overrideFileWithPackage) {
+		if (!overrideFileWithPackage) {
+			return super.getQualifiedName();
+		}
 		if (this.getParent() == null) {
 			return "";
 		}

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -65,10 +65,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
-        Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
-        assertEquals(DependencyType.INHERIT,r.getType());
-        assertEquals("Animal",r.getEntity().getQualifiedName());
+	    super.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
 	}
 	
 	@Test
@@ -82,10 +79,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("ZooCat").getRelations().size());
-        Relation r = entityRepo.getEntity("ZooCat").getRelations().get(0);
-        assertEquals(DependencyType.INHERIT,r.getType());
-        assertEquals("Zoo.Animal",r.getEntity().getQualifiedName());
+	    super.assertContainsRelation(entityRepo.getEntity("ZooCat"), DependencyType.INHERIT, "Zoo.Animal");
 	}
 	
 	@Test

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -1,6 +1,7 @@
 package depends.extractor.ruby;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import java.io.IOException;
 
@@ -8,6 +9,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.entity.Entity;
 import depends.extractor.FileParser;
 import depends.relations.Relation;
 
@@ -27,9 +29,8 @@ public class RubyMixinTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("MixedIn").getRelations().size());
-        Relation r = entityRepo.getEntity("MixedIn").getRelations().get(0);
-        assertEquals(DependencyType.MIXIN,r.getType());
-        assertEquals("ToBeMixin",r.getEntity().getRawName());
+	    assertContainsRelation(entityRepo.getEntity("MixedIn"),DependencyType.MIXIN,"ToBeMixin");
+
 	}
+
 }

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -1,7 +1,5 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
-
 import java.io.IOException;
 
 import org.junit.Before;
@@ -9,7 +7,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.extractor.FileParser;
-import depends.relations.Relation;
 
 public class RubyObjectCreationTest extends RubyParserTest {
 	@Before
@@ -27,10 +24,7 @@ public class RubyObjectCreationTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("T.foo").getRelations().size());
-        Relation r = entityRepo.getEntity("T.foo").getRelations().get(0);
-        assertEquals(DependencyType.INHERIT,r.getType());
-        assertEquals("Animal",r.getEntity().getRawName());
+	    super.assertContainsRelation(entityRepo.getEntity("T.foo"), DependencyType.INHERIT, "Animal");
 	}
 	
 

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -1,15 +1,21 @@
 package depends.extractor.ruby;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
+import depends.relations.Relation;
 public abstract class RubyParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
@@ -27,4 +33,20 @@ public abstract class RubyParserTest implements ParserCreator{
 	private List<String> includePaths() {
 		return new ArrayList<>();
 	}
+	
+	protected void assertContainsRelation(Entity inEntity, String dependencyType, String dependedEntityFullName) {
+		Relation relation = null;
+		for (Relation r:inEntity.getRelations()) {
+			if (r.getType().equals(dependencyType)) {
+				relation = r;
+				if (r.getEntity().getQualifiedName().equals(dependedEntityFullName))
+					return;
+			}
+		}
+		if (relation==null) {
+			fail("cannot found relation type of "+ dependencyType);
+		}else {
+			fail("cannot found relation type of " + dependencyType + " to entity " + dependedEntityFullName);
+		}
+	}
 }

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -8,6 +8,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.extractor.FileParser;
 
 public class RubyRequireTest extends RubyParserTest {
@@ -28,6 +29,8 @@ public class RubyRequireTest extends RubyParserTest {
 	    }
 	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals(2,entityRepo.getEntity(f.getCanonicalPath()).getRelations().size());
+        File f2 = new File(srcs[1]);
+        
+        super.assertContainsRelation(entityRepo.getEntity(f.getCanonicalPath()), DependencyType.IMPORT, f2.getCanonicalPath());
 	}
 }

b64d132343eae650f4f35572c89abbd9ed1d96ff
@@ -0,0 +1,24 @@
+package depends.extractor;
+
+import static org.junit.Assert.fail;
+
+import depends.entity.Entity;
+import depends.relations.Relation;
+
+public abstract class ParserTest {
+	protected void assertContainsRelation(Entity inEntity, String dependencyType, String dependedEntityFullName) {
+		Relation relation = null;
+		for (Relation r:inEntity.getRelations()) {
+			if (r.getType().equals(dependencyType)) {
+				relation = r;
+				if (r.getEntity().getQualifiedName().equals(dependedEntityFullName))
+					return;
+			}
+		}
+		if (relation==null) {
+			fail("cannot found relation type of "+ dependencyType);
+		}else {
+			fail("cannot found relation type of " + dependencyType + " to entity " + dependedEntityFullName);
+		}
+	}
+}

b64d132343eae650f4f35572c89abbd9ed1d96ff
@@ -24,7 +24,7 @@ public class RubyObjectCreationTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    super.assertContainsRelation(entityRepo.getEntity("T.foo"), DependencyType.INHERIT, "Animal");
+	    super.assertContainsRelation(entityRepo.getEntity("T.foo"), DependencyType.CREATE, "M");
 	}
 	
 

b64d132343eae650f4f35572c89abbd9ed1d96ff
@@ -1,6 +1,5 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
@@ -8,15 +7,15 @@ import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
+import depends.extractor.ParserTest;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
 import depends.relations.Relation;
-public abstract class RubyParserTest implements ParserCreator{
+public abstract class RubyParserTest extends ParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
 
@@ -34,19 +33,5 @@ public abstract class RubyParserTest implements ParserCreator{
 		return new ArrayList<>();
 	}
 	
-	protected void assertContainsRelation(Entity inEntity, String dependencyType, String dependedEntityFullName) {
-		Relation relation = null;
-		for (Relation r:inEntity.getRelations()) {
-			if (r.getType().equals(dependencyType)) {
-				relation = r;
-				if (r.getEntity().getQualifiedName().equals(dependedEntityFullName))
-					return;
-			}
-		}
-		if (relation==null) {
-			fail("cannot found relation type of "+ dependencyType);
-		}else {
-			fail("cannot found relation type of " + dependencyType + " to entity " + dependedEntityFullName);
-		}
-	}
+
 }

688be131883243dadff572e351c0bc4a04e2ab88
@@ -7,7 +7,6 @@ import depends.relations.Inferer;
 
 public class Expression {
 	public Integer id;
-	public Integer parentId;
 	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;
 	private List<Expression> deduceTypeChildren = new ArrayList<>();
@@ -38,9 +37,8 @@ public class Expression {
 		deduceParentType(inferer);
 	}
 	
-	public Expression(Integer id, Integer parentId) {
+	public Expression(Integer id) {
 		this.id = id;
-		this.parentId = parentId;
 	}
 
 	@Override

688be131883243dadff572e351c0bc4a04e2ab88
@@ -8,14 +8,43 @@ import java.util.Set;
 
 import org.codehaus.plexus.util.FileUtils;
 
+import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.DependencyGenerator;
 import depends.matrix.DependencyMatrix;
+import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import depends.util.FileTraversal;
+import depends.util.FileUtil;
 abstract public class AbstractLangProcessor {
+	/**
+	 * The name of the lang
+	 * @return
+	 */
 	public abstract String supportedLanguage();
+	/**
+	 * The file suffixes in the lang
+	 * @return
+	 */
 	public abstract String[] fileSuffixes();
+
+	/**
+	 * Strategy of how to lookup  types and entities in the lang.
+	 * @return
+	 */
+	public abstract ImportLookupStrategy getImportLookupStrategy();
+	/**
+	 * The builtInType of the lang. 
+	 * @return
+	 */
+	public abstract BuiltInType getBuiltInType();
+	/**
+	 * The language specific file parser
+	 * @param fileFullPath
+	 * @return
+	 */
+    protected abstract FileParser createFileParser(String fileFullPath);
+
 	protected Inferer inferer;
 	protected EntityRepo entityRepo;
 	DependencyMatrix dependencyMatrix;
@@ -27,25 +56,27 @@ abstract public class AbstractLangProcessor {
 		entityRepo = new EntityRepo();
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
+		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType());
 	}
 	
-    
-	public void work() {
+    /**
+     * The process steps of build dependencies.
+     * Step 1: parse all files, add entities and expression into repositories
+     * Step 2: resolve bindings of files (if not resolved yet)
+     * Step 3: identify dependencies 
+     */
+	public void buildDependencies() {
         parseAllFiles();
         resolveBindings();
         identifyDependencies();
 	}
 
-	/**
-	 * Errors during all execution steps. could be extend as several methods in future
-	 * @return
-	 */
-	public abstract List<String> getErrors();
+
 	/**
 	 * 
 	 * @return unsolved bindings
  	 */
-    protected void resolveBindings() {
+    private void resolveBindings() {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
         Set<String> unsolved = inferer.resolveAllBindings();
         if (unsolved.size()>0)
@@ -65,9 +96,11 @@ abstract public class AbstractLangProcessor {
     	FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor(){
 			@Override
 			public void visit(File file) {
-	            FileParser fileParser = createFileParser(file.getAbsolutePath());
+				String fileFullPath = file.getAbsolutePath();
+				fileFullPath = FileUtil.uniqFilePath(fileFullPath);
+	            FileParser fileParser = createFileParser(fileFullPath);
 	            try {
-	                System.out.println("parsing " + file.getAbsolutePath() 
+	                System.out.println("parsing " + fileFullPath 
 	                		+ "...");		
 	                fileParser.parse();
 	            } catch (IOException e) {
@@ -82,7 +115,6 @@ abstract public class AbstractLangProcessor {
 
 	}
     
-    protected abstract FileParser createFileParser(String fileFullPath);
 
 	public List<String> includePaths() {
 		ArrayList<String> r = new ArrayList<String>();

688be131883243dadff572e351c0bc4a04e2ab88
@@ -153,14 +153,14 @@ public abstract class HandlerContext {
 	}
 
 
-	public void foundVarDefinition(List<String> varNames, String type, List<String> typeArguments) {
+	public void foundVarDefinitions(List<String> varNames, String type, List<String> typeArguments) {
 		for (String varName : varNames) {
-			foundVarDefintion(varName,type,typeArguments);
+			foundVarDefinition(varName,type,typeArguments);
 		}
 	}
 
 
-	public void foundVarDefintion(String varName, String type, List<String> typeArguments) {
+	public void foundVarDefinition(String varName, String type, List<String> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);		
@@ -168,7 +168,7 @@ public abstract class HandlerContext {
 
 	public void foundEnumConstDefinition(String varName) {
 		String type = lastContainer().getRawName();
-		foundVarDefintion(varName,type,new ArrayList<>());
+		foundVarDefinition(varName,type,new ArrayList<>());
 	}
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();

688be131883243dadff572e351c0bc4a04e2ab88
@@ -1,13 +1,11 @@
 package depends.extractor.cpp;
 
-import java.util.ArrayList;
-import java.util.List;
-
+import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
-import depends.relations.Inferer;
+import depends.relations.ImportLookupStrategy;
 
 public class CppProcessor extends AbstractLangProcessor {
     private static final String LANG = "cpp";
@@ -15,8 +13,6 @@ public class CppProcessor extends AbstractLangProcessor {
     PreprocessorHandler preprocessorHandler;
     public CppProcessor(String inputDir, String[] includeDir) {
     	super(inputDir,includeDir);
-    	preprocessorHandler = new PreprocessorHandler(super.includePaths());
-		inferer = new Inferer(entityRepo,new CppImportLookupStrategy(),new CppBuiltInType());
     }
 
 
@@ -33,11 +29,18 @@ public class CppProcessor extends AbstractLangProcessor {
 
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
+    	preprocessorHandler = new PreprocessorHandler(super.includePaths());
 		return new CdtCppFileParser(fileFullPath,entityRepo,preprocessorHandler,inferer);
-		//return new Antlr4CppFileParser(fileFullPath,entityRepo,super.includePaths());
 	}
 
-	public List<String> getErrors(){
-		return new ArrayList<String>(preprocessorHandler.getNotExistedIncludedFiles());
+	@Override
+	public ImportLookupStrategy getImportLookupStrategy() {
+		return new CppImportLookupStrategy();
+	}
+
+
+	@Override
+	public BuiltInType getBuiltInType() {
+		return new CppBuiltInType();
 	}
 }

688be131883243dadff572e351c0bc4a04e2ab88
@@ -25,7 +25,7 @@ public class ExpressionUsage {
 
 	public void foundCallExpressionOfFunctionStyle(String functionName, IASTDeclarator declarator) {
 		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId(),null);
+		Expression expression = new Expression(idGenerator.generateId());
 		context.lastContainer().addExpression(declarator,expression);
 		expression.isCall = true;
 		expression.identifier = functionName;
@@ -34,7 +34,7 @@ public class ExpressionUsage {
 	public void foundExpression(IASTExpression ctx) {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		Expression expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
 		context.lastContainer().addExpression(ctx,expression);
 

688be131883243dadff572e351c0bc4a04e2ab88
@@ -37,13 +37,13 @@ import depends.extractor.java.JavaParser.TypeParameterContext;
 import depends.extractor.java.JavaParser.TypeParametersContext;
 import depends.extractor.java.JavaParserBaseListener;
 
-public class JavaEntitiesListener extends JavaParserBaseListener {
+public class JavaListener extends JavaParserBaseListener {
 	private JavaHandlerContext context;
 	private AnnotationProcessor annotationProcessor;
 	private ExpressionUsage expressionUsage;
 	private EntityRepo entityRepo;
 
-	public JavaEntitiesListener(String fileFullPath, EntityRepo entityRepo) {
+	public JavaListener(String fileFullPath, EntityRepo entityRepo) {
 		this.context = new JavaHandlerContext(entityRepo);
 		this.entityRepo = entityRepo;
 		annotationProcessor = new AnnotationProcessor(context);
@@ -225,7 +225,7 @@ public class JavaEntitiesListener extends JavaParserBaseListener {
 		List<String> varNames = VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators());
 		String type = ClassTypeContextHelper.getClassName(ctx.typeType());
 		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinition(varNames, type,typeArguments);
+		context.foundVarDefinitions(varNames, type,typeArguments);
 		annotationProcessor.processAnnotationModifier(ctx, "classBodyDeclaration");
 		super.enterFieldDeclaration(ctx);
 	}
@@ -233,7 +233,7 @@ public class JavaEntitiesListener extends JavaParserBaseListener {
 	@Override
 	public void enterConstDeclaration(ConstDeclarationContext ctx) {
 		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinition(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
+		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		annotationProcessor.processAnnotationModifier(ctx, "interfaceBodyDeclaration");
 		super.enterConstDeclaration(ctx);
@@ -262,7 +262,7 @@ public class JavaEntitiesListener extends JavaParserBaseListener {
 	@Override
 	public void enterAnnotationConstantRest(AnnotationConstantRestContext ctx) {
 		// TODO: no variable type defined in annotation const？
-		context.foundVarDefinition(VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators()), "",new ArrayList<>());
+		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators()), "",new ArrayList<>());
 		super.enterAnnotationConstantRest(ctx);
 	}
 
@@ -272,14 +272,14 @@ public class JavaEntitiesListener extends JavaParserBaseListener {
 	@Override
 	public void enterLocalVariableDeclaration(LocalVariableDeclarationContext ctx) {
 		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinition(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
+		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		super.enterLocalVariableDeclaration(ctx);
 	}
 
 	public void enterEnhancedForControl(EnhancedForControlContext ctx) {
 		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinition(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
+		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		super.enterEnhancedForControl(ctx);
 	}
@@ -290,7 +290,7 @@ public class JavaEntitiesListener extends JavaParserBaseListener {
 	@Override
 	public void enterResource(ResourceContext ctx) {
 		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
-		context.foundVarDefintion(ctx.variableDeclaratorId().IDENTIFIER().getText(),
+		context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
 				IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER()),typeArguments);
 		super.enterResource(ctx);
 	}

688be131883243dadff572e351c0bc4a04e2ab88
@@ -1,11 +1,9 @@
 package depends.extractor.java;
 
-import java.util.ArrayList;
-import java.util.List;
-
+import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
-import depends.relations.Inferer;
+import depends.relations.ImportLookupStrategy;
 
 public class JavaProcessor extends AbstractLangProcessor {
     private static final String JAVA_LANG = "java";
@@ -13,28 +11,30 @@ public class JavaProcessor extends AbstractLangProcessor {
     
     public JavaProcessor(String inputDir, String[] includeDir) {
     	super(inputDir,includeDir);
-		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(),new JavaBuiltInType());
     }
-
+    
 	@Override
 	public String supportedLanguage() {
 		return JAVA_LANG;
 	}
-
+	
 	@Override
 	public String[] fileSuffixes() {
 		return new String[] {JAVA_SUFFIX};
 	}
-
-
+	
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
 		return new JavaFileParser(fileFullPath,entityRepo, inferer);
 	}
-
-
+	
+	@Override
+	public ImportLookupStrategy getImportLookupStrategy() {
+		return new JavaImportLookupStrategy();
+	}
+	
 	@Override
-	public List<String> getErrors() {
-		return new ArrayList<String>();
+	public BuiltInType getBuiltInType() {
+		return new JavaBuiltInType();
 	}
 }

688be131883243dadff572e351c0bc4a04e2ab88
@@ -20,7 +20,7 @@ public class ExpressionUsage {
 	public void foundExpression(ExpressionContext ctx) {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		Expression expression = new Expression(idGenerator.generateId());
 		context.lastContainer().addExpression(ctx,expression);
 
 		expression.text = ctx.getText(); //for debug purpose. no actual effect

688be131883243dadff572e351c0bc4a04e2ab88
@@ -1,27 +1,21 @@
 package depends.extractor.ruby;
 
-import java.util.ArrayList;
-import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
+import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
-import depends.extractor.ruby.antlr.RubyFileAntlrParser;
 import depends.extractor.ruby.jruby.JRubyFileParser;
-import depends.relations.Inferer;
+import depends.relations.ImportLookupStrategy;
 
 public class RubyProcessor extends AbstractLangProcessor implements ParserCreator{
     private static final String LANG = "ruby";
     private static final String[] SUFFIX = new String[] {".rb"};
-    IncludedFileLocator preprocessorHandler;
 	private ExecutorService executor;
-    public RubyProcessor(String inputDir, String[] includeDir) {
-    	super(inputDir,includeDir);
-    	preprocessorHandler = new IncludedFileLocator(super.includePaths());
-		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType());
-		executor = Executors.newSingleThreadExecutor();
+    public RubyProcessor(String inputDir, String[] includeDirs) {
+    	super(inputDir,includeDirs);
     }
 
 
@@ -38,12 +32,8 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 
 	@Override
 	public FileParser createFileParser(String fileFullPath) {
-//		return new RubyFileAntlrParser(fileFullPath,entityRepo,executor,preprocessorHandler,inferer,this);
-		return new JRubyFileParser(fileFullPath,entityRepo,executor,preprocessorHandler,inferer,this);
-	}
-
-	public List<String> getErrors(){
-		return new ArrayList<String>();
+		executor = Executors.newSingleThreadExecutor();
+		return new JRubyFileParser(fileFullPath,entityRepo,executor,new IncludedFileLocator(super.includePaths()),inferer,this);
 	}
 
 
@@ -52,5 +42,16 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 		this.executor.shutdown();
 		super.finalize();
 	}
+
+	@Override
+	public ImportLookupStrategy getImportLookupStrategy() {
+		return new RubyImportLookupStrategy();
+	}
+
+
+	@Override
+	public BuiltInType getBuiltInType() {
+		return new RubyBuiltInType();
+	}
 	
 }

688be131883243dadff572e351c0bc4a04e2ab88
@@ -1,98 +0,0 @@
-package depends.extractor.ruby.antlr;
-
-import org.antlr.v4.runtime.ParserRuleContext;
-import org.antlr.v4.runtime.RuleContext;
-
-import depends.entity.Expression;
-import depends.entity.repo.IdGenerator;
-import depends.extractor.HandlerContext;
-import depends.extractor.ruby.RubyParser.ExprAssignContext;
-import depends.extractor.ruby.RubyParser.ExprBatchAssignContext;
-import depends.extractor.ruby.RubyParser.ExprContext;
-import depends.extractor.ruby.RubyParser.ExprListContext;
-import depends.extractor.ruby.RubyParser.ExprPrimaryContext;
-import depends.extractor.ruby.RubyParser.PrimaryVarPathContext;
-import depends.extractor.ruby.RubyParser.VarPathLiteralContext;
-import depends.extractor.ruby.RubyParser.Variable_pathContext;
-import depends.relations.Inferer;
-
-public class ExpressionUsage {
-	HandlerContext context;
-	IdGenerator idGenerator;
-	private RubyParserHelper helper;
-	Inferer inferer;
-	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator, RubyParserHelper helper,Inferer inferer) {
-		this.context = context;
-		this.idGenerator = idGenerator;
-		this.helper = helper;
-		this.inferer = inferer;
-	}
-	public Expression foundExpression(ParserRuleContext ctx) {
-		Expression expression = findExpression(ctx);
-		if (expression!=null) return expression;
-		Expression parent = findParentInStack(ctx);
-		System.out.println("expr " + ctx.getText());
-		/* create expression and link it with parent*/
-		expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
-		expression.parent = parent;
-		expression.text = ctx.getText();
-		if (expression.parent!=null) {
-			if (expression.parent.deduceTypeBasedId==null) 
-				expression.parent.deduceTypeBasedId = expression.id;
-			/* Set operation always use the 2nd expr's type*/
-			if (expression.parent.isSet) {
-				expression.parent.deduceTypeBasedId = expression.id;
-				parent.addDeduceTypeChild(expression);
-			}
-		}
-		context.lastContainer().addExpression(ctx,expression);
-		if (ctx instanceof PrimaryVarPathContext) {
-			Variable_pathContext variable_path = ((PrimaryVarPathContext)ctx).variable_path();
-			expression.identifier = helper.getName(variable_path);
-			if (variable_path instanceof VarPathLiteralContext) {
-				expression.rawType =Inferer.buildInType.getDisplayName();
-			}else  {
-				//to be deduced
-			}
-		}
-		if (ctx instanceof ExprBatchAssignContext) {
-			expression.isSet = true;
-  		    ExprContext left = ((ExprBatchAssignContext) ctx).expr(0);
-			ExprContext right = ((ExprBatchAssignContext) ctx).expr(1);
-			if (left instanceof ExprListContext) {
-				
-			}else if (left instanceof ExprPrimaryContext) {
-				expression.identifier = helper.getName(((ExprPrimaryContext)left).primary());
-				expression.rawType = null;//need deduce from right type
-				expression.autoVar = true;
-			}
-		}
-		if (ctx instanceof ExprAssignContext) {
-			expression.isSet = true;
-		}
-		if (ctx instanceof ExprPrimaryContext) {
-			
-		}
-		return expression;
-	}
-	
-	private Expression findParentInStack(RuleContext ctx) {
-		if (ctx==null) return null;
-		if (ctx.getParent()==null) return null;
-		if (context.lastContainer()==null) {
-			return null;
-		}
-		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
-		return findParentInStack(ctx.getParent());
-	}
-	
-	private Expression findExpression(RuleContext ctx) {
-		if (ctx==null) return null;
-		if (ctx.getParent()==null) return null;
-		if (context.lastContainer()==null) {
-			return null;
-		}
-		return context.lastContainer().expressions().get(ctx.getParent());
-	}
-
-}
\ No newline at end of file

688be131883243dadff572e351c0bc4a04e2ab88
@@ -42,7 +42,7 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		System.out.println("expr " + ctx.toString());
 		/* create expression and link it with parent*/
-		expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		expression = new Expression(idGenerator.generateId());
 		expression.parent = parent;
 		if (expression.parent!=null) {
 			if (expression.parent.deduceTypeBasedId==null) 

688be131883243dadff572e351c0bc4a04e2ab88
@@ -17,7 +17,6 @@ import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
-import depends.extractor.ruby.antlr.RubyFileAntlrParser;
 import depends.relations.Inferer;
 import depends.util.FileUtil;
 public class JRubyFileParser implements FileParser {

9c9690c06347324221b0a726098d00d255fe4d51
@@ -9,7 +9,7 @@ import depends.relations.ImportLookupStrategy;
 
 public class CppProcessor extends AbstractLangProcessor {
     private static final String LANG = "cpp";
-    private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh"};
+    private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh", ".cxx",".hxx"};
     PreprocessorHandler preprocessorHandler;
     public CppProcessor(String inputDir, String[] includeDir) {
     	super(inputDir,includeDir);

42fd7d1bfcfc8b61ab413b1ee32ae5ec409195c4
@@ -158,13 +158,27 @@ public abstract class HandlerContext {
 			foundVarDefinition(varName,type,typeArguments);
 		}
 	}
-
+	
+	public void foundVarDefinition(ContainerEntity container,String varName) {
+		if (container==null) {
+			System.err.println("potentail error:" + varName + " has no container");
+			return;
+		}
+		VarEntity var = new VarEntity(varName, null, container, idGenerator.generateId());
+		container.addVar(var);
+	}
 
 	public void foundVarDefinition(String varName, String type, List<String> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);		
 	}
+	
+	public void addMethodParameter(String paramName) {
+		if (currentFunction()==null) return;
+		VarEntity varEntity = new VarEntity(paramName,null,currentFunction(),idGenerator.generateId());
+		currentFunction().addParameter(varEntity);		
+	}
 
 	public void foundEnumConstDefinition(String varName) {
 		String type = lastContainer().getRawName();

42fd7d1bfcfc8b61ab413b1ee32ae5ec409195c4
@@ -40,7 +40,7 @@ public class ExpressionUsage {
 		Expression expression = findExpression(ctx);
 		if (expression!=null) return expression;
 		Expression parent = findParentInStack(ctx);
-		System.out.println("expr " + ctx.toString());
+		//System.out.println("expr " + ctx.toString());
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
 		expression.parent = parent;

42fd7d1bfcfc8b61ab413b1ee32ae5ec409195c4
@@ -5,9 +5,13 @@ import java.util.Collection;
 import java.util.concurrent.ExecutorService;
 
 import org.jrubyparser.ast.AliasNode;
+import org.jrubyparser.ast.ArgumentNode;
 import org.jrubyparser.ast.ArrayNode;
 import org.jrubyparser.ast.CallNode;
 import org.jrubyparser.ast.ClassNode;
+import org.jrubyparser.ast.ClassVarAsgnNode;
+import org.jrubyparser.ast.ClassVarDeclNode;
+import org.jrubyparser.ast.ClassVarNode;
 import org.jrubyparser.ast.Colon2ConstNode;
 import org.jrubyparser.ast.ConstNode;
 import org.jrubyparser.ast.DAsgnNode;
@@ -18,7 +22,6 @@ import org.jrubyparser.ast.FCallNode;
 import org.jrubyparser.ast.GlobalAsgnNode;
 import org.jrubyparser.ast.GlobalVarNode;
 import org.jrubyparser.ast.IArgumentNode;
-import org.jrubyparser.ast.INameNode;
 import org.jrubyparser.ast.InstAsgnNode;
 import org.jrubyparser.ast.InstVarNode;
 import org.jrubyparser.ast.LocalAsgnNode;
@@ -32,6 +35,7 @@ import org.jrubyparser.ast.UnaryCallNode;
 import org.jrubyparser.ast.VCallNode;
 import org.jrubyparser.util.NoopVisitor;
 
+import depends.entity.ContainerEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
@@ -40,15 +44,15 @@ import depends.relations.Inferer;
 
 public class JRubyVisitor extends NoopVisitor {
 
+
+
 	private RubyHandlerContext context;
-	private EntityRepo entityRepo;
 	RubyParserHelper helper = new RubyParserHelper();
 	private ExpressionUsage expressionUsage;
 
 	public JRubyVisitor(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
 			ExecutorService executorService, Inferer inferer, ParserCreator parserCreator) {
 		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, inferer,parserCreator);
-		this.entityRepo = entityRepo;
 		expressionUsage = new ExpressionUsage(context, entityRepo, helper,inferer);
 		context.startFile(fileFullPath);
 	}
@@ -155,7 +159,6 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitDefnNode(DefnNode node) {
 		context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
-
 		super.visitDefnNode(node);
 		context.exitLastedEntity();
 		return null;
@@ -185,24 +188,43 @@ public class JRubyVisitor extends NoopVisitor {
 		return super.visitInstVarNode(node);
 	}
 
+	@Override
+	public Object visitClassVarAsgnNode(ClassVarAsgnNode node) {
+		foundVar(context.currentType(),node.getName());
+		return super.visitClassVarAsgnNode(node);
+	}
+
 
+	@Override
+	public Object visitClassVarDeclNode(ClassVarDeclNode node) {
+		foundVar(context.currentType(),node.getName());
+		return super.visitClassVarDeclNode(node);
+	}
+
+
+	@Override
+	public Object visitClassVarNode(ClassVarNode node) {
+		foundVar(context.currentType(),node.getName());
+		return super.visitClassVarNode(node);
+	}
+	
 	@Override
 	public Object visitLocalVarNode(LocalVarNode node) {
-		//System.out.println("visitLocalVarNode"+node.getName());
+		System.out.println("visitLocalVarNode"+node.getName());
 		return super.visitLocalVarNode(node);
 	}
 
 
 	@Override
 	public Object visitDVarNode(DVarNode node) {
-		// TODO Auto-generated method stub
+		foundVar(context.lastContainer(),node.getName());
 		return super.visitDVarNode(node);
 	}
 
 
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
-		// TODO Auto-generated method stub
+		foundVar(context.lastContainer(),node.getName());
 		return super.visitDAsgnNode(node);
 	}
 
@@ -216,15 +238,22 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitInstAsgnNode(InstAsgnNode node) {
-		// TODO Auto-generated method stub
+		foundVar(context.currentType(),node.getName());
 		return super.visitInstAsgnNode(node);
 	}
 
 
+	@Override
+	public Object visitArgumentNode(ArgumentNode node) {
+		String paramName = node.getName();
+		context.addMethodParameter(paramName);
+		return super.visitArgumentNode(node);
+	}
+
+
 	@Override
 	public Object visitLocalAsgnNode(LocalAsgnNode node) {
-		//System.out.println("visitLocalAsgnNode"+node.getName());
-		Node right = node.getValue();
+		foundVar(context.lastContainer(),node.getName());
 		return super.visitLocalAsgnNode(node);
 	}
 
@@ -233,5 +262,11 @@ public class JRubyVisitor extends NoopVisitor {
 		expressionUsage.foundExpression(node);
 		return super.visit(node);
 	}
+	
+	private void foundVar(ContainerEntity container,String varName ) {
+		if (!context.isNameExist(varName)) {
+			context.foundVarDefinition(container,varName);
+		}
+	}
 
 }

42fd7d1bfcfc8b61ab413b1ee32ae5ec409195c4
@@ -2,7 +2,13 @@ package depends.extractor;
 
 import static org.junit.Assert.fail;
 
+import java.util.ArrayList;
+import java.util.Collection;
+
+import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.FunctionEntity;
+import depends.entity.VarEntity;
 import depends.relations.Relation;
 
 public abstract class ParserTest {
@@ -21,4 +27,26 @@ public abstract class ParserTest {
 			fail("cannot found relation type of " + dependencyType + " to entity " + dependedEntityFullName);
 		}
 	}
+	
+	protected void assertContainsVarWithRawName(Entity entity, String name) {
+	    ContainerEntity container = (ContainerEntity)entity;
+		ArrayList<VarEntity> vars = container.getVars();
+	    for (VarEntity var:vars) {
+	    	if (var.getRawName().equals(name)) {
+	    		return;
+	    	}
+	    }
+	    fail("cannot found var with rawname " + name);
+	}
+	
+	protected void assertContainsParametersWithRawName(FunctionEntity function, String name) {
+		Collection<VarEntity> vars = function.getParameters();
+	    for (VarEntity var:vars) {
+	    	if (var.getRawName().equals(name)) {
+	    		return;
+	    	}
+	    }
+	    fail("cannot found parameter with rawname " + name);		
+	}
+
 }

42fd7d1bfcfc8b61ab413b1ee32ae5ec409195c4
@@ -7,17 +7,33 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.FileEntity;
-import depends.entity.VarEntity;
+import depends.entity.ContainerEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
 import depends.extractor.FileParser;
-import depends.relations.Inferer;
-import depends.util.FileUtil;
 
 public class RubyVarTest extends RubyParserTest {
 	@Before
 	public void setUp() {
 		super.init();
 	}
+	
+	@Test
+	public void test_parameter_should_be_created() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method1"));
+	    assertEquals(1,function.getParameters().size());
+	    assertContainsParametersWithRawName(function, "param1");
+	}
+	
+
 	@Test
 	public void test_var_should_be_created_if_not_declared() throws IOException {
 		String[] srcs = new String[] {
@@ -28,12 +44,113 @@ public class RubyVarTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-        FileEntity f = (FileEntity) (entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
-        assertEquals(1,f.getVars().size());
-        VarEntity var = f.getVars().get(0);
-		assertEquals("var_1",var.getRawName());
-		assertEquals(Inferer.buildInType,var.getType());
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_with_local_var"));
+	    assertEquals(1,function.getVars().size());
+	    assertContainsVarWithRawName(function, "var_1");
+	}
+
+
+	@Test
+	public void test_var_should_only_create_once() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_with_local_var_2times"));
+	    assertEquals(1,function.getVars().size());
+	}
+	
+	@Test
+	public void test_var_should_not_be_created_if_it_actually_parameter() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_without_local_var_and_param"));
+	    assertEquals(0,function.getVars().size());
+	}
+	
+
+	@Test
+	public void test_var_should_not_be_created_if_it_actually_a_file_level_var() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_access_file_level_var"));
+	    assertEquals(0,function.getVars().size());
+	}
+	
+	@Test
+	public void test_var_should_not_be_created_with_a_lot_of_levels() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("M.C.method"));
+	    assertEquals(1,function.getVars().size());
+	}
+	@Test
+	public void test_var_should_not_be_created_not_in_scope() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("M.C.method2"));
+	    assertEquals(1,function.getVars().size());
 	}
 	
+	
+	@Test
+	public void test_var_should_created_at_class_level() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    TypeEntity c = (TypeEntity)(entityRepo.getEntity("M.C"));
+	    assertEquals(3,c.getVars().size());
+	    assertContainsVarWithRawName(c,"class_level_var");
+	    assertContainsVarWithRawName(c,"class_var");
+	    assertContainsVarWithRawName(c,"instance_var");
+	}
+	
+	@Test
+	public void test_var_in_block() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    ContainerEntity c = (ContainerEntity)(entityRepo.getEntity("Block"));
+	    assertEquals(1,c.getVars().size());
+	    assertContainsVarWithRawName(c,"a");
+	}
 }
+

5c25a329204cf658524b739e9d5d58547630a4d0
@@ -9,6 +9,7 @@ import depends.entity.MultiDeclareEntities;
 public class EntityRepo extends IdGenerator{
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
+	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
 	public EntityRepo() {
 	}

5c25a329204cf658524b739e9d5d58547630a4d0
@@ -8,6 +8,7 @@ import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
+import depends.entity.PackageEntity;
 import depends.entity.AliasEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
@@ -104,6 +105,15 @@ public abstract class HandlerContext {
 	public FileEntity currentFile() {
 		return currentFileEntity;
 	}
+	
+	public ContainerEntity globalScope() {
+		Entity global = entityRepo.getEntity(EntityRepo.GLOBAL_SCOPE_NAME);
+		if (global==null) {
+			global = new PackageEntity(EntityRepo.GLOBAL_SCOPE_NAME,idGenerator.generateId());
+			entityRepo.add(global);
+		}
+		return (ContainerEntity)global;
+	}
 
 	public Entity latestValidContainer() {
 		for (int i = entityStack.size() - 1; i >= 0; i--) {

5c25a329204cf658524b739e9d5d58547630a4d0
@@ -177,14 +177,14 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitGlobalVarNode(GlobalVarNode node) {
-		// TODO Auto-generated method stub
+		foundVar(context.globalScope(),node.getName());
 		return super.visitGlobalVarNode(node);
 	}
 
 
 	@Override
 	public Object visitInstVarNode(InstVarNode node) {
-		// TODO Auto-generated method stub
+		foundVar(context.currentType(),node.getName());
 		return super.visitInstVarNode(node);
 	}
 
@@ -231,7 +231,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitGlobalAsgnNode(GlobalAsgnNode node) {
-		// TODO Auto-generated method stub
+		foundVar(context.globalScope(),node.getName());
 		return super.visitGlobalAsgnNode(node);
 	}
 

5c25a329204cf658524b739e9d5d58547630a4d0
@@ -10,6 +10,7 @@ import org.junit.Test;
 import depends.entity.ContainerEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
+import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 
 public class RubyVarTest extends RubyParserTest {
@@ -152,5 +153,20 @@ public class RubyVarTest extends RubyParserTest {
 	    assertEquals(1,c.getVars().size());
 	    assertContainsVarWithRawName(c,"a");
 	}
+	
+	@Test
+	public void test_global_var()throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/auto_var.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    ContainerEntity c = (ContainerEntity)(entityRepo.getEntity(EntityRepo.GLOBAL_SCOPE_NAME));
+	    assertEquals(1,c.getVars().size());
+	    assertContainsVarWithRawName(c,"global_var");
+	}
 }
 

f288d8263e49e1f1b2953acdeb1e15f68924bb82
@@ -70,7 +70,12 @@ public class ExpressionUsage {
 			String name = helper.getName(ctx);
 			if (name.equals("new")) {
 				expression.isCreate = true;
-				expression.identifier = helper.getName(ctx.childNodes().get(0));
+				List<Node> childNodes = ctx.childNodes();
+				if (childNodes.size()>0) {
+					expression.identifier = helper.getName(ctx.childNodes().get(0));
+				}else {
+					expression.identifier = context.currentType().getRawName();
+				}
 				expression.rawType = expression.identifier ;
 				expression.deriveTypeFromChild  = false;
 			}

2055b7fed35746d90b1822f9bf9b09dcb4b6ec6c
@@ -211,4 +211,12 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return resolvedMixins;
 	}
 
+	public VarEntity getVarOfName(String varName) {
+		for (VarEntity var:this.vars) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		return null;
+	}
+
 }

2055b7fed35746d90b1822f9bf9b09dcb4b6ec6c
@@ -65,7 +65,15 @@ public abstract class HandlerContext {
 		return functionEntity;
 	}
 	
-
+	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName) {
+		FunctionEntity functionEntity = new FunctionEntity(methodName, containerEntity,
+				idGenerator.generateId(),null);
+		entityRepo.add(functionEntity);
+		containerEntity.addFunction(functionEntity);
+		pushToStack(functionEntity);
+		functionEntity.addThrowTypes(new ArrayList<>());
+		return functionEntity;		
+	}
 
 	public void foundNewImport(Import imported) {
 		currentFileEntity.addImport(imported);

2055b7fed35746d90b1822f9bf9b09dcb4b6ec6c
@@ -1,24 +1,10 @@
 package depends.extractor.ruby.jruby;
 
-import java.util.ArrayList;
 import java.util.List;
 
 import org.jrubyparser.ast.AssignableNode;
-import org.jrubyparser.ast.CallNode;
-import org.jrubyparser.ast.ClassVarAsgnNode;
-import org.jrubyparser.ast.ClassVarDeclNode;
-import org.jrubyparser.ast.ConstDeclNode;
-import org.jrubyparser.ast.DAsgnNode;
-import org.jrubyparser.ast.FCallNode;
-import org.jrubyparser.ast.GlobalAsgnNode;
 import org.jrubyparser.ast.ILiteralNode;
-import org.jrubyparser.ast.InstAsgnNode;
-import org.jrubyparser.ast.ListNode;
-import org.jrubyparser.ast.LocalAsgnNode;
-import org.jrubyparser.ast.MultipleAsgnNode;
 import org.jrubyparser.ast.Node;
-import org.jrubyparser.ast.UnaryCallNode;
-import org.jrubyparser.ast.VCallNode;
 
 import depends.entity.Expression;
 import depends.entity.repo.IdGenerator;

2055b7fed35746d90b1822f9bf9b09dcb4b6ec6c
@@ -22,6 +22,7 @@ import org.jrubyparser.ast.FCallNode;
 import org.jrubyparser.ast.GlobalAsgnNode;
 import org.jrubyparser.ast.GlobalVarNode;
 import org.jrubyparser.ast.IArgumentNode;
+import org.jrubyparser.ast.INameNode;
 import org.jrubyparser.ast.InstAsgnNode;
 import org.jrubyparser.ast.InstVarNode;
 import org.jrubyparser.ast.LocalAsgnNode;
@@ -36,6 +37,7 @@ import org.jrubyparser.ast.VCallNode;
 import org.jrubyparser.util.NoopVisitor;
 
 import depends.entity.ContainerEntity;
+import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
@@ -100,7 +102,6 @@ public class JRubyVisitor extends NoopVisitor {
 	
 	@Override
 	public Object visitRootNode(RootNode node) {
-		System.out.println(node);
 		return super.visitRootNode(node);
 	}
 
@@ -166,9 +167,20 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDefsNode(DefsNode node) {
-		//TODO: should add the method to the concrete variable
-		//
-		context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
+		boolean handled=false;
+	    	Node varNode = node.getReceiver();
+		if (varNode instanceof INameNode) {
+		    String varName = ((INameNode)varNode).getName();
+		    Entity var = context.foundEntityWithName(varName);
+		    if (var!=null && var instanceof ContainerEntity) {
+			context.foundMethodDeclarator(((ContainerEntity)var),node.getName());
+			handled = true;
+		    }
+		}
+		if (!handled) {
+		    	//fallback to add it to last container
+			context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
+		}
 		super.visitDefsNode(node);
 		context.exitLastedEntity();
 		return null;
@@ -210,7 +222,6 @@ public class JRubyVisitor extends NoopVisitor {
 	
 	@Override
 	public Object visitLocalVarNode(LocalVarNode node) {
-		System.out.println("visitLocalVarNode"+node.getName());
 		return super.visitLocalVarNode(node);
 	}
 

2055b7fed35746d90b1822f9bf9b09dcb4b6ec6c
@@ -0,0 +1,36 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.ContainerEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+import depends.util.FileUtil;
+
+public class RubySingletonMethodTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_singleton_method_should_created_in_var() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/singleton_method.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    ContainerEntity file = (ContainerEntity)(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
+	    VarEntity var = file.getVarOfName("var2");
+	    assertEquals(1,var.getFunctions().size());
+	}
+}
+

19174af827fd0b890dd17d8fa55fe9052b3b9a99
@@ -15,18 +15,21 @@ import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.IdGenerator;
 import depends.importtypes.Import;
+import depends.relations.Inferer;
 
 public abstract class HandlerContext {
 	protected EntityRepo entityRepo;
 	protected IdGenerator idGenerator;
 
 	protected FileEntity currentFileEntity;
+	protected Inferer inferer;
 
 	
-	public HandlerContext(EntityRepo entityRepo) {
+	public HandlerContext(EntityRepo entityRepo, Inferer inferer) {
 		this.entityRepo = entityRepo;
 		this.idGenerator = entityRepo;
 		entityStack = new Stack<Entity>();
+		this.inferer = inferer;
 	}
 
 	public FileEntity startFile(String fileName) {
@@ -214,4 +217,14 @@ public abstract class HandlerContext {
 		entityStack.pop();
 	}
 	
+	public boolean isNameExist(String rawName) {
+		Entity entity = inferer.resolveName(lastContainer(), rawName, true);
+		if (entity==null) return false;
+		if (entity.getId()!=-1) return true;
+		return false;
+	}
+
+	public Entity foundEntityWithName(String rawName) {
+		return inferer.resolveName(lastContainer(), rawName, true);
+	}
 }
\ No newline at end of file

19174af827fd0b890dd17d8fa55fe9052b3b9a99
@@ -14,6 +14,7 @@ import depends.extractor.java.context.QualitiedNameContextHelper;
 import depends.extractor.java.context.TypeParameterContextHelper;
 import depends.extractor.java.context.VariableDeclaratorsContextHelper;
 import depends.importtypes.ExactMatchImport;
+import depends.relations.Inferer;
 import depends.extractor.java.JavaParser.AnnotationConstantRestContext;
 import depends.extractor.java.JavaParser.AnnotationMethodRestContext;
 import depends.extractor.java.JavaParser.AnnotationTypeDeclarationContext;
@@ -43,8 +44,8 @@ public class JavaListener extends JavaParserBaseListener {
 	private ExpressionUsage expressionUsage;
 	private EntityRepo entityRepo;
 
-	public JavaListener(String fileFullPath, EntityRepo entityRepo) {
-		this.context = new JavaHandlerContext(entityRepo);
+	public JavaListener(String fileFullPath, EntityRepo entityRepo,Inferer inferer) {
+		this.context = new JavaHandlerContext(entityRepo,inferer);
 		this.entityRepo = entityRepo;
 		annotationProcessor = new AnnotationProcessor(context);
 		expressionUsage = new ExpressionUsage(context,entityRepo);

19174af827fd0b890dd17d8fa55fe9052b3b9a99
@@ -46,8 +46,6 @@ import depends.relations.Inferer;
 
 public class JRubyVisitor extends NoopVisitor {
 
-
-
 	private RubyHandlerContext context;
 	RubyParserHelper helper = new RubyParserHelper();
 	private ExpressionUsage expressionUsage;

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,76 +0,0 @@
-package depends;
-
-import picocli.CommandLine.Command;
-import picocli.CommandLine.Option;
-import picocli.CommandLine.Parameters;
-
-@Command(name = "depends")
-public class DependsCommand {
-	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
-    private String lang;
-	@Parameters(index = "1", description = "The directory to be analyzed")
-    private String src;
-	@Parameters(index = "2",  description = "The output file name")
-	private String output;
-    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
-    private String[] format=new String[]{"json"};
-	@Option(names = {"-d", "--dir"},  description = "The output directory")
-	private String dir;
-	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
-    private boolean dv8map = true;
-	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
-    private boolean stripLeadingPath = false;
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
-    private String granularity="file";
-	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
-    private String namePathPattern="default";
-	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
-    private String[] includes = new String[] {};
-    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
-    boolean help;
-	public String getLang() {
-		return lang;
-	}
-	public void setLang(String lang) {
-		this.lang = lang;
-	}
-	public String getSrc() {
-		return src;
-	}
-	public void setSrc(String src) {
-		this.src = src;
-	}
-	public String getOutputName() {
-		return output;
-	}
-	public void setOutput(String output) {
-		this.output = output;
-	}
-	public String[] getFormat() {
-		return format;
-	}
-	public String getOutputDir() {
-		if (dir==null) {
-			dir = System.getProperty("user.dir");
-		}
-		return dir;
-	}
-	public boolean isDv8map() {
-		return dv8map;
-	}
-	public String[] getIncludes() {
-		return includes;
-	}
-	public boolean isHelp() {
-		return help;
-	}
-    public String getGranularity() {
-		return granularity;
-	}
-	public String getNamePathPattern() {
-		return namePathPattern;
-	}
-	public boolean isStripLeadingPath() {
-		return stripLeadingPath;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,39 +0,0 @@
-package depends.deptypes;
-
-import java.util.ArrayList;
-
-public class DependencyType {
-	public static final String IMPORT = "Import";
-	public static final String CONTAIN = "Contain";
-	public static final String IMPLEMENT = "Implement";
-	public static final String INHERIT = "Extend";
-	public static final String CALL = "Call";
-	public static final String PARAMETER = "Parameter";
-	public static final String RETURN = "Return";
-	public static final String SET = "Set";
-	public static final String USE = "Use";
-	public static final String RECEIVE = "Receive";
-	public static final String CREATE = "Create";
-	public static final String CAST = "Cast";
-	public static final String THROW = "Throw";
-	public static final String ANNOTATION = "Annotation";
-
-	public static ArrayList<String> allDependencies() {
-		ArrayList<String> depedencyTypes = new ArrayList<String>();
-		depedencyTypes.add(IMPORT);
-		depedencyTypes.add(CONTAIN);
-		depedencyTypes.add(IMPLEMENT);
-		depedencyTypes.add(INHERIT);
-		depedencyTypes.add(CALL);
-		depedencyTypes.add(PARAMETER);
-		depedencyTypes.add(RETURN);
-		depedencyTypes.add(SET);
-		depedencyTypes.add(CREATE);
-		depedencyTypes.add(USE);
-		depedencyTypes.add(RECEIVE);
-		depedencyTypes.add(CAST);
-		depedencyTypes.add(THROW);
-		depedencyTypes.add(ANNOTATION);
-		return depedencyTypes;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,9 +0,0 @@
-package depends.entity;
-
-import java.util.UUID;
-
-public class AnonymousBlock extends ContainerEntity{
-    public AnonymousBlock(Entity parent, Integer id) {
-    	super(UUID.randomUUID().toString(),  parent, id);
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,235 +0,0 @@
-package depends.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import depends.extractor.java.JavaParser.ExpressionContext;
-import depends.relations.Inferer;
-
-/**
- * ContainerEntity for example file, class, method, etc.
- * they could contain vars, functions, ecpressions, type parameters, etc.
- */
-public abstract class ContainerEntity extends Entity {
-	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
-
-	private ArrayList<VarEntity> vars;
-	private ArrayList<FunctionEntity> functions;
-	private HashMap<Object, Expression> expressions;
-	private Collection<String> typeParameters; // Generic type parameters like <T>, <String>, <? extends Object>
-	private Collection<String> annotations = new ArrayList<>();
-	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
-	private Collection<TypeEntity> resolvedAnnotations = new ArrayList<>();
-
-	public ContainerEntity(String rawName, Entity parent, Integer id) {
-		super(rawName, parent, id);
-		vars = new ArrayList<>();
-		functions = new ArrayList<>();
-		expressions = new HashMap<>();
-		typeParameters = new ArrayList<>();
-	}
-	
-	public void addAnnotation(String name) {
-		this.annotations.add(name);
-	}
-	
-	public void addTypeParameter(String typeName) {
-		this.typeParameters.add(typeName);
-	}
-	
-	public void addTypeParameter(List<String> parameters) {
-		this.typeParameters.addAll(parameters);
-	}
-
-	public void addVar(VarEntity var) {
-		if (logger.isDebugEnabled()) {
-			logger.debug("var found: "+var.getRawName() +  ":" + var.getRawType());
-		}
-		this.vars.add(var);
-	}
-
-	public ArrayList<VarEntity> getVars() {
-		return this.vars;
-	}
-
-	public void addFunction(FunctionEntity functionEntity) {
-		this.functions.add(functionEntity);
-	}
-
-	public ArrayList<FunctionEntity> getFunctions() {
-		return this.functions;
-	}
-
-	public HashMap<Object, Expression> expressions() {
-		return expressions;
-	}
-
-	public void addExpression(Object key, Expression expression) {
-		expressions.put(key, expression);
-	}
-
-	/**
-	 * A common utility function used to transfer the identifiers 
-	 * to types.
-	 * @param inferer - the inferer object 
-	 * @param identifiers - the identifiers will be translated
-	 * @return The translated Types
-	 */
-	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
-		ArrayList<TypeEntity> r = new ArrayList<>();
-		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = inferer.inferTypeFromName(this, typeParameter);
-			if (typeEntity==null) {
-				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
-					typeEntity = Inferer.genericParameterType;
-				}
-			}
-			if (typeEntity != null)
-				r.add(typeEntity);
-		}
-		return r;
-	}
-
-	/**
-	 * For all data in the class, infer their types.
-	 * Should be override in sub-classes 
-	 */
-	public void inferLocalLevelEntities(Inferer inferer) {
-		resolvedTypeParameters = identiferToTypes(inferer, typeParameters);
-		resolvedAnnotations = identiferToTypes(inferer, annotations);
-		for (VarEntity var : this.vars) {
-			var.inferLocalLevelEntities(inferer);
-		}
-		for (FunctionEntity func:this.functions) {
-			func.inferLocalLevelEntities(inferer);
-		}
-	}
-
-	/**
-	 * Resolve all expression's type
-	 * @param inferer
-	 */
-	public void resolveExpressions(Inferer inferer) {
-		for (Expression expression : expressions.values()) {
-			//1. if expression's type existed, break;
-			if (expression.getType() != null)
-				continue;
-			
-			//2. if expression's rawType existed, directly infer type by rawType
-			//   if expression's rawType does not existed, infer type based on identifiers
-			if (expression.rawType != null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
-			}else if (expression.isDot){ //wait for previous
-				continue;
-			} else if (expression.rawType!=null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
-				if (expression.getType() !=null) {
-					 continue;
-				}
-			}
-			if (expression.identifier!=null) { 
-				Entity entity = inferer.resolveName(this, expression.identifier, true);
-				if (entity!=null) {
-					expression.setType(entity.getType(),entity,inferer);
-					continue;
-				}
-				if (expression.isCall) {
-					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
-					if (func!=null) {
-						expression.setType(func.getType(),func,inferer);
-					}
-				}else {
-					
-					VarEntity varEntity = this.lookupVarsInVisibleScope(expression.identifier);
-					if (varEntity!=null) {
-						expression.setType( varEntity.getType(),varEntity,inferer);
-					}
-				}
-			}
-		}
-	}
-
-
-	
-
-	public Collection<TypeEntity> getResolvedTypeParameters() {
-		return resolvedTypeParameters;
-	}
-
-
-	public Collection<TypeEntity> getResolvedAnnotations() {
-		return resolvedAnnotations;
-	}
-
-
-	public String dumpExpressions() {
-		StringBuilder sb = new StringBuilder();
-		for (Expression exp:expressions.values()) {
-			sb.append(exp.toString()).append("\n");
-		}
-		return sb.toString();
-	}
-	
-
-
-	public boolean isGenericTypeParameter(String rawType) {
-		if (this.typeParameters.contains(rawType)) return true;
-		if (this.getParent()==null || !(this.getParent() instanceof ContainerEntity))
-			return false;
-		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
-	}
-
-	protected FunctionEntity lookupFunctionLocally(String functionName) {
-		for (FunctionEntity func : getFunctions()) {
-			if (func.getRawName().equals(functionName))
-				return func;
-		}
-		return null;
-	}
-	
-	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
-		ContainerEntity fromEntity = this;
-		while (fromEntity != null) {
-			if (fromEntity instanceof ContainerEntity) {
-				FunctionEntity func = ((ContainerEntity) fromEntity).lookupFunctionLocally(functionName);
-				if (func != null)
-					return func;
-			}
-			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
-		}
-		return null;
-	}
-	
-	/**
-	 * To found the var. Must be invoked after all entities var binding solved
-	 * @param fromEntity
-	 * @param varName
-	 * @return
-	 */
-	public VarEntity lookupVarsInVisibleScope(String varName) {
-		
-		ContainerEntity fromEntity = this;
-		while (fromEntity != null) {
-			if (fromEntity instanceof ContainerEntity) {
-				VarEntity var = ((ContainerEntity) fromEntity).lookupVarLocally(varName);
-				if (var != null)
-					return var;
-			}
-			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
-		}
-		return null;
-	}
-
-	private VarEntity lookupVarLocally(String varName) {
-		for (VarEntity var:getVars()) {
-			if (var.getRawName().equals(varName))
-				return var;
-		}
-		return null;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,9 +0,0 @@
-package depends.entity;
-
-public class EmptyTypeEntity extends TypeEntity {
-
-	public EmptyTypeEntity() {
-		super("", null, -1);
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,152 +0,0 @@
-package depends.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
-import depends.relations.Inferer;
-import depends.relations.Relation;
-
-/**
- * Entity is the root of all entities, including file, package, module, 
- * class, method/function etc.
- * Each entity has unique id, name,qualifiedName, parent, children
- * We also use entity to record relations 
- */
-public abstract class Entity {
-	int id=-1;
-	String qualifiedName = null;
-	String rawName = "";
-	Entity parent;
-	Set<Entity> children = new HashSet<>();
-    ArrayList<Relation> relations = new ArrayList<>();
-
-	
-    public Entity(String rawName, Entity parent, Integer id) {
-		this.qualifiedName = null;
-		this.rawName = rawName;
-		this.parent = parent;
-		this.id = id;
-		if (parent!=null)
-			parent.children.add(this);
-		deduceQualifiedName();
-	}
-
-    /**
-     * Rule 1: if it contains '.' , then the name is equal to raw name
-     * Rule 2: if parent not exists, the name is equal to raw name
-     * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
-     * Rule 4: otherwise, qualified name = parent_qualfied_name + "."+rawName
-     * Rule 5: make sure the qualified name do not start with '.'
-     * TODO: the Rule 1 should be further check. Maybe issue exists - (C++中的ClassName::MethodName()会不会有问题？
-     */
-	private void deduceQualifiedName() {
-		rawName = rawName.replace("::","." );
-		if (this.rawName.contains(".")) {
-			this.qualifiedName = this.rawName;
-			return; //already qualified
-		}
-		if (parent==null) {
-			this.qualifiedName = this.rawName;
-			return;
-		}
-		if (parent.getQualifiedName()==null) {
-			this.qualifiedName = this.rawName;
-			return;
-		}
-		if (parent.getQualifiedName().isEmpty()) {
-			this.qualifiedName = rawName;
-			return;
-		}
-		this.qualifiedName= parent.getQualifiedName()+"." + rawName;
-		if (rawName.startsWith(".")) {
-			rawName = rawName.substring(2);
-		}
-	}
-
-
-	public String getRawName() {
-		return rawName;
-	}
-
-	public int getId() {
-        return id;
-    }
-
-    public void addRelation(Relation relation) {
-        relations.add(relation);
-    }
-
-    public ArrayList<Relation> getRelations() {
-        return relations;
-    }
-
-    public void addChild(Entity child) {
-        children.add(child);
-    }
-
-	public Entity getParent() {
-		return parent;
-	}
-
-	public void setParent(Entity parent) {
-		this.parent = parent;
-	}
-	
-	public Collection<Entity> getChildren() {
-		return children;
-	}
-	
-	public void setQualifiedName(String qualifiedName) {
-		this.qualifiedName = qualifiedName;
-	}
-
-	public void setRawName(String rawName) {
-		this.rawName = rawName;
-	}
-	
-	public String getQualifiedName() {
-		return qualifiedName;
-	}
-
-	@Override
-	public String toString() {
-		return "Entity [id=" + id + ", qualifiedName=" + qualifiedName + ", rawName=" + rawName + "]";
-	}
-
-	/**
-	 * Get ancestor of type.  
-	 * @param classType
-	 * @return null (if not exist) or the type
-	 */
-	public Entity getAncestorOfType(@SuppressWarnings("rawtypes") Class classType) {
-		Entity fromEntity = this;
-		while(fromEntity!=null) {
-			if (fromEntity.getClass().equals(classType))
-				return fromEntity;
-			if (fromEntity.getParent()==null) return null;
-			fromEntity = fromEntity.getParent();
-		}
-		return null;
-	}
-
-	/**
-	 * Invoke inferer to resolve the entity type etc. 
-	 * */
-	public void inferEntities(Inferer inferer) {
-		inferLocalLevelEntities(inferer);
-		for (Entity child:children) {
-			child.inferEntities(inferer);
-		}
-	}
-	public abstract void inferLocalLevelEntities(Inferer inferer);
-	
-	public TypeEntity getType() {
-		return null;
-	}
-
-	public String getDisplayName() {
-		return getRawName();
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,107 +0,0 @@
-package depends.entity;
-
-import depends.relations.Inferer;
-
-public class Expression {
-	public Integer id;
-	public Integer parentId;
-	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
-	public Expression parent;
-	public String text; // for debug purpose
-	public String rawType; //the raw type name
-	public String identifier; // the varName, or method name, etc.
-	public boolean isSet = false; // is a set relation from right to leftHand
-	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
-	public boolean isCall = false;
-	public boolean isLogic = false;
-	public boolean isCreate = false;
-	public boolean isCast = false;
-	public boolean deriveTypeFromChild = true;
-
-	private TypeEntity type; // the type we care - for relation calculation. 
-	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
-	private Entity referredEntity;
-	public TypeEntity getType() {
-		return type;
-	}
-
-	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
-		if (this.type!=null) return;
-		this.type = type;
-		this.referredEntity  = referredEntity;
-		if (this.referredEntity==null)
-			this.referredEntity = type;
-		deduceParentType(inferer);
-	}
-	
-	public Expression(Integer id, Integer parentId) {
-		this.id = id;
-		this.parentId = parentId;
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder s = new StringBuilder();
-		s.append("[").append(text).append("]").append("|")
-			.append("rawType:").append(rawType).append("|")
-			.append("identifier:").append(identifier).append("|")
-		    .append("prop:").append(isDot?"[dot]":"")
-		                      .append(isSet?"[set]":"")
-		                      .append(isLogic?"[bool]":"")
-		                      .append(isCall?"[call]":"").append("|")
-		    .append("parent:").append(parent==null?"none":parent.text)
-			.append("type:").append(type).append("|");
-		return s.toString();
-	}
-
-	/**
-	 * deduce type of parent based on child's type
-	 * @param expressionList
-	 * @param inferer
-	 */
-	public void deduceParentType(Inferer inferer) {
-		if (this.type==null) return;
-		if (this.parent==null) return;
-		Expression parent = this.parent;
-		if (parent.type != null)return;
-		if (!parent.deriveTypeFromChild) return;
-		//parent's type depends on first child's type
-		if (parent.deduceTypeBasedId!=this.id) return;
-		
-		//if child is a built-in/external type, then parent must also a built-in/external type
-		if (this.type.equals(Inferer.buildInType)) {
-			parent.setType(Inferer.buildInType,Inferer.buildInType,inferer);
-			return;
-		}else if (this.type.equals(Inferer.externalType)){
-			parent.setType(Inferer.externalType,Inferer.externalType,inferer);
-			return;
-		}
-		
-		/* if it is a logic expression, the return type/type is boolean. */
-		if (parent.isLogic) {
-			parent.setType(Inferer.buildInType,null,inferer);
-		}
-		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
-		else if (parent.isDot) {
-			if (parent.isCall) {
-				FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-				if (func!=null)
-					parent.setType(func.getType(), func,inferer);
-			}else {
-				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
-				if (parent.type!=null) return;
-				VarEntity var = this.getType().lookupVarsInVisibleScope(parent.identifier);
-				if (var!=null)
-					parent.setType(var.getType(),var, inferer);
-			}
-		}
-		/* if other situation, simple make the parent and child type same */
-		else {
-			parent.setType(type, null, inferer);
-		}
-	}
-
-	public Entity getReferredEntity() {
-		return referredEntity;
-	}
-}
\ No newline at end of file

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,89 +0,0 @@
-package depends.entity;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import depends.importtypes.Import;
-import depends.relations.Inferer;
-
-public class FileEntity extends ContainerEntity {
-	private List<Import> importedNames = new ArrayList<>();
-	private boolean isInProjectScope = false;
-	private List<Entity> importedRelationEntities = new ArrayList<>();
-	private List<Entity> importedFiles = new ArrayList<>();
-	private List<Entity> importedTypes = new ArrayList<>();
-
-	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
-		super(fullName, null, fileId);
-		setQualifiedName(fullName);
-	}
-
-	public FileEntity(String fullName, int fileId) {
-		this(fullName, fileId, true);
-	}
-
-	public void addImport(Import imported) {
-		importedNames.add(imported);
-	}
-	
-	/**
-	 * To match the imported name by suffix
-	 * for example:
-	 *    import a.b.ClassX;
-	 * the b.ClassX, ClassX , a.b.classX should be matched
-	 * @param lastName
-	 * @return
-	 */
-	public String importedSuffixMatch(String lastName) {
-		if (!lastName.startsWith("."))
-			lastName = "." + lastName;
-		for (Entity imported : this.importedTypes) {
-			String name = imported.getQualifiedName();
-			if (!name.startsWith("."))
-				name = "." + name;
-			if (imported.getQualifiedName().endsWith(lastName))
-				return imported.getQualifiedName();
-		}
-		return null;
-	}
-	
-	@Override
-	public String getQualifiedName() {
-		if (this.getParent() == null) {
-			return "";
-		}
-		if (this.getParent() instanceof PackageEntity)
-			return this.getParent().getQualifiedName();
-		else
-			return super.getQualifiedName();
-	}
-
-	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
-		this.importedRelationEntities = inferer.getImportedRelationEntities(importedNames);
-		this.importedTypes = inferer.getImportedTypes(importedNames);
-		this.importedFiles = inferer.getImportedFiles(importedNames);
-		super.inferLocalLevelEntities(inferer);
-	}
-
-	public boolean isInProjectScope() {
-		return isInProjectScope;
-	}
-
-	public void setInProjectScope(boolean isInProjectScope) {
-		this.isInProjectScope = isInProjectScope;
-	}
-
-	public List<Entity> getImportedRelationEntities() {
-		return importedRelationEntities;
-	}
-
-	public List<Entity> getImportedFiles() {
-		return importedFiles;
-	}
-
-	public List<Entity> getImportedTypes() {
-		return importedTypes;
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,78 +0,0 @@
-package depends.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import depends.relations.Inferer;
-
-public class FunctionEntity extends ContainerEntity{
-	private List<String> returnTypeIdentifiers = new ArrayList<>();
-	Collection<VarEntity> parameters;
-    Collection<String> throwTypesIdentifiers = new ArrayList<>(); 
-	private Collection<TypeEntity> returnTypes = new ArrayList<>();
-	private TypeEntity returnType;
-	private Collection<TypeEntity> throwTypes = new ArrayList<>();
-    public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
-		super(simpleName, parent,id);
-		this.returnTypes = new ArrayList<>();
-		returnTypeIdentifiers = new ArrayList<>();
-		this.parameters = new ArrayList<>();
-		throwTypesIdentifiers = new ArrayList<>();
-		addReturnType(returnType);
-	}
-	public Collection<TypeEntity> getReturnTypes() {
-		return returnTypes;
-	}
-	
-	@Override
-	public TypeEntity getType() {
-		return returnType;
-	}
-
-	public void addReturnType(String returnType) {
-		this.returnTypeIdentifiers.add(returnType);
-	}
-	public void addThrowTypes(List<String> throwedType) {
-		throwTypesIdentifiers.addAll(throwedType);
-	}
-	
-	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
-		for (VarEntity param:parameters) {
-			param.inferLocalLevelEntities(inferer);
-		}
-		returnTypes= identiferToTypes(inferer,this.returnTypeIdentifiers);
-		if (returnTypes.size()>0)
-			returnType = returnTypes.iterator().next();
-
-		throwTypes= identiferToTypes(inferer,this.throwTypesIdentifiers);
-		super.inferLocalLevelEntities(inferer);
-	}
-	public Collection<VarEntity> getParameters() {
-		return parameters;
-	}
-	public Collection<TypeEntity> getThrowTypes() {
-		return throwTypes;
-	}
-	@Override
-	public VarEntity lookupVarsInVisibleScope(String varName) {
-		for (VarEntity param:parameters) {
-			if (varName.equals(param.getRawName())) {
-				return param;
-			}
-		}
-		return super.lookupVarsInVisibleScope(varName);
-	}
-	public void addParameter(VarEntity var) {
-		this.parameters.add(var);
-	}
-	public void setReturnType(TypeEntity returnType) {
-		this.returnType = returnType;
-	}
-	@Override
-	public String getDisplayName() {
-		FileEntity f = (FileEntity) this.getAncestorOfType(FileEntity.class);
-		return f.getRawName()+"("+getRawName()+")";
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,55 +0,0 @@
-package depends.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import depends.relations.Inferer;
-
-/**
- * MultiDeclareEntity is a special container, which is used as a wrapper
- * of multi-declaration. for example, 
- * in C++, a function could be declared in different place with the same signature.
- */
-public class MultiDeclareEntities extends ContainerEntity {
-	List<ContainerEntity> entities = new ArrayList<>();
-	public MultiDeclareEntities(Entity entity, int id ) {
-		super(entity.getRawName(), entity.getParent(), id);
-		if (entity instanceof ContainerEntity)
-			entities.add((ContainerEntity)entity);
-	}
-
-	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
-		for (Entity entity:entities) {
-			entity.inferLocalLevelEntities(inferer);
-		}
-	}
-
-	public void add(Entity entity) {
-		if (entity instanceof ContainerEntity)
-			entities.add((ContainerEntity)entity);
-	}
-
-	public List<ContainerEntity> getEntities() {
-		return entities;
-	}
-
-	@Override
-	public Collection<Entity> getChildren() {
-		List<Entity> children = new ArrayList<>();
-		for (Entity entity:entities) {
-			children.addAll(entity.getChildren());
-		}
-		return children;
-	}
-
-	@Override
-	public TypeEntity getType() {
-		for (Entity entity:entities) {
-			if(entity.getType()!=null);
-				return entity.getType();
-		}
-		return null;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,72 +0,0 @@
-package depends.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-import depends.relations.Inferer;
-
-public class TypeEntity extends ContainerEntity{
-	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
-	Collection<TypeEntity> implementedTypes = new ArrayList<>();
-	Collection<String> inhertedTypeIdentifiers;
-	Collection<String> implementedIdentifiers;
-	TypeEntity inheritedType;
-
-	public TypeEntity(String simpleName, Entity parent, Integer id) {
-		super(simpleName,parent,id);
-		inhertedTypeIdentifiers = new ArrayList<>();
-		implementedIdentifiers = new ArrayList<>();
-	}
-	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
-		inheritedTypes= identiferToTypes(inferer,this.inhertedTypeIdentifiers);
-		implementedTypes= identiferToTypes(inferer,this.implementedIdentifiers);
-		if (inheritedTypes.size()>0)
-			inheritedType = inheritedTypes.iterator().next();
-		super.inferLocalLevelEntities(inferer);
-	}
-	public void addImplements(String typeName) {
-		if (typeName.equals(this.getRawName())) return;
-		if (implementedIdentifiers.contains(typeName)) return;
-		this.implementedIdentifiers.add(typeName);
-	}
-	public void addExtends(String typeName) {
-		if (typeName.equals(this.getRawName())) return;
-		if (inhertedTypeIdentifiers.contains(typeName)) return;
-		this.inhertedTypeIdentifiers.add(typeName);
-	}
-	public Collection<TypeEntity> getInheritedTypes() {
-		return inheritedTypes;
-	}
-	
-	public Collection<TypeEntity> getImplementedTypes() {
-		return implementedTypes;
-	}
-	
- 	public TypeEntity getInheritedType() {
-		return inheritedType;
-	}
- 	
- 	@Override
- 	protected FunctionEntity lookupFunctionLocally(String functionName) {
-		FunctionEntity funcType = super.lookupFunctionLocally(functionName);
-		if (funcType!=null) return funcType;
-		for (TypeEntity inhertedType : getInheritedTypes()) {
-			funcType = inhertedType.lookupFunctionLocally(functionName);
-			if (funcType == null)
-				break;
-		}
-		if (funcType != null)
-			return funcType;
-		for (TypeEntity implType : getImplementedTypes()) {
-			funcType = implType.lookupFunctionLocally( functionName);
-			if (funcType == null)
-				break;
-		}
-		return funcType;
- 	}
- 	@Override
- 	public TypeEntity getType() {
-		return this;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,37 +0,0 @@
-package depends.entity;
-
-import depends.relations.Inferer;
-
-public class VarEntity extends Entity {
-	private String rawType;
-	private TypeEntity type;
-	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
-		super(simpleName,  parent,id);
-		this.rawType = rawType;
-	}
-
-	public String getRawType() {
-		return rawType;
-	}
-
-	@Override
-	public TypeEntity getType() {
-		return type;
-	}
-
-	public void setType(TypeEntity type) {
-		this.type = type;
-	}
-
-	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
-		Entity entity = inferer.resolveName(this, rawType, true);
-		if (entity==null) return;
-		type = entity.getType();
-		if (type==null) {
-			if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
-				type = Inferer.genericParameterType;
-			}
-		}
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,54 +0,0 @@
-package depends.entity.repo;
-
-import java.util.Collection;
-import java.util.HashMap;
-
-import depends.entity.Entity;
-import depends.entity.MultiDeclareEntities;
-
-public class EntityRepo extends IdGenerator{
-	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
-	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
-
-	public EntityRepo() {
-	}
-	
-	public Entity getEntity(String entityName) {
-		return allEntieisByName.get(entityName);
-	}
-	
-	public Entity getEntity(Integer entityId) {
-		return allEntitiesById.get(entityId);
-	}
-	
-	public void add(Entity entity) {
-		allEntitiesById.put(entity.getId(), entity);
-		String name = entity.getRawName();
-		if (entity.getQualifiedName()!=null && !(entity.getQualifiedName().isEmpty()) ) {
-			name = entity.getQualifiedName();
-		}
-		if (allEntieisByName.containsKey(name)) {
-			Entity existedEntity = allEntieisByName.get(name);
-			if (existedEntity instanceof MultiDeclareEntities) {
-				((MultiDeclareEntities)existedEntity).add(entity);
-			}else {
-				MultiDeclareEntities eMultiDeclare = new MultiDeclareEntities(existedEntity,this.generateId());
-				eMultiDeclare.add(entity);
-				allEntieisByName.put(name, eMultiDeclare);
-			}
-		}else {
-			allEntieisByName.put(name, entity);
-		}
-		if (entity.getParent()!=null)
-			this.setParent(entity, entity.getParent());
-	}
-		
-	public Collection<Entity> getEntities() {
-		return allEntitiesById.values();
-	}
-	
-	public void setParent(Entity child, Entity parent) {
-		child.setParent(parent);
-		parent.addChild(child);
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,178 +0,0 @@
-package depends.extractor;
-
-import java.util.List;
-import java.util.Stack;
-
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.FunctionEntity;
-import depends.entity.TypeAliasEntity;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
-import depends.entity.repo.EntityRepo;
-import depends.entity.repo.IdGenerator;
-import depends.importtypes.Import;
-
-public abstract class HandlerContext {
-	protected EntityRepo entityRepo;
-	protected IdGenerator idGenerator;
-
-	protected FileEntity currentFileEntity;
-
-	
-	public HandlerContext(EntityRepo entityRepo) {
-		this.entityRepo = entityRepo;
-		this.idGenerator = entityRepo;
-		entityStack = new Stack<Entity>();
-	}
-
-	public FileEntity startFile(String fileName) {
-		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
-		pushToStack(currentFileEntity);
-		entityRepo.add(currentFileEntity);
-		return currentFileEntity;
-	}
-
-	
-
-	public Entity foundNewType(String classOrInterfaceName) {
-		TypeEntity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
-			idGenerator.generateId());
-		pushToStack(currentTypeEntity);
-	 	entityRepo.add(currentTypeEntity);
-		return currentTypeEntity;
-	}
-
-	public void foundNewTypeAlias(String aliasName, String originalName) {
-		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
-		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
-		TypeAliasEntity currentTypeEntity = new TypeAliasEntity(aliasName, this.latestValidContainer(),
-				idGenerator.generateId(),originalName );
-	 	entityRepo.add(currentTypeEntity);
-		return ;		
-	}
-	
-	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
-		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
-				idGenerator.generateId(),returnType);
-		entityRepo.add(functionEntity);
-		this.typeOrFileContainer().addFunction(functionEntity);
-		pushToStack(functionEntity);
-		functionEntity.addThrowTypes(throwedType);
-		return functionEntity;
-	}
-	
-
-
-	public void foundNewImport(Import imported) {
-		currentFileEntity.addImport(imported);
-	}
-
-	public TypeEntity currentType() {
-		for (int i = entityStack.size() - 1; i >= 0; i--) {
-			Entity t = entityStack.get(i);
-			if (t instanceof TypeEntity)
-				return (TypeEntity) t;
-		}
-		return null;
-	}
-	
-	public ContainerEntity typeOrFileContainer() {
-		for (int i = entityStack.size() - 1; i >= 0; i--) {
-			Entity t = entityStack.get(i);
-			if (t instanceof TypeEntity)
-				return (ContainerEntity) t;
-			if (t instanceof FileEntity) {
-				return (ContainerEntity)t;
-			}
-		}
-		return null;
-	}
-
-
-	public FunctionEntity currentFunction() {
-		for (int i = entityStack.size() - 1; i >= 0; i--) {
-			Entity t = entityStack.get(i);
-			if (t instanceof FunctionEntity)
-				return (FunctionEntity) t;
-		}
-		return null;
-	}
-
-	public FileEntity currentFile() {
-		return currentFileEntity;
-	}
-
-	public Entity latestValidContainer() {
-		for (int i = entityStack.size() - 1; i >= 0; i--) {
-			Entity t = entityStack.get(i);
-			if (t instanceof FunctionEntity)
-				return t;
-			if (t instanceof TypeEntity)
-				return t;
-			if (t instanceof FileEntity)
-				return t;
-		}
-		return null;
-	}
-
-	public ContainerEntity lastContainer() {
-		for (int i = entityStack.size() - 1; i >= 0; i--) {
-			Entity t = entityStack.get(i);
-			if (t instanceof ContainerEntity)
-				return (ContainerEntity) t;
-		}
-		return null;
-	}
-
-	public void foundAnnotation(String name) {
-		lastContainer().addAnnotation(name);
-	}
-
-	public void foundImplements(String typeName) {
-		currentType().addImplements(typeName);
-	}
-
-	public void foundExtends(String typeName) {
-		if (currentType()==null) {
-			System.out.println("error: type do not exist");
-		}
-		currentType().addExtends(typeName);
-	}
-
-
-	public void foundTypeParametes(String typeName) {
-		lastContainer().addTypeParameter(typeName);
-	}
-
-
-	public void foundVarDefinition(List<String> varNames, String type) {
-		for (String varName : varNames) {
-			foundVarDefintion(varName,type);
-		}
-	}
-
-
-	public void foundVarDefintion(String varName, String type) {
-		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
-		lastContainer().addVar(var);		
-	}
-
-	public void foundEnumConstDefinition(String varName) {
-		String type = lastContainer().getRawName();
-		foundVarDefintion(varName,type);
-	}
-	
-	protected Stack<Entity> entityStack = new Stack<Entity>();
-
-	private void pushToStack(Entity entity) {
-		entityStack.push(entity);
-	}
-	
-	
-	public void exitLastedEntity() {
-		entityStack.pop();
-	}
-	
-}
\ No newline at end of file

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,47 +0,0 @@
-package depends.extractor.cpp;
-
-import depends.entity.repo.BuiltInType;
-
-public class CppBuiltInType extends BuiltInType {
-
-	public CppBuiltInType() {
-		super.createBuiltInTypes();
-	}
-
-	@Override
-	public String[] getBuiltInTypeStr() {
-		return new String[] { "alignas", "alignof", "asm", "auto", "bool", "break", "case", "catch", "char",
-				"char16_t", "char32_t", "class", "const", "constexpr", "const_cast", "continue", "decltype",
-				"default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
-				"false", "final", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
-				"namespace", "new", "noexcept", "nullptr", "operator", "override", "private", "protected", "public",
-				"register", "reinterpret_cast", "return", "short", "signed", "sizeof", "static", "static_assert",
-				"static_cast", "struct", "switch", "template", "this", "thread_local", "throw", "true", "try",
-				"typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "volatile",
-				"wchar_t", "while", "<Built-in>",
-				"__cplusplus","_cpp_aggregate_bases","__cpp_aggregate_nsdmi","__cpp_alias_templates","__cpp_aligned_new",
-				"__cpp_attributes","__cpp_binary_literals","__cpp_capture_star_this","__cpp_constexpr","__cpp_decltype",
-				"__cpp_decltype_auto","__cpp_deduction_guides","__cpp_delegating_constructors",
-				"__cpp_enumerator_attributes","__cpp_explicit_bool","__cpp_fold_expressions","__cpp_generic_lambdas",
-				"__cpp_guaranteed_copy_elision","__cpp_hex_float","__cpp_if_constexpr","__cpp_inheriting_constructors",
-				"__cpp_init_captures","__cpp_initializer_lists","__cpp_inline_variables","__cpp_lambdas",
-				"__cpp_namespace_attributes","__cpp_noexcept_function_type","__cpp_nontype_template_args",
-				"__cpp_nontype_template_parameter_auto","__cpp_nontype_template_parameter_class","__cpp_nsdmi"
-						+ "","__cpp_range_based_for","__cpp_raw_strings","__cpp_ref_qualifiers","__cpp_return_type_deduction"
-						,"__cpp_rvalue_references","__cpp_sized_deallocation","__cpp_static_assert","__cpp_structured_bindings",
-						"__cpp_template_template_args","__cpp_threadsafe_static_init","__cpp_unicode_characters","__cpp_unicode_literals",
-						"__cpp_user_defined_literals","__cpp_variable_templates","__cpp_variadic_templates","__cpp_variadic_using",
-						"__DATE__","__FILE__","__LINE__","__STDC__","__STDC_ANALYZABLE__","__STDC_HOSTED__","__STDC_IEC_559__",
-						"__STDC_IEC_559_COMPLEX__","__STDC_ISO_10646__","__STDC_LIB_EXT1__","__STDC_MB_MIGHT_NEQ_WC__",
-						"__STDC_NO_ATOMICS__","__STDC_NO_COMPLEX__","__STDC_NO_THREADS__","__STDC_NO_VLA__",
-						"__STDCPP_DEFAULT_NEW_ALIGNMENT__","__STDCPP_STRICT_POINTER_SAFETY__","__STDCPP_THREADS__",
-						"__STDC_UTF_16__","__STDC_UTF_32__","__STDC_VERSION__","__TIME__"
-				};
-	}
-
-	@Override
-	public String[] getBuiltInPrefixStr() {
-		return new String[] {"__"};
-	}
-
-}
\ No newline at end of file

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,87 +0,0 @@
-package depends.extractor.cpp;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.repo.EntityRepo;
-import depends.importtypes.FileImport;
-import depends.importtypes.Import;
-import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
-
-public class CppImportLookupStrategy implements ImportLookupStrategy {
-	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
-		String importedString = fileEntity.importedSuffixMatch(name);
-		if (importedString!=null) {
-			Entity r = repo.getEntity(importedString);
-			if (r!=null) return r;
-		}
-		
-		HashSet<String> fileSet = new HashSet<>();
-		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
-		
-		for (String file:fileSet) {
-			Entity importedItem = repo.getEntity(file);
-			if (importedItem instanceof FileEntity) {
-				FileEntity importedFile = (FileEntity) repo.getEntity(file);
-				if (importedFile==null) continue;
-				 Entity entity = inferer.resolveName(importedFile,name, false);
-				if (entity!=null) return entity;
-				 List<Entity> namespaces = fileEntity.getImportedTypes();
-				for (Entity ns:namespaces) {
-					String nameWithPrefix = ns.getQualifiedName() + "." + name;
-					entity = inferer.resolveName(importedFile,nameWithPrefix, false);
-					if (entity!=null) return entity;				
-				}
-			}	
-		}		
-		return null;
-	}
-
-	private void foundIncludedFiles(HashSet<String> fileSet, List<Entity> importedFiles, EntityRepo repo) {
-		for (Entity file:importedFiles) {
-			if (file==null ) continue;
-			if (!(file instanceof FileEntity)) continue;
-			if (fileSet.contains(file.getRawName())) continue;
-			fileSet.add(file.getRawName());
-			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles(),repo);
-		}
-	}
-	
-	
-	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
-		ArrayList<Entity> result = new ArrayList<>();
-		for (Import importedItem:importedList) {
-			if (importedItem instanceof FileImport) {
-				Entity imported = repo.getEntity(importedItem.getContent());
-				if (imported==null) continue;
-				result.add(imported);
-			}
-		}
-		return result;
-	}
-
-	@Override
-	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
-		ArrayList<Entity> result = new ArrayList<>();
-		for (Import importedItem:importedList) {
-			if (!(importedItem instanceof FileImport)) {
-				Entity imported = repo.getEntity(importedItem.getContent());
-				if (imported==null) continue;
-				result.add(imported);
-			}
-		}
-		return result;
-	}
-
-	@Override
-	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
-		return getImportedRelationEntities(importedList,repo);
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,22 +0,0 @@
-package depends.extractor.cpp.cdt;
-
-import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
-
-class ANSICParserExtensionConfigurationExtension extends ANSICParserExtensionConfiguration {
-
-	@Override
-	public boolean supportDeclspecSpecifiers() {
-		return false;
-	}
-
-	@Override
-	public boolean supportKnRC() {
-		return false;
-	}
-	
-	@Override
-	public boolean supportStatementsInExpressions() {
-		return false;
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,71 +0,0 @@
-package depends.extractor.cpp.cdt;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
-import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
-import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
-import org.eclipse.cdt.core.parser.CodeReader;
-import org.eclipse.cdt.core.parser.FileContent;
-import org.eclipse.cdt.core.parser.IScanner;
-import org.eclipse.cdt.core.parser.NullLogService;
-import org.eclipse.cdt.core.parser.ParserLanguage;
-import org.eclipse.cdt.core.parser.ParserMode;
-import org.eclipse.cdt.core.parser.ScannerInfo;
-import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
-import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
-import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
-import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
-
-@SuppressWarnings("deprecation")
-public class CDTParser {
-	List<String> sysIncludePath = new ArrayList<>();
-
-	public CDTParser() {
-	}
-	
-	public CDTParser(List<String> includesPath) {
-		for (String f:includesPath) {
-			File file = new File(f);
-			if (file.exists()) {
-				try {
-					sysIncludePath.add(file.getCanonicalPath());
-				} catch (IOException e) {
-				}
-			}else {
-				//System.err.println("include path " + f + " does not exist!");
-			}
-		}
-	}
-	NullLogService NULL_LOG = new NullLogService();
-	Map<String, String> macroMap = new HashMap<>();
-	public IASTTranslationUnit parse(String file   ) {
-		CodeReader cr;
-		try {
-			cr = new CodeReader(file);
-			return getTranslationUnitofCPP(file,new String(cr.buffer));
-		} catch (IOException e) {
-		}
-		return new CASTTranslationUnit();
-	}
-
-	
-	private IASTTranslationUnit getTranslationUnitofCPP(String file, String content) {
-		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
-				.getInstance();
-		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath.toArray(new String[] {})), ParserLanguage.CPP,
-				new NullLogService(), configuration, null);
-		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
-				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),
-				new GPPParserExtensionConfigurationExtension(), null);
-		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
-		return astTranslationUnit;
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,61 +0,0 @@
-package depends.extractor.cpp.cdt;
-
-import org.eclipse.cdt.core.dom.ast.IASTComment;
-import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
-import org.eclipse.cdt.internal.core.dom.parser.ASTTranslationUnit;
-
-public class CommentManager {
-
-	private IASTTranslationUnit translationUnit;
-	IASTComment[] comments;
-	boolean[] joinWithNext;
-	public CommentManager(IASTTranslationUnit translationUnit) {
-		this.translationUnit = translationUnit;
-		comments = ((ASTTranslationUnit) translationUnit).getComments();
-		joinWithNext = new boolean[comments.length];
-		
-		
-		for (int i=1;i<comments.length;i++) {
-			IASTComment previous = comments[i-1];
-			int previousEnd = (previous.getFileLocation().getNodeOffset()+
-					previous.getFileLocation().getNodeLength());
-			IASTComment current = comments[i];
-			if (current.getFileLocation().getNodeOffset()-previousEnd<5)
-				joinWithNext[i-1] = true;
-			else
-				joinWithNext[i-1] = false;
-		}
-		joinWithNext[comments.length-1] = false;
-	}
-
-	public String getLeadingCommentText(int startOffset) {
-		int adjacent = findCommentIndex(startOffset);
-		if (adjacent==-1) return "";
-		String comment = new String( comments[adjacent].getComment());
-		int i=adjacent-1;
-		while(i>=0) {
-			if (joinWithNext[i]) {
-				comment = new String(comments[i].getComment())+comment;
-				i--;
-			}else {
-				break;
-			}
-		}
-		return comment;
-	}
-	private int findCommentIndex(int startOffset) {
-		
-		IASTComment[] comments = ((ASTTranslationUnit) translationUnit).getComments();
-		int i=0;
-		for (;i<comments.length;i++) {
-			IASTComment c = comments[i];
-			int gap = startOffset-(c.getFileLocation().getNodeOffset()+
-					c.getFileLocation().getNodeLength());
-			if (gap>0 && gap<10) {
-				break;
-			}
-			if (gap<0) return -1;
-		}
-		return i>=comments.length?-1:i;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,190 +0,0 @@
-package depends.extractor.cpp.cdt;
-import org.eclipse.cdt.core.dom.ast.IASTNode;
-import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
-import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
-import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
-import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
-import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
-import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
-import org.eclipse.cdt.core.dom.ast.IASTExpression;
-import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
-import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
-
-import depends.entity.Expression;
-import depends.entity.repo.IdGenerator;
-import depends.extractor.HandlerContext;
-
-public class ExpressionUsage {
-	HandlerContext context;
-	IdGenerator idGenerator;
-	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator) {
-		this.context = context;
-		this.idGenerator = idGenerator;
-	}
-
-	public void foundCallExpressionOfFunctionStyle(String functionName, IASTDeclarator declarator) {
-		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId(),null);
-		context.lastContainer().addExpression(declarator,expression);
-		expression.isCall = true;
-		expression.identifier = functionName;
-	}
-	
-	public void foundExpression(IASTExpression ctx) {
-		Expression parent = findParentInStack(ctx);
-		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
-		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
-		context.lastContainer().addExpression(ctx,expression);
-
-		if (parent!=null) {
-			if (parent.deduceTypeBasedId==null) parent.deduceTypeBasedId = expression.id;
-			expression.parent = parent;
-		}
-		
-		
-		if (isTerminalExpression(ctx)) {
-			tryFillExpressionTypeAndIdentifier(ctx,expression);
-			return;
-		}
-		
-		expression.isSet = isSet(ctx);
-		expression.isCall = (ctx instanceof IASTFunctionCallExpression)?true:false;
-		expression.isLogic = isLogic(ctx);
-		if (ctx instanceof ICPPASTNewExpression){
-			expression.isCreate = true;
-		}		
-		expression.isDot = isDot(ctx);
-
-		/**
- *    | expression bop='.'
-      ( IDENTIFIER
-      | methodCall
-      )
- */
-
-		//method call
-		if (ctx instanceof IASTFunctionCallExpression) {
-			expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)ctx);
-			expression.isCall = true;
-		}
-		if (ctx instanceof ICPPASTNewExpression) {
-			expression.rawType = ASTStringUtil.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
-			expression.isCall = true;
-			expression.deriveTypeFromChild = false;
-		}
-
-		if (ctx instanceof IASTCastExpression) {
-			expression.isCast=true;
-			expression.rawType = ASTStringUtil.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
-			expression.deriveTypeFromChild = false;
-
-		}
-		if (expression.isDot) {
-			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
-			if (op2 instanceof IASTIdExpression)
-				expression.identifier = ((IASTIdExpression)op2).getName().toString();
-			else if (op2 instanceof IASTLiteralExpression)
-				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
-			else if (op2 instanceof IASTFunctionCallExpression)
-				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
-			return;
-		}		
-	}
-
-	private boolean isTerminalExpression(IASTExpression ctx) {
-		if(ctx instanceof IASTIdExpression) return true;
-		if(ctx instanceof IASTLiteralExpression) return true;
-		if(ctx instanceof IASTTypeIdExpression) return true;
-		//TODO: add others
-		return false;
-	}
-	
-	private void tryFillExpressionTypeAndIdentifier(IASTExpression ctx, Expression expression) {
-		
-		//1. we only handle leaf node. if there is still expression,
-		//   the type will be determined by child node in the expression
-		if (ctx instanceof IASTIdExpression){
-			expression.identifier = ((IASTIdExpression) ctx).getName().toString();
-		}else if (ctx instanceof IASTLiteralExpression) {
-		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = "<Literal>";
-			expression.rawType =  "<Built-in>";
-		}else if (ctx instanceof IASTTypeIdExpression) {
-		//3. if given type directly
-			expression.rawType = ASTStringUtil.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
-			//TODO: check
-		}
-	}
-
-	private String getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
-		IASTExpression f = methodCall.getFunctionNameExpression();
-		if (f instanceof IASTIdExpression) {
-			return ((IASTIdExpression)f).getName().toString();
-		}
-		return null;
-	}
-
-	private boolean isDot(IASTExpression ctx) {
-		if (ctx instanceof IASTBinaryExpression) {
-			int op = ((IASTBinaryExpression)ctx).getOperator();
-			if (op==IASTBinaryExpression.op_pmdot ||
-					op==IASTBinaryExpression.op_pmarrow	) return true;
-		}
-		return false;
-	}
-	
-	private boolean isLogic(IASTExpression ctx) {
-		if (ctx instanceof IASTBinaryExpression) {
-			 int op = ((IASTBinaryExpression)ctx).getOperator();
-			 
-			if (op == IASTBinaryExpression.op_equals ||
-					op == IASTBinaryExpression.op_notequals ||
-					op == IASTBinaryExpression.op_lessThan ||
-					op == IASTBinaryExpression.op_lessEqual ||
-					op == IASTBinaryExpression.op_greaterThan ||
-					op == IASTBinaryExpression.op_greaterEqual ||
-					op == IASTBinaryExpression.op_logicalAnd ||
-					op == IASTBinaryExpression.op_logicalOr 
-					) {
-				return true;
-			}
-		}
-		return false;
-	}
-	
-	public boolean isSet(IASTExpression ctx) {
-		if (ctx instanceof IASTBinaryExpression) {
-			 int op = ((IASTBinaryExpression)ctx).getOperator();
-			if (op>=IASTBinaryExpression.op_assign &&
-					op<=IASTBinaryExpression.op_binaryOrAssign) {
-				return true;
-			}
-		}
-		if (ctx instanceof IASTUnaryExpression) {
-			 int op = ((IASTUnaryExpression)ctx).getOperator();
-			 if (op == IASTUnaryExpression.op_prefixIncr ||
-					 op == IASTUnaryExpression.op_prefixDecr ||
-					 op == IASTUnaryExpression.op_postFixIncr ||
-					 op == IASTUnaryExpression.op_postFixIncr
-					 )
-				return true;
-			}
-		return false;
-	}
-	
-
-	private Expression findParentInStack(IASTNode ctx) {
-		if (ctx==null) return null;
-		if (ctx.getParent()==null) return null;
-		if (context.lastContainer()==null) {
-			return null;
-		}
-		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
-		return findParentInStack(ctx.getParent());
-	}
-
-
-}
\ No newline at end of file

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,22 +0,0 @@
-package depends.extractor.cpp.cdt;
-
-import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
-
-class GPPParserExtensionConfigurationExtension extends GPPParserExtensionConfiguration {
-
-	@Override
-	public boolean supportKnRC() {
-		return false;
-	}
-
-	@Override
-	public boolean supportParameterInfoBlock() {
-		return false;
-	}
-	
-	@Override
-	public boolean supportStatementsInExpressions() {
-		return false;
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,64 +0,0 @@
-package depends.extractor.java;
-
-import depends.entity.repo.BuiltInType;
-
-public class JavaBuiltInType extends BuiltInType{
-	
-	public JavaBuiltInType() {
-        super.createBuiltInTypes();
-	}
-	@Override
-	public String[] getBuiltInTypeStr() {
-		return new String[]{
-				"void","int","double","char","byte","boolean","long","short","float",
-				"BigDecimal","Integer","Double","Char","Byte","Boolean","Long","Short","Float",
-				"String","Object","Class","Exception","StringBuilder",
-				"Appendable","AutoCloseable","Cloneable","Comparable","Iterable","Readable",
-				"Runnable","Thread.UncaughtExceptionHandler","Boolean","Byte","Character","Character.Subset",
-				"Character.UnicodeBlock","ClassLoader","ClassValue","Compiler","Double","Enum",
-				"InheritableThreadLocal","Math","Number","Package","Process",
-				"ProcessBuilder","ProcessBuilder.Redirect","Runtime","RuntimePermission",
-				"SecurityManager","StackTraceElement","StrictMath","StringBuffer",
-				"System","Thread","ThreadGroup","ThreadLocal","Throwable","Void","ProcessBuilder.Redirect.Type",
-				"Thread.State","ArithmeticException","ArrayIndexOutOfBoundsException",
-				"ArrayStoreException","ClassCastException","ClassNotFoundException","CloneNotSupportedException",
-				"EnumConstantNotPresentException","Exception","IllegalAccessException","IllegalArgumentException",
-				"IllegalMonitorStateException","IllegalStateException","IllegalThreadStateException",
-				"IndexOutOfBoundsException","InstantiationException","InterruptedException",
-				"NegativeArraySizeException","NoSuchFieldException","NoSuchMethodException","NullPointerException",
-				"NumberFormatException","ReflectiveOperationException","RuntimeException","SecurityException",
-				"StringIndexOutOfBoundsException","TypeNotPresentException","UnsupportedOperationException","AbstractMethodError",
-				"AssertionError","BootstrapMethodError","ClassCircularityError","ClassFormatError","Error","ExceptionInInitializerError",
-				"IllegalAccessError","IncompatibleClassChangeError","InstantiationError","InternalError","LinkageError","NoClassDefFoundError"
-				,"NoSuchFieldError","NoSuchMethodError","OutOfMemoryError","StackOverflowError","ThreadDeath","UnknownError",
-				"UnsatisfiedLinkError","UnsupportedClassVersionError","VerifyError","VirtualMachineError","Deprecated","Override",
-				"SafeVarargs","SuppressWarnings",
-				"Collection","Comparator","Deque","Enumeration","EventListener","Formattable","Iterator","List",
-				"ListIterator","Map","Map.Entry","NavigableMap","NavigableSet","Observer","Queue","RandomAccess",
-				"Set","SortedMap","SortedSet","AbstractCollection","AbstractList","AbstractMap","AbstractMap.SimpleEntry",
-				"AbstractMap.SimpleImmutableEntry","AbstractQueue","AbstractSequentialList","AbstractSet","ArrayDeque",
-				"ArrayList","Arrays","BitSet","Calendar","Collections","Currency","Date","Dictionary","EnumMap","EnumSet",
-				"EventListenerProxy","EventObject","FormattableFlags","Formatter","GregorianCalendar","HashMap","HashSet",
-				"Hashtable","IdentityHashMap","LinkedHashMap","LinkedHashSet","LinkedList","ListResourceBundle","Locale",
-				"Locale.Builder","Objects","Observable","PriorityQueue","Properties","PropertyPermission",
-				"PropertyResourceBundle","Random","ResourceBundle","ResourceBundle.Control","Scanner",
-				"ServiceLoader","SimpleTimeZone","Stack","StringTokenizer","Timer","TimerTask","TimeZone",
-				"TreeMap","TreeSet","UUID","Vector","WeakHashMap","Formatter.BigDecimalLayoutForm",
-				"Locale.Category","ConcurrentModificationException","DuplicateFormatFlagsException",
-				"EmptyStackException","FormatFlagsConversionMismatchException","FormatterClosedException",
-				"IllegalFormatCodePointException","IllegalFormatConversionException","IllegalFormatException",
-				"IllegalFormatFlagsException","IllegalFormatPrecisionException","IllegalFormatWidthException",
-				"IllformedLocaleException","InputMismatchException","InvalidPropertiesFormatException","MissingFormatArgumentException",
-				"MissingFormatWidthException","MissingResourceException","NoSuchElementException","TooManyListenersException",
-				"UnknownFormatConversionException","UnknownFormatFlagsException","ServiceConfigurationError",
-				"<Built-in>"
-		};
-	}
-	@Override
-	public String[] getBuiltInPrefixStr() {
-		return new String[]{
-				"java.","javax.","com.sun."
-		};
-	}
-	
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,54 +0,0 @@
-package depends.extractor.java;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.PackageEntity;
-import depends.entity.repo.EntityRepo;
-import depends.importtypes.Import;
-import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
-
-public class JavaImportLookupStrategy implements ImportLookupStrategy{
-	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
-		//Java Strategy
-		String importedString = fileEntity.importedSuffixMatch(name);
-		if (importedString==null) return null;	
-		return repo.getEntity(importedString);
-	}
-
-
-	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
-		ArrayList<Entity> result = new ArrayList<>();
-		for (Import importedItem:importedList) {
-			Entity imported = repo.getEntity(importedItem.getContent());
-			if (imported==null) continue;
-			if (imported instanceof PackageEntity) { 
-				//expand import of package to all classes under the package due to we dis-courage the behavior
-				for (Entity child:imported.getChildren()) {
-					result.add(child);
-				}
-			}else {
-				result.add(imported);
-			}
-		}
-		return result;
-	}
-
-	@Override
-	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
-		return getImportedRelationEntities(importedList,repo);
-	}
-
-	@Override
-	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
-		return new ArrayList<Entity>();
-	}
-
-
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,70 +0,0 @@
-package depends.extractor.java.context;
-
-import java.lang.reflect.Method;
-import java.util.List;
-
-import org.antlr.v4.runtime.RuleContext;
-
-import depends.extractor.HandlerContext;
-import depends.extractor.java.JavaParser.AnnotationContext;
-
-public class AnnotationProcessor {
-	private HandlerContext context;
-
-	public AnnotationProcessor(HandlerContext context) {
-		this.context = context;
-	}
-	/**
-	 * for any elements who with modifiers like 'public/static/... @Annotation‘，
-	 * process annotations as "USE"
-	 * 
-	 * @param ctx
-	 * @param class1
-	 */
-	
-	private boolean containsMethod(RuleContext ctx,String methodName) {
-		try {
-			Method m = ctx.getClass().getMethod(methodName);
-			if (m!=null) return true;
-		} catch (Exception e) {
-			return false;
-		}
-		return true;
-	}
-	private Method getMethod(RuleContext ctx, String methodName) {
-		try {
-			Method m = ctx.getClass().getMethod(methodName);
-			if (m!=null) return m;
-		} catch (Exception e) {
-			return null;
-		}
-		return null;	
-	}
-	
-	public void processAnnotationModifier(RuleContext ctx, String methodName) {
-		while (true) {
-			if (ctx == null)
-				break;
-			if (containsMethod(ctx,methodName))
-				break;
-			ctx = ctx.parent;
-		}
-		if (ctx==null)return;
-			
-		Method m = getMethod(ctx,methodName);
-		if (m==null) return;
-		try {
-			List<?> modifiers = (List<?>) m.invoke(ctx);
-			for (Object modifier : modifiers) {
-				Method annotationMethod = modifier.getClass().getMethod("annotation");
-				AnnotationContext annotation = (AnnotationContext) (annotationMethod.invoke(modifier));
-				if (annotation == null)
-					return;
-				String name = QualitiedNameContextHelper.getName(annotation.qualifiedName());
-				context.foundAnnotation(name);
-			}
-		} catch (Exception e) {
-			return;
-		}
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,182 +0,0 @@
-package depends.extractor.java.context;
-
-import org.antlr.v4.runtime.RuleContext;
-
-import depends.entity.Expression;
-import depends.entity.repo.IdGenerator;
-import depends.extractor.HandlerContext;
-import depends.extractor.java.JavaParser.ExpressionContext;
-import depends.extractor.java.JavaParser.MethodCallContext;
-import depends.extractor.java.JavaParser.PrimaryContext;
-
-public class ExpressionUsage {
-	HandlerContext context;
-	IdGenerator idGenerator;
-	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator) {
-		this.context = context;
-		this.idGenerator = idGenerator;
-	}
-
-	public void foundExpression(ExpressionContext ctx) {
-		Expression parent = findParentInStack(ctx);
-		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
-		context.lastContainer().addExpression(ctx,expression);
-
-		expression.text = ctx.getText(); //for debug purpose. no actual effect
-		expression.parent = parent;
-		if (expression.parent!=null) {
-			if (expression.parent.deduceTypeBasedId==null) 
-				expression.parent.deduceTypeBasedId = expression.id;
-		}
-		
-		if (ctx.primary()!=null) {
-			tryFillExpressionTypeAndIdentifier(ctx.primary(),expression);
-			return;
-		}
-		
-		expression.isSet = isSet(ctx);
-		expression.isCall = ctx.methodCall()==null?false:true;
-		expression.isLogic = isLogic(ctx);
-		expression.isDot = isDot(ctx);
-		if (ctx.creator()!=null ||ctx.innerCreator()!=null){
-			expression.isCreate = true;
-		}		
-/**
- *    | expression bop='.'
-      ( IDENTIFIER
-      | methodCall
-      | THIS
-      | NEW nonWildcardTypeArguments? innerCreator
-      | SUPER superSuffix
-      | explicitGenericInvocation
-      )
- */
-		//method call
-		if (ctx.methodCall()!=null) {
-			expression.identifier = getMethodCallIdentifier(ctx.methodCall());
-			expression.isCall = true;
-		}
-		//new 
-		if (ctx.NEW()!=null && ctx.creator()!=null) {
-			expression.rawType = CreatorContextHelper.getCreatorType(ctx.creator());
-			expression.isCall = true;
-			expression.deriveTypeFromChild = false;
-		}
-		
-		if (ctx.typeCast()!=null) {
-			expression.isCast=true;
-			expression.rawType = ctx.typeCast().typeType().getText();
-			expression.deriveTypeFromChild = false;
-		}
-		
-		if (ctx.bop!=null && ctx.bop.getText().equals("instanceof")) {
-			expression.isCast=true;
-			expression.rawType = ctx.typeType().getText();
-			expression.deriveTypeFromChild = false;
-		}
-		
-		if (ctx.creator()!=null) {
-			expression.deriveTypeFromChild = false;
-		}
-		
-		if (expression.isDot) {
-			if (ctx.IDENTIFIER()!=null)
-				expression.identifier = ctx.IDENTIFIER().getText();
-			else if (ctx.methodCall()!=null)
-				expression.identifier = getMethodCallIdentifier(ctx.methodCall());
-			else if (ctx.THIS()!=null)
-				expression.identifier = "this";
-			else if (ctx.innerCreator()!=null) //innner creator like new List(){}
-				expression.identifier =  ctx.innerCreator().IDENTIFIER().getText();
-			else if (ctx.SUPER()!=null)
-				expression.identifier = "super";
-			return;
-		}
-	}
-
-	private String getMethodCallIdentifier(MethodCallContext methodCall) {
-		if (methodCall.THIS()!=null) {
-			return "this";
-		}else if (methodCall.SUPER()!=null) {
-			return "super";
-		}else {
-			return methodCall.IDENTIFIER().getText();
-		}
-	}
-
-	private boolean isDot(ExpressionContext ctx) {
-		if (ctx.bop!=null)
-			if (ctx.bop.getText().equals(".")) return true;
-		return false;
-	}
-	
-	private boolean isLogic(ExpressionContext ctx) {
-		if (ctx.bop != null) {
-			if (OpHelper.isLogic(ctx.bop.getText())) {
-				return true;
-			}
-		}
-		return false;
-	}
-	
-	public boolean isSet(ExpressionContext ctx) {
-		if (ctx.bop != null) {
-			if (OpHelper.isAssigment(ctx.bop.getText())) {
-				return true;
-			}
-		}
-		if (ctx.prefix != null) {
-			if (OpHelper.isIncrementalDecremental(ctx.prefix.getText())) {
-				return true;
-			}
-		}
-		if (ctx.postfix != null) {
-			if (OpHelper.isIncrementalDecremental(ctx.postfix.getText())) {
-				return true;
-			}
-		}
-		
-		return false;
-	}
-	
-//  primary
-//    : '(' expression ')'
-//    | THIS
-//    | SUPER
-//    | literal
-//    | IDENTIFIER
-//    | typeTypeOrVoid '.' CLASS
-//    | nonWildcardTypeArguments (explicitGenericInvocationSuffix | THIS arguments) //Just USE relation
-//    
-	private void tryFillExpressionTypeAndIdentifier(PrimaryContext ctx, Expression expression) {
-		if (ctx.expression()!=null) return; 
-		//1. we only handle leaf node. if there is still expression,
-		//   the type will be determined by child node in the expression
-		if (ctx.literal()!=null) {
-		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
-			expression.rawType = "<Built-in>";
-			expression.identifier = "<Literal>";
-		}else if (ctx.IDENTIFIER()!=null) {
-		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = ctx.IDENTIFIER().getText();
-		}else if (ctx.typeTypeOrVoid()!=null) {
-		//3. if given type directly
-			expression.rawType = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
-		}else if (ctx.THIS()!=null){
-			expression.identifier = "this";
-		}else if (ctx.SUPER()!=null){
-			expression.identifier = "super";
-		}
-	}
-
-	private Expression findParentInStack(RuleContext ctx) {
-		if (ctx==null) return null;
-		if (ctx.parent==null) return null;
-		if (context.lastContainer()==null) {
-			return null;
-		}
-		if (context.lastContainer().expressions().containsKey(ctx.parent)) return context.lastContainer().expressions().get(ctx.parent);
-		return findParentInStack(ctx.parent);
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,74 +0,0 @@
-package depends.extractor.java.context;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.antlr.v4.runtime.tree.TerminalNode;
-
-import depends.entity.FunctionEntity;
-import depends.entity.VarEntity;
-import depends.entity.repo.IdGenerator;
-import depends.extractor.java.JavaParser.FormalParameterContext;
-import depends.extractor.java.JavaParser.FormalParameterListContext;
-import depends.extractor.java.JavaParser.FormalParametersContext;
-import depends.extractor.java.JavaParser.LastFormalParameterContext;
-import depends.extractor.java.JavaParser.TypeTypeContext;
-import depends.extractor.java.JavaParser.VariableModifierContext;
-
-public class FormalParameterListContextHelper {
-
-	FormalParameterListContext context;
-	private IdGenerator idGenerator;
-	private List<String> annotations;
-	private FunctionEntity container;
-
-	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext,FunctionEntity container, IdGenerator idGenerator) {
-		this.context = formalParameterListContext;
-		this.container = container;
-		annotations = new ArrayList<>();
-		this.idGenerator = idGenerator;
-		if (context!=null)
-			extractParameterTypeList();
-	}
-
-	public FormalParameterListContextHelper(FormalParametersContext formalParameters,FunctionEntity container, IdGenerator idGenerator) {
-		this(formalParameters.formalParameterList(),container,idGenerator);
-	}
-
-
-
-	public void extractParameterTypeList() {
-		if (context != null) {
-			if (context.formalParameter() != null) {
-				for (FormalParameterContext p : context.formalParameter()) {
-					foundParameterDefintion(p.typeType(),p.variableDeclaratorId().IDENTIFIER(),p.variableModifier());
-				}
-				if (context.lastFormalParameter()!=null) {
-					LastFormalParameterContext p = context.lastFormalParameter();
-					foundParameterDefintion(p.typeType(),p.variableDeclaratorId().IDENTIFIER(),p.variableModifier());
-				}
-			}
-		}
-		return;
-	}
-
-	private void foundParameterDefintion(TypeTypeContext typeType, TerminalNode identifier, List<VariableModifierContext> variableModifier) {
-		String type = ClassTypeContextHelper.getClassName(typeType);
-		String varName = identifier.getText();
-		VarEntity varEntity = new VarEntity(varName,type,container,idGenerator.generateId());
-		container.addParameter(varEntity);
-		
-		for ( VariableModifierContext modifier:variableModifier) {
-			if (modifier.annotation()!=null) {
-				this.annotations.add(QualitiedNameContextHelper.getName(modifier.annotation().qualifiedName()));
-			}
-		}
-
-	}
-
-	public List<String> getAnnotations() {
-		return annotations;
-	}
-
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,16 +0,0 @@
-package depends.extractor.java.context;
-
-import java.util.List;
-
-import org.antlr.v4.runtime.tree.TerminalNode;
-
-public class IdentifierContextHelper {
-	public static String getName(List<TerminalNode> identifiers) {
-		String r = "";
-		for (TerminalNode id:identifiers) {
-			String dot = r.isEmpty()?"":".";
-			r = r + dot + id.getText();
-		}
-		return r;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,19 +0,0 @@
-package depends.extractor.java.context;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import depends.extractor.java.JavaParser.TypeParameterContext;
-import depends.extractor.java.JavaParser.TypeParametersContext;
-
-public class TypeParameterContextHelper {
-
-	public static List<String> getTypeParameters(TypeParametersContext typeParameters) {
-		ArrayList<String> r = new ArrayList<>();
-		for(TypeParameterContext param:typeParameters.typeParameter()) {
-			r.add(param.IDENTIFIER().getText());
-		}
-		return r;
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,40 +0,0 @@
-package depends.extractor.java.context;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import depends.extractor.java.JavaParser.ConstantDeclaratorContext;
-import depends.extractor.java.JavaParser.VariableDeclaratorContext;
-import depends.extractor.java.JavaParser.VariableDeclaratorIdContext;
-import depends.extractor.java.JavaParser.VariableDeclaratorsContext;
-
-public class VariableDeclaratorsContextHelper {
-
-	public static List<String> getVariables(VariableDeclaratorsContext variableDeclarators) {
-		List<String> vars = new ArrayList<>();
-		if (variableDeclarators==null) return vars; 
-		for (VariableDeclaratorContext vContext:variableDeclarators.variableDeclarator()) {
-			vars.add(vContext.variableDeclaratorId().IDENTIFIER().getText());
-		}
-		return vars;
-	}
-
-	public static List<String> getVariables(List<ConstantDeclaratorContext> constantDeclarator) {
-		List<String> vars = new ArrayList<>();
-		if (constantDeclarator==null) return vars; 
-		for (ConstantDeclaratorContext vContext:constantDeclarator) {
-			vars.add(vContext.IDENTIFIER().getText());
-		}
-		return vars;
-	}
-
-	public static List<String> getVariable(VariableDeclaratorIdContext variableDeclaratorIdContext) {
-		List<String> vars = new ArrayList<>();
-		if (variableDeclaratorIdContext==null) return vars; 
-		vars.add(variableDeclaratorIdContext.IDENTIFIER().getText());
-		return vars;
-	}
-
-
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,38 +0,0 @@
-package depends.extractor.ruby;
-
-import java.util.List;
-
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.repo.EntityRepo;
-import depends.importtypes.Import;
-import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
-
-public class RubyImportLookupStrategy implements ImportLookupStrategy {
-
-	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedNames, EntityRepo repo) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,48 +0,0 @@
-package depends.format.detail;
-
-import java.io.FileNotFoundException;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Collection;
-
-import depends.format.AbstractFormatDependencyDumper;
-import depends.matrix.DependencyMatrix;
-import depends.matrix.DependencyPair;
-import depends.matrix.DependencyValue;
-
-public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDumper{
-	ArrayList<String> files;
-	@Override
-	public String getFormatName() {
-		return "detail";
-	}
-	public DetailTextFormatDependencyDumper(DependencyMatrix matrix, String name, String outputDir) {
-		super(matrix,name,outputDir);
-	}
-	@Override
-	public boolean output() {
-		PrintWriter writer;
-		try {
-			files = matrix.getNodes();
-			writer = new PrintWriter(composeFilename() +".txt");
-	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
-	        addRelations(writer,dependencyPairs); 
-			writer.close();
-			return true;
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
-			return false;
-		}
-	}
-
-	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
-		for (DependencyPair dependencyPair:dependencyPairs) {
-            int src = dependencyPair.getFrom();
-            int dst = dependencyPair.getTo();
-        	writer.println("======="+files.get(src) + " -> " + files.get(dst) + "=========");
-        	for (DependencyValue dependency:dependencyPair.getDependencies()) {
-        	writer.println(dependency.getDetails());
-        	}
-        }		
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,52 +0,0 @@
-package depends.format.dot;
-
-import java.io.FileNotFoundException;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Collection;
-
-import depends.format.AbstractFormatDependencyDumper;
-import depends.matrix.DependencyMatrix;
-import depends.matrix.DependencyPair;
-
-public class DotFormatDependencyDumper extends  AbstractFormatDependencyDumper{
-	@Override
-	public String getFormatName() {
-		return "dot";
-	}
-	public DotFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
-		super(dependencyMatrix,projectName,outputDir);
-	}
-	@Override
-	public boolean output() {
-		PrintWriter writer;
-		try {
-			writer = new PrintWriter(composeFilename()+".dot");
-			ArrayList<String> files = matrix.getNodes();
-			
-			for (int i=0;i<files.size();i++) {
-				String file = files.get(i);
-				writer.println("// "+i + ":"+file);
-			}
-			writer.println("digraph");
-			writer.println("{");
-	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
-
-	        addRelations(writer,dependencyPairs); 
-			writer.println("}");
-			writer.close();
-			return true;
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
-			return false;
-		}
-	}
-
-	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
-		for (DependencyPair dependencyPair:dependencyPairs) {
-            int src = dependencyPair.getFrom();
-            int dst = dependencyPair.getTo();
-        	writer.println("\t"+src + " -> " + dst + ";");
-        }		
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,41 +0,0 @@
-package depends.format.json;
-
-
-import javax.xml.bind.annotation.XmlAttribute;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.bind.annotation.XmlRootElement;
-import java.util.Map;
-
-@XmlRootElement(name = "cell")
-public class JCellObject {
-    private int src;
-    private int dest;
-    private Map<String, Float> values;
-
-    public int getSrc() {
-        return src;
-    }
-
-    @XmlAttribute(name = "src")
-    public void setSrc(int src) {
-        this.src = src;
-    }
-
-    public int getDest() {
-        return dest;
-    }
-
-    @XmlAttribute(name = "dest")
-    public void setDest(int dest) {
-        this.dest = dest;
-    }
-
-    public void setValues(Map<String, Float> values) {
-        this.values = values;
-    }
-
-    @XmlElement
-    public Map<String, Float> getValues() {
-        return values;
-    }
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,50 +0,0 @@
-package depends.format.json;
-
-import javax.xml.bind.annotation.XmlAttribute;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.bind.annotation.XmlRootElement;
-import java.util.ArrayList;
-
-@XmlRootElement(name = "matrix")
-public class JDepObject {
-    private String schemaVersion;
-    private String name;
-    private ArrayList<String> variables;
-    private ArrayList<JCellObject> cells;
-
-    public String getName() {
-        return name;
-    }
-
-    @XmlAttribute(name = "name")
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getSchemaVersion() {
-        return schemaVersion;
-    }
-
-    @XmlAttribute(name = "schema-version")
-    public void setSchemaVersion(String schemaVersion) {
-        this.schemaVersion = schemaVersion;
-    }
-
-    public ArrayList<String> getVariables() {
-        return variables;
-    }
-
-    @XmlElement
-    public void setVariables(ArrayList<String> variables) {
-        this.variables = variables;
-    }
-
-    public ArrayList<JCellObject> getCells() {
-        return cells;
-    }
-
-    @XmlElement
-    public void setCells(ArrayList<JCellObject> cells) {
-        this.cells = cells;
-    }
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,39 +0,0 @@
-package depends.format.xml;
-
-import java.io.FileOutputStream;
-
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.Marshaller;
-
-import depends.format.AbstractFormatDependencyDumper;
-import depends.format.FileAttributes;
-import depends.matrix.DependencyMatrix;
-
-public class XmlFormatDependencyDumper extends AbstractFormatDependencyDumper{
-	@Override
-	public String getFormatName() {
-		return "xml";
-	}
-    public XmlFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
-		super(dependencyMatrix,projectName,outputDir);
-	}
-
-	private void toXml(XDepObject xDepObject, String xmlFileName)  {
-        try {
-            JAXBContext jaxbContext = JAXBContext.newInstance(XDepObject.class);
-            Marshaller marshaller = jaxbContext.createMarshaller();
-            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
-            marshaller.marshal(xDepObject, new FileOutputStream(xmlFileName));
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-	@Override
-	public boolean output() {
-        XDataBuilder xBuilder = new XDataBuilder();
-        XDepObject xDepObject = xBuilder.build(matrix,new FileAttributes(name));
-        toXml(xDepObject,composeFilename()+".xml");
- 		return true;
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,7 +0,0 @@
-package depends.importtypes;
-
-public class ExactMatchImport extends Import{
-	public ExactMatchImport(String content) {
-		super(content);
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,7 +0,0 @@
-package depends.importtypes;
-
-public class FileImport extends Import{
-	public FileImport(String content) {
-		super(content);
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,7 +0,0 @@
-package depends.importtypes;
-
-public class PackageWildCardImport extends Import{
-	public PackageWildCardImport(String content) {
-		super(content);
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,45 +0,0 @@
-package depends.matrix;
-
-import java.util.ArrayList;
-
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.repo.EntityRepo;
-import depends.relations.Relation;
-
-public class FileDependencyGenerator implements DependencyGenerator{
-	/**
-	 * Build the dependency matrix (without re-mapping file id)
-	 * @param entityRepo which contains entities and relations
-	 * @return the generated dependency matrix
-	 */
-	@Override
-	public DependencyMatrix build(EntityRepo entityRepo) {
-		DependencyMatrix dependencyMatrix = new DependencyMatrix();
-        ArrayList<String> files = new ArrayList<String>();
-		for (Entity entity:entityRepo.getEntities()) {
-        	if (entity instanceof FileEntity){
-        		files.add( entity.getDisplayName());
-        	}
-        	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
-        	if (fileEntityFrom==-1) continue;
-        	for (Relation relation:entity.getRelations()) {
-        		if (relation.getEntity().getId()>=0) {
-        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
-        			if (fileEntityTo==-1) continue;
-        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
-        		}
-        	}
-        }
-		dependencyMatrix.setNodes(files);
-		return dependencyMatrix;
-	}
-
-	
-	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
-		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
-		if (ancestor==null)
-			return -1;
-		return ancestor.getId();
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,50 +0,0 @@
-package depends.matrix;
-
-import java.util.ArrayList;
-
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.FunctionEntity;
-import depends.entity.repo.EntityRepo;
-import depends.relations.Relation;
-
-public class FunctionDependencyGenerator implements DependencyGenerator {
-	@Override
-	public DependencyMatrix build(EntityRepo entityRepo) {
-		DependencyMatrix dependencyMatrix = new DependencyMatrix();
-		ArrayList<String> elements = new ArrayList<String>();
-		for (Entity entity : entityRepo.getEntities()) {
-			if (entity instanceof FunctionEntity) {
-				elements.add(entity.getDisplayName());
-			}
-			int fileEntityFrom = getFunctionEntityIdNoException(entity);
-			if (fileEntityFrom == -1)
-				continue;
-			for (Relation relation : entity.getRelations()) {
-				if (relation.getEntity().getId() >= 0) {
-					int fileEntityTo = getFunctionEntityIdNoException(relation.getEntity());
-					if (fileEntityTo == -1)
-						continue;
-					dependencyMatrix.addDependency(relation.getType(), fileEntityFrom, fileEntityTo, entity,
-							relation.getEntity());
-				}
-			}
-		}
-		dependencyMatrix.setNodes(elements);
-		return dependencyMatrix;
-	}
-
-	private String getFileNameNoException(Entity entity) {
-		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
-		if (ancestor == null)
-			return "";
-		return ancestor.getRawName();
-	}
-
-	private int getFunctionEntityIdNoException(Entity entity) {
-		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
-		if (ancestor == null)
-			return -1;
-		return ancestor.getId();
-	}
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,28 +0,0 @@
-package depends.relations;
-
-import depends.entity.Entity;
-
-/**
- * Dependency relation object
- */
-public class Relation {
-	private String type;
-	private Entity toEntity;
-	
-	public Relation(String type, Entity toEntity) {
-		this.toEntity = toEntity;
-		this.type = type;
-	}
-	public String getType() {
-		return type;
-	}
-
-	@Override
-	public String toString() {
-		return "Relation[" + type + "]-->" + toEntity.getId() + "(" + toEntity.getQualifiedName() + ")";
-	}
-	public Entity getEntity() {
-		return toEntity;
-	}
-	
-}

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,118 +0,0 @@
-package depends.relations;
-
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-
-import depends.deptypes.DependencyType;
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Expression;
-import depends.entity.FileEntity;
-import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
-
-public class RelationCounter {
-
-	private Collection<Entity> entities;
-
-	public RelationCounter(Collection<Entity> entities) {
-		this.entities = entities;
-	}
-	
-	public void computeRelations() {
-		for (Entity entity:entities) {
-			if (entity instanceof FileEntity) {
-				computeImports((FileEntity)entity);
-			}
-			if (entity instanceof FunctionEntity) {
-				computeFunctionRelations((FunctionEntity)entity);
-			}
-			if (entity instanceof TypeEntity) {
-				computeTypeRelations((TypeEntity)entity);
-			}
-			if (entity instanceof ContainerEntity) {
-				computeContainerRelations((ContainerEntity)entity);
-			}
-		}
-	}
-
-	
-	private void computeContainerRelations(ContainerEntity entity) {
-		for (VarEntity var:entity.getVars()) {
-			if (var.getType()!=null)
-				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
-		}
-		for (TypeEntity type:entity.getResolvedAnnotations()) {
-			entity.addRelation(new Relation(DependencyType.USE,type));
-		}
-		for (TypeEntity type:entity.getResolvedTypeParameters()) {
-			entity.addRelation(new Relation(DependencyType.USE,type));
-		}
-		
-		HashSet<Entity> usedEntities = new HashSet<>();
-		for (Expression expression:entity.expressions().values()){
-			Entity referredEntity = expression.getReferredEntity();
-			if (referredEntity==null) {
-				continue;
-			}
-			
-			if (expression.isCall) {
-				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
-			}
-			if (expression.isCreate) {
-				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
-			}
-			if (expression.isSet) { //SET is merged with USE
-				entity.addRelation(new Relation(DependencyType.USE,referredEntity));
-			}
-			if (expression.isCast) { 
-				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
-			}
-			if (!expression.isCall && !expression.isCreate && !expression.isCast) {
-				usedEntities.add(expression.getReferredEntity());
-			}
-		}
-		
-		for (Entity usedEntity:usedEntities) {
-			entity.addRelation(new Relation(DependencyType.USE,usedEntity));
-		}
-	}
-
-	private void computeTypeRelations(TypeEntity type) {
-		for (TypeEntity superType:type.getInheritedTypes()) {
-			type.addRelation(new Relation(DependencyType.INHERIT,superType));
-		}
-		for (TypeEntity interfaceType:type.getImplementedTypes()) {
-			type.addRelation(new Relation(DependencyType.IMPLEMENT,interfaceType));
-		}
-	}
-
-	private void computeFunctionRelations(FunctionEntity func) {
-		for (TypeEntity returnType:func.getReturnTypes()) {
-			func.addRelation(new Relation(DependencyType.RETURN,returnType));
-		}
-		for (VarEntity parameter:func.getParameters()) {
-			if (parameter.getType()!=null) 
-				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType()));
-		}
-		for (TypeEntity throwType:func.getThrowTypes()) {
-			func.addRelation(new Relation(DependencyType.THROW,throwType));
-		}
-	}
-
-	private void computeImports(FileEntity file) {
-		List<Entity> imports = file.getImportedRelationEntities();
-		for (Entity imported:imports) {
-			if (imported instanceof FileEntity)
-			{
-				if (((FileEntity)imported).isInProjectScope())
-					file.addRelation(new Relation(DependencyType.IMPORT,imported));
-			}else {
-				file.addRelation(new Relation(DependencyType.IMPORT,imported));
-			}
-		}
-	}
-
-}

ca464cbab4ebc3be933fe827247018803d122721
@@ -0,0 +1,11 @@
+package depends.entity;
+
+public class FunctionCall {
+	private String rawName;
+	public FunctionCall(String rawName){
+		this.rawName = rawName;
+	}
+	public String getRawName() {
+		return rawName;
+	}
+}

ca464cbab4ebc3be933fe827247018803d122721
@@ -1,14 +1,19 @@
 package depends.entity;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import depends.relations.Inferer;
 
 public class VarEntity extends ContainerEntity {
 	private String rawType;
 	private TypeEntity type;
-
+	private List<FunctionCall> functionCalls;
+	
 	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
 		super(simpleName,  parent,id);
 		this.rawType = rawType;
+		functionCalls = new ArrayList<>();
 	}
 
 	public String getRawType() {
@@ -37,5 +42,11 @@ public class VarEntity extends ContainerEntity {
 		}
 	}
 
-	
+	public List<FunctionCall> getCalledFunctions() {
+		return functionCalls;
+	}
+
+	public void addFunctionCall(String fname) {
+		this.functionCalls.add(new FunctionCall(fname));
+	}
 }

ca464cbab4ebc3be933fe827247018803d122721
@@ -38,6 +38,7 @@ import org.jrubyparser.util.NoopVisitor;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
@@ -52,19 +53,17 @@ public class JRubyVisitor extends NoopVisitor {
 
 	public JRubyVisitor(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
 			ExecutorService executorService, Inferer inferer, ParserCreator parserCreator) {
-		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, inferer,parserCreator);
-		expressionUsage = new ExpressionUsage(context, entityRepo, helper,inferer);
+		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, inferer, parserCreator);
+		expressionUsage = new ExpressionUsage(context, entityRepo, helper, inferer);
 		context.startFile(fileFullPath);
 	}
 
-
 	@Override
 	public Object visitAliasNode(AliasNode node) {
-		context.foundNewTypeAlias(node.getNewNameString(),
-				node.getOldNameString());
+		context.foundNewTypeAlias(node.getNewNameString(), node.getOldNameString());
 		return super.visitAliasNode(node);
 	}
-	
+
 	@Override
 	public Object visitModuleNode(ModuleNode node) {
 		String name = helper.getName(node.getCPath());
@@ -79,81 +78,86 @@ public class JRubyVisitor extends NoopVisitor {
 		context.foundNewType(node.getCPath().getName());
 		Node superNode = node.getSuper();
 		if (superNode instanceof ConstNode) {
-			String superName = ((ConstNode)superNode).getName();
+			String superName = ((ConstNode) superNode).getName();
 			context.foundExtends(superName);
-		}else if (superNode instanceof SymbolNode) {
-			String superName = ((SymbolNode)superNode).getName();
+		} else if (superNode instanceof SymbolNode) {
+			String superName = ((SymbolNode) superNode).getName();
 			context.foundExtends(superName);
-		}else if (superNode instanceof Colon2ConstNode) {
-			Colon2ConstNode colon2ConstNode = (Colon2ConstNode)superNode;
+		} else if (superNode instanceof Colon2ConstNode) {
+			Colon2ConstNode colon2ConstNode = (Colon2ConstNode) superNode;
 			String name1 = helper.getName(colon2ConstNode.getLeftNode());
 			String superName = colon2ConstNode.getName();
-			context.foundExtends(name1 + "."+superName);
+			context.foundExtends(name1 + "." + superName);
 		}
-		
+
 		super.visitClassNode(node);
-		
+
 		context.exitLastedEntity();
 		return null;
 	}
 
-	
 	@Override
 	public Object visitRootNode(RootNode node) {
+		System.out.println(node);
 		return super.visitRootNode(node);
 	}
 
 	@Override
 	public Object visitFCallNode(FCallNode node) {
-		String fname  = helper.getName(node);
+		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
 		context.processSpecialFuncCall(fname, params);
 		return super.visitFCallNode(node);
 	}
 
-
 	private Collection<String> getParams(IArgumentNode node) {
 		Node args = node.getArgs();
 		Collection<String> params = new ArrayList<>();
 		if (args instanceof ArrayNode) {
-			ArrayNode argArray = (ArrayNode)args;
-			for (Node arg:argArray.childNodes()) {
+			ArrayNode argArray = (ArrayNode) args;
+			for (Node arg : argArray.childNodes()) {
 				if (arg instanceof StrNode) {
-					params.add(((StrNode)arg).getValue());
-				}else if (arg instanceof ConstNode) {
-					params.add(((ConstNode)arg).getName());
+					params.add(((StrNode) arg).getValue());
+				} else if (arg instanceof ConstNode) {
+					params.add(((ConstNode) arg).getName());
 				}
 			}
 		}
 		return params;
 	}
-	
+
 	@Override
 	public Object visitCallNode(CallNode node) {
-		String fname  = helper.getName(node);
+		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
+		Node varNode = node.getReceiver();
+		if (varNode instanceof INameNode) {
+			String varName = ((INameNode) varNode).getName();
+			Entity var = context.foundEntityWithName(varName);
+			if (var != null && var instanceof VarEntity) {
+			    VarEntity varEntity = (VarEntity)var;
+				varEntity.addFunctionCall(fname);
+			}
+		}
 		context.processSpecialFuncCall(fname, params);
 		return super.visitCallNode(node);
 	}
 
-
 	@Override
 	public Object visitUnaryCallNode(UnaryCallNode node) {
-		String fname  = helper.getName(node);
+		String fname = helper.getName(node);
 		Collection<String> params = new ArrayList<>();
 		context.processSpecialFuncCall(fname, params);
 		return super.visitUnaryCallNode(node);
 	}
 
-
+	/**
+	 * VCallNode is just a function call without parameter
+	 */
 	@Override
 	public Object visitVCallNode(VCallNode node) {
-		String fname  = helper.getName(node);
-		Collection<String> params = new ArrayList<>();
-		context.processSpecialFuncCall(fname, params);
 		return super.visitVCallNode(node);
 	}
-	
 
 	@Override
 	public Object visitDefnNode(DefnNode node) {
@@ -165,18 +169,18 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDefsNode(DefsNode node) {
-		boolean handled=false;
-	    	Node varNode = node.getReceiver();
+		boolean handled = false;
+		Node varNode = node.getReceiver();
 		if (varNode instanceof INameNode) {
-		    String varName = ((INameNode)varNode).getName();
-		    Entity var = context.foundEntityWithName(varName);
-		    if (var!=null && var instanceof ContainerEntity) {
-			context.foundMethodDeclarator(((ContainerEntity)var),node.getName());
-			handled = true;
-		    }
+			String varName = ((INameNode) varNode).getName();
+			Entity var = context.foundEntityWithName(varName);
+			if (var != null && var instanceof ContainerEntity) {
+				context.foundMethodDeclarator(((ContainerEntity) var), node.getName());
+				handled = true;
+			}
 		}
 		if (!handled) {
-		    	//fallback to add it to last container
+			// fallback to add it to last container
 			context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
 		}
 		super.visitDefsNode(node);
@@ -184,74 +188,65 @@ public class JRubyVisitor extends NoopVisitor {
 		return null;
 	}
 
-
 	@Override
 	public Object visitGlobalVarNode(GlobalVarNode node) {
-		foundVar(context.globalScope(),node.getName());
+		foundVar(context.globalScope(), node.getName());
 		return super.visitGlobalVarNode(node);
 	}
 
-
 	@Override
 	public Object visitInstVarNode(InstVarNode node) {
-		foundVar(context.currentType(),node.getName());
+		foundVar(context.currentType(), node.getName());
 		return super.visitInstVarNode(node);
 	}
 
 	@Override
 	public Object visitClassVarAsgnNode(ClassVarAsgnNode node) {
-		foundVar(context.currentType(),node.getName());
+		foundVar(context.currentType(), node.getName());
 		return super.visitClassVarAsgnNode(node);
 	}
 
-
 	@Override
 	public Object visitClassVarDeclNode(ClassVarDeclNode node) {
-		foundVar(context.currentType(),node.getName());
+		foundVar(context.currentType(), node.getName());
 		return super.visitClassVarDeclNode(node);
 	}
 
-
 	@Override
 	public Object visitClassVarNode(ClassVarNode node) {
-		foundVar(context.currentType(),node.getName());
+		foundVar(context.currentType(), node.getName());
 		return super.visitClassVarNode(node);
 	}
-	
+
 	@Override
 	public Object visitLocalVarNode(LocalVarNode node) {
 		return super.visitLocalVarNode(node);
 	}
 
-
 	@Override
 	public Object visitDVarNode(DVarNode node) {
-		foundVar(context.lastContainer(),node.getName());
+		foundVar(context.lastContainer(), node.getName());
 		return super.visitDVarNode(node);
 	}
 
-
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
-		foundVar(context.lastContainer(),node.getName());
+		foundVar(context.lastContainer(), node.getName());
 		return super.visitDAsgnNode(node);
 	}
 
-
 	@Override
 	public Object visitGlobalAsgnNode(GlobalAsgnNode node) {
-		foundVar(context.globalScope(),node.getName());
+		foundVar(context.globalScope(), node.getName());
 		return super.visitGlobalAsgnNode(node);
 	}
 
-
 	@Override
 	public Object visitInstAsgnNode(InstAsgnNode node) {
-		foundVar(context.currentType(),node.getName());
+		foundVar(context.currentType(), node.getName());
 		return super.visitInstAsgnNode(node);
 	}
 
-
 	@Override
 	public Object visitArgumentNode(ArgumentNode node) {
 		String paramName = node.getName();
@@ -259,10 +254,9 @@ public class JRubyVisitor extends NoopVisitor {
 		return super.visitArgumentNode(node);
 	}
 
-
 	@Override
 	public Object visitLocalAsgnNode(LocalAsgnNode node) {
-		foundVar(context.lastContainer(),node.getName());
+		foundVar(context.lastContainer(), node.getName());
 		return super.visitLocalAsgnNode(node);
 	}
 
@@ -271,10 +265,10 @@ public class JRubyVisitor extends NoopVisitor {
 		expressionUsage.foundExpression(node);
 		return super.visit(node);
 	}
-	
-	private void foundVar(ContainerEntity container,String varName ) {
+
+	private void foundVar(ContainerEntity container, String varName) {
 		if (!context.isNameExist(varName)) {
-			context.foundVarDefinition(container,varName);
+			context.foundVarDefinition(container, varName);
 		}
 	}
 

ca464cbab4ebc3be933fe827247018803d122721
@@ -0,0 +1,45 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.ContainerEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+import depends.util.FileUtil;
+
+public class RubyVarInvocationRecordTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_singleton_method_should_created_in_var() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/var_invocation_record.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    ContainerEntity file = (ContainerEntity)(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
+	    VarEntity var = file.getVarOfName("var");
+	    assertEquals(1,var.getCalledFunctions().size());
+	}
+}
+
+
+//class Class
+//def foo
+//end
+//end
+//
+//var = Class.new
+//var.foo
+

2cee3f0f4605e00cc839e678b9c1a29972a1237a
@@ -65,6 +65,8 @@ public class ExpressionUsage {
 				expression.rawType = expression.identifier ;
 				expression.deriveTypeFromChild  = false;
 			}
+			expression.isCall = true;
+			expression.identifier = name;
 		}
 		return expression;
 	}

2cee3f0f4605e00cc839e678b9c1a29972a1237a
@@ -88,17 +88,20 @@ public class JRubyVisitor extends NoopVisitor {
 			String name1 = helper.getName(colon2ConstNode.getLeftNode());
 			String superName = colon2ConstNode.getName();
 			context.foundExtends(name1 + "." + superName);
+		}else {
+			if (superNode!=null) {
+				System.err.println("cannot support the super node style" + superNode.toString());
+			}
 		}
 
 		super.visitClassNode(node);
-
 		context.exitLastedEntity();
 		return null;
 	}
 
 	@Override
 	public Object visitRootNode(RootNode node) {
-		System.out.println(node);
+		//System.out.println(node);
 		return super.visitRootNode(node);
 	}
 

2cee3f0f4605e00cc839e678b9c1a29972a1237a
@@ -0,0 +1,35 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.FunctionEntity;
+import depends.extractor.FileParser;
+
+public class RubyVCallTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_parameter_should_be_created() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/vcall.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
+	    assertEquals(1,function.getRelations().size());
+	}
+	
+}
+

0ce243ecffceef70d2d01cb1a213b64119595e07
@@ -67,6 +67,10 @@ public class ExpressionUsage {
 			}
 			expression.isCall = true;
 			expression.identifier = name;
+			expression.rawType = helper.getReciever(ctx);
+			if (expression.rawType!=null) {
+				//expression.isDot = true;
+			}
 		}
 		return expression;
 	}

0ce243ecffceef70d2d01cb1a213b64119595e07
@@ -30,6 +30,7 @@ import org.jrubyparser.ast.LocalVarNode;
 import org.jrubyparser.ast.ModuleNode;
 import org.jrubyparser.ast.Node;
 import org.jrubyparser.ast.RootNode;
+import org.jrubyparser.ast.SelfNode;
 import org.jrubyparser.ast.StrNode;
 import org.jrubyparser.ast.SymbolNode;
 import org.jrubyparser.ast.UnaryCallNode;
@@ -88,8 +89,8 @@ public class JRubyVisitor extends NoopVisitor {
 			String name1 = helper.getName(colon2ConstNode.getLeftNode());
 			String superName = colon2ConstNode.getName();
 			context.foundExtends(name1 + "." + superName);
-		}else {
-			if (superNode!=null) {
+		} else {
+			if (superNode != null) {
 				System.err.println("cannot support the super node style" + superNode.toString());
 			}
 		}
@@ -101,7 +102,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitRootNode(RootNode node) {
-		//System.out.println(node);
+		System.out.println(node);
 		return super.visitRootNode(node);
 	}
 
@@ -138,7 +139,7 @@ public class JRubyVisitor extends NoopVisitor {
 			String varName = ((INameNode) varNode).getName();
 			Entity var = context.foundEntityWithName(varName);
 			if (var != null && var instanceof VarEntity) {
-			    VarEntity varEntity = (VarEntity)var;
+				VarEntity varEntity = (VarEntity) var;
 				varEntity.addFunctionCall(fname);
 			}
 		}
@@ -174,14 +175,25 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitDefsNode(DefsNode node) {
 		boolean handled = false;
 		Node varNode = node.getReceiver();
-		if (varNode instanceof INameNode) {
+		if (varNode instanceof SelfNode) {
+			//will be handled by context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
+		} else if (varNode instanceof ConstNode) {
+			String className = ((INameNode) varNode).getName();
+			Entity entity = context.foundEntityWithName(className);
+			if (entity != null && entity instanceof ContainerEntity) {
+				context.foundMethodDeclarator(((ContainerEntity) entity), node.getName());
+				handled = true;
+			}
+
+		} else if (varNode instanceof INameNode) {
 			String varName = ((INameNode) varNode).getName();
 			Entity var = context.foundEntityWithName(varName);
 			if (var != null && var instanceof ContainerEntity) {
 				context.foundMethodDeclarator(((ContainerEntity) var), node.getName());
 				handled = true;
 			}
-		}
+		} 
+
 		if (!handled) {
 			// fallback to add it to last container
 			context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());

0ce243ecffceef70d2d01cb1a213b64119595e07
@@ -0,0 +1,38 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.FileParser;
+
+public class RubyClassMethodcallTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_parameter_should_be_created() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/class_method_call.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
+	    this.assertContainsRelation(function, DependencyType.CALL, "Foo1");
+	    this.assertContainsRelation(function, DependencyType.CALL, "Foo2");
+	    this.assertContainsRelation(function, DependencyType.CALL, "Foo3");
+	}
+	
+}
+

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 
+import org.jrubyparser.ast.Node;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -219,4 +220,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return null;
 	}
 
+
+
+
+
 }

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -19,7 +19,6 @@ public class Expression {
 	public boolean isLogic = false;
 	public boolean isCreate = false;
 	public boolean isCast = false;
-	public boolean autoVar = false;
 	public boolean deriveTypeFromChild = true;
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
@@ -31,7 +30,15 @@ public class Expression {
 	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
 		if (this.type!=null) return;
 		this.type = type;
-		this.referredEntity  = referredEntity;
+		if (this.identifier!=null && this.identifier.equals("bar")) {
+			System.out.println("helo");
+		}
+		if (this.referredEntity==null) {
+			this.referredEntity  = referredEntity;
+		}else if (this.referredEntity.equals(Inferer.buildInType)) {
+			if (referredEntity!=null)
+				this.referredEntity = referredEntity;
+		}
 		if (this.referredEntity==null)
 			this.referredEntity = type;
 		deduceParentType(inferer);
@@ -63,15 +70,9 @@ public class Expression {
 	 */
 	public void deduceParentType(Inferer inferer) {
 		if (this.type==null) return;
-		//deduceChildrenType(inferer);
 		deduceTheParentType(inferer);
 	}
 
-	private void deduceChildrenType(Inferer inferer) {
-		for (Expression child:this.deduceTypeChildren) {
-			child.setType(type, type, inferer);
-		}
-	}
 
 	private void deduceTheParentType(Inferer inferer) {
 		if (this.parent==null) return;

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -16,6 +16,10 @@ public class VarEntity extends ContainerEntity {
 		functionCalls = new ArrayList<>();
 	}
 
+	public void setRawType(String rawType) {
+		this.rawType =rawType;
+	}
+	
 	public String getRawType() {
 		return rawType;
 	}
@@ -49,4 +53,6 @@ public class VarEntity extends ContainerEntity {
 	public void addFunctionCall(String fname) {
 		this.functionCalls.add(new FunctionCall(fname));
 	}
+
+
 }

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -180,14 +180,20 @@ public abstract class HandlerContext {
 		}
 	}
 	
-	public void foundVarDefinition(ContainerEntity container,String varName) {
+	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
 		if (container==null) {
 			System.err.println("potentail error:" + varName + " has no container");
-			return;
+			return null;
 		}
-		VarEntity var = new VarEntity(varName, null, container, idGenerator.generateId());
+		
+		VarEntity var = getVar(container,varName);
+		if (var!=null) return var;
+		var = new VarEntity(varName, null, container, idGenerator.generateId());
 		container.addVar(var);
+		return var;
 	}
+	
+
 
 	public void foundVarDefinition(String varName, String type, List<String> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
@@ -217,11 +223,11 @@ public abstract class HandlerContext {
 		entityStack.pop();
 	}
 	
-	public boolean isNameExist(String rawName) {
-		Entity entity = inferer.resolveName(lastContainer(), rawName, true);
-		if (entity==null) return false;
-		if (entity.getId()!=-1) return true;
-		return false;
+	private VarEntity getVar(ContainerEntity container, String varName) {
+		Entity entity = inferer.resolveName(container, varName, true); //TODO: should be check based on local/class/global
+		if (entity ==null ) return null;
+		if (entity instanceof VarEntity) return (VarEntity)entity;
+		return null;
 	}
 
 	public Entity foundEntityWithName(String rawName) {

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -3,25 +3,35 @@ package depends.extractor.ruby.jruby;
 import java.util.List;
 
 import org.jrubyparser.ast.AssignableNode;
+import org.jrubyparser.ast.ClassVarNode;
+import org.jrubyparser.ast.ConstNode;
+import org.jrubyparser.ast.FCallNode;
+import org.jrubyparser.ast.GlobalVarNode;
 import org.jrubyparser.ast.ILiteralNode;
+import org.jrubyparser.ast.InstVarNode;
+import org.jrubyparser.ast.LocalVarNode;
 import org.jrubyparser.ast.Node;
+import org.jrubyparser.ast.VCallNode;
 
+import depends.entity.ContainerEntity;
 import depends.entity.Expression;
+import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
-import depends.extractor.HandlerContext;
+import depends.extractor.ruby.RubyHandlerContext;
 import depends.relations.Inferer;
 
 public class ExpressionUsage {
-	HandlerContext context;
+	RubyHandlerContext context;
 	IdGenerator idGenerator;
 	Inferer inferer;
 	private RubyParserHelper helper;
-	public ExpressionUsage(HandlerContext context,IdGenerator idGenerator, RubyParserHelper helper, Inferer inferer) {
+	public ExpressionUsage(RubyHandlerContext context,IdGenerator idGenerator, RubyParserHelper helper, Inferer inferer) {
 		this.context = context;
 		this.idGenerator = idGenerator;
 		this.inferer = inferer;
 		this.helper = helper;
 	}
+	@SuppressWarnings("deprecation")
 	public Expression foundExpression(Node ctx) {
 		Expression expression = findExpression(ctx);
 		if (expression!=null) return expression;
@@ -41,19 +51,22 @@ public class ExpressionUsage {
 		}
 		context.lastContainer().addExpression(ctx,expression);
 		if (ctx instanceof ILiteralNode) {
-			expression.identifier = ((ILiteralNode)ctx).toString();
+			expression.identifier = "<literal>";
 			expression.rawType = Inferer.buildInType.getQualifiedName();
-		}else if (ctx instanceof AssignableNode) {
+		} else if (ctx instanceof ConstNode)  {
+			expression.rawType = helper.getName(ctx);
+			expression.identifier = helper.getName(ctx);
+		} else if (ctx instanceof LocalVarNode ||
+				ctx instanceof GlobalVarNode ||
+				ctx instanceof ClassVarNode||
+				ctx instanceof InstVarNode)  {
+			expression.identifier = helper.getName(ctx);
+		} 
+		if (ctx instanceof AssignableNode) {
 			expression.isSet = true;
-			Node valueNode = ((AssignableNode)ctx).getValue();
-			List<String> names = helper.getName((AssignableNode)ctx);
-			if (names.size()==1) {
-				expression.autoVar = true;
-				expression.identifier = names.get(0);
-			}else {
-			}
 		}else if (helper.isFunctionCall(ctx)) {
 			String name = helper.getName(ctx);
+			expression.isCall = true;
 			if (name.equals("new")) {
 				expression.isCreate = true;
 				List<Node> childNodes = ctx.childNodes();
@@ -63,13 +76,27 @@ public class ExpressionUsage {
 					expression.identifier = context.currentType().getRawName();
 				}
 				expression.rawType = expression.identifier ;
-				expression.deriveTypeFromChild  = false;
-			}
-			expression.isCall = true;
-			expression.identifier = name;
-			expression.rawType = helper.getReciever(ctx);
-			if (expression.rawType!=null) {
-				//expression.isDot = true;
+				expression.deriveTypeFromChild = false;
+				Node parentNode = ctx.getParent();
+				if (parentNode instanceof AssignableNode) {
+					ContainerEntity scope = helper.getScopeOfVar((AssignableNode)parentNode, this.context);
+					VarEntity var = scope.getVarOfName(helper.getName(parentNode));
+					if (var!=null) {
+						var.setRawType(expression.rawType);
+					}
+					System.out.println(var);
+				}
+			}else {
+				expression.identifier = name;
+				expression.rawType = helper.getReciever(ctx);
+				if (expression.rawType!=null) {
+					expression.isDot = true;
+				}
+				
+				if (ctx instanceof VCallNode ||
+						ctx instanceof FCallNode) {
+					expression.deriveTypeFromChild = false;
+				}
 			}
 		}
 		return expression;

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -205,31 +205,31 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitGlobalVarNode(GlobalVarNode node) {
-		foundVar(context.globalScope(), node.getName());
+		context.foundVarDefinition(context.globalScope(), node.getName());
 		return super.visitGlobalVarNode(node);
 	}
 
 	@Override
 	public Object visitInstVarNode(InstVarNode node) {
-		foundVar(context.currentType(), node.getName());
+		context.foundVarDefinition(context.currentType(), node.getName());
 		return super.visitInstVarNode(node);
 	}
 
 	@Override
 	public Object visitClassVarAsgnNode(ClassVarAsgnNode node) {
-		foundVar(context.currentType(), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
 		return super.visitClassVarAsgnNode(node);
 	}
 
 	@Override
 	public Object visitClassVarDeclNode(ClassVarDeclNode node) {
-		foundVar(context.currentType(), node.getName());
+		context.foundVarDefinition(context.currentType(), node.getName());
 		return super.visitClassVarDeclNode(node);
 	}
 
 	@Override
 	public Object visitClassVarNode(ClassVarNode node) {
-		foundVar(context.currentType(), node.getName());
+		context.foundVarDefinition(context.currentType(), node.getName());
 		return super.visitClassVarNode(node);
 	}
 
@@ -240,25 +240,25 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDVarNode(DVarNode node) {
-		foundVar(context.lastContainer(), node.getName());
+		context.foundVarDefinition(context.lastContainer(), node.getName());
 		return super.visitDVarNode(node);
 	}
 
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
-		foundVar(context.lastContainer(), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
 		return super.visitDAsgnNode(node);
 	}
 
 	@Override
 	public Object visitGlobalAsgnNode(GlobalAsgnNode node) {
-		foundVar(context.globalScope(), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
 		return super.visitGlobalAsgnNode(node);
 	}
 
 	@Override
 	public Object visitInstAsgnNode(InstAsgnNode node) {
-		foundVar(context.currentType(), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
 		return super.visitInstAsgnNode(node);
 	}
 
@@ -271,7 +271,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitLocalAsgnNode(LocalAsgnNode node) {
-		foundVar(context.lastContainer(), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
 		return super.visitLocalAsgnNode(node);
 	}
 
@@ -281,10 +281,6 @@ public class JRubyVisitor extends NoopVisitor {
 		return super.visit(node);
 	}
 
-	private void foundVar(ContainerEntity container, String varName) {
-		if (!context.isNameExist(varName)) {
-			context.foundVarDefinition(container, varName);
-		}
-	}
+	
 
 }

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -1,7 +1,5 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
-
 import java.io.IOException;
 
 import org.junit.Before;
@@ -29,9 +27,9 @@ public class RubyClassMethodcallTest extends RubyParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
-	    this.assertContainsRelation(function, DependencyType.CALL, "Foo1");
-	    this.assertContainsRelation(function, DependencyType.CALL, "Foo2");
-	    this.assertContainsRelation(function, DependencyType.CALL, "Foo3");
+	    this.assertContainsRelation(function, DependencyType.CALL, "Foo1.bar");
+	    this.assertContainsRelation(function, DependencyType.CALL, "Foo2.bar");
+	    this.assertContainsRelation(function, DependencyType.CALL, "Foo3.bar");
 	}
 	
 }

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -29,10 +29,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
-        Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
-        assertEquals(DependencyType.INHERIT,r.getType());
-        assertEquals("Animal",r.getEntity().getRawName());
+	    this.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
 	}
 	
 	@Test
@@ -47,10 +44,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
-        Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
-        assertEquals(DependencyType.INHERIT,r.getType());
-        assertEquals("Animal",r.getEntity().getRawName());
+	    this.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
 	}
 	
 	
@@ -93,10 +87,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(1,entityRepo.getEntity("Zoo.Cow").getRelations().size());
-        Relation r = entityRepo.getEntity("Zoo.Cow").getRelations().get(0);
-        assertEquals(DependencyType.INHERIT,r.getType());
-        assertEquals("Zoo.Animal",r.getEntity().getQualifiedName());
+	    this.assertContainsRelation(entityRepo.getEntity("Zoo.Cow"), DependencyType.INHERIT, "Zoo.Animal");
 	}
 	
 	@Ignore

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -7,6 +7,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 import depends.extractor.FileParser;
 
@@ -17,7 +18,7 @@ public class RubyVCallTest extends RubyParserTest {
 	}
 	
 	@Test
-	public void test_parameter_should_be_created() throws IOException {
+	public void test_vcall() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/ruby-code-examples/vcall.rb",
 	    	    };
@@ -29,7 +30,26 @@ public class RubyVCallTest extends RubyParserTest {
 	    inferer.resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
 	    assertEquals(1,function.getRelations().size());
+	    this.assertContainsRelation(function, DependencyType.CALL, "called");
 	}
 	
+	@Test
+	public void test_continuous_call() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/continuous_func_call.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
+	    this.assertContainsRelation(function, DependencyType.CALL, "foo");
+	    this.assertContainsRelation(function, DependencyType.CALL, "bar");
+	}
+	
+	
+	
 }
 

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -0,0 +1,34 @@
+package depends.extractor.ruby;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.FileParser;
+
+public class RubyVariableCallTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_variable_call_should_be_resoved_in_case_of_new() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/variable_call.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
+	    this.assertContainsRelation(function, DependencyType.CALL, "Class.function");
+	}
+	
+}
+

f1e8f852944e7d21e4d0469f47e9dcd3c9b1de57
@@ -23,6 +23,7 @@ public class Expression {
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
 	private Entity referredEntity;
+	private List<VarEntity> deducedTypeVars;
 	public TypeEntity getType() {
 		return type;
 	}
@@ -41,11 +42,15 @@ public class Expression {
 		}
 		if (this.referredEntity==null)
 			this.referredEntity = type;
+		for (VarEntity var:deducedTypeVars) {
+			var.setType(this.type);
+		}
 		deduceParentType(inferer);
 	}
 	
 	public Expression(Integer id) {
 		this.id = id;
+		this.deducedTypeVars = new ArrayList<>();
 	}
 
 	@Override
@@ -122,4 +127,8 @@ public class Expression {
 	public void addDeduceTypeChild(Expression expression) {
 		deduceTypeChildren.add(expression);
 	}
+
+	public void addDeducedTypeVar(VarEntity var) {
+		this.deducedTypeVars.add(var);
+	}
 }
\ No newline at end of file

f1e8f852944e7d21e4d0469f47e9dcd3c9b1de57
@@ -2,15 +2,19 @@ package depends.extractor.ruby.jruby;
 
 import java.util.List;
 
+import org.jrubyparser.ast.AndNode;
 import org.jrubyparser.ast.AssignableNode;
 import org.jrubyparser.ast.ClassVarNode;
 import org.jrubyparser.ast.ConstNode;
 import org.jrubyparser.ast.FCallNode;
+import org.jrubyparser.ast.FalseNode;
 import org.jrubyparser.ast.GlobalVarNode;
 import org.jrubyparser.ast.ILiteralNode;
 import org.jrubyparser.ast.InstVarNode;
 import org.jrubyparser.ast.LocalVarNode;
 import org.jrubyparser.ast.Node;
+import org.jrubyparser.ast.OrNode;
+import org.jrubyparser.ast.TrueNode;
 import org.jrubyparser.ast.VCallNode;
 
 import depends.entity.ContainerEntity;
@@ -53,7 +57,13 @@ public class ExpressionUsage {
 		if (ctx instanceof ILiteralNode) {
 			expression.identifier = "<literal>";
 			expression.rawType = Inferer.buildInType.getQualifiedName();
-		} else if (ctx instanceof ConstNode)  {
+		} else if (ctx instanceof TrueNode || ctx instanceof FalseNode) {
+			expression.identifier = "<boolean>";
+			expression.rawType = Inferer.buildInType.getQualifiedName();
+		}else if (ctx instanceof AndNode || ctx instanceof OrNode) {
+			expression.identifier = "<logical>";
+			expression.rawType = Inferer.buildInType.getQualifiedName();
+		}else if (ctx instanceof ConstNode)  {
 			expression.rawType = helper.getName(ctx);
 			expression.identifier = helper.getName(ctx);
 		} else if (ctx instanceof LocalVarNode ||
@@ -77,15 +87,9 @@ public class ExpressionUsage {
 				}
 				expression.rawType = expression.identifier ;
 				expression.deriveTypeFromChild = false;
-				Node parentNode = ctx.getParent();
-				if (parentNode instanceof AssignableNode) {
-					ContainerEntity scope = helper.getScopeOfVar((AssignableNode)parentNode, this.context);
-					VarEntity var = scope.getVarOfName(helper.getName(parentNode));
-					if (var!=null) {
-						var.setRawType(expression.rawType);
-					}
-					System.out.println(var);
-				}
+			} else if (isArithMeticOperator(name)) {
+				expression.identifier = "<operator>";
+				expression.rawType = Inferer.buildInType.getQualifiedName();
 			}else {
 				expression.identifier = name;
 				expression.rawType = helper.getReciever(ctx);
@@ -99,8 +103,47 @@ public class ExpressionUsage {
 				}
 			}
 		}
+		deduceVarTypeInCaseOfAssignment(ctx, expression);
 		return expression;
 	}
+	private boolean isArithMeticOperator(String name) {
+		return name.equals("+") ||
+				name.equals("-") ||
+				name.equals("*") ||
+				name.equals("/") ||
+				name.equals("**") ||
+				name.equals("%") ||
+				name.equals("&") ||
+				name.equals("<") ||
+				name.equals("<=") ||
+				name.equals(">") ||
+				name.equals(">=") ||
+				name.equals("==") ||
+				name.equals("!=") ||
+				name.equals("===") ||
+				name.equals("<<") ||
+				name.equals(">>") ||
+				name.equals("~") ||
+				name.equals("!") ||
+				name.equals("^");
+	}
+	/**
+	 * Auto deduce variable type from assignment.
+	 * for example:
+	 *       c = C.new  then c is type of C
+	 * @param node
+	 * @param expression
+	 */
+	private void deduceVarTypeInCaseOfAssignment(Node node, Expression expression) {
+		Node parentNode = node.getParent();
+		if (parentNode instanceof AssignableNode) {
+			ContainerEntity scope = helper.getScopeOfVar((AssignableNode)parentNode, this.context);
+			VarEntity var = scope.getVarOfName(helper.getName(parentNode));
+			if (var!=null) {
+				expression.addDeducedTypeVar(var);
+			}
+		}
+	}
 	
 	private Expression findParentInStack(Node ctx) {
 		if (ctx==null) return null;

f1e8f852944e7d21e4d0469f47e9dcd3c9b1de57
@@ -0,0 +1,84 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.ContainerEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+import depends.relations.Inferer;
+
+public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_variable_call_should_be_resoved_in_case_of_new() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/variable_assignment.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    ContainerEntity function = (ContainerEntity)(entityRepo.getEntity("Class.test"));
+	    VarEntity var = function.getVarOfName("var_int");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+
+	    var = function.getVarOfName("var_c");
+	    assertEquals("Class",var.getType().getRawName());
+	    
+
+	    function = (ContainerEntity)(entityRepo.getEntity("Class"));
+	    var = function.getVarOfName("inst_var");
+	    assertEquals("Class",var.getType().getRawName());
+	    
+	    var = function.getVarOfName("class_var");
+	    assertEquals("Class",var.getType().getRawName());
+	}
+	
+	@Test
+	public void test_compose_expression_with_operator() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/variable_assignment.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    ContainerEntity function = (ContainerEntity)(entityRepo.getEntity("Class.operator_is_call"));
+	    VarEntity var = function.getVarOfName("var_compose");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    
+	    var = function.getVarOfName("var_1");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+
+	    var = function.getVarOfName("var_2");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+
+	    var = function.getVarOfName("var_3");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+
+	    var = function.getVarOfName("var_4");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+
+	    var = function.getVarOfName("var_5");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+
+	    var = function.getVarOfName("var_6");
+	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+
+	}
+}
+

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -20,6 +20,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Object, Expression> expressions;
+	private ArrayList<Expression> expressionList;
 	private Collection<String> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
 
@@ -30,6 +31,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
 		expressions = new HashMap<>();
+		expressionList = new  ArrayList<>();
 	}
 	
 
@@ -59,6 +61,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	public void addExpression(Object key, Expression expression) {
 		expressions.put(key, expression);
+		expressionList.add(expression);
 	}
 
 	
@@ -96,7 +99,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
-		for (Expression expression : expressions.values()) {
+		for (Expression expression : expressionList) {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
 				continue;
@@ -143,7 +146,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();
-		for (Expression exp:expressions.values()) {
+		for (Expression exp:expressionList) {
 			sb.append(exp.toString()).append("\n");
 		}
 		return sb.toString();

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -9,7 +9,6 @@ public class Expression {
 	public Integer id;
 	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;
-	private List<Expression> deduceTypeChildren = new ArrayList<>();
 	public String text; // for debug purpose
 	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
@@ -24,16 +23,15 @@ public class Expression {
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
 	private Entity referredEntity;
 	private List<VarEntity> deducedTypeVars;
+	private List<FunctionEntity> deducedTypeFunctions;
 	public TypeEntity getType() {
 		return type;
 	}
 
 	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
+		if (type==null) return;
 		if (this.type!=null) return;
 		this.type = type;
-		if (this.identifier!=null && this.identifier.equals("bar")) {
-			System.out.println("helo");
-		}
 		if (this.referredEntity==null) {
 			this.referredEntity  = referredEntity;
 		}else if (this.referredEntity.equals(Inferer.buildInType)) {
@@ -45,12 +43,16 @@ public class Expression {
 		for (VarEntity var:deducedTypeVars) {
 			var.setType(this.type);
 		}
+		for (FunctionEntity func:deducedTypeFunctions) {
+			func.addReturnType(this.type);
+		}
 		deduceParentType(inferer);
 	}
 	
 	public Expression(Integer id) {
 		this.id = id;
-		this.deducedTypeVars = new ArrayList<>();
+		deducedTypeVars = new ArrayList<>();
+		deducedTypeFunctions = new ArrayList<>();
 	}
 
 	@Override
@@ -124,11 +126,12 @@ public class Expression {
 		return referredEntity;
 	}
 
-	public void addDeduceTypeChild(Expression expression) {
-		deduceTypeChildren.add(expression);
-	}
 
 	public void addDeducedTypeVar(VarEntity var) {
 		this.deducedTypeVars.add(var);
 	}
+
+	public void addDeducedTypeFunction(FunctionEntity function) {
+		this.deducedTypeFunctions.add(function);
+	}
 }
\ No newline at end of file

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -11,7 +11,6 @@ public class FunctionEntity extends ContainerEntity{
 	Collection<VarEntity> parameters;
     Collection<String> throwTypesIdentifiers = new ArrayList<>(); 
 	private Collection<TypeEntity> returnTypes = new ArrayList<>();
-	private TypeEntity returnType;
 	private Collection<TypeEntity> throwTypes = new ArrayList<>();
     public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
 		super(simpleName, parent,id);
@@ -27,12 +26,22 @@ public class FunctionEntity extends ContainerEntity{
 	
 	@Override
 	public TypeEntity getType() {
-		return returnType;
+		if (returnTypes.size()>0)
+			return returnTypes.iterator().next();
+		return null;
 	}
 
 	public void addReturnType(String returnType) {
 		this.returnTypeIdentifiers.add(returnType);
 	}
+	
+	public void addReturnType(TypeEntity returnType) {
+		if (!this.returnTypeIdentifiers.contains(returnType.rawName)){
+			this.returnTypeIdentifiers.add(returnType.rawName);
+			this.returnTypes.add(returnType);
+		}
+	}
+
 	public void addThrowTypes(List<String> throwedType) {
 		throwTypesIdentifiers.addAll(throwedType);
 	}
@@ -42,11 +51,10 @@ public class FunctionEntity extends ContainerEntity{
 		for (VarEntity param:parameters) {
 			param.inferLocalLevelEntities(inferer);
 		}
-		returnTypes= identiferToTypes(inferer,this.returnTypeIdentifiers);
-		if (returnTypes.size()>0)
-			returnType = returnTypes.iterator().next();
-
-		throwTypes= identiferToTypes(inferer,this.throwTypesIdentifiers);
+		if (returnTypes.size()<returnTypeIdentifiers.size())
+			returnTypes = identiferToTypes(inferer,this.returnTypeIdentifiers);
+		if (throwTypes.size()<throwTypesIdentifiers.size())
+			throwTypes = identiferToTypes(inferer,this.throwTypesIdentifiers);
 		super.inferLocalLevelEntities(inferer);
 	}
 	public Collection<VarEntity> getParameters() {
@@ -67,9 +75,6 @@ public class FunctionEntity extends ContainerEntity{
 	public void addParameter(VarEntity var) {
 		this.parameters.add(var);
 	}
-	public void setReturnType(TypeEntity returnType) {
-		this.returnType = returnType;
-	}
 	@Override
 	public String getDisplayName() {
 		FileEntity f = (FileEntity) this.getAncestorOfType(FileEntity.class);

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -1,14 +1,17 @@
 package depends.entity.repo;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 
 import depends.entity.Entity;
 import depends.entity.MultiDeclareEntities;
 
 public class EntityRepo extends IdGenerator{
-	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
-	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
+	private HashMap<String, Entity> allEntieisByName = new HashMap<>();
+	private HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
+	private List<Entity> allEntitiesByOrder = new ArrayList<>();
 	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
 	public EntityRepo() {
@@ -23,6 +26,7 @@ public class EntityRepo extends IdGenerator{
 	}
 	
 	public void add(Entity entity) {
+		allEntitiesByOrder.add(entity);
 		allEntitiesById.put(entity.getId(), entity);
 		String name = entity.getRawName();
 		if (entity.getQualifiedName()!=null && !(entity.getQualifiedName().isEmpty()) ) {
@@ -45,7 +49,7 @@ public class EntityRepo extends IdGenerator{
 	}
 		
 	public Collection<Entity> getEntities() {
-		return allEntitiesById.values();
+		return allEntitiesByOrder;
 	}
 	
 	public void setParent(Entity child, Entity parent) {

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -208,7 +208,7 @@ public class JavaListener extends JavaParserBaseListener {
 		FunctionEntity method = context.foundMethodDeclarator(ctx.IDENTIFIER().getText(), ctx.IDENTIFIER().getText(),
 				throwedType);
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
-		method.setReturnType(context.currentType());
+		method.addReturnType(context.currentType());
 		annotationProcessor.processAnnotationModifier(ctx, "classBodyDeclaration");
 		super.enterConstructorDeclaration(ctx);
 	}

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -14,11 +14,13 @@ import org.jrubyparser.ast.InstVarNode;
 import org.jrubyparser.ast.LocalVarNode;
 import org.jrubyparser.ast.Node;
 import org.jrubyparser.ast.OrNode;
+import org.jrubyparser.ast.ReturnNode;
 import org.jrubyparser.ast.TrueNode;
 import org.jrubyparser.ast.VCallNode;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Expression;
+import depends.entity.FunctionEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.ruby.RubyHandlerContext;
@@ -50,7 +52,6 @@ public class ExpressionUsage {
 			/* Set operation always use the 2nd expr's type*/
 			if (expression.parent.isSet) {
 				expression.parent.deduceTypeBasedId = expression.id;
-				parent.addDeduceTypeChild(expression);
 			}
 		}
 		context.lastContainer().addExpression(ctx,expression);
@@ -104,8 +105,10 @@ public class ExpressionUsage {
 			}
 		}
 		deduceVarTypeInCaseOfAssignment(ctx, expression);
+		deduceReturnTypeInCaseOfReturn(ctx, expression);
 		return expression;
 	}
+
 	private boolean isArithMeticOperator(String name) {
 		return name.equals("+") ||
 				name.equals("-") ||
@@ -144,6 +147,13 @@ public class ExpressionUsage {
 			}
 		}
 	}
+	private void deduceReturnTypeInCaseOfReturn(Node ctx, Expression expression) {
+		FunctionEntity currentFunction = context.currentFunction();
+		if (currentFunction ==null) return;
+		if (ctx instanceof ReturnNode) {
+			expression.addDeducedTypeFunction(currentFunction);
+		}
+	}
 	
 	private Expression findParentInStack(Node ctx) {
 		if (ctx==null) return null;

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -8,6 +8,7 @@ import java.util.Collection;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.relations.Relation;
 
@@ -49,4 +50,13 @@ public abstract class ParserTest {
 	    fail("cannot found parameter with rawname " + name);		
 	}
 
+	protected void assertContainReturnType(FunctionEntity function, String name) {
+		Collection<TypeEntity> types = function.getReturnTypes();
+	    for (TypeEntity type:types) {
+	    	if (type.getRawName().equals(name)) {
+	    		return;
+	    	}
+	    }
+	    fail("cannot found return type with rawname " + name);			
+	}
 }

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -7,7 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
 import depends.entity.ContainerEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -0,0 +1,38 @@
+package depends.extractor.ruby;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.FunctionEntity;
+import depends.extractor.FileParser;
+
+public class RubyReturnTypeDedudceTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_deduce_type_of_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/deducetype_return.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
+	    this.assertContainReturnType(function,"Class");
+
+	    function = (FunctionEntity)(entityRepo.getEntity("Class.implicitReturn"));
+	    this.assertContainReturnType(function,"Class1");
+
+	}
+
+
+}
+

f3097f23bd591bf584d03ee77f915407489d27ef
@@ -2,8 +2,7 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
+import java.util.List;
 
 import depends.relations.Inferer;
 import depends.relations.Relation;
@@ -19,7 +18,7 @@ public abstract class Entity {
 	String qualifiedName = null;
 	String rawName = "";
 	Entity parent;
-	Set<Entity> children = new HashSet<>();
+	List<Entity> children = new ArrayList<>();
     ArrayList<Relation> relations = new ArrayList<>();
 
 	
@@ -39,7 +38,6 @@ public abstract class Entity {
      * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
      * Rule 4: otherwise, qualified name = parent_qualfied_name + "."+rawName
      * Rule 5: make sure the qualified name do not start with '.'
-     * TODO: the Rule 1 should be further check. Maybe issue exists - (C++中的ClassName::MethodName()会不会有问题？
      */
 	private void deduceQualifiedName() {
 		rawName = rawName.replace("::","." );

f3097f23bd591bf584d03ee77f915407489d27ef
@@ -29,24 +29,24 @@ public class Expression {
 	}
 
 	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
-		if (type==null) return;
-		if (this.type!=null) return;
-		this.type = type;
-		if (this.referredEntity==null) {
+		boolean changedType = false;
+		if (this.type==null && type!=null) {
+			this.type = type;
+			for (VarEntity var:deducedTypeVars) {
+				var.setType(this.type);
+			}
+			for (FunctionEntity func:deducedTypeFunctions) {
+				func.addReturnType(this.type);
+			}
+			changedType = true;
+		}
+		if (this.referredEntity==null && referredEntity!=null) {
 			this.referredEntity  = referredEntity;
-		}else if (this.referredEntity.equals(Inferer.buildInType)) {
-			if (referredEntity!=null)
-				this.referredEntity = referredEntity;
 		}
 		if (this.referredEntity==null)
-			this.referredEntity = type;
-		for (VarEntity var:deducedTypeVars) {
-			var.setType(this.type);
-		}
-		for (FunctionEntity func:deducedTypeFunctions) {
-			func.addReturnType(this.type);
-		}
-		deduceParentType(inferer);
+			this.referredEntity = this.type;
+		if (changedType)
+			deduceTheParentType(inferer);
 	}
 	
 	public Expression(Integer id) {
@@ -75,13 +75,8 @@ public class Expression {
 	 * @param expressionList
 	 * @param inferer
 	 */
-	public void deduceParentType(Inferer inferer) {
-		if (this.type==null) return;
-		deduceTheParentType(inferer);
-	}
-
-
 	private void deduceTheParentType(Inferer inferer) {
+		if (this.type==null) return;
 		if (this.parent==null) return;
 		Expression parent = this.parent;
 		if (parent.type != null)return;
@@ -108,18 +103,27 @@ public class Expression {
 				FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 				if (func!=null)
 					parent.setType(func.getType(), func,inferer);
+					parent.setReferredEntity(func);
 			}else {
 				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
-				if (parent.type!=null) return;
 				VarEntity var = this.getType().lookupVarsInVisibleScope(parent.identifier);
-				if (var!=null)
+				if (var!=null) {
 					parent.setType(var.getType(),var, inferer);
+					parent.setReferredEntity(var);
+				}
 			}
+
 		}
 		/* if other situation, simple make the parent and child type same */
 		else {
 			parent.setType(type, null, inferer);
 		}
+		if (parent.referredEntity==null)
+			parent.referredEntity = parent.type;
+	}
+
+	private void setReferredEntity(Entity referredEntity) {
+		this.referredEntity = referredEntity;
 	}
 
 	public Entity getReferredEntity() {

f3097f23bd591bf584d03ee77f915407489d27ef
@@ -20,7 +20,6 @@ import depends.extractor.ruby.IncludedFileLocator;
 import depends.relations.Inferer;
 import depends.util.FileUtil;
 public class JRubyFileParser implements FileParser {
-	private static final long MAX_PARSE_TIME_PER_FILE = 180000L;
 	private String fileFullPath;
 	private EntityRepo entityRepo;
 	private ExecutorService executor;
@@ -40,6 +39,7 @@ public class JRubyFileParser implements FileParser {
         this.parserCreator = parserCreator;
     }
 
+	@SuppressWarnings("unchecked")
 	@Override
 	public void parse() throws IOException {
 		/** If file already exist, skip it */

f3097f23bd591bf584d03ee77f915407489d27ef
@@ -26,10 +26,10 @@ public class RelationCounter {
 			if (entity instanceof FileEntity) {
 				computeImports((FileEntity)entity);
 			}
-			if (entity instanceof FunctionEntity) {
+			else if (entity instanceof FunctionEntity) {
 				computeFunctionRelations((FunctionEntity)entity);
 			}
-			if (entity instanceof TypeEntity) {
+			else if (entity instanceof TypeEntity) {
 				computeTypeRelations((TypeEntity)entity);
 			}
 			if (entity instanceof ContainerEntity) {

f3097f23bd591bf584d03ee77f915407489d27ef
@@ -54,7 +54,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(22,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        assertEquals(23,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
 	}
 	
 	@Test

f3097f23bd591bf584d03ee77f915407489d27ef
@@ -16,7 +16,7 @@ public class RubyClassMethodcallTest extends RubyParserTest {
 	}
 	
 	@Test
-	public void test_parameter_should_be_created() throws IOException {
+	public void test_class_method_call() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/ruby-code-examples/class_method_call.rb",
 	    	    };

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -4,7 +4,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 
-import org.jrubyparser.ast.Node;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -79,6 +78,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			func.inferLocalLevelEntities(inferer);
 		}
 		resolvedMixins = identiferToContainerEntity(inferer, mixins);
+		this.resolveExpressions(inferer);
 	}
 
 	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<String> identifiers) {
@@ -139,10 +139,14 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 	}
 
-
-	
-
-
+	public TypeEntity getLastExpressionType() {
+		for (int i=this.expressionList.size()-1;i>=0;i--) {
+			Expression expr= this.expressionList.get(i);
+			if (expr.isStatement)
+				return expr.getType();
+		}
+		return null;
+	}
 
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -18,6 +18,8 @@ public class Expression {
 	public boolean isLogic = false;
 	public boolean isCreate = false;
 	public boolean isCast = false;
+	public boolean isStatement = false; //statement is only used for return type calcuation in some langs such as ruby
+	                                    //they will not be treat as real expressions in case of relation calculation
 	public boolean deriveTypeFromChild = true;
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -56,6 +56,9 @@ public class FunctionEntity extends ContainerEntity{
 		if (throwTypes.size()<throwTypesIdentifiers.size())
 			throwTypes = identiferToTypes(inferer,this.throwTypesIdentifiers);
 		super.inferLocalLevelEntities(inferer);
+		if (this.returnTypes.size()==0 && this.getLastExpressionType()!=null) {
+			this.returnTypes.add(this.getLastExpressionType());
+		}
 	}
 	public Collection<VarEntity> getParameters() {
 		return parameters;

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -4,6 +4,7 @@ import java.util.List;
 
 import org.jrubyparser.ast.AndNode;
 import org.jrubyparser.ast.AssignableNode;
+import org.jrubyparser.ast.BlockNode;
 import org.jrubyparser.ast.ClassVarNode;
 import org.jrubyparser.ast.ConstNode;
 import org.jrubyparser.ast.FCallNode;
@@ -12,9 +13,11 @@ import org.jrubyparser.ast.GlobalVarNode;
 import org.jrubyparser.ast.ILiteralNode;
 import org.jrubyparser.ast.InstVarNode;
 import org.jrubyparser.ast.LocalVarNode;
+import org.jrubyparser.ast.NewlineNode;
 import org.jrubyparser.ast.Node;
 import org.jrubyparser.ast.OrNode;
 import org.jrubyparser.ast.ReturnNode;
+import org.jrubyparser.ast.RootNode;
 import org.jrubyparser.ast.TrueNode;
 import org.jrubyparser.ast.VCallNode;
 
@@ -39,6 +42,8 @@ public class ExpressionUsage {
 	}
 	@SuppressWarnings("deprecation")
 	public Expression foundExpression(Node ctx) {
+		if (ctx instanceof RootNode) return null;
+		if (ctx instanceof BlockNode) return null;
 		Expression expression = findExpression(ctx);
 		if (expression!=null) return expression;
 		Expression parent = findParentInStack(ctx);
@@ -46,6 +51,9 @@ public class ExpressionUsage {
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
 		expression.parent = parent;
+		if (ctx instanceof NewlineNode) {
+			expression.isStatement = true;
+		}
 		if (expression.parent!=null) {
 			if (expression.parent.deduceTypeBasedId==null) 
 				expression.parent.deduceTypeBasedId = expression.id;

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -56,9 +56,6 @@ public class JRubyFileParser implements FileParser {
 		Node node = rubyParser.parse("<code>", in, config);
 		node.accept(new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator));
 		fileEntity = entityRepo.getEntity(fileFullPath);
-		if (fileEntity!=null) {
-			fileEntity.inferEntities(inferer);
-		}
 	}
 
 }

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -59,11 +59,13 @@ public class RelationCounter {
 		
 		HashSet<Entity> usedEntities = new HashSet<>();
 		for (Expression expression:entity.expressions().values()){
+			if (expression.isStatement) {
+				continue;
+			}
 			Entity referredEntity = expression.getReferredEntity();
 			if (referredEntity==null) {
 				continue;
 			}
-			
 			if (expression.isCall) {
 				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
 			}

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -29,7 +29,6 @@ public class RubyVCallTest extends RubyParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
-	    assertEquals(1,function.getRelations().size());
 	    this.assertContainsRelation(function, DependencyType.CALL, "called");
 	}
 	

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -12,6 +12,7 @@ public class FileEntity extends ContainerEntity {
 	private List<Entity> importedRelationEntities = new ArrayList<>();
 	private List<Entity> importedFiles = new ArrayList<>();
 	private List<Entity> importedTypes = new ArrayList<>();
+	private List<TypeEntity> declaredTypes = new ArrayList<>();
 
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
 		super(fullName, null, fileId);
@@ -91,4 +92,12 @@ public class FileEntity extends ContainerEntity {
 		return importedTypes;
 	}
 
+	public List<TypeEntity> getDeclaredTypes() {
+		return this.declaredTypes;
+	}
+
+	public void addType(TypeEntity currentTypeEntity) {
+		this.declaredTypes.add(currentTypeEntity);
+	}
+
 }

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -49,6 +49,7 @@ public class FunctionEntity extends ContainerEntity{
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
 		for (VarEntity param:parameters) {
+			param.fillCandidateTypes(inferer);
 			param.inferLocalLevelEntities(inferer);
 		}
 		if (returnTypes.size()<returnTypeIdentifiers.size())
@@ -83,4 +84,12 @@ public class FunctionEntity extends ContainerEntity{
 		FileEntity f = (FileEntity) this.getAncestorOfType(FileEntity.class);
 		return f.getRawName()+"("+getRawName()+")";
 	}
+	@Override
+	public VarEntity getVarOfName(String varName) {
+		for (VarEntity var:this.parameters) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		return super.getVarOfName(varName);
+	}
 }

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -9,11 +9,13 @@ public class VarEntity extends ContainerEntity {
 	private String rawType;
 	private TypeEntity type;
 	private List<FunctionCall> functionCalls;
+	private List<TypeEntity> candidateTypes;
 	
 	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
 		super(simpleName,  parent,id);
 		this.rawType = rawType;
 		functionCalls = new ArrayList<>();
+		candidateTypes = new ArrayList<>();
 	}
 
 	public void setRawType(String rawType) {
@@ -54,5 +56,13 @@ public class VarEntity extends ContainerEntity {
 		this.functionCalls.add(new FunctionCall(fname));
 	}
 
+	public void fillCandidateTypes(Inferer inferer) {
+		if (type!=null) return ; //it is a strong type lang, do not need deduce candidate types
+		if (functionCalls.size()==0) return; //no information avaliable for type deduction
+		this.candidateTypes = inferer.calculateCandidateTypes(this,this.functionCalls);
+	}
 
+	public List<TypeEntity> getCandidateTypes() {
+		return candidateTypes;
+	}
 }

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -46,6 +46,7 @@ public abstract class HandlerContext {
 			idGenerator.generateId());
 		pushToStack(currentTypeEntity);
 	 	entityRepo.add(currentTypeEntity);
+	 	currentFileEntity.addType(currentTypeEntity);
 		return currentTypeEntity;
 	}
 

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -43,5 +43,9 @@ public class CppBuiltInType extends BuiltInType {
 	public String[] getBuiltInPrefixStr() {
 		return new String[] {"__"};
 	}
+	@Override
+	public String[] getBuiltInMethods() {
+		return new String[]{};
+	}
 
 }
\ No newline at end of file

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -60,5 +60,9 @@ public class JavaBuiltInType extends BuiltInType{
 				"java.","javax.","com.sun."
 		};
 	}
+	@Override
+	public String[] getBuiltInMethods() {
+		return new String[]{};
+	}
 	
 }

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -96,7 +96,7 @@ public class ExpressionUsage {
 				}
 				expression.rawType = expression.identifier ;
 				expression.deriveTypeFromChild = false;
-			} else if (isArithMeticOperator(name)) {
+			} else if (helper.isArithMeticOperator(name)) {
 				expression.identifier = "<operator>";
 				expression.rawType = Inferer.buildInType.getQualifiedName();
 			}else {
@@ -117,27 +117,7 @@ public class ExpressionUsage {
 		return expression;
 	}
 
-	private boolean isArithMeticOperator(String name) {
-		return name.equals("+") ||
-				name.equals("-") ||
-				name.equals("*") ||
-				name.equals("/") ||
-				name.equals("**") ||
-				name.equals("%") ||
-				name.equals("&") ||
-				name.equals("<") ||
-				name.equals("<=") ||
-				name.equals(">") ||
-				name.equals(">=") ||
-				name.equals("==") ||
-				name.equals("!=") ||
-				name.equals("===") ||
-				name.equals("<<") ||
-				name.equals(">>") ||
-				name.equals("~") ||
-				name.equals("!") ||
-				name.equals("^");
-	}
+
 	/**
 	 * Auto deduce variable type from assignment.
 	 * for example:

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -49,7 +49,7 @@ import depends.relations.Inferer;
 public class JRubyVisitor extends NoopVisitor {
 
 	private RubyHandlerContext context;
-	RubyParserHelper helper = new RubyParserHelper();
+	RubyParserHelper helper = RubyParserHelper.getInst();
 	private ExpressionUsage expressionUsage;
 
 	public JRubyVisitor(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
@@ -102,7 +102,6 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitRootNode(RootNode node) {
-		System.out.println(node);
 		return super.visitRootNode(node);
 	}
 
@@ -134,6 +133,14 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitCallNode(CallNode node) {
 		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
+		addCallToReceiverVar(node, fname);
+		context.processSpecialFuncCall(fname, params);
+		return super.visitCallNode(node);
+	}
+
+	private void addCallToReceiverVar(CallNode node, String fname) {
+		if (helper.isCommonOperator(fname))return;
+		System.out.println("called ->"+fname);
 		Node varNode = node.getReceiver();
 		if (varNode instanceof INameNode) {
 			String varName = ((INameNode) varNode).getName();
@@ -143,8 +150,6 @@ public class JRubyVisitor extends NoopVisitor {
 				varEntity.addFunctionCall(fname);
 			}
 		}
-		context.processSpecialFuncCall(fname, params);
-		return super.visitCallNode(node);
 	}
 
 	@Override
@@ -280,7 +285,4 @@ public class JRubyVisitor extends NoopVisitor {
 		expressionUsage.foundExpression(node);
 		return super.visit(node);
 	}
-
-	
-
 }

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -0,0 +1,41 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+
+public class RubyParameterTypeDedudceTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_deduce_type_of_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/deducetype_parameter.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
+	    VarEntity var = function.getVarOfName("t1");
+	    List<TypeEntity> types = var.getCandidateTypes();
+	    assertEquals(2,types.size());
+	}
+
+
+}
+

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -0,0 +1,287 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+import depends.relations.Inferer;
+import depends.relations.Relation;
+
+public class CandidateTypes extends TypeEntity {
+	private List<TypeEntity> candidateTypes;
+
+	public CandidateTypes(List<TypeEntity> candidateTypes) {
+		super("candidateTypes", null, -1);
+		this.candidateTypes = candidateTypes;
+	}
+
+	public List<TypeEntity> getCandidateTypes() {
+		return candidateTypes;
+	}
+
+ 	@Override
+	public Collection<TypeEntity> getInheritedTypes() {
+ 		List<TypeEntity> result = new ArrayList<>();
+		for (TypeEntity type:candidateTypes) {
+			result.addAll(type.getInheritedTypes());
+		}
+		return result;
+	}
+	
+ 	@Override
+	public Collection<TypeEntity> getImplementedTypes() {
+ 		List<TypeEntity> result = new ArrayList<>();
+		for (TypeEntity type:candidateTypes) {
+			result.addAll(type.getImplementedTypes());
+		}
+		return result;
+	}
+ 	
+	@Override
+	public ArrayList<FunctionEntity> getFunctions() {
+ 		ArrayList<FunctionEntity> result = new ArrayList<>();
+		for (TypeEntity type:candidateTypes) {
+			result.addAll(type.getFunctions());
+		}
+		return result;
+	}
+	
+ 	@Override
+ 	public TypeEntity getInheritedType() {
+		return inheritedType;
+	}
+ 	@Override
+ 	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+ 		for (TypeEntity type:candidateTypes) {
+			FunctionEntity f = type.lookupFunctionInVisibleScope(functionName);
+			if (f!=null) return f;
+		}
+ 		return null;
+	}
+ 	
+	@Override
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		for (TypeEntity type:candidateTypes) {
+			VarEntity v = type.lookupVarsInVisibleScope(varName);
+			if (v!=null) return v;
+		}
+ 		return null;	
+	}
+	
+	
+	@Override
+	public VarEntity getVarOfName(String varName) {
+		for (TypeEntity type:candidateTypes) {
+			VarEntity v = type.getVarOfName(varName);
+			if (v!=null) return v;
+		}
+		return null;
+	}
+	
+ 	@Override
+ 	public TypeEntity getType() {
+ 		if (candidateTypes.size()>0) return candidateTypes.get(0);
+		return null;
+	}
+
+	@Override
+	public void inferLocalLevelEntities(Inferer inferer) {
+		System.err.println("error: inferLocalLevelEntities should not been invoked");
+		super.inferLocalLevelEntities(inferer);
+	}
+
+	@Override
+	public void addImplements(String typeName) {
+		System.err.println("error: addImplements should not been invoked");
+		super.addImplements(typeName);
+	}
+
+	@Override
+	public void addExtends(String typeName) {
+		System.err.println("error: addExtends should not been invoked");
+		super.addExtends(typeName);
+	}
+
+	@Override
+	public void addVar(VarEntity var) {
+		System.err.println("error: addVar should not been invoked");
+		super.addVar(var);
+	}
+
+	@Override
+	public ArrayList<VarEntity> getVars() {
+		System.err.println("error: getVars should not been invoked");
+		return super.getVars();
+	}
+
+	@Override
+	public void addFunction(FunctionEntity functionEntity) {
+		System.err.println("error: addFunction should not been invoked");
+		super.addFunction(functionEntity);
+	}
+
+	@Override
+	public HashMap<Object, Expression> expressions() {
+		System.err.println("error: expressions should not been invoked");
+		return super.expressions();
+	}
+
+	@Override
+	public void addExpression(Object key, Expression expression) {
+		System.err.println("error: addExpression should not been invoked");
+		super.addExpression(key, expression);
+	}
+
+	@Override
+	public void resolveExpressions(Inferer inferer) {
+		System.err.println("error: resolveExpressions should not been invoked");
+		super.resolveExpressions(inferer);
+	}
+
+	@Override
+	public TypeEntity getLastExpressionType() {
+		System.err.println("error: getLastExpressionType should not been invoked");
+		return super.getLastExpressionType();
+	}
+
+	@Override
+	public void addMixin(String moduleName) {
+		System.err.println("error: addMixin should not been invoked");
+		super.addMixin(moduleName);
+	}
+
+	@Override
+	public Collection<ContainerEntity> getResolvedMixins() {
+		System.err.println("error: getResolvedMixins should not been invoked");
+		return super.getResolvedMixins();
+	}
+
+	@Override
+	public void addTypeParameter(List<String> typeArguments) {
+		System.err.println("error: addTypeParameter should not been invoked");
+		super.addTypeParameter(typeArguments);
+	}
+
+	@Override
+	public void addAnnotation(String name) {
+		System.err.println("error: addAnnotation should not been invoked");
+		super.addAnnotation(name);
+	}
+
+	@Override
+	public void addTypeParameter(String typeName) {
+		System.err.println("error: addTypeParameter should not been invoked");
+		super.addTypeParameter(typeName);
+	}
+
+	@Override
+	public Collection<TypeEntity> getResolvedTypeParameters() {
+		System.err.println("error: getResolvedTypeParameters should not been invoked");
+		return super.getResolvedTypeParameters();
+	}
+
+	@Override
+	public Collection<TypeEntity> getResolvedAnnotations() {
+		System.err.println("error: getResolvedAnnotations should not been invoked");
+		return super.getResolvedAnnotations();
+	}
+
+	@Override
+	public boolean isGenericTypeParameter(String rawType) {
+		System.err.println("error: isGenericTypeParameter should not been invoked");
+		return super.isGenericTypeParameter(rawType);
+	}
+
+	@Override
+	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
+		System.err.println("error: identiferToTypes should not been invoked");
+		return super.identiferToTypes(inferer, identifiers);
+	}
+
+	@Override
+	public String getRawName() {
+		System.err.println("error: getRawName should not been invoked");
+		return super.getRawName();
+	}
+
+	@Override
+	public int getId() {
+		System.err.println("error: getId should not been invoked");
+		return super.getId();
+	}
+
+	@Override
+	public void addRelation(Relation relation) {
+		System.err.println("error: addRelation should not been invoked");
+		super.addRelation(relation);
+	}
+
+	@Override
+	public ArrayList<Relation> getRelations() {
+		System.err.println("error: getRelations should not been invoked");
+		return super.getRelations();
+	}
+
+	@Override
+	public void addChild(Entity child) {
+		System.err.println("error: addChild should not been invoked");
+		super.addChild(child);
+	}
+
+	@Override
+	public Entity getParent() {
+		System.err.println("error: getParent should not been invoked");
+		return super.getParent();
+	}
+
+	@Override
+	public void setParent(Entity parent) {
+		System.err.println("error: setParent should not been invoked");
+		super.setParent(parent);
+	}
+
+	@Override
+	public Collection<Entity> getChildren() {
+		System.err.println("error: getChildren should not been invoked");
+		return super.getChildren();
+	}
+
+	@Override
+	public void setQualifiedName(String qualifiedName) {
+		System.err.println("error: setQualifiedName should not been invoked");
+		super.setQualifiedName(qualifiedName);
+	}
+
+	@Override
+	public void setRawName(String rawName) {
+		System.err.println("error: setRawName should not been invoked");
+		super.setRawName(rawName);
+	}
+
+	@Override
+	public String getQualifiedName(boolean overrideFileWithPackage) {
+		System.err.println("error: getQualifiedName should not been invoked");
+		return super.getQualifiedName(overrideFileWithPackage);
+	}
+
+	
+	@Override
+	public Entity getAncestorOfType(Class classType) {
+		System.err.println("error: getAncestorOfType should not been invoked");
+		return super.getAncestorOfType(classType);
+	}
+
+	@Override
+	public void inferEntities(Inferer inferer) {
+		System.err.println("error: inferEntities should not been invoked");
+		super.inferEntities(inferer);
+	}
+
+	@Override
+	public String getDisplayName() {
+		System.err.println("error: getDisplayName should not been invoked");
+		return super.getDisplayName();
+	}
+ 	
+}

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -186,7 +186,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @return
 	 */
 	public VarEntity lookupVarsInVisibleScope(String varName) {
-		
 		ContainerEntity fromEntity = this;
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -1,7 +1,9 @@
 package depends.entity;
 
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import depends.importtypes.Import;
 import depends.relations.Inferer;
@@ -13,7 +15,7 @@ public class FileEntity extends ContainerEntity {
 	private List<Entity> importedFiles = new ArrayList<>();
 	private List<Entity> importedTypes = new ArrayList<>();
 	private List<TypeEntity> declaredTypes = new ArrayList<>();
-
+	private ImportedFileCollector importedFileCollector = null;
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
 		super(fullName, null, fileId);
 		setQualifiedName(fullName);
@@ -100,4 +102,10 @@ public class FileEntity extends ContainerEntity {
 		this.declaredTypes.add(currentTypeEntity);
 	}
 
+	public Set<FileEntity> getImportedFilesInAllLevel() {
+		if (importedFileCollector==null)
+			importedFileCollector = new ImportedFileCollector(this);
+		return importedFileCollector.getFiles();
+	}
+
 }

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -0,0 +1,29 @@
+package depends.entity;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class ImportedFileCollector {
+	Set<FileEntity> checkedFiles = new HashSet<>();
+	Set<FileEntity> files = new HashSet<>();
+
+	public ImportedFileCollector(FileEntity fileEntity) {
+		appendImportedFiles(fileEntity);
+	}
+
+	private void appendImportedFiles(FileEntity fileEntity) {
+
+		if (checkedFiles.contains(fileEntity)) return;
+		checkedFiles.add(fileEntity);
+		files.add(fileEntity);
+		for (Entity importedFile:fileEntity.getImportedFiles()) {
+			if (importedFile instanceof FileEntity) {
+				appendImportedFiles((FileEntity)importedFile);
+			}
+		}
+	}
+
+	public Set<FileEntity> getFiles() {
+		return files;
+	}
+}

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -53,18 +53,19 @@ public class TypeEntity extends ContainerEntity{
 		if (funcType!=null) return funcType;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
 			funcType = inhertedType.lookupFunctionLocally(functionName);
-			if (funcType == null)
+			if (funcType != null)
 				break;
 		}
 		if (funcType != null)
 			return funcType;
 		for (TypeEntity implType : getImplementedTypes()) {
 			funcType = implType.lookupFunctionLocally( functionName);
-			if (funcType == null)
+			if (funcType != null)
 				break;
 		}
 		return funcType;
  	}
+ 	
  	@Override
  	public TypeEntity getType() {
 		return this;

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -9,13 +9,11 @@ public class VarEntity extends ContainerEntity {
 	private String rawType;
 	private TypeEntity type;
 	private List<FunctionCall> functionCalls;
-	private List<TypeEntity> candidateTypes;
 	
 	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
 		super(simpleName,  parent,id);
 		this.rawType = rawType;
 		functionCalls = new ArrayList<>();
-		candidateTypes = new ArrayList<>();
 	}
 
 	public void setRawType(String rawType) {
@@ -46,6 +44,9 @@ public class VarEntity extends ContainerEntity {
 				type = Inferer.genericParameterType;
 			}
 		}
+		if (type==null) {
+			fillCandidateTypes(inferer);
+		}
 	}
 
 	public List<FunctionCall> getCalledFunctions() {
@@ -59,10 +60,8 @@ public class VarEntity extends ContainerEntity {
 	public void fillCandidateTypes(Inferer inferer) {
 		if (type!=null) return ; //it is a strong type lang, do not need deduce candidate types
 		if (functionCalls.size()==0) return; //no information avaliable for type deduction
-		this.candidateTypes = inferer.calculateCandidateTypes(this,this.functionCalls);
-	}
-
-	public List<TypeEntity> getCandidateTypes() {
-		return candidateTypes;
+		if (this.rawType==null) {
+			this.type = new CandidateTypes(inferer.calculateCandidateTypes(this,this.functionCalls));
+		}
 	}
 }

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -53,9 +53,14 @@ public class JRubyFileParser implements FileParser {
 		StringReader in = new StringReader(input.toString());
 		CompatVersion version = CompatVersion.RUBY2_3;
 		ParserConfiguration config = new ParserConfiguration(0, version);
-		Node node = rubyParser.parse("<code>", in, config);
-		node.accept(new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator));
-		fileEntity = entityRepo.getEntity(fileFullPath);
+		try {
+			Node node = rubyParser.parse("<code>", in, config);
+			node.accept(new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator));
+			fileEntity = entityRepo.getEntity(fileFullPath);
+			fileEntity.inferEntities(inferer);
+		}catch(Exception e) {
+			System.err.println("parsing error in "+fileFullPath);
+		}
 	}
 
 }

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -140,7 +140,6 @@ public class JRubyVisitor extends NoopVisitor {
 
 	private void addCallToReceiverVar(CallNode node, String fname) {
 		if (helper.isCommonOperator(fname))return;
-		System.out.println("called ->"+fname);
 		Node varNode = node.getReceiver();
 		if (varNode instanceof INameNode) {
 			String varName = ((INameNode) varNode).getName();

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -1,9 +1,12 @@
 package depends.matrix;
 
 import java.util.ArrayList;
+import java.util.List;
 
+import depends.entity.CandidateTypes;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
+import depends.entity.TypeEntity;
 import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
 
@@ -24,10 +27,24 @@ public class FileDependencyGenerator implements DependencyGenerator{
         	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
         	if (fileEntityFrom==-1) continue;
         	for (Relation relation:entity.getRelations()) {
-        		if (relation.getEntity().getId()>=0) {
-        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
-        			if (fileEntityTo==-1) continue;
-        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
+        		Entity relatedEntity = relation.getEntity();
+        		if (relatedEntity instanceof CandidateTypes) {
+        			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
+        			for (TypeEntity candidateType:candidateTypes) {
+    	        		if (candidateType.getId()>=0) {
+    	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,candidateType);
+    	        			if (fileEntityTo!=-1) {
+    	        				dependencyMatrix.addDependency(relation.getType()+"(Candidate)", fileEntityFrom,fileEntityTo,entity,candidateType);
+    	        			}
+    	        		}
+        			}
+        		}else {
+	        		if (relatedEntity.getId()>=0) {
+	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relatedEntity);
+	        			if (fileEntityTo!=-1) {
+	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relatedEntity);
+	        			}
+	        		}
         		}
         	}
         }

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -1,13 +1,14 @@
 package depends.extractor.ruby;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
-import java.util.List;
 
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.entity.CandidateTypes;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
@@ -32,10 +33,9 @@ public class RubyParameterTypeDedudceTest extends RubyParserTest {
 	    inferer.resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
 	    VarEntity var = function.getVarOfName("t1");
-	    List<TypeEntity> types = var.getCandidateTypes();
-	    assertEquals(2,types.size());
+	    TypeEntity type = var.getType();
+	    assertTrue(type instanceof CandidateTypes);
+	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
 	}
-
-
 }
 

e24e3960f77b60597272487b31a9d91720a3c8ff
@@ -105,6 +105,7 @@ public class FileEntity extends ContainerEntity {
 	public Set<FileEntity> getImportedFilesInAllLevel() {
 		if (importedFileCollector==null)
 			importedFileCollector = new ImportedFileCollector(this);
+
 		return importedFileCollector.getFiles();
 	}
 

e24e3960f77b60597272487b31a9d91720a3c8ff
@@ -57,6 +57,7 @@ public class JRubyVisitor extends NoopVisitor {
 		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, inferer, parserCreator);
 		expressionUsage = new ExpressionUsage(context, entityRepo, helper, inferer);
 		context.startFile(fileFullPath);
+
 	}
 
 	@Override

e24e3960f77b60597272487b31a9d91720a3c8ff
@@ -34,7 +34,7 @@ public class FileDependencyGenerator implements DependencyGenerator{
     	        		if (candidateType.getId()>=0) {
     	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,candidateType);
     	        			if (fileEntityTo!=-1) {
-    	        				dependencyMatrix.addDependency(relation.getType()+"(Candidate)", fileEntityFrom,fileEntityTo,entity,candidateType);
+    	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,candidateType);
     	        			}
     	        		}
         			}

a468b34326c2c9bb38f046acba12293c2ef7b863
@@ -16,12 +16,17 @@ public class AliasEntity extends Entity {
 
 	public void inferLocalLevelEntities(Inferer inferer) {
 		Entity entity = inferer.resolveName(this, originName, true);
+		while(entity instanceof AliasEntity) {
+			AliasEntity aliasEntity = (AliasEntity)entity;
+			entity = inferer.resolveName(aliasEntity, aliasEntity.originName,true);
+			if (entity==null) break;
+			if (entity.equals(this)) {
+				entity = null;
+				break;
+			}
+		}
 		if (entity != null)
 			referToEntity = entity;
-		if (entity.equals(this)) {
-			referToEntity = new EmptyTypeEntity();
-		}
-		referToEntity.inferLocalLevelEntities(inferer);
 	}
 
 	public Collection<TypeEntity> getResolvedTypeParameters() {

a468b34326c2c9bb38f046acba12293c2ef7b863
@@ -20,7 +20,9 @@ public class TypeEntity extends ContainerEntity{
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
 		inheritedTypes= identiferToTypes(inferer,this.inhertedTypeIdentifiers);
+		inheritedTypes.remove(this);
 		implementedTypes= identiferToTypes(inferer,this.implementedIdentifiers);
+		implementedTypes.remove(this);
 		if (inheritedTypes.size()>0)
 			inheritedType = inheritedTypes.iterator().next();
 		super.inferLocalLevelEntities(inferer);
@@ -28,11 +30,13 @@ public class TypeEntity extends ContainerEntity{
 	public void addImplements(String typeName) {
 		if (typeName.equals(this.getRawName())) return;
 		if (implementedIdentifiers.contains(typeName)) return;
+		if (typeName.equals(this.rawName)) return;
 		this.implementedIdentifiers.add(typeName);
 	}
 	public void addExtends(String typeName) {
 		if (typeName.equals(this.getRawName())) return;
 		if (inhertedTypeIdentifiers.contains(typeName)) return;
+		if (typeName.equals(this.rawName)) return;
 		this.inhertedTypeIdentifiers.add(typeName);
 	}
 	public Collection<TypeEntity> getInheritedTypes() {

65c0b0c4055b0c16ac00850488ab68600ac7ff44
@@ -183,8 +183,8 @@ public abstract class HandlerContext {
 	
 	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
 		if (container==null) {
-			System.err.println("potentail error:" + varName + " has no container");
-			return null;
+			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
+			container = currentFile();
 		}
 		
 		VarEntity var = getVar(container,varName);

65c0b0c4055b0c16ac00850488ab68600ac7ff44
@@ -13,6 +13,7 @@ import org.jrubyparser.ast.ClassVarAsgnNode;
 import org.jrubyparser.ast.ClassVarDeclNode;
 import org.jrubyparser.ast.ClassVarNode;
 import org.jrubyparser.ast.Colon2ConstNode;
+import org.jrubyparser.ast.Colon3Node;
 import org.jrubyparser.ast.ConstNode;
 import org.jrubyparser.ast.DAsgnNode;
 import org.jrubyparser.ast.DVarNode;
@@ -90,7 +91,11 @@ public class JRubyVisitor extends NoopVisitor {
 			String name1 = helper.getName(colon2ConstNode.getLeftNode());
 			String superName = colon2ConstNode.getName();
 			context.foundExtends(name1 + "." + superName);
-		} else {
+		} else if (superNode instanceof Colon3Node){
+			Colon3Node colon3Node = (Colon3Node) superNode;
+			String superName = colon3Node.getName();
+			context.foundExtends(superName + "." + superName);
+		}else{
 			if (superNode != null) {
 				System.err.println("cannot support the super node style" + superNode.toString());
 			}

ff958d154cd7c759098fc9911071ce6f194a3466
@@ -18,6 +18,7 @@ public class Expression {
 	public boolean isLogic = false;
 	public boolean isCreate = false;
 	public boolean isCast = false;
+	public boolean isThrow = false;
 	public boolean isStatement = false; //statement is only used for return type calcuation in some langs such as ruby
 	                                    //they will not be treat as real expressions in case of relation calculation
 	public boolean deriveTypeFromChild = true;
@@ -67,6 +68,8 @@ public class Expression {
 		                      .append(isSet?"[set]":"")
 		                      .append(isLogic?"[bool]":"")
 		                      .append(isCall?"[call]":"").append("|")
+		                      .append(isCreate?"[new]":"").append("|")
+		                      .append(isThrow?"[throw]":"").append("|")
 		    .append("parent:").append(parent==null?"nil":parent.text).append("|")
 			.append("type:").append(type).append("|");
 		return s.toString();

ff958d154cd7c759098fc9911071ce6f194a3466
@@ -3,6 +3,7 @@ package depends.extractor.ruby.jruby;
 import java.util.List;
 
 import org.jrubyparser.ast.AndNode;
+import org.jrubyparser.ast.ArrayNode;
 import org.jrubyparser.ast.AssignableNode;
 import org.jrubyparser.ast.BlockNode;
 import org.jrubyparser.ast.ClassVarNode;
@@ -12,6 +13,7 @@ import org.jrubyparser.ast.FalseNode;
 import org.jrubyparser.ast.GlobalVarNode;
 import org.jrubyparser.ast.ILiteralNode;
 import org.jrubyparser.ast.InstVarNode;
+import org.jrubyparser.ast.ListNode;
 import org.jrubyparser.ast.LocalVarNode;
 import org.jrubyparser.ast.NewlineNode;
 import org.jrubyparser.ast.Node;
@@ -50,6 +52,7 @@ public class ExpressionUsage {
 		//System.out.println("expr " + ctx.toString());
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
+		expression.text = ctx.toString();
 		expression.parent = parent;
 		if (ctx instanceof NewlineNode) {
 			expression.isStatement = true;
@@ -63,7 +66,7 @@ public class ExpressionUsage {
 			}
 		}
 		context.lastContainer().addExpression(ctx,expression);
-		if (ctx instanceof ILiteralNode) {
+		if (ctx instanceof ILiteralNode && !(ctx instanceof ListNode)) {
 			expression.identifier = "<literal>";
 			expression.rawType = Inferer.buildInType.getQualifiedName();
 		} else if (ctx instanceof TrueNode || ctx instanceof FalseNode) {
@@ -96,6 +99,9 @@ public class ExpressionUsage {
 				}
 				expression.rawType = expression.identifier ;
 				expression.deriveTypeFromChild = false;
+			} else if (name.equals("raise")) {
+				expression.isThrow = true;
+				expression.deriveTypeFromChild = true;
 			} else if (helper.isArithMeticOperator(name)) {
 				expression.identifier = "<operator>";
 				expression.rawType = Inferer.buildInType.getQualifiedName();

ff958d154cd7c759098fc9911071ce6f194a3466
@@ -70,6 +70,7 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitModuleNode(ModuleNode node) {
 		String name = helper.getName(node.getCPath());
+		System.out.println("module "+ name);
 		context.foundNamespace(name);
 		super.visitModuleNode(node);
 		context.exitLastedEntity();

ff958d154cd7c759098fc9911071ce6f194a3466
@@ -72,6 +72,9 @@ public class RelationCounter {
 			if (expression.isCreate) {
 				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
 			}
+			if (expression.isThrow) {
+				entity.addRelation(new Relation(DependencyType.THROW,referredEntity));
+			}
 			if (expression.isSet) { //SET is merged with USE
 				entity.addRelation(new Relation(DependencyType.USE,referredEntity));
 			}

ff958d154cd7c759098fc9911071ce6f194a3466
@@ -0,0 +1,35 @@
+package depends.extractor.ruby;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.FileParser;
+
+public class RubyRaiseTypeDedudceTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_deduce_type_of_raise() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/deducetype_raise.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
+	    this.assertContainsRelation(function, DependencyType.THROW, "Class1");
+	}
+
+
+}
+

4e7600c918fd9703c24a9baae5a9c0ac61016a7b
@@ -33,7 +33,7 @@ public abstract class Entity {
 	}
 
     /**
-     * Rule 1: if it contains '.' , then the name is equal to raw name
+     * Rule 1: if it start with '.' , then the name is equal to raw name
      * Rule 2: if parent not exists, the name is equal to raw name
      * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
      * Rule 4: otherwise, qualified name = parent_qualfied_name + "."+rawName
@@ -41,8 +41,8 @@ public abstract class Entity {
      */
 	private void deduceQualifiedName() {
 		rawName = rawName.replace("::","." );
-		if (this.rawName.contains(".")) {
-			this.qualifiedName = this.rawName;
+		if (this.rawName.startsWith(".")) {
+			this.qualifiedName = this.rawName.substring(1);
 			return; //already qualified
 		}
 		if (parent==null) {
@@ -58,9 +58,6 @@ public abstract class Entity {
 			return;
 		}
 		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName;
-		if (rawName.startsWith(".")) {
-			rawName = rawName.substring(2);
-		}
 	}
 
 

4e7600c918fd9703c24a9baae5a9c0ac61016a7b
@@ -56,7 +56,7 @@ public class JavaListener extends JavaParserBaseListener {
 	// Package
 	@Override
 	public void enterPackageDeclaration(PackageDeclarationContext ctx) {
-		context.foundNewPackage(QualitiedNameContextHelper.getName(ctx.qualifiedName()));
+		context.foundNewPackage(sureDotStartName(QualitiedNameContextHelper.getName(ctx.qualifiedName())));
 		super.enterPackageDeclaration(ctx);
 	}
 
@@ -74,16 +74,16 @@ public class JavaListener extends JavaParserBaseListener {
 	/////////////////////// annotationTypeDeclaration
 	@Override
 	public void enterClassDeclaration(ClassDeclarationContext ctx) {
-		context.foundNewType(ctx.IDENTIFIER().getText());
+		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
 		// implements
 		if (ctx.typeList() != null) {
 			for (int i = 0; i < ctx.typeList().typeType().size(); i++) {
-				context.foundImplements(ClassTypeContextHelper.getClassName(ctx.typeList().typeType().get(i)));
+				context.foundImplements(sureDotStartName(ClassTypeContextHelper.getClassName(ctx.typeList().typeType().get(i))));
 			}
 		}
 		// extends relation
 		if (ctx.typeType() != null) {
-			context.foundExtends(ClassTypeContextHelper.getClassName(ctx.typeType()));
+			context.foundExtends(sureDotStartName(ClassTypeContextHelper.getClassName(ctx.typeType())));
 		}
 
 		if (ctx.typeParameters() != null) {
@@ -101,7 +101,7 @@ public class JavaListener extends JavaParserBaseListener {
 
 	@Override
 	public void enterEnumDeclaration(EnumDeclarationContext ctx) {
-		context.foundNewType(ctx.IDENTIFIER().getText());
+		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
 		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
 		super.enterEnumDeclaration(ctx);
 	}
@@ -118,7 +118,7 @@ public class JavaListener extends JavaParserBaseListener {
 	 */
 	@Override
 	public void enterInterfaceDeclaration(InterfaceDeclarationContext ctx) {
-		context.foundNewType(ctx.IDENTIFIER().getText());
+		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
 		// type parameters
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
@@ -141,7 +141,7 @@ public class JavaListener extends JavaParserBaseListener {
 
 	@Override
 	public void enterAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
-		context.foundNewType(ctx.IDENTIFIER().getText());
+		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
 		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
 		super.enterAnnotationTypeDeclaration(ctx);
 	}
@@ -328,4 +328,12 @@ public class JavaListener extends JavaParserBaseListener {
 			context.currentType().addTypeParameter(typeParam.IDENTIFIER().getText());
 		}
 	}
+	
+	private String sureDotStartName(String name) {
+		if (name==null) return null;
+		if (name.contains(".") && !name.startsWith(".")) {
+			name = "." + name;
+		}
+		return name;
+	}
 }

4e7600c918fd9703c24a9baae5a9c0ac61016a7b
@@ -79,23 +79,15 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitClassNode(ClassNode node) {
-		context.foundNewType(node.getCPath().getName());
+		context.foundNewType(helper.getName(node.getCPath()));
 		Node superNode = node.getSuper();
-		if (superNode instanceof ConstNode) {
-			String superName = ((ConstNode) superNode).getName();
+		
+		if (superNode instanceof ConstNode ||
+				superNode instanceof SymbolNode ||
+				superNode instanceof Colon2ConstNode ||
+				superNode instanceof Colon3Node) {
+			String superName = helper.getName(superNode);
 			context.foundExtends(superName);
-		} else if (superNode instanceof SymbolNode) {
-			String superName = ((SymbolNode) superNode).getName();
-			context.foundExtends(superName);
-		} else if (superNode instanceof Colon2ConstNode) {
-			Colon2ConstNode colon2ConstNode = (Colon2ConstNode) superNode;
-			String name1 = helper.getName(colon2ConstNode.getLeftNode());
-			String superName = colon2ConstNode.getName();
-			context.foundExtends(name1 + "." + superName);
-		} else if (superNode instanceof Colon3Node){
-			Colon3Node colon3Node = (Colon3Node) superNode;
-			String superName = colon3Node.getName();
-			context.foundExtends(superName + "." + superName);
 		}else{
 			if (superNode != null) {
 				System.err.println("cannot support the super node style" + superNode.toString());

4e7600c918fd9703c24a9baae5a9c0ac61016a7b
@@ -0,0 +1,37 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.PackageEntity;
+import depends.extractor.FileParser;
+
+public class RubyModuleLevelsTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_parameter_should_be_created() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/ruby_modules.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    PackageEntity module = (PackageEntity)(entityRepo.getEntity("A.B"));
+	    assertNotNull(module);
+	    module = (PackageEntity)(entityRepo.getEntity("X.Y.Z"));
+	    assertNotNull(module);
+	    module = (PackageEntity)(entityRepo.getEntity("L.M.N"));
+	    assertNotNull(module);
+	}
+}
+

4e7600c918fd9703c24a9baae5a9c0ac61016a7b
@@ -0,0 +1,40 @@
+package depends.extractor.ruby;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.ContainerEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.PackageEntity;
+import depends.entity.TypeEntity;
+import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+
+public class RubyNameTest extends RubyParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_parameter_should_be_created() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/ruby-code-examples/ruby_name.rb",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    PackageEntity module = (PackageEntity)(entityRepo.getEntity("A.B.C"));
+	    assertNotNull(module);
+	}
+	
+
+}
+

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -75,7 +75,7 @@ public class AliasEntity extends Entity {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
-		return origin.lookupVarsInVisibleScope(varName);
+		return origin.lookupVarInVisibleScope(varName);
 	}
 
 	public Collection<ContainerEntity> getResolvedMixins() {

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -61,9 +61,9 @@ public class CandidateTypes extends TypeEntity {
 	}
  	
 	@Override
-	public VarEntity lookupVarsInVisibleScope(String varName) {
+	public VarEntity lookupVarInVisibleScope(String varName) {
 		for (TypeEntity type:candidateTypes) {
-			VarEntity v = type.lookupVarsInVisibleScope(varName);
+			VarEntity v = type.lookupVarInVisibleScope(varName);
 			if (v!=null) return v;
 		}
  		return null;	
@@ -71,9 +71,9 @@ public class CandidateTypes extends TypeEntity {
 	
 	
 	@Override
-	public VarEntity getVarOfName(String varName) {
+	public VarEntity lookupVarLocally(String varName) {
 		for (TypeEntity type:candidateTypes) {
-			VarEntity v = type.getVarOfName(varName);
+			VarEntity v = type.lookupVarLocally(varName);
 			if (v!=null) return v;
 		}
 		return null;

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -130,7 +130,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 					}
 				}else {
 					
-					VarEntity varEntity = this.lookupVarsInVisibleScope(expression.identifier);
+					VarEntity varEntity = this.lookupVarInVisibleScope(expression.identifier);
 					if (varEntity!=null) {
 						expression.setType( varEntity.getType(),varEntity,inferer);
 					}
@@ -155,19 +155,38 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 		return sb.toString();
 	}
-	
 
 
-	protected FunctionEntity lookupFunctionLocally(String functionName) {
-		for (FunctionEntity func : getFunctions()) {
-			if (func.getRawName().equals(functionName))
-				return func;
+	
+	/**
+	 * The entry point of lookup functions. It will treat multi-declare entities and normal
+	 * entity differently.
+	 * - for multiDeclare entity, it means to lookup all entities
+	 * - for normal entity, it means to lookup entities from current scope still root 
+	 * @param functionName
+	 * @return
+	 */
+	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+		if (this.getMutliDeclare()!=null) {
+			for (ContainerEntity fromEntity:this.getMutliDeclare().getEntities()) {
+				FunctionEntity f = lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
+				if (f!=null)
+					return f;
+			}
+		}else {
+			ContainerEntity fromEntity = this;
+			return lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
 		}
 		return null;
 	}
-	
-	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
-		ContainerEntity fromEntity = this;
+
+	/**
+	 * lookup function bottom up till the most outside container
+	 * @param functionName
+	 * @param fromEntity
+	 * @return
+	 */
+	private FunctionEntity lookupFunctionBottomUpTillTopContainer(String functionName, ContainerEntity fromEntity) {
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {
 				FunctionEntity func = ((ContainerEntity) fromEntity).lookupFunctionLocally(functionName);
@@ -180,13 +199,40 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	/**
-	 * To found the var. Must be invoked after all entities var binding solved
-	 * @param fromEntity
+	 * lookup function in local entity. 
+	 * It could be override such as the type entity (it should also lookup the 
+	 * inherit/implemented types
+	 * @param functionName
+	 * @return
+	 */
+	public FunctionEntity lookupFunctionLocally(String functionName) {
+		for (FunctionEntity func : getFunctions()) {
+			if (func.getRawName().equals(functionName))
+				return func;
+		}
+		return null;
+	}
+
+	/**
+	 * The entry point of lookup var. It will treat multi-declare entities and normal
+	 * entity differently.
+	 * - for multiDeclare entity, it means to lookup all entities
+	 * - for normal entity, it means to lookup entities from current scope still root 
 	 * @param varName
 	 * @return
 	 */
-	public VarEntity lookupVarsInVisibleScope(String varName) {
+	public VarEntity lookupVarInVisibleScope(String varName) {
 		ContainerEntity fromEntity = this;
+		return lookupVarBottomUpTillTopContainer(varName, fromEntity);
+	}
+
+	/**
+	 * To found the var. 
+	 * @param fromEntity
+	 * @param varName
+	 * @return
+	 */
+	private VarEntity lookupVarBottomUpTillTopContainer(String varName, ContainerEntity fromEntity) {
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {
 				VarEntity var = ((ContainerEntity) fromEntity).lookupVarLocally(varName);
@@ -198,7 +244,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return null;
 	}
 
-	private VarEntity lookupVarLocally(String varName) {
+	public VarEntity lookupVarLocally(String varName) {
 		for (VarEntity var:getVars()) {
 			if (var.getRawName().equals(varName))
 				return var;
@@ -206,28 +252,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return null;
 	}
 
-
-
 	public void addMixin(String moduleName) {
 		mixins.add(moduleName);
 	}
 
-
-
 	public Collection<ContainerEntity> getResolvedMixins() {
 		return resolvedMixins;
 	}
-
-	public VarEntity getVarOfName(String varName) {
-		for (VarEntity var:this.vars) {
-			if (var.getRawName().equals(varName))
-				return var;
-		}
-		return null;
-	}
-
-
-
-
-
 }

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -18,7 +18,8 @@ public abstract class Entity {
 	String qualifiedName = null;
 	String rawName = "";
 	Entity parent;
-	List<Entity> children = new ArrayList<>();
+	private MultiDeclareEntities mutliDeclare = null;
+	private List<Entity> children = new ArrayList<>();
     ArrayList<Relation> relations = new ArrayList<>();
 
 	
@@ -148,4 +149,12 @@ public abstract class Entity {
 	public String getDisplayName() {
 		return getRawName();
 	}
+
+	public MultiDeclareEntities getMutliDeclare() {
+		return mutliDeclare;
+	}
+
+	public void setMutliDeclare(MultiDeclareEntities mutliDeclare) {
+		this.mutliDeclare = mutliDeclare;
+	}
 }

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -111,7 +111,7 @@ public class Expression {
 					parent.setReferredEntity(func);
 			}else {
 				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
-				VarEntity var = this.getType().lookupVarsInVisibleScope(parent.identifier);
+				VarEntity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
 					parent.setType(var.getType(),var, inferer);
 					parent.setReferredEntity(var);

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -32,10 +32,12 @@ public class FunctionEntity extends ContainerEntity{
 	}
 
 	public void addReturnType(String returnType) {
+		if (returnType==null) return;
 		this.returnTypeIdentifiers.add(returnType);
 	}
 	
 	public void addReturnType(TypeEntity returnType) {
+		if (returnType==null) return;
 		if (!this.returnTypeIdentifiers.contains(returnType.rawName)){
 			this.returnTypeIdentifiers.add(returnType.rawName);
 			this.returnTypes.add(returnType);
@@ -68,13 +70,13 @@ public class FunctionEntity extends ContainerEntity{
 		return throwTypes;
 	}
 	@Override
-	public VarEntity lookupVarsInVisibleScope(String varName) {
+	public VarEntity lookupVarInVisibleScope(String varName) {
 		for (VarEntity param:parameters) {
 			if (varName.equals(param.getRawName())) {
 				return param;
 			}
 		}
-		return super.lookupVarsInVisibleScope(varName);
+		return super.lookupVarInVisibleScope(varName);
 	}
 	public void addParameter(VarEntity var) {
 		this.parameters.add(var);
@@ -85,11 +87,11 @@ public class FunctionEntity extends ContainerEntity{
 		return f.getRawName()+"("+getRawName()+")";
 	}
 	@Override
-	public VarEntity getVarOfName(String varName) {
+	public VarEntity lookupVarLocally(String varName) {
 		for (VarEntity var:this.parameters) {
 			if (var.getRawName().equals(varName))
 				return var;
 		}
-		return super.getVarOfName(varName);
+		return super.lookupVarLocally(varName);
 	}
 }

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -15,8 +15,7 @@ public class MultiDeclareEntities extends ContainerEntity {
 	List<ContainerEntity> entities = new ArrayList<>();
 	public MultiDeclareEntities(Entity entity, int id ) {
 		super(entity.getRawName(), entity.getParent(), id);
-		if (entity instanceof ContainerEntity)
-			entities.add((ContainerEntity)entity);
+		add(entity);
 	}
 
 	@Override
@@ -27,6 +26,7 @@ public class MultiDeclareEntities extends ContainerEntity {
 	}
 
 	public void add(Entity entity) {
+		entity.setMutliDeclare(this);
 		if (entity instanceof ContainerEntity)
 			entities.add((ContainerEntity)entity);
 	}

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -52,24 +52,41 @@ public class TypeEntity extends ContainerEntity{
 	}
  	
  	@Override
- 	protected FunctionEntity lookupFunctionLocally(String functionName) {
-		FunctionEntity funcType = super.lookupFunctionLocally(functionName);
-		if (funcType!=null) return funcType;
+ 	public FunctionEntity lookupFunctionLocally(String functionName) {
+		FunctionEntity func = super.lookupFunctionLocally(functionName);
+		if (func!=null) return func;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
-			funcType = inhertedType.lookupFunctionLocally(functionName);
-			if (funcType != null)
+			func = inhertedType.lookupFunctionLocally(functionName);
+			if (func != null)
 				break;
 		}
-		if (funcType != null)
-			return funcType;
+		if (func != null)
+			return func;
 		for (TypeEntity implType : getImplementedTypes()) {
-			funcType = implType.lookupFunctionLocally( functionName);
-			if (funcType != null)
+			func = implType.lookupFunctionLocally( functionName);
+			if (func != null)
 				break;
 		}
-		return funcType;
+		return func;
  	}
- 	
+ 	@Override
+ 	public VarEntity lookupVarLocally(String varName) {
+ 		VarEntity var = super.lookupVarLocally(varName);
+		if (var!=null) return var;
+		for (TypeEntity inhertedType : getInheritedTypes()) {
+			var = inhertedType.lookupVarLocally(varName);
+			if (var != null)
+				break;
+		}
+		if (var != null)
+			return var;
+		for (TypeEntity implType : getImplementedTypes()) {
+			var = implType.lookupVarLocally( varName);
+			if (var != null)
+				break;
+		}
+		return var;
+	}
  	@Override
  	public TypeEntity getType() {
 		return this;

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -53,6 +53,9 @@ public class EntityRepo extends IdGenerator{
 	}
 	
 	public void setParent(Entity child, Entity parent) {
+		if (parent==null) return;
+		if (child==null) return;
+		if (parent.equals(child.getParent())) return;
 		child.setParent(parent);
 		parent.addChild(child);
 	}

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -135,7 +135,7 @@ public class ExpressionUsage {
 		Node parentNode = node.getParent();
 		if (parentNode instanceof AssignableNode) {
 			ContainerEntity scope = helper.getScopeOfVar((AssignableNode)parentNode, this.context);
-			VarEntity var = scope.getVarOfName(helper.getName(parentNode));
+			VarEntity var = scope.lookupVarLocally(helper.getName(parentNode));
 			if (var!=null) {
 				expression.addDeducedTypeVar(var);
 			}

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -30,18 +30,18 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    ContainerEntity function = (ContainerEntity)(entityRepo.getEntity("Class.test"));
-	    VarEntity var = function.getVarOfName("var_int");
+	    VarEntity var = function.lookupVarLocally("var_int");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
-	    var = function.getVarOfName("var_c");
+	    var = function.lookupVarLocally("var_c");
 	    assertEquals("Class",var.getType().getRawName());
 	    
 
 	    function = (ContainerEntity)(entityRepo.getEntity("Class"));
-	    var = function.getVarOfName("inst_var");
+	    var = function.lookupVarLocally("inst_var");
 	    assertEquals("Class",var.getType().getRawName());
 	    
-	    var = function.getVarOfName("class_var");
+	    var = function.lookupVarLocally("class_var");
 	    assertEquals("Class",var.getType().getRawName());
 	}
 	
@@ -57,25 +57,25 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    ContainerEntity function = (ContainerEntity)(entityRepo.getEntity("Class.operator_is_call"));
-	    VarEntity var = function.getVarOfName("var_compose");
+	    VarEntity var = function.lookupVarLocally("var_compose");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 	    
-	    var = function.getVarOfName("var_1");
+	    var = function.lookupVarLocally("var_1");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
-	    var = function.getVarOfName("var_2");
+	    var = function.lookupVarLocally("var_2");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
-	    var = function.getVarOfName("var_3");
+	    var = function.lookupVarLocally("var_3");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
-	    var = function.getVarOfName("var_4");
+	    var = function.lookupVarLocally("var_4");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
-	    var = function.getVarOfName("var_5");
+	    var = function.lookupVarLocally("var_5");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
-	    var = function.getVarOfName("var_6");
+	    var = function.lookupVarLocally("var_6");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
 	}

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -32,7 +32,7 @@ public class RubyParameterTypeDedudceTest extends RubyParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
-	    VarEntity var = function.getVarOfName("t1");
+	    VarEntity var = function.lookupVarLocally("t1");
 	    TypeEntity type = var.getType();
 	    assertTrue(type instanceof CandidateTypes);
 	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -29,7 +29,7 @@ public class RubySingletonMethodTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    ContainerEntity file = (ContainerEntity)(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
-	    VarEntity var = file.getVarOfName("var2");
+	    VarEntity var = file.lookupVarLocally("var2");
 	    assertEquals(1,var.getFunctions().size());
 	}
 }

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -29,7 +29,7 @@ public class RubyVarInvocationRecordTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    ContainerEntity file = (ContainerEntity)(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
-	    VarEntity var = file.getVarOfName("var");
+	    VarEntity var = file.lookupVarLocally("var");
 	    assertEquals(1,var.getCalledFunctions().size());
 	}
 }

956454688ea4fba4a0103560f7e856989f9d2f6b
@@ -3,10 +3,10 @@ package depends.extractor.ruby.jruby;
 import java.util.List;
 
 import org.jrubyparser.ast.AndNode;
-import org.jrubyparser.ast.ArrayNode;
 import org.jrubyparser.ast.AssignableNode;
 import org.jrubyparser.ast.BlockNode;
 import org.jrubyparser.ast.ClassVarNode;
+import org.jrubyparser.ast.Colon3Node;
 import org.jrubyparser.ast.ConstNode;
 import org.jrubyparser.ast.FCallNode;
 import org.jrubyparser.ast.FalseNode;
@@ -81,7 +81,8 @@ public class ExpressionUsage {
 		} else if (ctx instanceof LocalVarNode ||
 				ctx instanceof GlobalVarNode ||
 				ctx instanceof ClassVarNode||
-				ctx instanceof InstVarNode)  {
+				ctx instanceof InstVarNode ||
+				ctx instanceof Colon3Node)  {
 			expression.identifier = helper.getName(ctx);
 		} 
 		if (ctx instanceof AssignableNode) {

956454688ea4fba4a0103560f7e856989f9d2f6b
@@ -140,13 +140,13 @@ public class JRubyVisitor extends NoopVisitor {
 	private void addCallToReceiverVar(CallNode node, String fname) {
 		if (helper.isCommonOperator(fname))return;
 		Node varNode = node.getReceiver();
-		if (varNode instanceof INameNode) {
-			String varName = ((INameNode) varNode).getName();
-			Entity var = context.foundEntityWithName(varName);
-			if (var != null && var instanceof VarEntity) {
-				VarEntity varEntity = (VarEntity) var;
-				varEntity.addFunctionCall(fname);
-			}
+		
+		String varName = helper.getName(varNode);
+		if (varName==null) return;
+		Entity var = context.foundEntityWithName(varName);
+		if (var != null && var instanceof VarEntity) {
+			VarEntity varEntity = (VarEntity) var;
+			varEntity.addFunctionCall(fname);
 		}
 	}
 

9000e91ed96f9e9f1794d320ae5ad189c78bf16c
@@ -42,7 +42,6 @@ public class ExpressionUsage {
 		this.inferer = inferer;
 		this.helper = helper;
 	}
-	@SuppressWarnings("deprecation")
 	public Expression foundExpression(Node ctx) {
 		if (ctx instanceof RootNode) return null;
 		if (ctx instanceof BlockNode) return null;

a37e043184f41aae7c73c728f231819f2b68fa5e
@@ -71,6 +71,7 @@ public class FileEntity extends ContainerEntity {
 		this.importedRelationEntities = inferer.getImportedRelationEntities(importedNames);
 		this.importedTypes = inferer.getImportedTypes(importedNames);
 		this.importedFiles = inferer.getImportedFiles(importedNames);
+
 		super.inferLocalLevelEntities(inferer);
 	}
 

a37e043184f41aae7c73c728f231819f2b68fa5e
@@ -330,10 +330,10 @@ public class JavaListener extends JavaParserBaseListener {
 	}
 	
 	private String sureDotStartName(String name) {
-		if (name==null) return null;
-		if (name.contains(".") && !name.startsWith(".")) {
-			name = "." + name;
-		}
+//		if (name==null) return null;
+//		if (name.contains(".") && !name.startsWith(".")) {
+//			name = "." + name;
+//		}
 		return name;
 	}
 }

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -78,7 +78,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			func.inferLocalLevelEntities(inferer);
 		}
 		resolvedMixins = identiferToContainerEntity(inferer, mixins);
-		this.resolveExpressions(inferer);
+		if (inferer.isEagerExpressionResolve()) {
+			this.resolveExpressions(inferer);
+		}
 	}
 
 	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<String> identifiers) {

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -106,18 +106,26 @@ public class Expression {
 		else if (parent.isDot) {
 			if (parent.isCall) {
 				FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-				if (func!=null)
+				if (func!=null) {
 					parent.setType(func.getType(), func,inferer);
 					parent.setReferredEntity(func);
+				}
 			}else {
-				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
 				VarEntity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
 					parent.setType(var.getType(),var, inferer);
 					parent.setReferredEntity(var);
+				}else {
+					FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
+					if (func!=null) {
+						parent.setType(func.getType(), func,inferer);
+						parent.setReferredEntity(func);
+					}
 				}
 			}
-
+			if (parent.getType()==null) {
+				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
+			}
 		}
 		/* if other situation, simple make the parent and child type same */
 		else {

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -52,11 +52,11 @@ abstract public class AbstractLangProcessor {
 	private String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
 
-	public AbstractLangProcessor(String inputDir, String[] includeDir) {
+	public AbstractLangProcessor(String inputDir, String[] includeDir, boolean eagerExpressionResolve) {
 		entityRepo = new EntityRepo();
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
-		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType());
+		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
 	}
 	
     /**

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -12,7 +12,7 @@ public class CppProcessor extends AbstractLangProcessor {
     private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh", ".cxx",".hxx"};
     PreprocessorHandler preprocessorHandler;
     public CppProcessor(String inputDir, String[] includeDir) {
-    	super(inputDir,includeDir);
+    	super(inputDir,includeDir,false);
     }
 
 

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -10,7 +10,7 @@ public class JavaProcessor extends AbstractLangProcessor {
     private static final String JAVA_SUFFIX = ".java";
     
     public JavaProcessor(String inputDir, String[] includeDir) {
-    	super(inputDir,includeDir);
+    	super(inputDir,includeDir,false);
     }
     
 	@Override

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -15,7 +15,7 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
     private static final String[] SUFFIX = new String[] {".rb"};
 	private ExecutorService executor;
     public RubyProcessor(String inputDir, String[] includeDirs) {
-    	super(inputDir,includeDirs);
+    	super(inputDir,includeDirs,true);
     }
 
 

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -14,7 +14,7 @@ public abstract class CppParserTest {
 
 	public void init() {
     	repo = new EntityRepo();
-    	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType());
+    	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType(),false);
     	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
     }
 	

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -12,7 +12,7 @@ public abstract class JavaParserTest {
 
 	public void init() {
 		entityRepo = new EntityRepo();
-		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(),new JavaBuiltInType());
+		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(),new JavaBuiltInType(),false);
 	}
 	
 	public JavaFileParser createParser(String src) {

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -21,7 +21,7 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 
 	public void init() {
 		entityRepo = new EntityRepo();
-		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType());
+		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType(),true);
 	}
 	
 	public FileParser createFileParser(String src) {

50a43ba3d0dd7e42af40cfa92371a2630864cb23
@@ -48,7 +48,6 @@ public class ExpressionUsage {
 		Expression expression = findExpression(ctx);
 		if (expression!=null) return expression;
 		Expression parent = findParentInStack(ctx);
-		//System.out.println("expr " + ctx.toString());
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.toString();

50a43ba3d0dd7e42af40cfa92371a2630864cb23
@@ -70,7 +70,6 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitModuleNode(ModuleNode node) {
 		String name = helper.getName(node.getCPath());
-		System.out.println("module "+ name);
 		context.foundNamespace(name);
 		super.visitModuleNode(node);
 		context.exitLastedEntity();

50a43ba3d0dd7e42af40cfa92371a2630864cb23
@@ -45,7 +45,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         parser.parse();
         inferer.resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
-        assertEquals(17,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(18,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
 	}
 	
 	@Test

732df06a5137eb2037e24c0b52305e6280eaec63
@@ -1,12 +1,19 @@
 package depends;
 
+import java.util.ArrayList;
+import depends.extractor.LangProcessorRegistration;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
 @Command(name = "depends")
 public class DependsCommand {
-	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
+	public static class SupportedLangs extends ArrayList<String> {
+		private static final long serialVersionUID = 1L;
+		public SupportedLangs() { super( LangProcessorRegistration.getRegistry().getLangs()); }
+	}
+	
+	@Parameters(index = "0", completionCandidates = DependsCommand.SupportedLangs.class, description = "The lanauge of project files: [${COMPLETION-CANDIDATES}]")
     private String lang;
 	@Parameters(index = "1", description = "The directory to be analyzed")
     private String src;
@@ -30,6 +37,8 @@ public class DependsCommand {
 	private boolean autoInclude = false;
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
+	public DependsCommand() {
+	}
 	public String getLang() {
 		return lang;
 	}

732df06a5137eb2037e24c0b52305e6280eaec63
@@ -52,10 +52,9 @@ abstract public class AbstractLangProcessor {
 	private String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
 
-	public AbstractLangProcessor(String inputDir, String[] includeDir, boolean eagerExpressionResolve) {
+	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new EntityRepo();
-		this.inputSrcPath = inputDir;
-		this.includeDirs = includeDir;
+
 		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
 	}
 	
@@ -64,8 +63,12 @@ abstract public class AbstractLangProcessor {
      * Step 1: parse all files, add entities and expression into repositories
      * Step 2: resolve bindings of files (if not resolved yet)
      * Step 3: identify dependencies 
+     * @param includeDir 
+     * @param inputDir 
      */
-	public void buildDependencies() {
+	public void buildDependencies(String inputDir, String[] includeDir) {
+		this.inputSrcPath = inputDir;
+		this.includeDirs = includeDir;
         parseAllFiles();
         resolveBindings();
         identifyDependencies();

732df06a5137eb2037e24c0b52305e6280eaec63
@@ -1,5 +1,7 @@
 package depends.extractor;
 
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 
 /* Registration of the lang processors. 
@@ -17,4 +19,9 @@ public class LangProcessorRegistration {
 		if (getProcessorOf(processor.supportedLanguage())!=null) return;
 		langProcessors.put(processor.supportedLanguage(), processor);
 	}
+	public Collection<String> getLangs() {
+		ArrayList<String> langs = new ArrayList<>();
+		langProcessors.values().forEach(item->{langs.add(item.supportedLanguage());});
+		return langs;
+	}
 }

732df06a5137eb2037e24c0b52305e6280eaec63
@@ -11,8 +11,8 @@ public class CppProcessor extends AbstractLangProcessor {
     private static final String LANG = "cpp";
     private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh", ".cxx",".hxx"};
     PreprocessorHandler preprocessorHandler;
-    public CppProcessor(String inputDir, String[] includeDir) {
-    	super(inputDir,includeDir,false);
+    public CppProcessor() {
+    	super(false);
     }
 
 

732df06a5137eb2037e24c0b52305e6280eaec63
@@ -9,8 +9,8 @@ public class JavaProcessor extends AbstractLangProcessor {
     private static final String JAVA_LANG = "java";
     private static final String JAVA_SUFFIX = ".java";
     
-    public JavaProcessor(String inputDir, String[] includeDir) {
-    	super(inputDir,includeDir,false);
+    public JavaProcessor() {
+    	super(false);
     }
     
 	@Override

732df06a5137eb2037e24c0b52305e6280eaec63
@@ -14,11 +14,10 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
     private static final String LANG = "ruby";
     private static final String[] SUFFIX = new String[] {".rb"};
 	private ExecutorService executor;
-    public RubyProcessor(String inputDir, String[] includeDirs) {
-    	super(inputDir,includeDirs,true);
+    public RubyProcessor() {
+    	super(true);
     }
 
-
 	@Override
 	public String supportedLanguage() {
 		return LANG;

02140fab12c27d68728d1602e2aa481aec23846c
@@ -267,7 +267,7 @@ public class CandidateTypes extends TypeEntity {
 
 	
 	@Override
-	public Entity getAncestorOfType(Class classType) {
+	public Entity getAncestorOfType(@SuppressWarnings("rawtypes") Class classType) {
 		System.err.println("error: getAncestorOfType should not been invoked");
 		return super.getAncestorOfType(classType);
 	}

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,7 +1,6 @@
 package depends.entity;
 
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 

02140fab12c27d68728d1602e2aa481aec23846c
@@ -306,13 +306,13 @@ public class JavaListener extends JavaParserBaseListener {
 	// Block
 	@Override
 	public void enterBlock(BlockContext ctx) {
-		// TODO Auto-generated method stub
+		// TODO support block in java
 		super.enterBlock(ctx);
 	}
 
 	@Override
 	public void exitBlock(BlockContext ctx) {
-		// TODO Auto-generated method stub
+		// TODO support block in java
 		super.exitBlock(ctx);
 	}
 

02140fab12c27d68728d1602e2aa481aec23846c
@@ -3,7 +3,6 @@ package depends.matrix;
 import java.util.ArrayList;
 
 import depends.entity.Entity;
-import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
@@ -34,12 +33,6 @@ public class FunctionDependencyGenerator implements DependencyGenerator {
 		return dependencyMatrix;
 	}
 
-	private String getFileNameNoException(Entity entity) {
-		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
-		if (ancestor == null)
-			return "";
-		return ancestor.getRawName();
-	}
 
 	private int getFunctionEntityIdNoException(Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,7 +1,5 @@
 package depends.addons;
 
-import static org.junit.Assert.*;
-
 import org.junit.Test;
 
 public class DV8MappingFileBuilderTest {

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,6 +1,4 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
 import java.io.IOException;
 
 import org.junit.Before;

02140fab12c27d68728d1602e2aa481aec23846c
@@ -2,13 +2,10 @@ package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
-import java.util.ArrayList;
 
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.extractor.cpp.CppFileParser;
-
 public class CppExpressionTest extends CppParserTest{
     @Before
     public void setUp() {

02140fab12c27d68728d1602e2aa481aec23846c
@@ -2,13 +2,10 @@ package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
-import java.util.ArrayList;
 
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.extractor.cpp.CppFileParser;
-
 public class CppParameterParserTest extends CppParserTest{
     @Before
     public void setUp() {

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,12 +1,9 @@
 package depends.extractor.cpp;
-import java.io.File;
 import java.io.IOException;
 
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.Entity;
-import depends.matrix.DependencyMatrix;
 import depends.matrix.FileDependencyGenerator;
 
 public class ForwardDeclareTest extends CppParserTest{
@@ -28,8 +25,6 @@ public class ForwardDeclareTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        File f = new File(srcs[0]);
-        Entity e = repo.getEntity("App.foo");
         FileDependencyGenerator dependencyGenerator= new FileDependencyGenerator();
         dependencyGenerator.build(repo);
 	}

02140fab12c27d68728d1602e2aa481aec23846c
@@ -68,7 +68,6 @@ public class IncludeRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        File f = new File(srcs[0]);
         assertEquals("abc",((AliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName());
         
 	}

02140fab12c27d68728d1602e2aa481aec23846c
@@ -6,8 +6,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.extractor.cpp.cdt.CdtCppFileParser;
-
 public class MacroRelationTest extends CppParserTest{
     @Before
     public void setUp() {

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,17 +1,12 @@
 package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
-import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.entity.AliasEntity;
-import depends.extractor.cpp.CppFileParser;
 
 public class UsingTest extends CppParserTest{
     @Before
@@ -30,7 +25,6 @@ public class UsingTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        File f = new File(srcs[0]);
         Entity e = repo.getEntity("foo");
         assertEquals(3,e.getRelations().size());
 	}
@@ -46,7 +40,6 @@ public class UsingTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        File f = new File(srcs[0]);
         Entity e = repo.getEntity("bar");
         assertEquals(3,e.getRelations().size());
 	}

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,17 +1,12 @@
 package depends.extractor.cpp;
 import static org.junit.Assert.assertEquals;
 
-import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.Entity;
-import depends.entity.AliasEntity;
-import depends.extractor.cpp.CppFileParser;
 
 public class extendsTest extends CppParserTest{
     @Before
@@ -30,7 +25,6 @@ public class extendsTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        File f = new File(srcs[0]);
         Entity e = repo.getEntity("B");
         assertEquals(2,e.getRelations().size());
 	}

02140fab12c27d68728d1602e2aa481aec23846c
@@ -7,8 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.repo.EntityRepo;
-
 public class JavaAnnotationParserTest extends JavaParserTest {
 	@Before
 	public void setUp() {

02140fab12c27d68728d1602e2aa481aec23846c
@@ -7,8 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.repo.EntityRepo;
-
 public class JavaParameterParserTest extends JavaParserTest {
 	@Before
 	public void setUp() {

02140fab12c27d68728d1602e2aa481aec23846c
@@ -45,7 +45,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         parser.parse();
         inferer.resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
-        assertEquals(18,entityRepo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(18,e.getRelations().size());
 	}
 	
 	@Test

02140fab12c27d68728d1602e2aa481aec23846c
@@ -3,7 +3,6 @@ package depends.extractor.ruby;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
-import java.util.ArrayList;
 
 import org.junit.Before;
 import org.junit.Ignore;

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,17 +1,12 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
 import java.io.IOException;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
-import depends.entity.Entity;
 import depends.extractor.FileParser;
-import depends.relations.Relation;
 
 public class RubyMixinTest extends RubyParserTest {
 	@Before

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,6 +1,5 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
@@ -8,11 +7,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.ContainerEntity;
-import depends.entity.FunctionEntity;
 import depends.entity.PackageEntity;
-import depends.entity.TypeEntity;
-import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 
 public class RubyNameTest extends RubyParserTest {

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,20 +1,16 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.fail;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
-import depends.relations.Relation;
 public abstract class RubyParserTest extends ParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,7 +1,5 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
-
 import java.io.File;
 import java.io.IOException;
 

02140fab12c27d68728d1602e2aa481aec23846c
@@ -1,7 +1,5 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
-
 import java.io.IOException;
 
 import org.junit.Before;

4c239662054d7375d9f5f7de95fadebea850c0f2
@@ -0,0 +1,21 @@
+package depends.extractor.empty;
+
+import depends.entity.repo.BuiltInType;
+
+public class EmptyBuiltInType extends BuiltInType {
+
+	@Override
+	public String[] getBuiltInMethods() {
+		return new String[] {};
+	}
+
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[] {};
+	}
+
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[] {};
+	}
+}

4c239662054d7375d9f5f7de95fadebea850c0f2
@@ -0,0 +1,35 @@
+package depends.extractor.empty;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.repo.EntityRepo;
+import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
+
+public class EmptyImportLookupStategy implements ImportLookupStrategy {
+
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedNames, EntityRepo repo) {
+		return new ArrayList<Entity>();
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
+		return new ArrayList<Entity>();
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
+		return new ArrayList<Entity>();
+	}
+
+}

4c239662054d7375d9f5f7de95fadebea850c0f2
@@ -0,0 +1,30 @@
+package depends.extractor.maven;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.pom.PomFileParser;
+
+public class EntityExtractTest extends MavenParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void use_package_contains() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/simple/log4j.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(0,repo.getEntity("log4j.log4j(1.2.12)").getRelations().size());
+	}
+}
\ No newline at end of file

4c239662054d7375d9f5f7de95fadebea850c0f2
@@ -0,0 +1,21 @@
+package depends.extractor.maven;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.empty.EmptyBuiltInType;
+import depends.extractor.empty.EmptyImportLookupStategy;
+import depends.extractor.pom.PomFileParser;
+import depends.relations.Inferer;
+
+public abstract class MavenParserTest {
+	protected EntityRepo repo;
+	protected Inferer inferer;
+
+	public void init() {
+    	repo = new EntityRepo();
+    	inferer = new Inferer(repo,new EmptyImportLookupStategy(),new EmptyBuiltInType(),false);
+    }
+	
+	public PomFileParser createParser(String src) {
+		return new  PomFileParser(src,repo);
+	}
+}

05c416f888dea9fc3eb9bf57f4e28aa914263c3d
@@ -0,0 +1,22 @@
+package depends.extractor.pom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.repo.EntityRepo;
+import depends.extractor.empty.EmptyImportLookupStategy;
+import depends.importtypes.Import;
+
+public class PomImportLookupStategy extends EmptyImportLookupStategy  {
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) continue;
+			result.add(imported);
+		}
+		return result;
+	}
+}

05c416f888dea9fc3eb9bf57f4e28aa914263c3d
@@ -0,0 +1,12 @@
+package depends.extractor.pom;
+
+import depends.importtypes.Import;
+
+public class PomParent extends Import {
+
+	public PomParent(String content) {
+		super(content);
+	}
+
+
+}

e3f0512ef99bd46826a63b91f11912a25257aa7b
@@ -8,5 +8,8 @@ public class PomParent extends Import {
 		super(content);
 	}
 
+	public String groupId;
+	public String artifactId;
+	public String version;
 
 }

e3f0512ef99bd46826a63b91f11912a25257aa7b
@@ -25,6 +25,21 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(0,repo.getEntity("log4j.log4j(1.2.12)").getRelations().size());
+        assertEquals(0,repo.getEntity("org.log4j-test.log4j(1.2.12)").getRelations().size());
+	}
+	
+	
+	@Test
+	public void test2() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/surefire-junit4-2.12.4.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        //TODO: add assert 
 	}
 }
\ No newline at end of file

f40c7911a672c8863cc2bcf6b8a263ee7c48b1e7
@@ -1,5 +1,6 @@
-package depends.extractor.maven;
+package depends.extractor.pom;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
 
@@ -32,7 +33,7 @@ public class EntityExtractTest extends MavenParserTest{
 	@Test
 	public void test2() throws IOException {
 	    String[] srcs = new String[] {
-	    		"./src/test/resources/maven-code-examples/surefire-junit4-2.12.4.pom",
+	    		"./src/test/resources/maven-code-examples/use_parent_groupId_and_version.pom",
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -40,6 +41,6 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        //TODO: add assert 
+        assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4(2.12.4)"));
 	}
 }
\ No newline at end of file

f40c7911a672c8863cc2bcf6b8a263ee7c48b1e7
@@ -1,4 +1,4 @@
-package depends.extractor.maven;
+package depends.extractor.pom;
 
 import depends.entity.repo.EntityRepo;
 import depends.extractor.empty.EmptyBuiltInType;

7734d1f19ea4631b9952a69bee9d11c8d57b3365
@@ -31,7 +31,7 @@ public class EntityExtractTest extends MavenParserTest{
 	
 	
 	@Test
-	public void test2() throws IOException {
+	public void should_use_parent_groupId() throws IOException {
 	    String[] srcs = new String[] {
 	    		"./src/test/resources/maven-code-examples/use_parent_groupId_and_version.pom",
 	    	    };

3f1f6b70b5311ae1bbfce3c08a2864f19be1e4be
@@ -0,0 +1,40 @@
+package depends.extractor.pom;
+
+import java.io.File;
+import java.util.List;
+
+import depends.util.FileUtil;
+
+public class PomLocator {
+
+	private List<String> includePaths;
+	private PomParent pomParent;
+
+	public PomLocator(List<String> includePaths, PomParent pomParent) {
+		this.includePaths = includePaths;
+		this.pomParent = pomParent;
+	}
+
+	public String getLocation() {
+		StringBuilder sb = new StringBuilder();
+		sb.append(pomParent.groupId.replace(".", File.separator));
+		sb.append(File.separator);
+		sb.append(pomParent.artifactId);
+		sb.append(File.separator);
+		sb.append(pomParent.version);
+		sb.append(File.separator);
+		sb.append(pomParent.artifactId);
+		sb.append("-");
+		sb.append(pomParent.version);
+		sb.append(".pom");
+		System.out.println(sb.toString());
+		for (String includePath:includePaths) {
+			String path = includePath+File.separator+sb.toString();
+			if (FileUtil.existFile(path)) {
+				return FileUtil.uniqFilePath(path);
+			}
+		}
+		return null;
+	}
+
+}

3f1f6b70b5311ae1bbfce3c08a2864f19be1e4be
@@ -1,5 +1,7 @@
 package depends.extractor.pom;
 
+import java.util.ArrayList;
+
 import depends.entity.repo.EntityRepo;
 import depends.extractor.empty.EmptyBuiltInType;
 import depends.extractor.empty.EmptyImportLookupStategy;
@@ -16,6 +18,6 @@ public abstract class MavenParserTest {
     }
 	
 	public PomFileParser createParser(String src) {
-		return new  PomFileParser(src,repo);
+		return new  PomFileParser(src,repo,new ArrayList<>(),null);
 	}
 }

2bf1d256e46649052957392a4e992bb689471576
@@ -43,4 +43,25 @@ public class EntityExtractTest extends MavenParserTest{
 	    inferer.resolveAllBindings();
         assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4(2.12.4)"));
 	}
+	
+	@Test
+	public void should_parse_properties_in_same_pom() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/properties-test1.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+    	/*
+        <project.version>1.00</project.version>
+        <activeio-version>3.1.4</activeio-version>
+        <projectName>Apache ActiveMQ</projectName>
+        <siteId>activemq-${project.version}</siteId>	 */
+        assertEquals("1.00",entity.getProperty("project.version"));
+        assertEquals("activemq-1.00",entity.getProperty("siteId"));
+	}
 }
\ No newline at end of file

0015763f36796308409ae18dabf1546558d6b5de
@@ -3,6 +3,8 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -64,4 +66,34 @@ public class EntityExtractTest extends MavenParserTest{
         assertEquals("1.00",entity.getProperty("project.version"));
         assertEquals("activemq-1.00",entity.getProperty("siteId"));
 	}
+	
+	
+	@Test
+	public void should_parse_multiple_properties_in_same_pom() throws IOException {
+		Pattern p = Pattern.compile("cat");
+	     Matcher m = p.matcher("one cat two cats in the yard");
+	     StringBuffer sb = new StringBuffer();
+	     while (m.find()) {
+	         m.appendReplacement(sb, "dog");
+	     }
+	     m.appendTail(sb);
+	     
+	     System.out.println(sb.toString());
+		String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/properties-test1.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+    	/*
+        <project.version>1.00</project.version>
+        <activeio-version>3.1.4</activeio-version>
+        <projectName>Apache ActiveMQ</projectName>
+        <anotherId>activemq-${project.version}--${activeio-version}</anotherId>	 */
+        assertEquals("activemq-1.00-3.1.4",entity.getProperty("anotherId"));
+	}
 }
\ No newline at end of file

f415479b5b75cd2a0932424e02ce9b1438a56695
@@ -45,11 +45,11 @@ abstract public class AbstractLangProcessor {
 	 */
     protected abstract FileParser createFileParser(String fileFullPath);
 
-	protected Inferer inferer;
+	public Inferer inferer;
 	protected EntityRepo entityRepo;
 	DependencyMatrix dependencyMatrix;
 	private String inputSrcPath;
-	private String[] includeDirs;
+	public String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {

f415479b5b75cd2a0932424e02ce9b1438a56695
@@ -3,14 +3,10 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.extractor.pom.PomFileParser;
-
 public class EntityExtractTest extends MavenParserTest{
     @Before
     public void setUp() {
@@ -70,15 +66,6 @@ public class EntityExtractTest extends MavenParserTest{
 	
 	@Test
 	public void should_parse_multiple_properties_in_same_pom() throws IOException {
-		Pattern p = Pattern.compile("cat");
-	     Matcher m = p.matcher("one cat two cats in the yard");
-	     StringBuffer sb = new StringBuffer();
-	     while (m.find()) {
-	         m.appendReplacement(sb, "dog");
-	     }
-	     m.appendTail(sb);
-	     
-	     System.out.println(sb.toString());
 		String[] srcs = new String[] {
 	    		"./src/test/resources/maven-code-examples/properties-test1.pom",
 	    	    };
@@ -96,4 +83,19 @@ public class EntityExtractTest extends MavenParserTest{
         <anotherId>activemq-${project.version}--${activeio-version}</anotherId>	 */
         assertEquals("activemq-1.00-3.1.4",entity.getProperty("anotherId"));
 	}
+	
+	@Test
+	public void should_parse_multiple_properties_in_parent_pom() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/properties-test-child.pom"
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+        assertEquals("13",entity.getProperty("project.version"));
+	}
 }
\ No newline at end of file

f415479b5b75cd2a0932424e02ce9b1438a56695
@@ -1,23 +1,28 @@
 package depends.extractor.pom;
 
 import java.util.ArrayList;
+import java.util.List;
 
 import depends.entity.repo.EntityRepo;
-import depends.extractor.empty.EmptyBuiltInType;
-import depends.extractor.empty.EmptyImportLookupStategy;
-import depends.extractor.pom.PomFileParser;
 import depends.relations.Inferer;
 
 public abstract class MavenParserTest {
+
 	protected EntityRepo repo;
+	private PomProcessor p;
 	protected Inferer inferer;
 
 	public void init() {
-    	repo = new EntityRepo();
-    	inferer = new Inferer(repo,new EmptyImportLookupStategy(),new EmptyBuiltInType(),false);
+		List<String> includeDir = new ArrayList<>();
+		includeDir.add("./src/test/resources/maven-code-examples/");
+		this.p = new PomProcessor();
+		p.includeDirs = includeDir.toArray(new String[] {});
+		
+		this.repo = p.getEntityRepo();
+		this.inferer = p.inferer;
     }
 	
 	public PomFileParser createParser(String src) {
-		return new  PomFileParser(src,repo,new ArrayList<>(),null);
+		return (PomFileParser) p.createFileParser(src);
 	}
 }

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.deptypes;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.UUID;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 public class EmptyTypeEntity extends TypeEntity {

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 public class FunctionCall {

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.HashSet;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.entity.repo;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor;
 
 import java.io.File;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp;
 
 import depends.entity.repo.BuiltInType;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp;
 
 import depends.entity.repo.BuiltInType;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp.cdt;
 
 import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp.cdt;
 
 import java.io.File;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp.cdt;
 
 import org.eclipse.cdt.core.dom.ast.IASTComment;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp.cdt;
 import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
 import org.eclipse.cdt.core.dom.ast.IASTCastExpression;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.cpp.cdt;
 
 import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.empty;
 
 import depends.entity.repo.BuiltInType;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.empty;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java;
 
 import depends.entity.repo.BuiltInType;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java;
 
 import depends.entity.repo.BuiltInType;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java.context;
 
 import java.lang.reflect.Method;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java.context;
 
 import org.antlr.v4.runtime.RuleContext;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java.context;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java.context;
 
 import java.util.List;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java.context;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.java.context;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.pom;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.pom;
 
 import java.io.File;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.pom;
 
 import depends.importtypes.Import;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.ruby;
 
 import depends.extractor.cpp.CppImportLookupStrategy;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.ruby;
 
 import java.util.concurrent.ExecutorService;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.ruby.jruby;
 
 import java.util.List;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.ruby.jruby;
 
 import java.io.IOException;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.extractor.ruby.jruby;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.format.detail;
 
 import java.io.FileNotFoundException;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.format.dot;
 
 import java.io.FileNotFoundException;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.format.json;
 
 

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.format.json;
 
 import javax.xml.bind.annotation.XmlAttribute;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.format.xml;
 
 import java.io.FileOutputStream;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.importtypes;
 
 public class ExactMatchImport extends Import{

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.importtypes;
 
 public class FileImport extends Import{

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.importtypes;
 
 public class PackageWildCardImport extends Import{

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.matrix;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.matrix;
 
 import java.util.ArrayList;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.relations;
 
 import depends.entity.Entity;

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends.relations;
 
 import java.util.Collection;

e60a7bb2778e88e2b649493b15828015b884e240
@@ -114,7 +114,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
-        dependencyMatrix.remapIds(entityRepo);
+        dependencyMatrix.remapIds();
         System.out.println("dependencie data generating done successfully...");	 	
     }
 

e60a7bb2778e88e2b649493b15828015b884e240
@@ -35,6 +35,8 @@ import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
 
 public class FileDependencyGenerator implements DependencyGenerator{
+	private ILeadingNameStrippper stripper = new EmptyLeadingNameStripper();
+
 	/**
 	 * Build the dependency matrix (without re-mapping file id)
 	 * @param entityRepo which contains entities and relations
@@ -43,10 +45,9 @@ public class FileDependencyGenerator implements DependencyGenerator{
 	@Override
 	public DependencyMatrix build(EntityRepo entityRepo) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix();
-        ArrayList<String> files = new ArrayList<String>();
 		for (Entity entity:entityRepo.getEntities()) {
         	if (entity instanceof FileEntity){
-        		files.add( entity.getDisplayName());
+        		dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
         	}
         	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
         	if (fileEntityFrom==-1) continue;
@@ -72,7 +73,6 @@ public class FileDependencyGenerator implements DependencyGenerator{
         		}
         	}
         }
-		dependencyMatrix.setNodes(files);
 		return dependencyMatrix;
 	}
 
@@ -83,4 +83,10 @@ public class FileDependencyGenerator implements DependencyGenerator{
 			return -1;
 		return ancestor.getId();
 	}
+
+
+	@Override
+	public void setLeadingStripper(ILeadingNameStrippper stripper) {
+		this.stripper = stripper;
+	}
 }

e60a7bb2778e88e2b649493b15828015b884e240
@@ -32,13 +32,14 @@ import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
 
 public class FunctionDependencyGenerator implements DependencyGenerator {
+	private ILeadingNameStrippper stripper = new EmptyLeadingNameStripper();
+
 	@Override
 	public DependencyMatrix build(EntityRepo entityRepo) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix();
-		ArrayList<String> elements = new ArrayList<String>();
 		for (Entity entity : entityRepo.getEntities()) {
 			if (entity instanceof FunctionEntity) {
-				elements.add(entity.getDisplayName());
+				dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
 			}
 			int fileEntityFrom = getFunctionEntityIdNoException(entity);
 			if (fileEntityFrom == -1)
@@ -53,7 +54,6 @@ public class FunctionDependencyGenerator implements DependencyGenerator {
 				}
 			}
 		}
-		dependencyMatrix.setNodes(elements);
 		return dependencyMatrix;
 	}
 
@@ -64,4 +64,9 @@ public class FunctionDependencyGenerator implements DependencyGenerator {
 			return -1;
 		return ancestor.getId();
 	}
+
+	@Override
+	public void setLeadingStripper(ILeadingNameStrippper stripper) {
+		this.stripper = stripper;
+	}
 }

95e9c7693c8da589e8037167a804ae59c3f1fe16
@@ -114,7 +114,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
-        dependencyMatrix.remapIds();
+        dependencyMatrix = dependencyMatrix.orderedMatrix();
         System.out.println("dependencie data generating done successfully...");	 	
     }
 

95e9c7693c8da589e8037167a804ae59c3f1fe16
@@ -65,7 +65,7 @@ public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDu
             int dst = dependencyPair.getTo();
         	writer.println("======="+files.get(src) + " -> " + files.get(dst) + "=========");
         	for (DependencyValue dependency:dependencyPair.getDependencies()) {
-        	writer.println(dependency.getDetails());
+        	writer.println("["+dependency.getType()+"]"+dependency.getDetails()+"\n");
         	}
         }		
 	}

95e9c7693c8da589e8037167a804ae59c3f1fe16
@@ -24,7 +24,6 @@ SOFTWARE.
 
 package depends.matrix;
 
-import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.CandidateTypes;
@@ -34,9 +33,7 @@ import depends.entity.TypeEntity;
 import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
 
-public class FileDependencyGenerator implements DependencyGenerator{
-	private ILeadingNameStrippper stripper = new EmptyLeadingNameStripper();
-
+public class FileDependencyGenerator extends DependencyGenerator{
 	/**
 	 * Build the dependency matrix (without re-mapping file id)
 	 * @param entityRepo which contains entities and relations
@@ -59,7 +56,7 @@ public class FileDependencyGenerator implements DependencyGenerator{
     	        		if (candidateType.getId()>=0) {
     	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,candidateType);
     	        			if (fileEntityTo!=-1) {
-    	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,candidateType);
+    	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,candidateType));
     	        			}
     	        		}
         			}
@@ -67,7 +64,7 @@ public class FileDependencyGenerator implements DependencyGenerator{
 	        		if (relatedEntity.getId()>=0) {
 	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relatedEntity);
 	        			if (fileEntityTo!=-1) {
-	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relatedEntity);
+	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,relatedEntity));
 	        			}
 	        		}
         		}
@@ -77,6 +74,9 @@ public class FileDependencyGenerator implements DependencyGenerator{
 	}
 
 	
+
+
+
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null)
@@ -85,8 +85,5 @@ public class FileDependencyGenerator implements DependencyGenerator{
 	}
 
 
-	@Override
-	public void setLeadingStripper(ILeadingNameStrippper stripper) {
-		this.stripper = stripper;
-	}
+
 }

95e9c7693c8da589e8037167a804ae59c3f1fe16
@@ -24,33 +24,28 @@ SOFTWARE.
 
 package depends.matrix;
 
-import java.util.ArrayList;
-
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.repo.EntityRepo;
 import depends.relations.Relation;
 
-public class FunctionDependencyGenerator implements DependencyGenerator {
-	private ILeadingNameStrippper stripper = new EmptyLeadingNameStripper();
-
-	@Override
+public class FunctionDependencyGenerator extends DependencyGenerator {
 	public DependencyMatrix build(EntityRepo entityRepo) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix();
 		for (Entity entity : entityRepo.getEntities()) {
 			if (entity instanceof FunctionEntity) {
 				dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
 			}
-			int fileEntityFrom = getFunctionEntityIdNoException(entity);
-			if (fileEntityFrom == -1)
+			int entityFrom = getFunctionEntityIdNoException(entity);
+			if (entityFrom == -1)
 				continue;
 			for (Relation relation : entity.getRelations()) {
 				if (relation.getEntity().getId() >= 0) {
-					int fileEntityTo = getFunctionEntityIdNoException(relation.getEntity());
-					if (fileEntityTo == -1)
+					int entityTo = getFunctionEntityIdNoException(relation.getEntity());
+					if (entityTo == -1)
 						continue;
-					dependencyMatrix.addDependency(relation.getType(), fileEntityFrom, fileEntityTo, entity,
-							relation.getEntity());
+					dependencyMatrix.addDependency(relation.getType(), entityFrom, entityTo, 1,buildDescription(entity,
+							relation.getEntity()));
 				}
 			}
 		}
@@ -65,8 +60,4 @@ public class FunctionDependencyGenerator implements DependencyGenerator {
 		return ancestor.getId();
 	}
 
-	@Override
-	public void setLeadingStripper(ILeadingNameStrippper stripper) {
-		this.stripper = stripper;
-	}
 }

87d26cacfee504df31ec6a30d77e29f81008038a
@@ -73,10 +73,6 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		return dependencyMatrix;
 	}
 
-	
-
-
-
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null)
@@ -84,6 +80,4 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		return ancestor.getId();
 	}
 
-
-
 }

0f46120a8a1bf842fb72c29a12fb32d14d191b5f
@@ -36,6 +36,7 @@ import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.DependencyGenerator;
 import depends.matrix.DependencyMatrix;
+import depends.matrix.OrderedMatrixGenerator;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import depends.util.FileTraversal;
@@ -114,7 +115,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
-        dependencyMatrix = dependencyMatrix.orderedMatrix();
+        dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
         System.out.println("dependencie data generating done successfully...");	 	
     }
 

0f46120a8a1bf842fb72c29a12fb32d14d191b5f
@@ -0,0 +1,65 @@
+package depends.matrix;
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashMap;
+
+public class OrderedMatrixGenerator  {
+	private DependencyMatrix matrix;
+	public OrderedMatrixGenerator(DependencyMatrix matrix) {
+		this.matrix = matrix;
+	}
+	public DependencyMatrix build() {
+	    ArrayList<String> reMappedNodes= new ArrayList<>(matrix.getNodes());
+	    //sort nodes by name
+	    reMappedNodes.sort(new Comparator<String>() {
+			@Override
+			public int compare(String o1, String o2) {
+				return o1.compareTo(o2);
+			}
+		});
+	    DependencyMatrix ordered = new DependencyMatrix();
+	    ordered.setNodes(reMappedNodes); 
+	    
+		HashMap<String, Integer> nodesMap = new HashMap<>();
+		for (int i=0;i<reMappedNodes.size();i++) {
+			nodesMap.put(reMappedNodes.get(i), i);
+		}
+		//add dependencies
+		for (DependencyPair dependencyPair:matrix.getDependencyPairs()) {
+			Integer from = dependencyPair.getFrom();
+			Integer to = dependencyPair.getTo();
+			for (DependencyValue dep:dependencyPair.getDependencies()) {
+				ordered.addDependency(dep.getType(), translateToNewId( nodesMap, from), translateToNewId( nodesMap, to), dep.getWeight(),dep.getDetails());
+			}
+		}
+		return ordered;
+	}
+	private Integer translateToNewId( HashMap<String, Integer> nodesMap, Integer id) {
+		return nodesMap.get(matrix.getNodeName(id));
+	}
+
+}

b3f3dc7849afc8742c1025e76a2652f27eb6bb49
@@ -51,7 +51,7 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
     private String namePathPattern="default";

b3f3dc7849afc8742c1025e76a2652f27eb6bb49
@@ -41,13 +41,14 @@ public class OrderedMatrixGenerator  {
 				return o1.compareTo(o2);
 			}
 		});
-	    DependencyMatrix ordered = new DependencyMatrix();
-	    ordered.setNodes(reMappedNodes); 
 	    
+	    DependencyMatrix ordered = new DependencyMatrix();
 		HashMap<String, Integer> nodesMap = new HashMap<>();
-		for (int i=0;i<reMappedNodes.size();i++) {
-			nodesMap.put(reMappedNodes.get(i), i);
+		for (int id=0;id<reMappedNodes.size();id++) {
+			nodesMap.put(reMappedNodes.get(id), id);
+			ordered.addNode(reMappedNodes.get(id), id);
 		}
+
 		//add dependencies
 		for (DependencyPair dependencyPair:matrix.getDependencyPairs()) {
 			Integer from = dependencyPair.getFrom();

f0d4e9dea522938cdd90d5c886d98456a5014b12
@@ -0,0 +1,84 @@
+package depends.format.plantuml;
+
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import depends.deptypes.DependencyType;
+import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.DependencyMatrix;
+import depends.matrix.DependencyPair;
+import depends.matrix.DependencyValue;
+
+public class PlantUmlFormatDependencyDumper extends AbstractFormatDependencyDumper {
+	@Override
+	public String getFormatName() {
+		return "plantuml";
+	}
+	
+	public PlantUmlFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+
+
+	@Override
+	public boolean output() {
+		PrintWriter writer;
+		try {
+			writer = new PrintWriter(composeFilename()+".uml");
+			ArrayList<String> files = matrix.getNodes();
+			
+			for (int i=0;i<files.size();i++) {
+				String file = files.get(i);
+				writer.println("class " + " "+file);
+			}
+			writer.println("@startuml");
+	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
+	        addRelations(writer,dependencyPairs); 
+			writer.println("@enduml");
+			writer.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
+		for (DependencyPair dependencyPair:dependencyPairs) {
+            int src = dependencyPair.getFrom();
+            int dst = dependencyPair.getTo();
+            Set<String> relations = new HashSet<>();
+            for (DependencyValue dep:dependencyPair.getDependencies()) {
+            	relations.add("\t"+ getNodeName(src) + getRelationSymbol(dep.getType()) +getNodeName(dst) + "");
+            }
+            for (String relation:relations) {
+            	writer.println(relation);
+            }
+		}		
+	}
+
+	private String getRelationSymbol(String type) {
+		if (type.equals(DependencyType.IMPLEMENT)) {
+			return "..|>";
+		}else if (type.equals(DependencyType.INHERIT)) {
+			return "--|>";
+		}else if (type.equals(DependencyType.CONTAIN)) {
+			return "*-->";
+		}else if (type.equals(DependencyType.MIXIN)) {
+			return "o-->";
+		}
+		return "..>";
+	}
+
+	private String getNodeName(int src) {
+		String result = matrix.getNodeName(src);
+//		if(result.startsWith(".")) result = result.substring(1);
+//		if(result.startsWith("/")) result = result.substring(1);
+//		if(result.startsWith("\\")) result = result.substring(1);
+		return result;
+	}
+}

f0d4e9dea522938cdd90d5c886d98456a5014b12
@@ -0,0 +1,50 @@
+package depends.matrix;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class MatrixLevelReducerTest {
+
+	@Test
+	public void test_MatrixLevelReducer_1() {
+		String node = ".maven.maven-parent.16.maven-parent-16_pom";
+		assertEquals(".maven",
+				MatrixLevelReducer.calcuateNodeAtLevel(node, 1));
+	}
+	
+	@Test
+	public void test_MatrixLevelReducer_2() {
+		String node = "maven.maven-parent.16.maven-parent-16_pom";
+		assertEquals("maven",
+				MatrixLevelReducer.calcuateNodeAtLevel(node, 1));
+	}
+	
+	@Test
+	public void test_MatrixLevelReducer_3() {
+		String node = ".maven.maven-parent.16.maven-parent-16_pom";
+		assertEquals(".maven.maven-parent.16.maven-parent-16_pom",
+				MatrixLevelReducer.calcuateNodeAtLevel(node, 100));
+	}
+	
+	@Test
+	public void test_MatrixLevelReducer_4() {
+		String node = "maven.maven-parent....16.maven-parent-16_pom";
+		assertEquals("maven.maven-parent.16",
+				MatrixLevelReducer.calcuateNodeAtLevel(node, 3));
+	}
+	
+	@Test
+	public void test_MatrixLevelReducer_5() {
+		String node = "maven/maven-parent/16/maven-parent-16.pom";
+		assertEquals("maven",
+				MatrixLevelReducer.calcuateNodeAtLevel(node, 1));
+	}
+	
+	@Test
+	public void test_MatrixLevelReducer_6() {
+		String node = "/maven/maven-parent/16/maven-parent-16.pom";
+		assertEquals("/maven",
+				MatrixLevelReducer.calcuateNodeAtLevel(node, 1));
+	}
+}

7c73166c8a304f72fcd110424d570ce17be2ee18
@@ -43,7 +43,7 @@ public class DependsCommand {
     private String src;
 	@Parameters(index = "2",  description = "The output file name")
 	private String output;
-    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
+    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail,dot,plantuml]")
     private String[] format=new String[]{"json"};
 	@Option(names = {"-d", "--dir"},  description = "The output directory")
 	private String dir;

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -34,9 +34,9 @@ import org.codehaus.plexus.util.FileUtils;
 
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
-import depends.matrix.DependencyGenerator;
-import depends.matrix.DependencyMatrix;
-import depends.matrix.OrderedMatrixGenerator;
+import depends.generator.DependencyGenerator;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.transform.OrderedMatrixGenerator;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import depends.util.FileTraversal;

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -30,9 +30,9 @@ import java.util.ArrayList;
 import java.util.Collection;
 
 import depends.format.AbstractFormatDependencyDumper;
-import depends.matrix.DependencyMatrix;
-import depends.matrix.DependencyPair;
-import depends.matrix.DependencyValue;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.DependencyPair;
+import depends.matrix.core.DependencyValue;
 
 public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDumper{
 	ArrayList<String> files;

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -30,8 +30,8 @@ import java.util.ArrayList;
 import java.util.Collection;
 
 import depends.format.AbstractFormatDependencyDumper;
-import depends.matrix.DependencyMatrix;
-import depends.matrix.DependencyPair;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.DependencyPair;
 
 public class DotFormatDependencyDumper extends  AbstractFormatDependencyDumper{
 	@Override

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -9,9 +9,9 @@ import java.util.Set;
 
 import depends.deptypes.DependencyType;
 import depends.format.AbstractFormatDependencyDumper;
-import depends.matrix.DependencyMatrix;
-import depends.matrix.DependencyPair;
-import depends.matrix.DependencyValue;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.DependencyPair;
+import depends.matrix.core.DependencyValue;
 
 public class PlantUmlFormatDependencyDumper extends AbstractFormatDependencyDumper {
 	@Override

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -31,7 +31,7 @@ import javax.xml.bind.Marshaller;
 
 import depends.format.AbstractFormatDependencyDumper;
 import depends.format.FileAttributes;
-import depends.matrix.DependencyMatrix;
+import depends.matrix.core.DependencyMatrix;
 
 public class XmlFormatDependencyDumper extends AbstractFormatDependencyDumper{
 	@Override

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -22,7 +22,7 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
 
-package depends.matrix;
+package depends.generator;
 
 import java.util.List;
 
@@ -31,6 +31,7 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.TypeEntity;
 import depends.entity.repo.EntityRepo;
+import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
 
 public class FileDependencyGenerator extends DependencyGenerator{

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -22,11 +22,12 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
 
-package depends.matrix;
+package depends.generator;
 
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.repo.EntityRepo;
+import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
 
 public class FunctionDependencyGenerator extends DependencyGenerator {

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -1,4 +1,4 @@
-package depends.matrix;
+package depends.matrix.transform;
 /*
 MIT License
 
@@ -27,6 +27,10 @@ import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.HashMap;
 
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.DependencyPair;
+import depends.matrix.core.DependencyValue;
+
 public class OrderedMatrixGenerator  {
 	private DependencyMatrix matrix;
 	public OrderedMatrixGenerator(DependencyMatrix matrix) {

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -4,7 +4,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.matrix.FileDependencyGenerator;
+import depends.generator.FileDependencyGenerator;
 
 public class ForwardDeclareTest extends CppParserTest{
     @Before

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -4,6 +4,8 @@ import static org.junit.Assert.*;
 
 import org.junit.Test;
 
+import depends.matrix.transform.MatrixLevelReducer;
+
 public class MatrixLevelReducerTest {
 
 	@Test

0ea6f03acd8e3fa13192ae1484fb31f60c9cbb94
@@ -94,14 +94,14 @@ public class ExpressionUsage {
 			expression.isCall = true;
 		}
 		if (ctx instanceof ICPPASTNewExpression) {
-			expression.rawType = ASTStringUtil.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
+			expression.rawType = ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
 			expression.isCall = true;
 			expression.deriveTypeFromChild = false;
 		}
 
 		if (ctx instanceof IASTCastExpression) {
 			expression.isCast=true;
-			expression.rawType = ASTStringUtil.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
+			expression.rawType = ASTStringUtilExt.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
 			expression.deriveTypeFromChild = false;
 
 		}
@@ -137,7 +137,7 @@ public class ExpressionUsage {
 			expression.rawType =  "<Built-in>";
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly
-			expression.rawType = ASTStringUtil.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
+			expression.rawType = ASTStringUtilExt.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
 			//TODO: check
 		}
 	}

cc39d49032383fc435d11548c4d1e11e72e48c43
@@ -0,0 +1,38 @@
+package depends.extractor.kotlin;
+
+import java.io.IOException;
+
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.CharStreams;
+import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.Lexer;
+import org.antlr.v4.runtime.tree.ParseTreeWalker;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.relations.Inferer;
+
+public class KotlinFileParser implements FileParser {
+
+	@Override
+	public void parse() throws IOException {
+	       CharStream input = CharStreams.fromFileName(fileFullPath);
+	        Lexer lexer = new KotlinLexer(input);
+	        CommonTokenStream tokens = new CommonTokenStream(lexer);
+	        KotlinParser parser = new KotlinParser(tokens);
+	        KotlinListener bridge = new KotlinListener(fileFullPath, entityRepo,inferer);
+		    ParseTreeWalker walker = new ParseTreeWalker();
+		    walker.walk(bridge, parser.kotlinFile());
+	}
+	
+	private String fileFullPath;
+	private EntityRepo entityRepo;
+	private Inferer inferer;
+	public KotlinFileParser(String fileFullPath,EntityRepo entityRepo, Inferer inferer) {
+        this.fileFullPath = fileFullPath;
+        this.entityRepo = entityRepo;
+        this.inferer = inferer;
+	}
+
+
+}

cc39d49032383fc435d11548c4d1e11e72e48c43
@@ -0,0 +1,42 @@
+package depends.extractor.kotlin;
+
+import depends.entity.repo.BuiltInType;
+import depends.extractor.AbstractLangProcessor;
+import depends.extractor.FileParser;
+import depends.extractor.java.JavaBuiltInType;
+import depends.extractor.java.JavaFileParser;
+import depends.extractor.java.JavaImportLookupStrategy;
+import depends.relations.ImportLookupStrategy;
+
+public class KotlinProcessor extends AbstractLangProcessor {
+
+	public KotlinProcessor() {
+    	super(true);
+	}
+
+	@Override
+	public String supportedLanguage() {
+		return "kotlin";
+	}
+
+	@Override
+	public String[] fileSuffixes() {
+		return new String[] {".kt"};
+	}
+
+	@Override
+	public ImportLookupStrategy getImportLookupStrategy() {
+		return new JavaImportLookupStrategy();
+	}
+
+	@Override
+	public BuiltInType getBuiltInType() {
+		return new JavaBuiltInType();
+	}
+
+	@Override
+	protected FileParser createFileParser(String fileFullPath) {
+		return new KotlinFileParser(fileFullPath,entityRepo, inferer);
+	}
+
+}

cc39d49032383fc435d11548c4d1e11e72e48c43
@@ -0,0 +1,12 @@
+package depends.extractor.kotlin.context;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.kotlin.KotlinHandlerContext;
+
+public class ExpressionUsage {
+
+	public ExpressionUsage(KotlinHandlerContext context, EntityRepo entityRepo) {
+		// TODO Auto-generated constructor stub
+	}
+
+}

591411548f540dd2d9140a07d9664cdd89946ca0
@@ -170,5 +170,6 @@ abstract public class AbstractLangProcessor {
 	public void setDependencyGenerator(DependencyGenerator dependencyGenerator) {
 		this.dependencyGenerator = dependencyGenerator;
 	}
+	public abstract List<String> supportedRelations();
 
 }

591411548f540dd2d9140a07d9664cdd89946ca0
@@ -24,6 +24,10 @@ SOFTWARE.
 
 package depends.extractor.cpp;
 
+import static depends.deptypes.DependencyType.*;
+import java.util.ArrayList;
+import java.util.List;
+
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
@@ -67,4 +71,22 @@ public class CppProcessor extends AbstractLangProcessor {
 	public BuiltInType getBuiltInType() {
 		return new CppBuiltInType();
 	}
+	
+	@Override
+	public List<String> supportedRelations() {
+		ArrayList<String> depedencyTypes = new ArrayList<>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(CONTAIN);
+		depedencyTypes.add(IMPLEMENT);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		return depedencyTypes;
+	}	
 }

591411548f540dd2d9140a07d9664cdd89946ca0
@@ -24,11 +24,14 @@ SOFTWARE.
 
 package depends.extractor.java;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
 import depends.relations.ImportLookupStrategy;
-
+import static depends.deptypes.DependencyType.*;
 public class JavaProcessor extends AbstractLangProcessor {
     private static final String JAVA_LANG = "java";
     private static final String JAVA_SUFFIX = ".java";
@@ -61,4 +64,23 @@ public class JavaProcessor extends AbstractLangProcessor {
 	public BuiltInType getBuiltInType() {
 		return new JavaBuiltInType();
 	}
+	
+	@Override
+	public List<String> supportedRelations() {
+		ArrayList<String> depedencyTypes = new ArrayList<>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(CONTAIN);
+		depedencyTypes.add(IMPLEMENT);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		depedencyTypes.add(ANNOTATION);
+		return depedencyTypes;
+	}
 }

591411548f540dd2d9140a07d9664cdd89946ca0
@@ -1,10 +1,26 @@
 package depends.extractor.kotlin;
 
+import static depends.deptypes.DependencyType.ANNOTATION;
+import static depends.deptypes.DependencyType.CALL;
+import static depends.deptypes.DependencyType.CAST;
+import static depends.deptypes.DependencyType.CONTAIN;
+import static depends.deptypes.DependencyType.CREATE;
+import static depends.deptypes.DependencyType.IMPLEMENT;
+import static depends.deptypes.DependencyType.IMPORT;
+import static depends.deptypes.DependencyType.INHERIT;
+import static depends.deptypes.DependencyType.PARAMETER;
+import static depends.deptypes.DependencyType.RETURN;
+import static depends.deptypes.DependencyType.SET;
+import static depends.deptypes.DependencyType.THROW;
+import static depends.deptypes.DependencyType.USE;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
 import depends.extractor.java.JavaBuiltInType;
-import depends.extractor.java.JavaFileParser;
 import depends.extractor.java.JavaImportLookupStrategy;
 import depends.relations.ImportLookupStrategy;
 
@@ -38,5 +54,24 @@ public class KotlinProcessor extends AbstractLangProcessor {
 	protected FileParser createFileParser(String fileFullPath) {
 		return new KotlinFileParser(fileFullPath,entityRepo, inferer);
 	}
+	
+	@Override
+	public List<String> supportedRelations() {
+		ArrayList<String> depedencyTypes = new ArrayList<>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(CONTAIN);
+		depedencyTypes.add(IMPLEMENT);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		depedencyTypes.add(ANNOTATION);
+		return depedencyTypes;
+	}	
 
 }

591411548f540dd2d9140a07d9664cdd89946ca0
@@ -24,6 +24,10 @@ SOFTWARE.
 
 package depends.extractor.ruby;
 
+import static depends.deptypes.DependencyType.*;
+
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
@@ -77,4 +81,21 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 		return new RubyBuiltInType();
 	}
 	
+	@Override
+	public List<String> supportedRelations() {
+		ArrayList<String> depedencyTypes = new ArrayList<>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(CONTAIN);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		depedencyTypes.add(MIXIN);
+		return depedencyTypes;
+	}		
 }

591411548f540dd2d9140a07d9664cdd89946ca0
@@ -1,12 +1,14 @@
 package depends.addons;
 
+import java.util.ArrayList;
+
 import org.junit.Test;
 
 public class DV8MappingFileBuilderTest {
 
 	@Test
 	public void test() {
-		DV8MappingFileBuilder b = new DV8MappingFileBuilder();
+		DV8MappingFileBuilder b = new DV8MappingFileBuilder(new ArrayList<>());
 		b.create("/tmp/depends-dv8-mapping.json");
 	}
 

1975777eaebe51249170858dd42764930f232962
@@ -53,7 +53,7 @@ public class PlantUmlFormatDependencyDumper extends AbstractFormatDependencyDump
             int dst = dependencyPair.getTo();
             Set<String> relations = new HashSet<>();
             for (DependencyValue dep:dependencyPair.getDependencies()) {
-            	relations.add("\t"+ getNodeName(src) + getRelationSymbol(dep.getType()) +getNodeName(dst) + "");
+            	relations.add("\t"+ getNodeName(src) + " " + getRelationSymbol(dep.getType()) +" " + getNodeName(dst) + "");
             }
             for (String relation:relations) {
             	writer.println(relation);
@@ -76,9 +76,7 @@ public class PlantUmlFormatDependencyDumper extends AbstractFormatDependencyDump
 
 	private String getNodeName(int src) {
 		String result = matrix.getNodeName(src);
-//		if(result.startsWith(".")) result = result.substring(1);
-//		if(result.startsWith("/")) result = result.substring(1);
-//		if(result.startsWith("\\")) result = result.substring(1);
+		result = result.replace("-", "_");
 		return result;
 	}
 }

4b76b093a48e6abfae442b288db9362b4a01467b
@@ -32,7 +32,7 @@ public class KotlinProcessor extends AbstractLangProcessor {
 
 	@Override
 	public String supportedLanguage() {
-		return "kotlin";
+		return "kotlin[on-going]";
 	}
 
 	@Override

86e7c895c7fb279a4ba51e20ffeba80b8afa533c
@@ -0,0 +1,5 @@
+package depends.extractor.python;
+
+public class ExpressionUsage {
+
+}

86e7c895c7fb279a4ba51e20ffeba80b8afa533c
@@ -0,0 +1,25 @@
+package depends.extractor.python;
+
+import depends.entity.repo.BuiltInType;
+
+public class PythonBuiltInType extends BuiltInType {
+
+	@Override
+	public String[] getBuiltInMethods() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String[] getBuiltInTypeStr() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+}

86e7c895c7fb279a4ba51e20ffeba80b8afa533c
@@ -0,0 +1,40 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.CharStreams;
+import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.Lexer;
+import org.antlr.v4.runtime.tree.ParseTreeWalker;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.extractor.ruby.IncludedFileLocator;
+import depends.relations.Inferer;
+
+public class PythonFileParser implements FileParser {
+
+	private String fileFullPath;
+	private EntityRepo entityRepo;
+	private Inferer inferer;
+
+	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
+			Inferer inferer, PythonProcessor pythonProcessor) {
+		this.fileFullPath = fileFullPath;
+		this.entityRepo = entityRepo;
+		this.inferer = inferer;
+	}
+
+	@Override
+	public void parse() throws IOException {
+        CharStream input = CharStreams.fromFileName(fileFullPath);
+        Lexer lexer = new Python3Lexer(input);
+        CommonTokenStream tokens = new CommonTokenStream(lexer);
+        Python3Parser parser = new Python3Parser(tokens);
+        Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer);
+	    ParseTreeWalker walker = new ParseTreeWalker();
+	    walker.walk(bridge, parser.file_input());
+	}
+
+}

86e7c895c7fb279a4ba51e20ffeba80b8afa533c
@@ -139,6 +139,7 @@ public class RelationCounter {
 
 	private void computeImports(FileEntity file) {
 		List<Entity> imports = file.getImportedRelationEntities();
+		if (imports==null) return;
 		for (Entity imported:imports) {
 			if (imported instanceof FileEntity)
 			{

86e7c895c7fb279a4ba51e20ffeba80b8afa533c
@@ -0,0 +1,31 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.extractor.pom.PomFileParser;
+
+public class PythonFunctionTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_methods() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertEquals(0,repo.getEntity("foo").getRelations().size());
+	}
+}

86e7c895c7fb279a4ba51e20ffeba80b8afa533c
@@ -0,0 +1,28 @@
+package depends.extractor.python;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.entity.repo.EntityRepo;
+import depends.relations.Inferer;
+
+public abstract class PythonParserTest {
+
+	protected EntityRepo repo;
+	private PythonProcessor p;
+	protected Inferer inferer;
+
+	public void init() {
+		List<String> includeDir = new ArrayList<>();
+		includeDir.add("./src/test/resources/python-code-examples/");
+		this.p = new PythonProcessor();
+		p.includeDirs = includeDir.toArray(new String[] {});
+		
+		this.repo = p.getEntityRepo();
+		this.inferer = p.inferer;
+    }
+	
+	public PythonFileParser createParser(String src) {
+		return (PythonFileParser) p.createFileParser(src);
+	}
+}

7360bdc13f9441981585a7ed36e9cf6c309feb7a
@@ -83,6 +83,15 @@ public abstract class HandlerContext {
 		return ;		
 	}
 	
+	/**
+	 * Tell the context that a new method was found.
+	 * Do not forget to tell the context leave the method when you finish
+	 * the process of the method
+	 * @param methodName
+	 * @param returnType  - if no return type information avaliable, keep it as null;
+	 * @param throwedType - if no throwed type information avaliable, keep it as empty list;  
+	 * @return the new function enity
+	 */
 	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
 		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
 				idGenerator.generateId(),returnType);

7360bdc13f9441981585a7ed36e9cf6c309feb7a
@@ -1,12 +1,15 @@
 package depends.extractor.python;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
 
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.entity.Entity;
+import depends.entity.FunctionEntity;
 import depends.extractor.pom.PomFileParser;
 
 public class PythonFunctionTest extends PythonParserTest {
@@ -26,6 +29,21 @@ public class PythonFunctionTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(0,repo.getEntity("foo").getRelations().size());
+        assertNotNull(repo.getEntity("foo"));
+	}
+	
+	@Test
+	public void should_parse_method_parameters() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
+        assertEquals(2,func.getParameters().size());
 	}
 }

5bb575a6c9b0f0d40174657087ad682b5533d9e4
@@ -0,0 +1,50 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.extractor.pom.PomFileParser;
+
+public class PythonClassTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity("Foo"));
+	}
+	
+	@Test
+	public void should_parse_method_of_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    TypeEntity type = (TypeEntity)repo.getEntity("Foo");
+        assertEquals(2,type.getFunctions().size());
+	}
+}

78c3d0e8b4e5c48647a944833c7d1eef5a690848
@@ -64,8 +64,12 @@ public abstract class HandlerContext {
 	}
 
 	
-
-	public Entity foundNewType(String classOrInterfaceName) {
+	/**
+	 * Tell the context object that a new type founded.
+	 * @param classOrInterfaceName
+	 * @return
+	 */
+	public TypeEntity foundNewType(String classOrInterfaceName) {
 		TypeEntity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
 			idGenerator.generateId());
 		pushToStack(currentTypeEntity);

78c3d0e8b4e5c48647a944833c7d1eef5a690848
@@ -8,9 +8,11 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
+import depends.extractor.FileParser;
 import depends.extractor.pom.PomFileParser;
 
 public class PythonClassTest extends PythonParserTest {
@@ -47,4 +49,21 @@ public class PythonClassTest extends PythonParserTest {
 	    TypeEntity type = (TypeEntity)repo.getEntity("Foo");
         assertEquals(2,type.getFunctions().size());
 	}
+	
+	@Test
+	public void should_parse_baseclass_of_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    TypeEntity type = (TypeEntity)repo.getEntity("Bar");
+	    this.assertContainsRelation(type, DependencyType.INHERIT, "Foo");
+	}
+
+
 }

78c3d0e8b4e5c48647a944833c7d1eef5a690848
@@ -4,9 +4,12 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.extractor.ParserCreator;
+import depends.extractor.ParserTest;
 import depends.relations.Inferer;
 
-public abstract class PythonParserTest {
+public abstract class PythonParserTest extends ParserTest implements ParserCreator {
 
 	protected EntityRepo repo;
 	private PythonProcessor p;
@@ -25,4 +28,10 @@ public abstract class PythonParserTest {
 	public PythonFileParser createParser(String src) {
 		return (PythonFileParser) p.createFileParser(src);
 	}
+	
+	@Override
+	public FileParser createFileParser(String src) {
+		// TODO Auto-generated method stub
+		return null;
+	}
 }

abcfc508235d96e36355792435c7b60852db42b3
@@ -53,14 +53,14 @@ public class AliasEntity extends Entity {
 			referToEntity = entity;
 	}
 
-	public Collection<TypeEntity> getResolvedTypeParameters() {
+	public Collection<Entity> getResolvedTypeParameters() {
 		if (!(referToEntity instanceof DecoratedEntity))
 			return new ArrayList<>();
 		DecoratedEntity origin = (DecoratedEntity) referToEntity;
 		return origin.getResolvedTypeParameters();
 	}
 
-	public Collection<TypeEntity> getResolvedAnnotations() {
+	public Collection<Entity> getResolvedAnnotations() {
 		if (!(referToEntity instanceof DecoratedEntity))
 			return new ArrayList<>();
 		DecoratedEntity origin = (DecoratedEntity) referToEntity;
@@ -127,7 +127,7 @@ public class AliasEntity extends Entity {
 		return null;
 	}
 
-	public Collection<TypeEntity> getReturnTypes() {
+	public Collection<Entity> getReturnTypes() {
 		if (!(referToEntity instanceof FunctionEntity))
 			return new ArrayList<>();
 		FunctionEntity origin = (FunctionEntity) referToEntity;
@@ -145,7 +145,7 @@ public class AliasEntity extends Entity {
 		return origin.getParameters();
 	}
 
-	public Collection<TypeEntity> getThrowTypes() {
+	public Collection<Entity> getThrowTypes() {
 		if (!(referToEntity instanceof FunctionEntity))
 			return new ArrayList<>();
 		FunctionEntity origin = (FunctionEntity) referToEntity;

abcfc508235d96e36355792435c7b60852db42b3
@@ -200,13 +200,13 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public Collection<TypeEntity> getResolvedTypeParameters() {
+	public Collection<Entity> getResolvedTypeParameters() {
 		System.err.println("error: getResolvedTypeParameters should not been invoked");
 		return super.getResolvedTypeParameters();
 	}
 
 	@Override
-	public Collection<TypeEntity> getResolvedAnnotations() {
+	public Collection<Entity> getResolvedAnnotations() {
 		System.err.println("error: getResolvedAnnotations should not been invoked");
 		return super.getResolvedAnnotations();
 	}
@@ -218,9 +218,9 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
+	protected Collection<Entity> identiferToEntities(Inferer inferer, Collection<String> identifiers) {
 		System.err.println("error: identiferToTypes should not been invoked");
-		return super.identiferToTypes(inferer, identifiers);
+		return super.identiferToEntities(inferer, identifiers);
 	}
 
 	@Override

abcfc508235d96e36355792435c7b60852db42b3
@@ -34,8 +34,8 @@ public class FunctionEntity extends ContainerEntity{
 	private List<String> returnTypeIdentifiers = new ArrayList<>();
 	Collection<VarEntity> parameters;
     Collection<String> throwTypesIdentifiers = new ArrayList<>(); 
-	private Collection<TypeEntity> returnTypes = new ArrayList<>();
-	private Collection<TypeEntity> throwTypes = new ArrayList<>();
+	private Collection<Entity> returnTypes = new ArrayList<>();
+	private Collection<Entity> throwTypes = new ArrayList<>();
     public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
 		super(simpleName, parent,id);
 		this.returnTypes = new ArrayList<>();
@@ -44,14 +44,17 @@ public class FunctionEntity extends ContainerEntity{
 		throwTypesIdentifiers = new ArrayList<>();
 		addReturnType(returnType);
 	}
-	public Collection<TypeEntity> getReturnTypes() {
+	public Collection<Entity> getReturnTypes() {
 		return returnTypes;
 	}
 	
 	@Override
 	public TypeEntity getType() {
-		if (returnTypes.size()>0)
-			return returnTypes.iterator().next();
+		if (returnTypes.size()>0){
+			Object type = returnTypes.iterator().next();
+			if (type instanceof TypeEntity)
+				return (TypeEntity)type;
+		}
 		return null;
 	}
 
@@ -79,9 +82,9 @@ public class FunctionEntity extends ContainerEntity{
 			param.inferLocalLevelEntities(inferer);
 		}
 		if (returnTypes.size()<returnTypeIdentifiers.size())
-			returnTypes = identiferToTypes(inferer,this.returnTypeIdentifiers);
+			returnTypes = identiferToEntities(inferer,this.returnTypeIdentifiers);
 		if (throwTypes.size()<throwTypesIdentifiers.size())
-			throwTypes = identiferToTypes(inferer,this.throwTypesIdentifiers);
+			throwTypes = identiferToEntities(inferer,this.throwTypesIdentifiers);
 		super.inferLocalLevelEntities(inferer);
 		if (this.returnTypes.size()==0 && this.getLastExpressionType()!=null) {
 			this.returnTypes.add(this.getLastExpressionType());
@@ -90,7 +93,7 @@ public class FunctionEntity extends ContainerEntity{
 	public Collection<VarEntity> getParameters() {
 		return parameters;
 	}
-	public Collection<TypeEntity> getThrowTypes() {
+	public Collection<Entity> getThrowTypes() {
 		return throwTypes;
 	}
 	@Override

abcfc508235d96e36355792435c7b60852db42b3
@@ -43,9 +43,12 @@ public class TypeEntity extends ContainerEntity{
 	}
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
-		inheritedTypes= identiferToTypes(inferer,this.inhertedTypeIdentifiers);
+		inheritedTypes= new ArrayList<>();
+		identiferToEntities(inferer,this.inhertedTypeIdentifiers).forEach(item->inheritedTypes.add((TypeEntity)item));
 		inheritedTypes.remove(this);
-		implementedTypes= identiferToTypes(inferer,this.implementedIdentifiers);
+
+		implementedTypes= new ArrayList<>();
+		identiferToEntities(inferer,this.implementedIdentifiers).forEach(item->implementedTypes.add((TypeEntity)item));
 		implementedTypes.remove(this);
 		if (inheritedTypes.size()>0)
 			inheritedType = inheritedTypes.iterator().next();

abcfc508235d96e36355792435c7b60852db42b3
@@ -67,14 +67,14 @@ public class RelationCounter {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
-			for (TypeEntity type:var.getResolvedTypeParameters()) {
+			for (Entity type:var.getResolvedTypeParameters()) {
 				entity.addRelation(new Relation(DependencyType.USE,type));
 			}
 		}
-		for (TypeEntity type:entity.getResolvedAnnotations()) {
+		for (Entity type:entity.getResolvedAnnotations()) {
 			entity.addRelation(new Relation(DependencyType.USE,type));
 		}
-		for (TypeEntity type:entity.getResolvedTypeParameters()) {
+		for (Entity type:entity.getResolvedTypeParameters()) {
 			entity.addRelation(new Relation(DependencyType.USE,type));
 		}
 		for (ContainerEntity mixin:entity.getResolvedMixins()) {
@@ -125,14 +125,14 @@ public class RelationCounter {
 	}
 
 	private void computeFunctionRelations(FunctionEntity func) {
-		for (TypeEntity returnType:func.getReturnTypes()) {
+		for (Entity returnType:func.getReturnTypes()) {
 			func.addRelation(new Relation(DependencyType.RETURN,returnType));
 		}
 		for (VarEntity parameter:func.getParameters()) {
 			if (parameter.getType()!=null) 
 				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType()));
 		}
-		for (TypeEntity throwType:func.getThrowTypes()) {
+		for (Entity throwType:func.getThrowTypes()) {
 			func.addRelation(new Relation(DependencyType.THROW,throwType));
 		}
 	}

abcfc508235d96e36355792435c7b60852db42b3
@@ -51,8 +51,8 @@ public abstract class ParserTest {
 	}
 
 	protected void assertContainReturnType(FunctionEntity function, String name) {
-		Collection<TypeEntity> types = function.getReturnTypes();
-	    for (TypeEntity type:types) {
+		Collection<Entity> types = function.getReturnTypes();
+	    for (Entity type:types) {
 	    	if (type.getRawName().equals(name)) {
 	    		return;
 	    	}

abcfc508235d96e36355792435c7b60852db42b3
@@ -0,0 +1,34 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.FunctionEntity;
+
+public class PythonDecoratorTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_decorated() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/decorated.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
+		assertEquals(1,func.getResolvedAnnotations().size());
+	}
+
+}

abcfc508235d96e36355792435c7b60852db42b3
@@ -6,6 +6,7 @@ import static org.junit.Assert.assertNotNull;
 import java.io.IOException;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import depends.entity.Entity;
@@ -46,4 +47,7 @@ public class PythonFunctionTest extends PythonParserTest {
 	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
         assertEquals(2,func.getParameters().size());
 	}
+	
+
+
 }

b74252b07c979d6e0cb2885c997db6c5e3defe65
@@ -1,5 +1,170 @@
 package depends.extractor.python;
 
+import java.util.List;
+
+import org.antlr.v4.runtime.ParserRuleContext;
+
+import depends.entity.ContainerEntity;
+import depends.entity.Expression;
+import depends.entity.FunctionEntity;
+import depends.entity.VarEntity;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.python.Python3Parser.And_testContext;
+import depends.extractor.python.Python3Parser.Arith_exprContext;
+import depends.extractor.python.Python3Parser.AtomContext;
+import depends.extractor.python.Python3Parser.Atom_exprContext;
+import depends.extractor.python.Python3Parser.AugassignContext;
+import depends.extractor.python.Python3Parser.ComparisonContext;
+import depends.extractor.python.Python3Parser.Expr_stmtContext;
+import depends.extractor.python.Python3Parser.Not_testContext;
+import depends.extractor.python.Python3Parser.Or_testContext;
+import depends.extractor.python.Python3Parser.Raise_stmtContext;
+import depends.extractor.python.Python3Parser.Return_stmtContext;
+import depends.extractor.python.Python3Parser.Shift_exprContext;
+import depends.extractor.python.Python3Parser.Xor_exprContext;
+import depends.relations.Inferer;
+
 public class ExpressionUsage {
+	IdGenerator idGenerator;
+	Inferer inferer;
+	private PythonHandlerContext context;
+	private PythonParserHelper helper;
+	public ExpressionUsage(PythonHandlerContext context,IdGenerator idGenerator, PythonParserHelper helper, Inferer inferer) {
+		this.context = context;
+		this.idGenerator = idGenerator;
+		this.inferer = inferer;
+		this.helper = helper;
+	}
+	
+	public Expression foundExpression(ParserRuleContext ctx) {
+		Expression expression = findExpression(ctx);
+		if (expression!=null) return expression;
+		Expression parent = findParentInStack(ctx);
+		/* create expression and link it with parent*/
+		expression = new Expression(idGenerator.generateId());
+		expression.text = ctx.toString();
+		expression.parent = parent;
+		if (expression.parent!=null) {
+			if (expression.parent.deduceTypeBasedId==null) 
+				expression.parent.deduceTypeBasedId = expression.id;
+			/* Set operation always use the 2nd expr's type*/
+			if (expression.parent.isSet) {
+				expression.parent.deduceTypeBasedId = expression.id;
+			}
+		}
+		context.lastContainer().addExpression(ctx,expression);
+		if (ctx instanceof AtomContext) {
+			AtomContext atom = (AtomContext)ctx;
+			if (atom.NUMBER()!=null ||
+					atom.STRING()!=null &&
+					atom.STRING().size()>0) {
+				expression.identifier = "<literal>";
+				expression.rawType = Inferer.buildInType.getQualifiedName();
+			}else if (atom.getText().equals("True")||
+					atom.getText().equals("False")) {
+				expression.identifier = "<boolean>";
+				expression.rawType = Inferer.buildInType.getQualifiedName();
+			}else if (atom.getText().equals("None")) {
+				expression.identifier = "<null>";
+				expression.rawType = Inferer.buildInType.getQualifiedName();
+			}else if (atom.NAME()!=null) {
+				expression.identifier = atom.NAME().getText();
+			}
+		}else if (ctx instanceof Or_testContext || ctx instanceof And_testContext ||
+				ctx instanceof Not_testContext || ctx instanceof ComparisonContext){ 
+			expression.identifier = "<logical>";
+			expression.rawType = Inferer.buildInType.getQualifiedName();
+		}else if (ctx instanceof Xor_exprContext ||
+				ctx instanceof Shift_exprContext ||
+				ctx instanceof Arith_exprContext ||
+				ctx instanceof AugassignContext) {
+			expression.identifier = "<arith>";
+			expression.rawType = Inferer.buildInType.getQualifiedName();
+		}
+		
+		
+		if (ctx instanceof Expr_stmtContext) {
+			Expr_stmtContext expr = ((Expr_stmtContext)ctx);
+			if ((expr.expr_stmt_rhs()!=null)||
+					(expr.augassign()!=null)||
+					(expr.annassign()!=null))
+			{
+				expression.isSet = true;
+			}
+		}else if (ctx instanceof Atom_exprContext) {
+			Atom_exprContext expr = ((Atom_exprContext)ctx);
+			if (expr.func_call()!=null) {
+				expression.isCall = true;
+				expression.identifier = helper.getFirstName(expr.atom_expr());
+			}
+			else if (expr.member_access()!=null) {
+				expression.isDot = true;
+			}
+			//TODO: member access in python should be handled seperately. they could be different types;
+		}else if (ctx instanceof Return_stmtContext) {
+			deduceReturnTypeInCaseOfReturn(ctx,expression);
+		}else if (ctx instanceof Raise_stmtContext) {
+			expression.isThrow = true;
+			expression.deriveTypeFromChild = true;
+		}
+		deduceVarTypeInCaseOfAssignment(ctx, expression);
+		return expression;
+	}
+
+
+	/**
+	 * Auto deduce variable type from assignment.
+	 * for example:
+	 *       c = C.new  then c is type of C
+	 * @param node
+	 * @param expression
+	 */
+	private void deduceVarTypeInCaseOfAssignment(ParserRuleContext node, Expression expression) {
+		ParserRuleContext parentNode = node.getParent();
+		if (parentNode instanceof Expr_stmtContext) {
+			Expr_stmtContext expr = (Expr_stmtContext)parentNode;
+			if (expr.expr_stmt_rhs()!=null) {
+				ContainerEntity scope = helper.getScopeOfVar(expr, this.context);
+				if (scope==null) return;
+				String varName = null;
+				//TODO: should handle list properly;
+				List<String> names = helper.getName(expr.testlist_star_expr());
+				if (names.size()==1)
+					varName = names.get(0);
+				if (varName==null) return;
+				VarEntity var = scope.lookupVarLocally(varName );
+				if (var!=null) {
+					expression.addDeducedTypeVar(var);
+				}
+			}
+		}
+	}
+	
+	private void deduceReturnTypeInCaseOfReturn(ParserRuleContext ctx, Expression expression) {
+		FunctionEntity currentFunction = context.currentFunction();
+		if (currentFunction ==null) return;
+		if (ctx instanceof Return_stmtContext) {
+			expression.addDeducedTypeFunction(currentFunction);
+		}
+	}
+	
+	private Expression findParentInStack(ParserRuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
+		return findParentInStack(ctx.getParent());
+	}
+	
+	private Expression findExpression(ParserRuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		return context.lastContainer().expressions().get(ctx);
+	}
 
 }

b74252b07c979d6e0cb2885c997db6c5e3defe65
@@ -72,7 +72,7 @@ public class RelationCounter {
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {
-			entity.addRelation(new Relation(DependencyType.USE,type));
+			entity.addRelation(new Relation(DependencyType.ANNOTATION,type));
 		}
 		for (Entity type:entity.getResolvedTypeParameters()) {
 			entity.addRelation(new Relation(DependencyType.USE,type));

b74252b07c979d6e0cb2885c997db6c5e3defe65
@@ -7,6 +7,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 
 public class PythonDecoratorTest extends PythonParserTest {
@@ -28,7 +29,8 @@ public class PythonDecoratorTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
-		assertEquals(1,func.getResolvedAnnotations().size());
+		this.assertContainsRelation(func, DependencyType.ANNOTATION	, "our_decorator");
+	    assertEquals(1,func.getResolvedAnnotations().size());
 	}
 
 }

b74252b07c979d6e0cb2885c997db6c5e3defe65
@@ -0,0 +1,33 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+
+public class PythonFuncCallTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_func_call() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func_call.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
+	    this.assertContainsRelation(func, DependencyType.CALL, "bar");
+	}
+
+}

aa18f1a885d7b9f8460fa6b254ae3ef78876782d
@@ -5,8 +5,10 @@ import java.util.List;
 import org.antlr.v4.runtime.ParserRuleContext;
 
 import depends.entity.ContainerEntity;
+import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.python.Python3Parser.And_testContext;
@@ -94,11 +96,18 @@ public class ExpressionUsage {
 		}else if (ctx instanceof Atom_exprContext) {
 			Atom_exprContext expr = ((Atom_exprContext)ctx);
 			if (expr.func_call()!=null) {
-				expression.isCall = true;
 				expression.identifier = helper.getFirstName(expr.atom_expr());
+
+				Entity entity = context.foundEntityWithName(expression.identifier);
+				if (entity instanceof TypeEntity) {
+					expression.isCreate = true;
+				}else {
+					expression.isCall = true;
+				}
 			}
 			else if (expr.member_access()!=null) {
 				expression.isDot = true;
+				expression.identifier = expr.member_access().NAME().getText();
 			}
 			//TODO: member access in python should be handled seperately. they could be different types;
 		}else if (ctx instanceof Return_stmtContext) {

aa18f1a885d7b9f8460fa6b254ae3ef78876782d
@@ -0,0 +1,33 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+
+public class PythonObjectCreationTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_object_creation() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/object_creation.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
+	    this.assertContainsRelation(func, DependencyType.CREATE, "Bar");
+	}
+
+}

19b8f2cc6573262bb35cf03aa69bff814ea13613
@@ -44,7 +44,7 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
-		expression.text = ctx.toString();
+		expression.text = ctx.getText();
 		expression.parent = parent;
 		if (expression.parent!=null) {
 			if (expression.parent.deduceTypeBasedId==null) 
@@ -72,16 +72,6 @@ public class ExpressionUsage {
 			}else if (atom.NAME()!=null) {
 				expression.identifier = atom.NAME().getText();
 			}
-		}else if (ctx instanceof Or_testContext || ctx instanceof And_testContext ||
-				ctx instanceof Not_testContext || ctx instanceof ComparisonContext){ 
-			expression.identifier = "<logical>";
-			expression.rawType = Inferer.buildInType.getQualifiedName();
-		}else if (ctx instanceof Xor_exprContext ||
-				ctx instanceof Shift_exprContext ||
-				ctx instanceof Arith_exprContext ||
-				ctx instanceof AugassignContext) {
-			expression.identifier = "<arith>";
-			expression.rawType = Inferer.buildInType.getQualifiedName();
 		}
 		
 		

19b8f2cc6573262bb35cf03aa69bff814ea13613
@@ -0,0 +1,50 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+
+public class PythonObjectThrowReturn extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_throws() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/throw_return.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity("t1");
+	    this.assertContainsRelation(func, DependencyType.THROW, "Bar");
+	}
+	
+	
+	@Test
+	public void could_parse_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/throw_return.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity("t2");
+	    this.assertContainsRelation(func, DependencyType.RETURN, "Bar");
+	}
+
+
+}

f56f4bfef3d33338e25dd5ab6a1ec926641e6b67
@@ -18,12 +18,14 @@ public class PythonFileParser implements FileParser {
 	private String fileFullPath;
 	private EntityRepo entityRepo;
 	private Inferer inferer;
+	private IncludedFileLocator includeFileLocator;
 
-	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
+	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includeFileLocator,
 			Inferer inferer, PythonProcessor pythonProcessor) {
 		this.fileFullPath = fileFullPath;
 		this.entityRepo = entityRepo;
 		this.inferer = inferer;
+		this.includeFileLocator = includeFileLocator;
 	}
 
 	@Override

f56f4bfef3d33338e25dd5ab6a1ec926641e6b67
@@ -0,0 +1,58 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.extractor.FileParser;
+import depends.extractor.pom.PomFileParser;
+import depends.util.FileUtil;
+
+public class PythonImportTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_module_in_same_package() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    		"./src/test/resources/python-code-examples/importing.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[0]));
+	}
+	
+	
+	@Test
+	public void should_parse_module_in_same_package_order_robust() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/importing.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
+	
+}

f56f4bfef3d33338e25dd5ab6a1ec926641e6b67
@@ -8,6 +8,7 @@ import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
 import depends.relations.Inferer;
+import depends.util.FileUtil;
 
 public abstract class PythonParserTest extends ParserTest implements ParserCreator {
 
@@ -26,12 +27,11 @@ public abstract class PythonParserTest extends ParserTest implements ParserCreat
     }
 	
 	public PythonFileParser createParser(String src) {
-		return (PythonFileParser) p.createFileParser(src);
+		return (PythonFileParser)createFileParser(src);
 	}
 	
 	@Override
 	public FileParser createFileParser(String src) {
-		// TODO Auto-generated method stub
-		return null;
+		return  p.createFileParser(FileUtil.uniqFilePath(src));
 	}
 }

8b44b187b1c561cec399b1db222e1e04e0ac7e3d
@@ -8,6 +8,8 @@ import org.antlr.v4.runtime.CommonTokenStream;
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
+import depends.entity.Entity;
+import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ruby.IncludedFileLocator;
@@ -19,6 +21,7 @@ public class PythonFileParser implements FileParser {
 	private EntityRepo entityRepo;
 	private Inferer inferer;
 	private IncludedFileLocator includeFileLocator;
+	private PythonProcessor processor;
 
 	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includeFileLocator,
 			Inferer inferer, PythonProcessor pythonProcessor) {
@@ -26,17 +29,26 @@ public class PythonFileParser implements FileParser {
 		this.entityRepo = entityRepo;
 		this.inferer = inferer;
 		this.includeFileLocator = includeFileLocator;
+		this.processor = pythonProcessor;
 	}
 
 	@Override
 	public void parse() throws IOException {
+		/** If file already exist, skip it */
+		Entity fileEntity = entityRepo.getEntity(fileFullPath);
+		if (fileEntity!=null && fileEntity instanceof FileEntity) {
+			return;
+		}
         CharStream input = CharStreams.fromFileName(fileFullPath);
         Lexer lexer = new Python3Lexer(input);
         CommonTokenStream tokens = new CommonTokenStream(lexer);
         Python3Parser parser = new Python3Parser(tokens);
-        Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer);
+        Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();
 	    walker.walk(bridge, parser.file_input());
+	    
+		fileEntity = entityRepo.getEntity(fileFullPath);
+		fileEntity.inferEntities(inferer);
 	}
 
 }

46d74885110c34cd8e4f01990d5828ad7a4af826
@@ -133,4 +133,8 @@ public class FileEntity extends ContainerEntity {
 		return importedFileCollector.getFiles();
 	}
 
+	public List<Import> getImportedNames() {
+		return importedNames;
+	}
+
 }

46d74885110c34cd8e4f01990d5828ad7a4af826
@@ -86,14 +86,9 @@ public class ExpressionUsage {
 		}else if (ctx instanceof Atom_exprContext) {
 			Atom_exprContext expr = ((Atom_exprContext)ctx);
 			if (expr.func_call()!=null) {
-				expression.identifier = helper.getFirstName(expr.atom_expr());
-
-				Entity entity = context.foundEntityWithName(expression.identifier);
-				if (entity instanceof TypeEntity) {
-					expression.isCreate = true;
-				}else {
-					expression.isCall = true;
-				}
+				expression.identifier = helper.getFirstName(expr);
+				expression.isCreate = true;
+				expression.isCall = true;
 			}
 			else if (expr.member_access()!=null) {
 				expression.isDot = true;

46d74885110c34cd8e4f01990d5828ad7a4af826
@@ -55,4 +55,6 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
+	
+	
 }

ee7f8fb970603e83023c7ba9af905fa1e71bb0c9
@@ -31,7 +31,7 @@ import java.util.Set;
 import depends.importtypes.Import;
 import depends.relations.Inferer;
 
-public class FileEntity extends ContainerEntity {
+public class FileEntity extends TypeEntity {
 	private List<Import> importedNames = new ArrayList<>();
 	private boolean isInProjectScope = false;
 	private List<Entity> importedRelationEntities = new ArrayList<>();

ee7f8fb970603e83023c7ba9af905fa1e71bb0c9
@@ -86,9 +86,14 @@ public class ExpressionUsage {
 		}else if (ctx instanceof Atom_exprContext) {
 			Atom_exprContext expr = ((Atom_exprContext)ctx);
 			if (expr.func_call()!=null) {
-				expression.identifier = helper.getFirstName(expr);
-				expression.isCreate = true;
-				expression.isCall = true;
+				//TODO: should be refined later. Currently only a.b.c could be solved.
+				expression.identifier = expr.atom_expr().getText();
+				Entity entity = context.foundEntityWithName(expression.identifier);
+				if (entity instanceof FunctionEntity) {
+					expression.isCall = true;
+				}else {
+					expression.isCreate = true;
+				}
 			}
 			else if (expr.member_access()!=null) {
 				expression.isDot = true;

ee7f8fb970603e83023c7ba9af905fa1e71bb0c9
@@ -53,8 +53,24 @@ public class PythonImportTest extends PythonParserTest {
 	    inferer.resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(file, DependencyType.CALL,"foo");
 	}
 	
-	
+	@Test
+	public void should_parse_module_in_same_package_with_alias() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/importing_with_alias.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+	}
 	
 }

53ea2c4e496abc989dc868a2700808e9d6aa061b
@@ -25,6 +25,7 @@ SOFTWARE.
 package depends.entity;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
@@ -34,9 +35,9 @@ import depends.relations.Inferer;
 public class FileEntity extends TypeEntity {
 	private List<Import> importedNames = new ArrayList<>();
 	private boolean isInProjectScope = false;
-	private List<Entity> importedRelationEntities = new ArrayList<>();
-	private List<Entity> importedFiles = new ArrayList<>();
-	private List<Entity> importedTypes = new ArrayList<>();
+	private Collection<Entity> importedRelationEntities = new ArrayList<>();
+	private Collection<Entity> importedFiles = new ArrayList<>();
+	private Collection<Entity> importedTypes = new ArrayList<>();
 	private List<TypeEntity> declaredTypes = new ArrayList<>();
 	private ImportedFileCollector importedFileCollector = null;
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
@@ -106,15 +107,15 @@ public class FileEntity extends TypeEntity {
 		this.isInProjectScope = isInProjectScope;
 	}
 
-	public List<Entity> getImportedRelationEntities() {
+	public Collection<Entity> getImportedRelationEntities() {
 		return importedRelationEntities;
 	}
 
-	public List<Entity> getImportedFiles() {
+	public Collection<Entity> getImportedFiles() {
 		return importedFiles;
 	}
 
-	public List<Entity> getImportedTypes() {
+	public Collection<Entity> getImportedTypes() {
 		return importedTypes;
 	}
 

53ea2c4e496abc989dc868a2700808e9d6aa061b
@@ -25,6 +25,7 @@ SOFTWARE.
 package depends.extractor.cpp;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 
@@ -55,7 +56,7 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 				if (importedFile==null) continue;
 				 Entity entity = inferer.resolveName(importedFile,name, false);
 				if (entity!=null) return entity;
-				 List<Entity> namespaces = fileEntity.getImportedTypes();
+				Collection<Entity> namespaces = fileEntity.getImportedTypes();
 				for (Entity ns:namespaces) {
 					String nameWithPrefix = ns.getQualifiedName() + "." + name;
 					entity = inferer.resolveName(importedFile,nameWithPrefix, false);
@@ -66,7 +67,7 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
-	private void foundIncludedFiles(HashSet<String> fileSet, List<Entity> importedFiles, EntityRepo repo) {
+	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles, EntityRepo repo) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;
 			if (!(file instanceof FileEntity)) continue;

53ea2c4e496abc989dc868a2700808e9d6aa061b
@@ -138,7 +138,7 @@ public class RelationCounter {
 	}
 
 	private void computeImports(FileEntity file) {
-		List<Entity> imports = file.getImportedRelationEntities();
+		Collection<Entity> imports = file.getImportedRelationEntities();
 		if (imports==null) return;
 		for (Entity imported:imports) {
 			if (imported instanceof FileEntity)

53ea2c4e496abc989dc868a2700808e9d6aa061b
@@ -73,4 +73,38 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(file, DependencyType.CALL,"foo");
 	}
 	
+	@Test
+	public void should_parse_module_in_from_importing() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/from_importing.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
+	
+	
+	@Test
+	public void should_parse_module_in_from_importing_star() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/from_importing_star.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
 }

26501da0b6cc85630c535fa5b756b0d8e60975b6
@@ -48,6 +48,9 @@ public class PythonFileParser implements FileParser {
 	    walker.walk(bridge, parser.file_input());
 	    
 		fileEntity = entityRepo.getEntity(fileFullPath);
+		if (fileEntity.getRawName().contains("av_bench.py")) {
+			System.out.println("hlo");
+		}
 		fileEntity.inferEntities(inferer);
 	}
 

26501da0b6cc85630c535fa5b756b0d8e60975b6
@@ -51,6 +51,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
         	if (fileEntityFrom==-1) continue;
         	for (Relation relation:entity.getRelations()) {
         		Entity relatedEntity = relation.getEntity();
+        		if (relatedEntity==null) continue;
         		if (relatedEntity instanceof CandidateTypes) {
         			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
         			for (TypeEntity candidateType:candidateTypes) {

26501da0b6cc85630c535fa5b756b0d8e60975b6
@@ -107,4 +107,22 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(file, DependencyType.CALL,"foo");
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
+	
+	
+	@Test
+	public void should_parse_import_with_multi_dots() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/from_importing_multidot.py",
+	    		"./src/test/resources/python-code-examples/pkg/imported.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
 }

2906517017bdb3e65b0000eb0f5b32c0f4233ab8
@@ -8,22 +8,13 @@ import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
-import depends.extractor.python.Python3Parser.And_testContext;
-import depends.extractor.python.Python3Parser.Arith_exprContext;
 import depends.extractor.python.Python3Parser.AtomContext;
 import depends.extractor.python.Python3Parser.Atom_exprContext;
-import depends.extractor.python.Python3Parser.AugassignContext;
-import depends.extractor.python.Python3Parser.ComparisonContext;
 import depends.extractor.python.Python3Parser.Expr_stmtContext;
-import depends.extractor.python.Python3Parser.Not_testContext;
-import depends.extractor.python.Python3Parser.Or_testContext;
 import depends.extractor.python.Python3Parser.Raise_stmtContext;
 import depends.extractor.python.Python3Parser.Return_stmtContext;
-import depends.extractor.python.Python3Parser.Shift_exprContext;
-import depends.extractor.python.Python3Parser.Xor_exprContext;
 import depends.relations.Inferer;
 
 public class ExpressionUsage {

2906517017bdb3e65b0000eb0f5b32c0f4233ab8
@@ -26,7 +26,6 @@ package depends.relations;
 
 import java.util.Collection;
 import java.util.HashSet;
-import java.util.List;
 
 import depends.deptypes.DependencyType;
 import depends.entity.ContainerEntity;

2906517017bdb3e65b0000eb0f5b32c0f4233ab8
@@ -8,7 +8,6 @@ import java.util.Collection;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.relations.Relation;
 

2906517017bdb3e65b0000eb0f5b32c0f4233ab8
@@ -9,11 +9,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
-import depends.entity.Entity;
-import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
-import depends.extractor.FileParser;
-import depends.extractor.pom.PomFileParser;
 
 public class PythonClassTest extends PythonParserTest {
     @Before

2906517017bdb3e65b0000eb0f5b32c0f4233ab8
@@ -6,12 +6,9 @@ import static org.junit.Assert.assertNotNull;
 import java.io.IOException;
 
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
-import depends.entity.Entity;
 import depends.entity.FunctionEntity;
-import depends.extractor.pom.PomFileParser;
 
 public class PythonFunctionTest extends PythonParserTest {
     @Before

2906517017bdb3e65b0000eb0f5b32c0f4233ab8
@@ -1,8 +1,5 @@
 package depends.extractor.python;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
 import java.io.IOException;
 
 import org.junit.Before;
@@ -10,10 +7,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
-import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
-import depends.extractor.FileParser;
-import depends.extractor.pom.PomFileParser;
 import depends.util.FileUtil;
 
 public class PythonImportTest extends PythonParserTest {

3fbc714e2879967c93806f63b0d7a344ca60fb4f
@@ -48,9 +48,6 @@ public class PythonFileParser implements FileParser {
 	    walker.walk(bridge, parser.file_input());
 	    
 		fileEntity = entityRepo.getEntity(fileFullPath);
-		if (fileEntity.getRawName().contains("av_bench.py")) {
-			System.out.println("hlo");
-		}
 		fileEntity.inferEntities(inferer);
 	}
 

b499608b3494ccf7bf40fee3f24620f5aece9f29
@@ -29,7 +29,7 @@ import java.util.Collection;
 
 import depends.relations.Inferer;
 
-public class TypeEntity extends ContainerEntity{
+public class TypeEntity extends ContainerEntity {
 	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
 	Collection<TypeEntity> implementedTypes = new ArrayList<>();
 	Collection<String> inhertedTypeIdentifiers;
@@ -37,51 +37,75 @@ public class TypeEntity extends ContainerEntity{
 	TypeEntity inheritedType;
 
 	public TypeEntity(String simpleName, Entity parent, Integer id) {
-		super(simpleName,parent,id);
+		super(simpleName, parent, id);
 		inhertedTypeIdentifiers = new ArrayList<>();
 		implementedIdentifiers = new ArrayList<>();
 	}
+
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
-		inheritedTypes= new ArrayList<>();
-		identiferToEntities(inferer,this.inhertedTypeIdentifiers).forEach(item->inheritedTypes.add((TypeEntity)item));
+		inheritedTypes = new ArrayList<>();
+		identiferToEntities(inferer, this.inhertedTypeIdentifiers).forEach(item -> {
+			if (item instanceof TypeEntity) {
+				inheritedTypes.add((TypeEntity) item);
+			}else {
+				System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
+			}
+		});
 		inheritedTypes.remove(this);
 
-		implementedTypes= new ArrayList<>();
-		identiferToEntities(inferer,this.implementedIdentifiers).forEach(item->implementedTypes.add((TypeEntity)item));
+		implementedTypes = new ArrayList<>();
+		identiferToEntities(inferer, this.implementedIdentifiers)
+				.forEach(item -> {
+					if (item instanceof TypeEntity) {
+						implementedTypes.add((TypeEntity) item);
+					}else {
+						System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
+					}
+				});
 		implementedTypes.remove(this);
-		if (inheritedTypes.size()>0)
+		if (inheritedTypes.size() > 0)
 			inheritedType = inheritedTypes.iterator().next();
 		super.inferLocalLevelEntities(inferer);
 	}
+
 	public void addImplements(String typeName) {
-		if (typeName.equals(this.getRawName())) return;
-		if (implementedIdentifiers.contains(typeName)) return;
-		if (typeName.equals(this.rawName)) return;
+		if (typeName.equals(this.getRawName()))
+			return;
+		if (implementedIdentifiers.contains(typeName))
+			return;
+		if (typeName.equals(this.rawName))
+			return;
 		this.implementedIdentifiers.add(typeName);
 	}
+
 	public void addExtends(String typeName) {
-		if (typeName.equals(this.getRawName())) return;
-		if (inhertedTypeIdentifiers.contains(typeName)) return;
-		if (typeName.equals(this.rawName)) return;
+		if (typeName.equals(this.getRawName()))
+			return;
+		if (inhertedTypeIdentifiers.contains(typeName))
+			return;
+		if (typeName.equals(this.rawName))
+			return;
 		this.inhertedTypeIdentifiers.add(typeName);
 	}
+
 	public Collection<TypeEntity> getInheritedTypes() {
 		return inheritedTypes;
 	}
-	
+
 	public Collection<TypeEntity> getImplementedTypes() {
 		return implementedTypes;
 	}
-	
- 	public TypeEntity getInheritedType() {
+
+	public TypeEntity getInheritedType() {
 		return inheritedType;
 	}
- 	
- 	@Override
- 	public FunctionEntity lookupFunctionLocally(String functionName) {
+
+	@Override
+	public FunctionEntity lookupFunctionLocally(String functionName) {
 		FunctionEntity func = super.lookupFunctionLocally(functionName);
-		if (func!=null) return func;
+		if (func != null)
+			return func;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
 			func = inhertedType.lookupFunctionLocally(functionName);
 			if (func != null)
@@ -90,16 +114,18 @@ public class TypeEntity extends ContainerEntity{
 		if (func != null)
 			return func;
 		for (TypeEntity implType : getImplementedTypes()) {
-			func = implType.lookupFunctionLocally( functionName);
+			func = implType.lookupFunctionLocally(functionName);
 			if (func != null)
 				break;
 		}
 		return func;
- 	}
- 	@Override
- 	public VarEntity lookupVarLocally(String varName) {
- 		VarEntity var = super.lookupVarLocally(varName);
-		if (var!=null) return var;
+	}
+
+	@Override
+	public VarEntity lookupVarLocally(String varName) {
+		VarEntity var = super.lookupVarLocally(varName);
+		if (var != null)
+			return var;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
 			var = inhertedType.lookupVarLocally(varName);
 			if (var != null)
@@ -108,14 +134,15 @@ public class TypeEntity extends ContainerEntity{
 		if (var != null)
 			return var;
 		for (TypeEntity implType : getImplementedTypes()) {
-			var = implType.lookupVarLocally( varName);
+			var = implType.lookupVarLocally(varName);
 			if (var != null)
 				break;
 		}
 		return var;
 	}
- 	@Override
- 	public TypeEntity getType() {
+
+	@Override
+	public TypeEntity getType() {
 		return this;
 	}
 }

b499608b3494ccf7bf40fee3f24620f5aece9f29
@@ -130,6 +130,13 @@ public class JavaListener extends JavaParserBaseListener {
 		super.enterEnumDeclaration(ctx);
 	}
 
+	@Override
+	public void enterAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
+		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
+		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
+		super.enterAnnotationTypeDeclaration(ctx);
+	}
+	
 	@Override
 	public void exitEnumDeclaration(EnumDeclarationContext ctx) {
 		exitLastEntity();
@@ -163,12 +170,7 @@ public class JavaListener extends JavaParserBaseListener {
 		super.exitInterfaceDeclaration(ctx);
 	}
 
-	@Override
-	public void enterAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
-		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
-		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
-		super.enterAnnotationTypeDeclaration(ctx);
-	}
+
 
 	@Override
 	public void exitAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {

aa0fc62e76ec5dd6f801cf3b2b84524879c10365
@@ -111,7 +111,7 @@ public class FunctionEntity extends ContainerEntity{
 	@Override
 	public String getDisplayName() {
 		FileEntity f = (FileEntity) this.getAncestorOfType(FileEntity.class);
-		return f.getRawName()+"("+getRawName()+")";
+		return f.getRawName()+"("+this.getQualifiedName()+")";
 	}
 	@Override
 	public VarEntity lookupVarLocally(String varName) {

aa0fc62e76ec5dd6f801cf3b2b84524879c10365
@@ -92,19 +92,16 @@ public class RelationCounter {
 			if (expression.isCall) {
 				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
 			}
-			if (expression.isCreate) {
+			else if (expression.isCreate) {
 				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
 			}
-			if (expression.isThrow) {
+			else if (expression.isThrow) {
 				entity.addRelation(new Relation(DependencyType.THROW,referredEntity));
 			}
-			if (expression.isSet) { //SET is merged with USE
-				entity.addRelation(new Relation(DependencyType.USE,referredEntity));
-			}
-			if (expression.isCast) { 
+			else if (expression.isCast) { 
 				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
 			}
-			if (!expression.isCall && !expression.isCreate && !expression.isCast) {
+			else  {
 				usedEntities.add(expression.getReferredEntity());
 			}
 		}

f4c48c2854b43b3b3da8662775eedebf4e0705ec
@@ -27,6 +27,7 @@ package depends.extractor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Stack;
+import java.util.stream.Collectors;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
@@ -212,10 +213,8 @@ public abstract class HandlerContext {
 	}
 
 
-	public void foundVarDefinitions(List<String> varNames, String type, List<String> typeArguments) {
-		for (String varName : varNames) {
-			foundVarDefinition(varName,type,typeArguments);
-		}
+	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<String> typeArguments) {
+		return varNames.stream().map(item->foundVarDefinition(item,type,typeArguments)).collect(Collectors.toList());
 	}
 	
 	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
@@ -228,15 +227,19 @@ public abstract class HandlerContext {
 		if (var!=null) return var;
 		var = new VarEntity(varName, null, container, idGenerator.generateId());
 		container.addVar(var);
+		entityRepo.add(var);
+
 		return var;
 	}
 	
 
 
-	public void foundVarDefinition(String varName, String type, List<String> typeArguments) {
+	public VarEntity foundVarDefinition(String varName, String type, List<String> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
-		lastContainer().addVar(var);		
+		lastContainer().addVar(var);	
+		entityRepo.add(var);
+		return var;
 	}
 	
 	public void addMethodParameter(String paramName) {

f4c48c2854b43b3b3da8662775eedebf4e0705ec
@@ -28,6 +28,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.FunctionEntity;
+import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.java.context.AnnotationProcessor;
 import depends.extractor.java.context.ClassTypeContextHelper;
@@ -43,7 +44,9 @@ import depends.extractor.java.JavaParser.AnnotationConstantRestContext;
 import depends.extractor.java.JavaParser.AnnotationMethodRestContext;
 import depends.extractor.java.JavaParser.AnnotationTypeDeclarationContext;
 import depends.extractor.java.JavaParser.BlockContext;
+import depends.extractor.java.JavaParser.ClassBodyDeclarationContext;
 import depends.extractor.java.JavaParser.ClassDeclarationContext;
+import depends.extractor.java.JavaParser.ClassOrInterfaceModifierContext;
 import depends.extractor.java.JavaParser.ConstDeclarationContext;
 import depends.extractor.java.JavaParser.ConstructorDeclarationContext;
 import depends.extractor.java.JavaParser.EnhancedForControlContext;
@@ -52,12 +55,15 @@ import depends.extractor.java.JavaParser.EnumDeclarationContext;
 import depends.extractor.java.JavaParser.ExpressionContext;
 import depends.extractor.java.JavaParser.FieldDeclarationContext;
 import depends.extractor.java.JavaParser.ImportDeclarationContext;
+import depends.extractor.java.JavaParser.InterfaceBodyDeclarationContext;
 import depends.extractor.java.JavaParser.InterfaceDeclarationContext;
 import depends.extractor.java.JavaParser.InterfaceMethodDeclarationContext;
+import depends.extractor.java.JavaParser.InterfaceMethodModifierContext;
 import depends.extractor.java.JavaParser.LocalVariableDeclarationContext;
 import depends.extractor.java.JavaParser.MethodDeclarationContext;
 import depends.extractor.java.JavaParser.PackageDeclarationContext;
 import depends.extractor.java.JavaParser.ResourceContext;
+import depends.extractor.java.JavaParser.TypeDeclarationContext;
 import depends.extractor.java.JavaParser.TypeParameterContext;
 import depends.extractor.java.JavaParser.TypeParametersContext;
 import depends.extractor.java.JavaParserBaseListener;
@@ -71,7 +77,7 @@ public class JavaListener extends JavaParserBaseListener {
 	public JavaListener(String fileFullPath, EntityRepo entityRepo,Inferer inferer) {
 		this.context = new JavaHandlerContext(entityRepo,inferer);
 		this.entityRepo = entityRepo;
-		annotationProcessor = new AnnotationProcessor(context);
+		annotationProcessor = new AnnotationProcessor();
 		expressionUsage = new ExpressionUsage(context,entityRepo);
 		context.startFile(fileFullPath);
 	}
@@ -113,7 +119,7 @@ public class JavaListener extends JavaParserBaseListener {
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
 		}
-		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
+		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterClassDeclaration(ctx);
 	}
 
@@ -126,14 +132,14 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterEnumDeclaration(EnumDeclarationContext ctx) {
 		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
-		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
+		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterEnumDeclaration(ctx);
 	}
 
 	@Override
 	public void enterAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
 		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
-		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
+		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterAnnotationTypeDeclaration(ctx);
 	}
 	
@@ -160,7 +166,7 @@ public class JavaListener extends JavaParserBaseListener {
 				context.foundExtends(ClassTypeContextHelper.getClassName(ctx.typeList().typeType().get(i)));
 			}
 		}
-		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
+		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterInterfaceDeclaration(ctx);
 	}
 
@@ -191,7 +197,7 @@ public class JavaListener extends JavaParserBaseListener {
 			List<String> parameters = TypeParameterContextHelper.getTypeParameters(ctx.typeParameters());
 			method.addTypeParameter(parameters);
 		}
-		annotationProcessor.processAnnotationModifier(ctx, "classOrInterfaceModifier");
+		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterMethodDeclaration(ctx);
 	}
 
@@ -218,7 +224,7 @@ public class JavaListener extends JavaParserBaseListener {
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
 		}
-		annotationProcessor.processAnnotationModifier(ctx, "interfaceMethodModifier");
+		annotationProcessor.processAnnotationModifier(ctx, InterfaceBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterInterfaceMethodDeclaration(ctx);
 	}
 
@@ -235,7 +241,7 @@ public class JavaListener extends JavaParserBaseListener {
 				throwedType);
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		method.addReturnType(context.currentType());
-		annotationProcessor.processAnnotationModifier(ctx, "classBodyDeclaration");
+		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterConstructorDeclaration(ctx);
 	}
 
@@ -252,17 +258,19 @@ public class JavaListener extends JavaParserBaseListener {
 		List<String> varNames = VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators());
 		String type = ClassTypeContextHelper.getClassName(ctx.typeType());
 		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinitions(varNames, type,typeArguments);
-		annotationProcessor.processAnnotationModifier(ctx, "classBodyDeclaration");
+		List<VarEntity> vars = context.foundVarDefinitions(varNames, type,typeArguments);
+		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterFieldDeclaration(ctx);
 	}
+	
+
 
 	@Override
 	public void enterConstDeclaration(ConstDeclarationContext ctx) {
 		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
+		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
-		annotationProcessor.processAnnotationModifier(ctx, "interfaceBodyDeclaration");
+		annotationProcessor.processAnnotationModifier(ctx, InterfaceBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterConstDeclaration(ctx);
 	}
 

f4c48c2854b43b3b3da8662775eedebf4e0705ec
@@ -24,71 +24,97 @@ SOFTWARE.
 
 package depends.extractor.java.context;
 
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
+import java.util.stream.Collectors;
 
 import org.antlr.v4.runtime.RuleContext;
+import org.codehaus.plexus.util.StringUtils;
 
-import depends.extractor.HandlerContext;
+import depends.entity.ContainerEntity;
 import depends.extractor.java.JavaParser.AnnotationContext;
 
 public class AnnotationProcessor {
-	private HandlerContext context;
 
-	public AnnotationProcessor(HandlerContext context) {
-		this.context = context;
+	public AnnotationProcessor() {
 	}
-	/**
-	 * for any elements who with modifiers like 'public/static/... @Annotation‘，
-	 * process annotations as "USE"
-	 * 
-	 * @param ctx
-	 * @param class1
-	 */
-	
-	private boolean containsMethod(RuleContext ctx,String methodName) {
-		try {
-			Method m = ctx.getClass().getMethod(methodName);
-			if (m!=null) return true;
-		} catch (Exception e) {
-			return false;
-		}
-		return true;
-	}
-	private Method getMethod(RuleContext ctx, String methodName) {
-		try {
-			Method m = ctx.getClass().getMethod(methodName);
-			if (m!=null) return m;
-		} catch (Exception e) {
-			return null;
-		}
-		return null;	
+
+	public void processAnnotationModifier(RuleContext ctx, Class rootClass,
+		String toAnnotationPath,ContainerEntity container) {
+		List<ContainerEntity> list  = new ArrayList<>() ;
+		list.add(container);
+		processAnnotationModifier(ctx, rootClass,
+				toAnnotationPath, list);
 	}
 	
-	public void processAnnotationModifier(RuleContext ctx, String methodName) {
+	public void processAnnotationModifier(RuleContext ctx, Class rootClass,
+			String toAnnotationPath, List<?> containers) {
+
 		while (true) {
 			if (ctx == null)
 				break;
-			if (containsMethod(ctx,methodName))
+			if (ctx.getClass().equals(rootClass))
 				break;
 			ctx = ctx.parent;
 		}
-		if (ctx==null)return;
-			
-		Method m = getMethod(ctx,methodName);
-		if (m==null) return;
+		if (ctx == null)
+			return;
+
+
 		try {
-			List<?> modifiers = (List<?>) m.invoke(ctx);
-			for (Object modifier : modifiers) {
-				Method annotationMethod = modifier.getClass().getMethod("annotation");
-				AnnotationContext annotation = (AnnotationContext) (annotationMethod.invoke(modifier));
-				if (annotation == null)
+			Object r = ctx;
+			String[] paths = toAnnotationPath.split("\\.");
+			for (String path : paths) {
+				r = invokeMethod(r, path);
+				if (r == null)
 					return;
+			}
+			Collection<AnnotationContext> contexts = new HashSet<>();
+			mergeElements(contexts, r);
+			for (Object item : contexts) {
+				AnnotationContext annotation = (AnnotationContext) item;
 				String name = QualitiedNameContextHelper.getName(annotation.qualifiedName());
-				context.foundAnnotation(name);
+				containers.stream().forEach(container->((ContainerEntity)container).addAnnotation(name));
 			}
 		} catch (Exception e) {
 			return;
 		}
 	}
+	
+
+	private void mergeElements(Collection<AnnotationContext> collection, Object r) {
+		if (r instanceof Collection) {
+			for (Object item : (Collection<?>) r) {
+				mergeElements(collection, item);
+			}
+		} else {
+			if (r instanceof AnnotationContext)
+				collection.add((AnnotationContext) r);
+		}
+	}
+
+	private Object invokeMethod(Object r, String path) {
+		if (StringUtils.isEmpty(path))
+			return null;
+		if (r instanceof Collection) {
+			Collection<?> list = (Collection<?>) r;
+			return list.stream().map(item -> invokeMethod(item, path)).filter(item -> item != null)
+					.collect(Collectors.toSet());
+		}
+		try {
+			Method m = r.getClass().getMethod(path);
+			return m.invoke(r);
+		} catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException
+				| InvocationTargetException e) {
+			return null;
+		}
+	}
+
+
+
+
 }

f4c48c2854b43b3b3da8662775eedebf4e0705ec
@@ -12,6 +12,16 @@ import depends.entity.VarEntity;
 import depends.relations.Relation;
 
 public abstract class ParserTest {
+	protected void assertNotContainsRelation(Entity inEntity, String dependencyType, String dependedEntityFullName) {
+		for (Relation r:inEntity.getRelations()) {
+			if (r.getType().equals(dependencyType)) {
+				if (r.getEntity().getQualifiedName().equals(dependedEntityFullName)) {
+					fail("found unexpected relation: type = " + dependencyType + " to entity " + dependedEntityFullName);
+				}
+			}
+		}
+	}
+	
 	protected void assertContainsRelation(Entity inEntity, String dependencyType, String dependedEntityFullName) {
 		Relation relation = null;
 		for (Relation r:inEntity.getRelations()) {

f4c48c2854b43b3b3da8662775eedebf4e0705ec
@@ -7,18 +7,77 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
+
+/*
+ * classOrInterfaceModifier
+interfaceMethodModifier
+
+packageDeclaration
+
+variableModifier
+typeParameter
+enumConstant
+interfaceMethodDeclaration
+
+elementValue
+classType
+typeType
+
+ */
 public class JavaAnnotationParserTest extends JavaParserTest {
 	@Before
 	public void setUp() {
 		super.init();
 	}
 	@Test
-	public void test_annotationType() throws IOException {
+	public void test_could_parse_annotationType() throws IOException {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
         JavaFileParser parser =createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("AnnotationTest.value").getRelations().size());
 	}
+	
+	@Test
+	public void test_could_detect_annotation_in_class_level() throws IOException {
+        String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
+        JavaFileParser parser =createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(entityRepo.getEntity("TheClass"), DependencyType.ANNOTATION, "AnnotationTest");
+	}
+	
+	@Test
+	public void test_could_detect_annotation_in_function_level() throws IOException {
+        String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
+        JavaFileParser parser =createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(entityRepo.getEntity("TheFunction.foo"), DependencyType.ANNOTATION, "AnnotationTest");
+	}
+	
+	@Test
+	public void test_could_detect_no_annotation_in_function_level() throws IOException {
+        String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
+        JavaFileParser parser =createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertNotContainsRelation(entityRepo.getEntity("TheFunction.bar"), DependencyType.ANNOTATION, "AnnotationTest");
+	}
+
+	@Test
+	public void test_could_detect_annotation_in_miscs() throws IOException {
+        String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
+        JavaFileParser parser =createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(entityRepo.getEntity("TheClass.TheClass"), DependencyType.ANNOTATION, "AnnotationTest");
+        this.assertContainsRelation(entityRepo.getEntity("TheEnum"), DependencyType.ANNOTATION, "AnnotationTest");
+        this.assertContainsRelation(entityRepo.getEntity("TheInterface.foo"), DependencyType.ANNOTATION, "AnnotationTest");
+        this.assertContainsRelation(entityRepo.getEntity("TheInterface.theConst"), DependencyType.ANNOTATION, "AnnotationTest");
+        this.assertContainsRelation(entityRepo.getEntity("TheClass.theField"), DependencyType.ANNOTATION, "AnnotationTest");
+	}
+	
 
 }

f4c48c2854b43b3b3da8662775eedebf4e0705ec
@@ -1,12 +1,13 @@
 package depends.extractor.java;
 
 import depends.entity.repo.EntityRepo;
+import depends.extractor.ParserTest;
 import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaFileParser;
 import depends.extractor.java.JavaImportLookupStrategy;
 import depends.relations.Inferer;
 
-public abstract class JavaParserTest {
+public abstract class JavaParserTest  extends ParserTest{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
 

e70523571dbd04f8db9ee2e4fe3b8d56eaf4d3d8
@@ -89,19 +89,24 @@ public class RelationCounter {
 			if (referredEntity==null) {
 				continue;
 			}
+			boolean matched = false;
 			if (expression.isCall) {
 				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
+				matched = true;
 			}
-			else if (expression.isCreate) {
+			if (expression.isCreate) {
 				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
+				matched = true;
 			}
-			else if (expression.isThrow) {
+			if (expression.isThrow) {
 				entity.addRelation(new Relation(DependencyType.THROW,referredEntity));
+				matched = true;
 			}
-			else if (expression.isCast) { 
+			if (expression.isCast) { 
 				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
+				matched = true;
 			}
-			else  {
+			if (!matched)  {
 				usedEntities.add(expression.getReferredEntity());
 			}
 		}

e70523571dbd04f8db9ee2e4fe3b8d56eaf4d3d8
@@ -1,11 +1,12 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
 import java.io.IOException;
 
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+
 public class CppExpressionTest extends CppParserTest{
     @Before
     public void setUp() {
@@ -18,7 +19,16 @@ public class CppExpressionTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(21,repo.getEntity("foo").getRelations().size());
+        Entity e = repo.getEntity("foo");
+        this.assertContainsRelation(e, DependencyType.PARAMETER,"ClassA");
+        this.assertContainsRelation(e, DependencyType.CONTAIN,"ClassA");
+        this.assertContainsRelation(e, DependencyType.CAST,"ClassA");
+        this.assertContainsRelation(e, DependencyType.CALL,"ClassA");
+        this.assertContainsRelation(e, DependencyType.CREATE,"ClassA");
+        this.assertContainsRelation(e, DependencyType.USE,"ClassA");
+        this.assertContainsRelation(e, DependencyType.USE,"foo.a2");
+        this.assertContainsRelation(e, DependencyType.USE,"foo.a3");
+        this.assertContainsRelation(e, DependencyType.USE,"foo.a");        
 	}
 
 }

e70523571dbd04f8db9ee2e4fe3b8d56eaf4d3d8
@@ -3,11 +3,12 @@ package depends.extractor.cpp;
 import java.util.ArrayList;
 
 import depends.entity.repo.EntityRepo;
+import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
 import depends.relations.Inferer;
 
-public abstract class CppParserTest {
+public abstract class CppParserTest extends ParserTest{
 	protected EntityRepo repo;
 	protected Inferer inferer;
     protected PreprocessorHandler preprocessorHandler;

e70523571dbd04f8db9ee2e4fe3b8d56eaf4d3d8
@@ -7,6 +7,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
@@ -45,7 +46,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         parser.parse();
         inferer.resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
-        assertEquals(18,e.getRelations().size());
+        this.assertContainsRelation(e, DependencyType.CONTAIN, "MyInteger");
 	}
 	
 	@Test
@@ -54,7 +55,18 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(23,entityRepo.getEntity("test.ComplexExpressionExample.setExample").getRelations().size());
+        Entity e = entityRepo.getEntity("test.ComplexExpressionExample.setExample");
+        this.assertContainsRelation(e, DependencyType.PARAMETER, "test.ClassA");
+        this.assertContainsRelation(e, DependencyType.CREATE, "test.ClassA");
+        this.assertContainsRelation(e, DependencyType.CALL, "test.ClassA");
+        this.assertContainsRelation(e, DependencyType.CAST, "test.ClassA");
+        this.assertContainsRelation(e, DependencyType.CALL, "test.ClassA.foo");
+        this.assertContainsRelation(e, DependencyType.CALL, "test.ClassA");
+        this.assertContainsRelation(e, DependencyType.USE, "test.ComplexExpressionExample.setExample.a3");
+        this.assertContainsRelation(e, DependencyType.USE, "test.ClassX.m");
+        this.assertContainsRelation(e, DependencyType.USE, "test.ComplexExpressionExample.setExample.a2");
+        this.assertContainsRelation(e, DependencyType.USE, "test.ClassA.x");
+        this.assertContainsRelation(e, DependencyType.USE, "test.ComplexExpressionExample.setExample.a");
 	}
 	
 	@Test

e70523571dbd04f8db9ee2e4fe3b8d56eaf4d3d8
@@ -18,4 +18,5 @@ public class ComplexExpressionExample {
 		ClassA a3[] = new ClassA[10];          //def a3(1)
 		a3[1].x.m = 3; //still lack 1          //set a3,t(2)
 	}
-}
\ No newline at end of file
+}
+

0088f1c359f852bd5d383395ca887338b0402fae
@@ -70,6 +70,9 @@ public class TypeEntity extends ContainerEntity {
 	}
 
 	public void addImplements(String typeName) {
+		if (typeName==null) {
+			return;
+		}
 		if (typeName.equals(this.getRawName()))
 			return;
 		if (implementedIdentifiers.contains(typeName))
@@ -80,6 +83,9 @@ public class TypeEntity extends ContainerEntity {
 	}
 
 	public void addExtends(String typeName) {
+		if (typeName==null) {
+			return;
+		}
 		if (typeName.equals(this.getRawName()))
 			return;
 		if (inhertedTypeIdentifiers.contains(typeName))
@@ -103,38 +109,52 @@ public class TypeEntity extends ContainerEntity {
 
 	@Override
 	public FunctionEntity lookupFunctionLocally(String functionName) {
+		Collection<TypeEntity> searchedTypes = new ArrayList<>();
+		return lookupFunctionLocally(functionName,searchedTypes);
+	}
+
+	private FunctionEntity lookupFunctionLocally(String functionName, Collection<TypeEntity> searched) {
+		if (searched.contains(this)) return null;
+		searched.add(this);
 		FunctionEntity func = super.lookupFunctionLocally(functionName);
 		if (func != null)
 			return func;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
-			func = inhertedType.lookupFunctionLocally(functionName);
+			func = inhertedType.lookupFunctionLocally(functionName, searched);
 			if (func != null)
 				break;
 		}
 		if (func != null)
 			return func;
 		for (TypeEntity implType : getImplementedTypes()) {
-			func = implType.lookupFunctionLocally(functionName);
+			func = implType.lookupFunctionLocally(functionName,searched);
 			if (func != null)
 				break;
 		}
 		return func;
 	}
-
+	
 	@Override
 	public VarEntity lookupVarLocally(String varName) {
+		Collection<TypeEntity> searchedTypes = new ArrayList<>();
+		return lookupVarLocally(varName,searchedTypes);
+	}
+	
+	private VarEntity lookupVarLocally(String varName, Collection<TypeEntity> searched) {
+		if (searched.contains(this)) return null;
+		searched.add(this);
 		VarEntity var = super.lookupVarLocally(varName);
 		if (var != null)
 			return var;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
-			var = inhertedType.lookupVarLocally(varName);
+			var = inhertedType.lookupVarLocally(varName,searched);
 			if (var != null)
 				break;
 		}
 		if (var != null)
 			return var;
 		for (TypeEntity implType : getImplementedTypes()) {
-			var = implType.lookupVarLocally(varName);
+			var = implType.lookupVarLocally(varName,searched);
 			if (var != null)
 				break;
 		}

0088f1c359f852bd5d383395ca887338b0402fae
@@ -24,9 +24,9 @@ SOFTWARE.
 
 package depends.entity.repo;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.List;
 
 import depends.entity.Entity;
@@ -35,7 +35,7 @@ import depends.entity.MultiDeclareEntities;
 public class EntityRepo extends IdGenerator{
 	private HashMap<String, Entity> allEntieisByName = new HashMap<>();
 	private HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
-	private List<Entity> allEntitiesByOrder = new ArrayList<>();
+	private List<Entity> allEntitiesByOrder = new LinkedList<>();
 	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
 	public EntityRepo() {

0088f1c359f852bd5d383395ca887338b0402fae
@@ -30,23 +30,12 @@ import java.util.List;
 import depends.entity.FunctionEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
-import depends.extractor.java.context.AnnotationProcessor;
-import depends.extractor.java.context.ClassTypeContextHelper;
-import depends.extractor.java.context.ExpressionUsage;
-import depends.extractor.java.context.FormalParameterListContextHelper;
-import depends.extractor.java.context.IdentifierContextHelper;
-import depends.extractor.java.context.QualitiedNameContextHelper;
-import depends.extractor.java.context.TypeParameterContextHelper;
-import depends.extractor.java.context.VariableDeclaratorsContextHelper;
-import depends.importtypes.ExactMatchImport;
-import depends.relations.Inferer;
 import depends.extractor.java.JavaParser.AnnotationConstantRestContext;
 import depends.extractor.java.JavaParser.AnnotationMethodRestContext;
 import depends.extractor.java.JavaParser.AnnotationTypeDeclarationContext;
 import depends.extractor.java.JavaParser.BlockContext;
 import depends.extractor.java.JavaParser.ClassBodyDeclarationContext;
 import depends.extractor.java.JavaParser.ClassDeclarationContext;
-import depends.extractor.java.JavaParser.ClassOrInterfaceModifierContext;
 import depends.extractor.java.JavaParser.ConstDeclarationContext;
 import depends.extractor.java.JavaParser.ConstructorDeclarationContext;
 import depends.extractor.java.JavaParser.EnhancedForControlContext;
@@ -58,7 +47,6 @@ import depends.extractor.java.JavaParser.ImportDeclarationContext;
 import depends.extractor.java.JavaParser.InterfaceBodyDeclarationContext;
 import depends.extractor.java.JavaParser.InterfaceDeclarationContext;
 import depends.extractor.java.JavaParser.InterfaceMethodDeclarationContext;
-import depends.extractor.java.JavaParser.InterfaceMethodModifierContext;
 import depends.extractor.java.JavaParser.LocalVariableDeclarationContext;
 import depends.extractor.java.JavaParser.MethodDeclarationContext;
 import depends.extractor.java.JavaParser.PackageDeclarationContext;
@@ -66,7 +54,16 @@ import depends.extractor.java.JavaParser.ResourceContext;
 import depends.extractor.java.JavaParser.TypeDeclarationContext;
 import depends.extractor.java.JavaParser.TypeParameterContext;
 import depends.extractor.java.JavaParser.TypeParametersContext;
-import depends.extractor.java.JavaParserBaseListener;
+import depends.extractor.java.context.AnnotationProcessor;
+import depends.extractor.java.context.ClassTypeContextHelper;
+import depends.extractor.java.context.ExpressionUsage;
+import depends.extractor.java.context.FormalParameterListContextHelper;
+import depends.extractor.java.context.IdentifierContextHelper;
+import depends.extractor.java.context.QualitiedNameContextHelper;
+import depends.extractor.java.context.TypeParameterContextHelper;
+import depends.extractor.java.context.VariableDeclaratorsContextHelper;
+import depends.importtypes.ExactMatchImport;
+import depends.relations.Inferer;
 
 public class JavaListener extends JavaParserBaseListener {
 	private JavaHandlerContext context;
@@ -104,6 +101,7 @@ public class JavaListener extends JavaParserBaseListener {
 	/////////////////////// annotationTypeDeclaration
 	@Override
 	public void enterClassDeclaration(ClassDeclarationContext ctx) {
+		if (ctx.IDENTIFIER()==null) return;
 		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
 		// implements
 		if (ctx.typeList() != null) {

0088f1c359f852bd5d383395ca887338b0402fae
@@ -46,8 +46,11 @@ public class ExpressionUsage {
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());
 		context.lastContainer().addExpression(ctx,expression);
-
-		expression.text = ctx.getText(); //for debug purpose. no actual effect
+//		try {
+//			expression.text = ctx.getText(); //for debug purpose. no actual effect
+//		}catch (Exception e) {
+//			expression.text = "error during getText";
+//		}
 		expression.parent = parent;
 		if (expression.parent!=null) {
 			if (expression.parent.deduceTypeBasedId==null) 

0088f1c359f852bd5d383395ca887338b0402fae
@@ -0,0 +1,30 @@
+package depends.extractor.cpp;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.extractor.cpp.cdt.CdtCppFileParser;
+
+public class TypeDefTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void test_ref_parameter() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/TypeDefTest.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("foo"), DependencyType.PARAMETER, "MyInt");
+	}
+			
+}
\ No newline at end of file

0088f1c359f852bd5d383395ca887338b0402fae
@@ -9,22 +9,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 
-/*
- * classOrInterfaceModifier
-interfaceMethodModifier
-
-packageDeclaration
-
-variableModifier
-typeParameter
-enumConstant
-interfaceMethodDeclaration
-
-elementValue
-classType
-typeType
-
- */
 public class JavaAnnotationParserTest extends JavaParserTest {
 	@Before
 	public void setUp() {

0088f1c359f852bd5d383395ca887338b0402fae
@@ -0,0 +1,25 @@
+package depends.extractor.java;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+
+public class JavaCylicInheritTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test(timeout=3000L)
+	public void test_cyclic_should_not_occur_inifinite_test() throws IOException {
+        String src = "./src/test/resources/java-code-examples/CyclicInherit.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+	}
+	
+	
+}

0088f1c359f852bd5d383395ca887338b0402fae
@@ -0,0 +1,35 @@
+package depends.extractor.java;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+
+public class JavaParseErrorFileTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_incomplete_file_should_not_stop_process() throws IOException {
+        String src = "./src/test/resources/java-code-examples/IncompleteFile.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        Entity classEntity = entityRepo.getEntity("FieldVar");
+	}
+	
+	@Test
+	public void test_should_resolve_types() throws IOException {
+        String src = "./src/test/resources/java-code-examples/EclipseTestBase_No_ResponseDuirngTypeResolve.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        Entity classEntity = entityRepo.getEntity("FieldVar");
+	}
+	
+	
+}

c06448455579ac860e3231c8340714e9fb1d011e
@@ -2,6 +2,7 @@ package depends.extractor.cpp;
 import java.io.IOException;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
@@ -13,7 +14,7 @@ public class TypeDefTest extends CppParserTest{
     	super.init();
     }
 	
-	@Test
+	@Ignore
 	public void test_ref_parameter() throws IOException {
 	    String[] srcs = new String[] {
 	    		"./src/test/resources/cpp-code-examples/TypeDefTest.cpp",

0aa68e1b303d8ecfaa9d070aef5f9edc02a773cc
@@ -27,6 +27,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -165,6 +166,10 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 	}
 
+	public void cleanExpression() {
+		this.expressions = null;
+	}
+
 	public TypeEntity getLastExpressionType() {
 		for (int i=this.expressionList.size()-1;i>=0;i--) {
 			Expression expr= this.expressionList.get(i);
@@ -285,4 +290,14 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public Collection<ContainerEntity> getResolvedMixins() {
 		return resolvedMixins;
 	}
+
+
+
+	public List<Expression> expressionList() {
+		return expressionList;
+	}
+
+
+
+	
 }

0aa68e1b303d8ecfaa9d070aef5f9edc02a773cc
@@ -45,6 +45,7 @@ public abstract class Entity {
 	private MultiDeclareEntities mutliDeclare = null;
 	private List<Entity> children = new ArrayList<>();
     ArrayList<Relation> relations = new ArrayList<>();
+	private Entity actualReferTo = null;
 
 	
     public Entity(String rawName, Entity parent, Integer id) {
@@ -181,4 +182,15 @@ public abstract class Entity {
 	public void setMutliDeclare(MultiDeclareEntities mutliDeclare) {
 		this.mutliDeclare = mutliDeclare;
 	}
+
+	public Entity getActualReferTo() {
+		if (this.actualReferTo ==null)
+			return this;
+		return actualReferTo;
+	}
+	
+	public void setActualReferTo(Entity actualReferTo) {
+		this.actualReferTo = actualReferTo;
+	}
+
 }

0aa68e1b303d8ecfaa9d070aef5f9edc02a773cc
@@ -62,6 +62,7 @@ public class VarEntity extends ContainerEntity {
 		super.inferLocalLevelEntities(inferer);
 		Entity entity = inferer.resolveName(this, rawType, true);
 		if (entity==null) return;
+		this.setActualReferTo(entity);
 		type = entity.getType();
 		if (type==null) {
 			if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {

0aa68e1b303d8ecfaa9d070aef5f9edc02a773cc
@@ -261,6 +261,11 @@ public abstract class HandlerContext {
 	
 	
 	public void exitLastedEntity() {
+		Entity e = entityStack.peek();
+		if (e instanceof ContainerEntity) {
+			ContainerEntity container = (ContainerEntity)e;
+			container.cleanExpression();
+		}
 		entityStack.pop();
 	}
 	

0aa68e1b303d8ecfaa9d070aef5f9edc02a773cc
@@ -81,7 +81,7 @@ public class RelationCounter {
 		}
 		
 		HashSet<Entity> usedEntities = new HashSet<>();
-		for (Expression expression:entity.expressions().values()){
+		for (Expression expression:entity.expressionList()){
 			if (expression.isStatement) {
 				continue;
 			}
@@ -127,11 +127,11 @@ public class RelationCounter {
 
 	private void computeFunctionRelations(FunctionEntity func) {
 		for (Entity returnType:func.getReturnTypes()) {
-			func.addRelation(new Relation(DependencyType.RETURN,returnType));
+			func.addRelation(new Relation(DependencyType.RETURN,returnType.getActualReferTo()));
 		}
 		for (VarEntity parameter:func.getParameters()) {
 			if (parameter.getType()!=null) 
-				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getType()));
+				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getActualReferTo()));
 		}
 		for (Entity throwType:func.getThrowTypes()) {
 			func.addRelation(new Relation(DependencyType.THROW,throwType));

0aa68e1b303d8ecfaa9d070aef5f9edc02a773cc
@@ -14,7 +14,7 @@ public class TypeDefTest extends CppParserTest{
     	super.init();
     }
 	
-	@Ignore
+	@Test
 	public void test_ref_parameter() throws IOException {
 	    String[] srcs = new String[] {
 	    		"./src/test/resources/cpp-code-examples/TypeDefTest.cpp",

36da25ae72f6da4e0d352eb0c2f2c94453f1f1fe
@@ -60,7 +60,7 @@ public class IncludeRelationTest extends CppParserTest{
 	@Test
 	public void test_type_t_should_be_treat_as_structure() throws IOException {
 	    String[] srcs = new String[] {
-	    		"./src/test/resources/cpp-code-examples/typedefTest.cpp",
+	    		"./src/test/resources/cpp-code-examples/typedeftest2.cpp",
 	    	    };
 	    
 	    for (String src:srcs) {

c671159811f1b49cde87b2cd17a21b94a79d589b
@@ -51,7 +51,7 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#]")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
     private String namePathPattern="default";

5ece4e7c6b382d64750e632187291e71fdce43b4
@@ -118,4 +118,20 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(file, DependencyType.CALL,"foo");
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
+	
+	@Test
+	public void should_parse_import_with_prefix_dots() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_with_dir/importing.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
 }

0a1aba7f2ba19937fb75cd8aa93295091a277d3c
@@ -108,5 +108,9 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
 		return getImportedRelationEntities(importedList,repo);
 	}
-
+	
+	@Override
+	public boolean supportGlobalNameLookup() {
+		return false;
+	}
 }

0a1aba7f2ba19937fb75cd8aa93295091a277d3c
@@ -55,5 +55,8 @@ public class EmptyImportLookupStategy implements ImportLookupStrategy {
 	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
 		return new ArrayList<Entity>();
 	}
-
+	@Override
+	public boolean supportGlobalNameLookup() {
+		return false;
+	}
 }

0a1aba7f2ba19937fb75cd8aa93295091a277d3c
@@ -74,5 +74,9 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	}
 
 
+	@Override
+	public boolean supportGlobalNameLookup() {
+		return true;
+	}
 
 }

0a1aba7f2ba19937fb75cd8aa93295091a277d3c
@@ -9,6 +9,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.entity.AliasEntity;
 import depends.extractor.cpp.CppFileParser;
 
@@ -71,4 +72,21 @@ public class IncludeRelationTest extends CppParserTest{
         assertEquals("abc",((AliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName());
         
 	}
+	
+	@Test
+	public void test_call_should_only_in_relations_with_include() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/includeTest2/f0.cpp",
+	    		"./src/test/resources/cpp-code-examples/includeTest2/f_with_include.cpp",
+	    		"./src/test/resources/cpp-code-examples/includeTest2/f_without_include.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(this.repo.getEntity("foo"), DependencyType.CALL, "bar");
+	    this.assertNotContainsRelation(this.repo.getEntity("foo2"), DependencyType.CALL, "bar");
+	}
 }

e354996c47c39d7a72a036561d311a06cb6d8b39
@@ -43,4 +43,9 @@ public class PomImportLookupStategy extends EmptyImportLookupStategy  {
 		}
 		return result;
 	}
+	
+	@Override
+	public boolean supportGlobalNameLookup() {
+		return true;
+	}
 }

0a3c4e42401c04db8f657f9bd670741b5bfff1a9
@@ -124,6 +124,7 @@ public class PythonImportTest extends PythonParserTest {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/python-code-examples/import_with_dir/importing.py",
 	    		"./src/test/resources/python-code-examples/import_with_dir/imported_a.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing.py",
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -131,7 +132,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 }

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -267,8 +267,11 @@ public class CandidateTypes extends TypeEntity {
 
 	@Override
 	public Collection<Entity> getChildren() {
-		System.err.println("error: getChildren should not been invoked");
-		return super.getChildren();
+		List<Entity> children = new ArrayList<>();
+		for (Entity entity:this.candidateTypes) {
+			children.addAll(entity.getChildren());
+		}
+		return children;
 	}
 
 	@Override

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -178,6 +178,15 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 		return null;
 	}
+	
+	public List<Expression> expressionList() {
+		return expressionList;
+	}
+
+	public boolean containsExpression() {
+		return expressions.size()>0;
+	}
+
 
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();
@@ -293,9 +302,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 
 
-	public List<Expression> expressionList() {
-		return expressionList;
-	}
 
 
 

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -26,7 +26,9 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import depends.relations.Inferer;
 import depends.relations.Relation;
@@ -43,7 +45,7 @@ public abstract class Entity {
 	String rawName = "";
 	Entity parent;
 	private MultiDeclareEntities mutliDeclare = null;
-	private List<Entity> children = new ArrayList<>();
+	private Set<Entity> children = new HashSet<>();
     ArrayList<Relation> relations = new ArrayList<>();
 	private Entity actualReferTo = null;
 

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -56,6 +56,9 @@ public class Expression {
 	}
 
 	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
+		if (type instanceof CandidateTypes) {
+			return ;
+		}
 		boolean changedType = false;
 		if (this.type==null && type!=null) {
 			this.type = type;

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -242,10 +242,11 @@ public abstract class HandlerContext {
 		return var;
 	}
 	
-	public void addMethodParameter(String paramName) {
-		if (currentFunction()==null) return;
+	public VarEntity addMethodParameter(String paramName) {
+		if (currentFunction()==null) return null;
 		VarEntity varEntity = new VarEntity(paramName,null,currentFunction(),idGenerator.generateId());
-		currentFunction().addParameter(varEntity);		
+		currentFunction().addParameter(varEntity);
+		return varEntity;
 	}
 
 	public void foundEnumConstDefinition(String varName) {

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -8,6 +8,7 @@ import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.python.Python3Parser.AtomContext;
@@ -15,6 +16,8 @@ import depends.extractor.python.Python3Parser.Atom_exprContext;
 import depends.extractor.python.Python3Parser.Expr_stmtContext;
 import depends.extractor.python.Python3Parser.Raise_stmtContext;
 import depends.extractor.python.Python3Parser.Return_stmtContext;
+import depends.extractor.python.Python3Parser.SuiteContext;
+import depends.extractor.python.Python3Parser.TestContext;
 import depends.relations.Inferer;
 
 public class ExpressionUsage {
@@ -30,6 +33,11 @@ public class ExpressionUsage {
 	}
 	
 	public Expression foundExpression(ParserRuleContext ctx) {
+		if (!context.lastContainer().containsExpression()){
+			if (!isStartOfContainerRule(ctx)) {
+				return null;
+			}
+		}
 		Expression expression = findExpression(ctx);
 		if (expression!=null) return expression;
 		Expression parent = findParentInStack(ctx);
@@ -79,11 +87,26 @@ public class ExpressionUsage {
 			if (expr.func_call()!=null) {
 				//TODO: should be refined later. Currently only a.b.c could be solved.
 				expression.identifier = expr.atom_expr().getText();
-				Entity entity = context.foundEntityWithName(expression.identifier);
-				if (entity instanceof FunctionEntity) {
-					expression.isCall = true;
-				}else {
-					expression.isCreate = true;
+				String callPrefix = expr.atom_expr().getText();
+				//call with variables
+				if (callPrefix.contains(".")) {
+					int pos = callPrefix.lastIndexOf('.');
+					String functionName = callPrefix.substring(pos+1);
+					String preFix = callPrefix.substring(0,pos);
+					Entity prefixEntity = context.foundEntityWithName(preFix);
+					if (prefixEntity instanceof VarEntity) {
+						((VarEntity)prefixEntity).addFunctionCall(functionName);
+						expression.isCall = true;
+					}
+				}
+				if (!expression.isCall) {
+					Entity typeEntity = context.foundEntityWithName(expression.identifier);
+					if (typeEntity instanceof TypeEntity &&
+							typeEntity.getId()>0) {
+						expression.isCreate = true;
+					}else {
+						expression.isCall = true;
+					}
 				}
 			}
 			else if (expr.member_access()!=null) {
@@ -101,6 +124,17 @@ public class ExpressionUsage {
 		return expression;
 	}
 
+	/**
+	 * To judge whether is an 'real' expression 
+	 * @param ctx
+	 * @return
+	 */
+	private boolean isStartOfContainerRule(ParserRuleContext ctx) {
+		return ctx instanceof SuiteContext ||
+				ctx instanceof TestContext ||
+				ctx instanceof Expr_stmtContext;
+	}
+
 
 	/**
 	 * Auto deduce variable type from assignment.

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -125,6 +125,7 @@ public class PythonImportTest extends PythonParserTest {
 	    		"./src/test/resources/python-code-examples/import_with_dir/importing.py",
 	    		"./src/test/resources/python-code-examples/import_with_dir/imported_a.py",
 	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing2.py",
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -134,5 +135,6 @@ public class PythonImportTest extends PythonParserTest {
 	    inferer.resolveAllBindings();
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[3])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 }

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -0,0 +1,41 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.CandidateTypes;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+
+public class PythonParameterTypeDedudceTest extends PythonParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_deduce_type_of_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/deducetype_parameter.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(repo.getEntity("test"));
+	    VarEntity var = function.lookupVarLocally("t1");
+	    TypeEntity type = var.getType();
+	    assertTrue(type instanceof CandidateTypes);
+	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
+	}
+}
+

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -0,0 +1,40 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.CandidateTypes;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+
+public class SelfShouldBeThisTypeTest extends PythonParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_deduce_type_of_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/self_should_be_this_type.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(repo.getEntity("A.foo"));
+	    VarEntity var = function.lookupVarLocally("self");
+	    TypeEntity type = var.getType();
+	    assertTrue(type.getQualifiedName().equals("A"));
+	}
+}
+

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -0,0 +1,40 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.CandidateTypes;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+
+public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_relations_of_sampe_package() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/a.py",
+	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/b.py"
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(repo.getEntity("bar"));
+	    this.assertContainsRelation(function, DependencyType.CALL, "foo");
+	}
+}
+

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -28,7 +28,7 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity("Foo"));
+        assertNotNull(repo.getEntity(withPackageName(srcs[0],"Foo")));
 	}
 	
 	@Test
@@ -42,7 +42,7 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity("Foo");
+	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Foo"));
         assertEquals(2,type.getFunctions().size());
 	}
 	
@@ -57,8 +57,8 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity("Bar");
-	    this.assertContainsRelation(type, DependencyType.INHERIT, "Foo");
+	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Bar"));
+	    this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
 	}
 
 

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -28,8 +28,8 @@ public class PythonDecoratorTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
-		this.assertContainsRelation(func, DependencyType.ANNOTATION	, "our_decorator");
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(func, DependencyType.ANNOTATION	, withPackageName(srcs[0],"our_decorator"));
 	    assertEquals(1,func.getResolvedAnnotations().size());
 	}
 

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -26,8 +26,8 @@ public class PythonFuncCallTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
-	    this.assertContainsRelation(func, DependencyType.CALL, "bar");
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"bar"));
 	}
 
 }

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -27,7 +27,7 @@ public class PythonFunctionTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity("foo"));
+        assertNotNull(repo.getEntity(withPackageName(srcs[0],"foo")));
 	}
 	
 	@Test
@@ -41,7 +41,7 @@ public class PythonFunctionTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
         assertEquals(2,func.getParameters().size());
 	}
 	

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -46,7 +46,7 @@ public class PythonImportTest extends PythonParserTest {
 	    inferer.resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 	}
 	
 	@Test
@@ -63,7 +63,7 @@ public class PythonImportTest extends PythonParserTest {
 	    inferer.resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 	}
 	
 	@Test
@@ -79,7 +79,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
@@ -97,7 +97,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
@@ -115,7 +115,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,"foo");
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[1],"foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -26,8 +26,8 @@ public class PythonObjectCreationTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity("foo");
-	    this.assertContainsRelation(func, DependencyType.CREATE, "Bar");
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    this.assertContainsRelation(func, DependencyType.CREATE, withPackageName(srcs[0],"Bar"));
 	}
 
 }

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -26,8 +26,8 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity("t1");
-	    this.assertContainsRelation(func, DependencyType.THROW, "Bar");
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t1"));
+	    this.assertContainsRelation(func, DependencyType.THROW, withPackageName(srcs[0],"Bar"));
 	}
 	
 	
@@ -42,8 +42,8 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity("t2");
-	    this.assertContainsRelation(func, DependencyType.RETURN, "Bar");
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t2"));
+	    this.assertContainsRelation(func, DependencyType.RETURN, withPackageName(srcs[0],"Bar"));
 	}
 
 

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -3,16 +3,19 @@ package depends.extractor.python;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
+import java.io.File;
 import java.io.IOException;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.CandidateTypes;
+import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
+import depends.util.FileUtil;
 
 public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	@Before
@@ -31,11 +34,14 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(repo.getEntity("test"));
+	    String name = withPackageName(srcs[0],"test");
+	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
 	    TypeEntity type = var.getType();
 	    assertTrue(type instanceof CandidateTypes);
 	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
 	}
+
+
 }
 

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -34,4 +34,8 @@ public abstract class PythonParserTest extends ParserTest implements ParserCreat
 	public FileParser createFileParser(String src) {
 		return  p.createFileParser(FileUtil.uniqFilePath(src));
 	}
+	
+	protected String withPackageName(String theFile,String entityName) {
+		return FileUtil.uniqFilePath(FileUtil.getLocatedDir(theFile))+"."+entityName;
+	}
 }

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -31,10 +31,10 @@ public class SelfShouldBeThisTypeTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(repo.getEntity("A.foo"));
+	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"A.foo")));
 	    VarEntity var = function.lookupVarLocally("self");
 	    TypeEntity type = var.getType();
-	    assertTrue(type.getQualifiedName().equals("A"));
+	    assertTrue(type.getQualifiedName().equals(withPackageName(srcs[0],"A")));
 	}
 }
 

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -33,8 +33,8 @@ public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(repo.getEntity("bar"));
-	    this.assertContainsRelation(function, DependencyType.CALL, "foo");
+	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"bar")));
+	    this.assertContainsRelation(function, DependencyType.CALL, withPackageName(srcs[0],"foo"));
 	}
 }
 

56df947bb2d0eb23149ddb036f2e2aa34e1e33bb
@@ -0,0 +1,91 @@
+package depends.format.plantuml;
+
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+
+import depends.deptypes.DependencyType;
+import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.DependencyPair;
+import depends.matrix.core.DependencyValue;
+
+public class BriefPlantUmlFormatDependencyDumper extends AbstractFormatDependencyDumper {
+	@Override
+	public String getFormatName() {
+		return "briefplantuml";
+	}
+	
+	public BriefPlantUmlFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+
+
+	@Override
+	public boolean output() {
+		PrintWriter writer;
+		try {
+			writer = new PrintWriter(composeFilename()+".uml");
+			ArrayList<String> files = matrix.getNodes();
+			
+			for (int i=0;i<files.size();i++) {
+				String file = files.get(i);
+				writer.println("class " + " "+file);
+			}
+			writer.println("@startuml");
+	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
+	        addRelations(writer,dependencyPairs); 
+			writer.println("@enduml");
+			writer.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
+		
+		HashMap <String,HashMap<String,Integer>> relationMap = new HashMap<>();
+		for (DependencyPair dependencyPair:dependencyPairs) {
+            int src = dependencyPair.getFrom();
+            int dst = dependencyPair.getTo();
+            for (DependencyValue dep:dependencyPair.getDependencies()) {
+            	String key = getNodeName(src)+"..>" + getNodeName(dst);
+            	if (!relationMap.containsKey(key)){
+            		relationMap.put(key, new HashMap<>());
+            	}
+            	HashMap<String, Integer> relationValues = relationMap.get(key);
+            	
+            	Integer value = 0;
+            	if (!relationValues.containsKey(dep.getType())) {
+            		relationValues.get(dep.getType());
+            	}
+            	relationValues.put(dep.getType(), value+=dep.getWeight());
+            }
+		}		
+		
+		for (String key:relationMap.keySet()) {
+        	writer.println("\t"+key + " : " +  buildNotes(relationMap.get(key)) );
+		}
+	}
+
+
+	private String buildNotes(HashMap<String, Integer> relations) {
+		StringBuffer sb = new StringBuffer();
+		for (String dep:relations.keySet()) {
+			sb.append(dep.substring(0,3).toUpperCase()).append(relations.get(dep));
+		}
+		return sb.toString();
+	}
+
+	private String getNodeName(int src) {
+		String result = matrix.getNodeName(src);
+		result = result.replace("-", "_");
+		return result;
+	}
+}

ee6513673e6ce32d9a20fb4d028dff3774490d8c
@@ -27,6 +27,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 
+
 import depends.relations.Inferer;
 
 public class AliasEntity extends Entity {

ee6513673e6ce32d9a20fb4d028dff3774490d8c
@@ -0,0 +1,21 @@
+package depends.persistent.neo4j.executor;
+
+import com.fasterxml.jackson.annotation.JsonIdentityInfo;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.voodoodyne.jackson.jsog.JSOGGenerator;
+
+@JsonIdentityInfo(generator = JSOGGenerator.class)
+abstract class Entity {
+
+    @JsonProperty("id")
+    private Long id;
+
+    Long getId() {
+        return id;
+    }
+
+    void setId(Long id) {
+        this.id = id;
+    }
+ 
+}
\ No newline at end of file

1f9e3949a4029c28578e7f390bdd0843ba0f1958
@@ -30,6 +30,10 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import org.neo4j.ogm.annotation.Id;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
 import depends.relations.Inferer;
 import depends.relations.Relation;
 
@@ -40,7 +44,9 @@ import depends.relations.Relation;
  * We also use entity to record relations 
  */
 public abstract class Entity {
-	int id=-1;
+	
+    @Id
+    Integer id=-1;
 	String qualifiedName = null;
 	String rawName = "";
 	Entity parent;

1f9e3949a4029c28578e7f390bdd0843ba0f1958
@@ -1,21 +0,0 @@
-package depends.persistent.neo4j.executor;
-
-import com.fasterxml.jackson.annotation.JsonIdentityInfo;
-import com.fasterxml.jackson.annotation.JsonProperty;
-import com.voodoodyne.jackson.jsog.JSOGGenerator;
-
-@JsonIdentityInfo(generator = JSOGGenerator.class)
-abstract class Entity {
-
-    @JsonProperty("id")
-    private Long id;
-
-    Long getId() {
-        return id;
-    }
-
-    void setId(Long id) {
-        this.id = id;
-    }
- 
-}
\ No newline at end of file

363a2f7966ace601867d66357314513bf203aae4
@@ -25,62 +25,20 @@ SOFTWARE.
 package depends.entity.repo;
 
 import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
 
 import depends.entity.Entity;
-import depends.entity.MultiDeclareEntities;
 
-public class EntityRepo extends IdGenerator{
-	private HashMap<String, Entity> allEntieisByName = new HashMap<>();
-	private HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
-	private List<Entity> allEntitiesByOrder = new LinkedList<>();
+public interface EntityRepo extends IdGenerator {
 	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
-	public EntityRepo() {
-	}
-	
-	public Entity getEntity(String entityName) {
-		return allEntieisByName.get(entityName);
-	}
-	
-	public Entity getEntity(Integer entityId) {
-		return allEntitiesById.get(entityId);
-	}
-	
-	public void add(Entity entity) {
-		allEntitiesByOrder.add(entity);
-		allEntitiesById.put(entity.getId(), entity);
-		String name = entity.getRawName();
-		if (entity.getQualifiedName()!=null && !(entity.getQualifiedName().isEmpty()) ) {
-			name = entity.getQualifiedName();
-		}
-		if (allEntieisByName.containsKey(name)) {
-			Entity existedEntity = allEntieisByName.get(name);
-			if (existedEntity instanceof MultiDeclareEntities) {
-				((MultiDeclareEntities)existedEntity).add(entity);
-			}else {
-				MultiDeclareEntities eMultiDeclare = new MultiDeclareEntities(existedEntity,this.generateId());
-				eMultiDeclare.add(entity);
-				allEntieisByName.put(name, eMultiDeclare);
-			}
-		}else {
-			allEntieisByName.put(name, entity);
-		}
-		if (entity.getParent()!=null)
-			this.setParent(entity, entity.getParent());
-	}
-		
-	public Collection<Entity> getEntities() {
-		return allEntitiesByOrder;
-	}
-	
-	public void setParent(Entity child, Entity parent) {
-		if (parent==null) return;
-		if (child==null) return;
-		if (parent.equals(child.getParent())) return;
-		child.setParent(parent);
-		parent.addChild(child);
-	}
+	Entity getEntity(String entityName);
+
+	Entity getEntity(Integer entityId);
+
+	void add(Entity entity);
+
+	Collection<Entity> getEntities();
+
+	void setParent(Entity child, Entity parent);
+
 }

363a2f7966ace601867d66357314513bf203aae4
@@ -0,0 +1,75 @@
+package depends.entity.repo;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.MultiDeclareEntities;
+
+public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo {
+
+	private HashMap<String, Entity> allEntieisByName;
+	private HashMap<Integer, Entity> allEntitiesById;
+	private List<Entity> allEntitiesByOrder;
+
+	public InMemoryEntityRepo() {
+		allEntieisByName = new HashMap<>();
+		allEntitiesById = new HashMap<>();
+		allEntitiesByOrder = new LinkedList<>();
+	}
+
+	@Override
+	public Entity getEntity(String entityName) {
+		return allEntieisByName.get(entityName);
+	}
+
+	@Override
+	public Entity getEntity(Integer entityId) {
+		return allEntitiesById.get(entityId);
+	}
+
+	@Override
+	public void add(Entity entity) {
+		allEntitiesByOrder.add(entity);
+		allEntitiesById.put(entity.getId(), entity);
+		String name = entity.getRawName();
+		if (entity.getQualifiedName() != null && !(entity.getQualifiedName().isEmpty())) {
+			name = entity.getQualifiedName();
+		}
+		if (allEntieisByName.containsKey(name)) {
+			Entity existedEntity = allEntieisByName.get(name);
+			if (existedEntity instanceof MultiDeclareEntities) {
+				((MultiDeclareEntities) existedEntity).add(entity);
+			} else {
+				MultiDeclareEntities eMultiDeclare = new MultiDeclareEntities(existedEntity, this.generateId());
+				eMultiDeclare.add(entity);
+				allEntieisByName.put(name, eMultiDeclare);
+			}
+		} else {
+			allEntieisByName.put(name, entity);
+		}
+		if (entity.getParent() != null)
+			this.setParent(entity, entity.getParent());
+	}
+
+	@Override
+	public Collection<Entity> getEntities() {
+		return allEntitiesByOrder;
+	}
+
+	@Override
+	public void setParent(Entity child, Entity parent) {
+		if (parent == null)
+			return;
+		if (child == null)
+			return;
+		if (parent.equals(child.getParent()))
+			return;
+		child.setParent(parent);
+		parent.addChild(child);
+	}
+
+
+}

363a2f7966ace601867d66357314513bf203aae4
@@ -0,0 +1,18 @@
+package depends.entity.repo;
+
+public class SimpleIdGenerator implements IdGenerator {
+
+	private int nextAvaliableIndex;
+	public SimpleIdGenerator() {
+		nextAvaliableIndex = 0;
+	}
+	/**
+	 * Generate a global unique ID for entity
+	 * @return the unique id
+	 */
+	@Override
+	public Integer generateId() {
+		return nextAvaliableIndex++;
+	}
+
+}

363a2f7966ace601867d66357314513bf203aae4
@@ -34,6 +34,7 @@ import org.codehaus.plexus.util.FileUtils;
 
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
+import depends.entity.repo.InMemoryEntityRepo;
 import depends.generator.DependencyGenerator;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.transform.OrderedMatrixGenerator;
@@ -78,7 +79,7 @@ abstract public class AbstractLangProcessor {
 	private DependencyGenerator dependencyGenerator;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
-		entityRepo = new EntityRepo();
+		entityRepo = new InMemoryEntityRepo();
 
 		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
 	}

363a2f7966ace601867d66357314513bf203aae4
@@ -3,6 +3,7 @@ package depends.extractor.cpp;
 import java.util.ArrayList;
 
 import depends.entity.repo.EntityRepo;
+import depends.entity.repo.InMemoryEntityRepo;
 import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
@@ -14,7 +15,7 @@ public abstract class CppParserTest extends ParserTest{
     protected PreprocessorHandler preprocessorHandler;
 
 	public void init() {
-    	repo = new EntityRepo();
+    	repo = new InMemoryEntityRepo();
     	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType(),false);
     	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
     }

363a2f7966ace601867d66357314513bf203aae4
@@ -1,6 +1,7 @@
 package depends.extractor.java;
 
 import depends.entity.repo.EntityRepo;
+import depends.entity.repo.InMemoryEntityRepo;
 import depends.extractor.ParserTest;
 import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaFileParser;
@@ -12,7 +13,7 @@ public abstract class JavaParserTest  extends ParserTest{
 	protected Inferer inferer ;
 
 	public void init() {
-		entityRepo = new EntityRepo();
+		entityRepo = new InMemoryEntityRepo();
 		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(),new JavaBuiltInType(),false);
 	}
 	

363a2f7966ace601867d66357314513bf203aae4
@@ -47,7 +47,7 @@ public class RubyInheritTest extends RubyParserTest {
 	}
 	
 	
-	@Test
+	@Ignore
 	public void test_relation_with_cpath_1() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/ruby-code-examples/extends_with_cpath.rb",

363a2f7966ace601867d66357314513bf203aae4
@@ -6,6 +6,7 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 import depends.entity.repo.EntityRepo;
+import depends.entity.repo.InMemoryEntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
@@ -16,7 +17,7 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 	protected Inferer inferer ;
 
 	public void init() {
-		entityRepo = new EntityRepo();
+		entityRepo = new InMemoryEntityRepo();
 		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType(),true);
 	}
 	

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -33,7 +33,9 @@ import depends.relations.Inferer;
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
 	private String originName;
-
+	public AliasEntity() {
+		
+	}
 	public AliasEntity(String simpleName, Entity parent, Integer id, String originTypeName) {
 		super(simpleName, parent, id);
 		this.originName = originTypeName;

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -35,6 +35,9 @@ import depends.relations.Relation;
 public class CandidateTypes extends TypeEntity {
 	private List<TypeEntity> candidateTypes;
 
+	public CandidateTypes() {
+		candidateTypes = new ArrayList<>();
+	}
 	public CandidateTypes(List<TypeEntity> candidateTypes) {
 		super("candidateTypes", null, -1);
 		this.candidateTypes = candidateTypes;
@@ -230,7 +233,7 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public int getId() {
+	public Integer getId() {
 		System.err.println("error: getId should not been invoked");
 		return super.getId();
 	}

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -47,7 +47,14 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<Expression> expressionList;
 	private Collection<String> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
-
+	public ContainerEntity() {
+		vars = new ArrayList<>();
+		functions = new ArrayList<>();
+		mixins = new ArrayList<>();
+		resolvedMixins = new ArrayList<>();
+		expressions = new HashMap<>();
+		expressionList = new  ArrayList<>();
+	}
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -55,7 +55,7 @@ public abstract class Entity {
     ArrayList<Relation> relations = new ArrayList<>();
 	private Entity actualReferTo = null;
 
-	
+	public Entity() {};
     public Entity(String rawName, Entity parent, Integer id) {
 		this.qualifiedName = null;
 		this.rawName = rawName;
@@ -99,7 +99,7 @@ public abstract class Entity {
 		return rawName;
 	}
 
-	public int getId() {
+	public Integer getId() {
         return id;
     }
 
@@ -201,4 +201,14 @@ public abstract class Entity {
 		this.actualReferTo = actualReferTo;
 	}
 
+	public static void setParent(Entity child, Entity parent) {
+		if (parent == null)
+			return;
+		if (child == null)
+			return;
+		if (parent.equals(child.getParent()))
+			return;
+		child.setParent(parent);
+		parent.addChild(child);
+	}
 }

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -27,9 +27,12 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.neo4j.ogm.annotation.Id;
+
 import depends.relations.Inferer;
 
 public class Expression {
+	@Id
 	public Integer id;
 	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -40,6 +40,8 @@ public class FileEntity extends TypeEntity {
 	private Collection<Entity> importedTypes = new ArrayList<>();
 	private List<TypeEntity> declaredTypes = new ArrayList<>();
 	private ImportedFileCollector importedFileCollector = null;
+	public FileEntity() {}
+
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
 		super(fullName, null, fileId);
 		setQualifiedName(fullName);

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -36,6 +36,9 @@ public class FunctionEntity extends ContainerEntity{
     Collection<String> throwTypesIdentifiers = new ArrayList<>(); 
 	private Collection<Entity> returnTypes = new ArrayList<>();
 	private Collection<Entity> throwTypes = new ArrayList<>();
+	public FunctionEntity() {
+		this.parameters = new ArrayList<>();
+	}
     public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
 		super(simpleName, parent,id);
 		this.returnTypes = new ArrayList<>();

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -35,7 +35,7 @@ public class TypeEntity extends ContainerEntity {
 	Collection<String> inhertedTypeIdentifiers;
 	Collection<String> implementedIdentifiers;
 	TypeEntity inheritedType;
-
+	public TypeEntity() {}
 	public TypeEntity(String simpleName, Entity parent, Integer id) {
 		super(simpleName, parent, id);
 		inhertedTypeIdentifiers = new ArrayList<>();

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -33,7 +33,9 @@ public class VarEntity extends ContainerEntity {
 	private String rawType;
 	private TypeEntity type;
 	private List<FunctionCall> functionCalls;
-	
+	public VarEntity() {
+		
+	}
 	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
 		super(simpleName,  parent,id);
 		this.rawType = rawType;

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -24,7 +24,7 @@ SOFTWARE.
 
 package depends.entity.repo;
 
-import java.util.Collection;
+import java.util.Iterator;
 
 import depends.entity.Entity;
 
@@ -37,8 +37,9 @@ public interface EntityRepo extends IdGenerator {
 
 	void add(Entity entity);
 
-	Collection<Entity> getEntities();
+	Iterator<Entity> getEntities();
+
+	void update(Entity entity);
 
-	void setParent(Entity child, Entity parent);
 
 }

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -1,7 +1,7 @@
 package depends.entity.repo;
 
-import java.util.Collection;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
@@ -51,25 +51,20 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 			allEntieisByName.put(name, entity);
 		}
 		if (entity.getParent() != null)
-			this.setParent(entity, entity.getParent());
+			Entity.setParent(entity, entity.getParent());
 	}
 
 	@Override
-	public Collection<Entity> getEntities() {
-		return allEntitiesByOrder;
+	public Iterator<Entity> getEntities() {
+		return allEntitiesByOrder.iterator();
 	}
 
 	@Override
-	public void setParent(Entity child, Entity parent) {
-		if (parent == null)
-			return;
-		if (child == null)
-			return;
-		if (parent.equals(child.getParent()))
-			return;
-		child.setParent(parent);
-		parent.addChild(child);
+	public void update(Entity entity) {
+		// TODO Auto-generated method stub
+		
 	}
 
 
+
 }

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -35,6 +35,7 @@ import org.codehaus.plexus.util.FileUtils;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
+import depends.entity.repo.Neo4jEntityRepo;
 import depends.generator.DependencyGenerator;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.transform.OrderedMatrixGenerator;
@@ -81,6 +82,7 @@ abstract public class AbstractLangProcessor {
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
 
+		//entityRepo = new Neo4jEntityRepo();
 		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
 	}
 	

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -24,6 +24,7 @@ SOFTWARE.
 
 package depends.generator;
 
+import java.util.Iterator;
 import java.util.List;
 
 import depends.entity.CandidateTypes;
@@ -43,8 +44,12 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	@Override
 	public DependencyMatrix build(EntityRepo entityRepo) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix();
-		for (Entity entity:entityRepo.getEntities()) {
-        	if (entity instanceof FileEntity){
+		Iterator<Entity> iterator = entityRepo.getEntities();
+		System.out.println("Start create dependencies matrix....");
+		while(iterator.hasNext()) {
+			System.out.print(".");
+			Entity entity = iterator.next();
+			if (entity instanceof FileEntity){
         		dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
         	}
         	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
@@ -72,6 +77,8 @@ public class FileDependencyGenerator extends DependencyGenerator{
         		}
         	}
         }
+		System.out.println("Finish create dependencies matrix....");
+
 		return dependencyMatrix;
 	}
 

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -24,6 +24,8 @@ SOFTWARE.
 
 package depends.generator;
 
+import java.util.Iterator;
+
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.repo.EntityRepo;
@@ -33,7 +35,9 @@ import depends.relations.Relation;
 public class FunctionDependencyGenerator extends DependencyGenerator {
 	public DependencyMatrix build(EntityRepo entityRepo) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix();
-		for (Entity entity : entityRepo.getEntities()) {
+		Iterator<Entity> iterator = entityRepo.getEntities();
+		while(iterator.hasNext()) {
+			Entity entity = iterator.next();
 			if (entity instanceof FunctionEntity) {
 				dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
 			}

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -26,6 +26,7 @@ package depends.relations;
 
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.Iterator;
 
 import depends.deptypes.DependencyType;
 import depends.entity.ContainerEntity;
@@ -38,14 +39,16 @@ import depends.entity.VarEntity;
 
 public class RelationCounter {
 
-	private Collection<Entity> entities;
+	private Iterator<Entity> iterator;
 
-	public RelationCounter(Collection<Entity> entities) {
-		this.entities = entities;
+	public RelationCounter(Iterator<Entity> iterator) {
+		this.iterator = iterator;
 	}
 	
 	public void computeRelations() {
-		for (Entity entity:entities) {
+		while(iterator.hasNext()) {
+			Entity entity= iterator.next();
+
 			if (entity instanceof FileEntity) {
 				computeImports((FileEntity)entity);
 			}

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -4,6 +4,8 @@ import java.util.ArrayList;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
+import depends.entity.repo.Neo4jEntityRepo;
+
 import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -2,6 +2,7 @@ package depends.extractor.java;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
+import depends.entity.repo.Neo4jEntityRepo;
 import depends.extractor.ParserTest;
 import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaFileParser;

54f62ce44ad8d8799f32ca9c8f9e9c8303285200
@@ -47,10 +47,11 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		Iterator<Entity> iterator = entityRepo.getEntities();
 		System.out.println("Start create dependencies matrix....");
 		while(iterator.hasNext()) {
-			System.out.print(".");
 			Entity entity = iterator.next();
 			if (entity instanceof FileEntity){
-        		dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
+				String name = stripper.stripFilename(entity.getDisplayName());
+				name = filenameWritter.reWrite(name);
+        		dependencyMatrix.addNode(name,entity.getId());
         	}
         	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
         	if (fileEntityFrom==-1) continue;

54f62ce44ad8d8799f32ca9c8f9e9c8303285200
@@ -27,7 +27,9 @@ package depends.generator;
 import java.util.Iterator;
 
 import depends.entity.Entity;
+import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
+import depends.entity.PackageEntity;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
@@ -39,7 +41,8 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 		while(iterator.hasNext()) {
 			Entity entity = iterator.next();
 			if (entity instanceof FunctionEntity) {
-				dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
+				String name = getFunctionEntityDisplayName((FunctionEntity)entity);
+				dependencyMatrix.addNode(name,entity.getId());
 			}
 			int entityFrom = getFunctionEntityIdNoException(entity);
 			if (entityFrom == -1)
@@ -58,6 +61,20 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 	}
 
 
+	private String getFunctionEntityDisplayName(FunctionEntity entity) {
+		FileEntity file = (FileEntity) entity.getAncestorOfType(FileEntity.class);
+		String name = stripper.stripFilename(file.getRawName());
+		name = filenameWritter.reWrite(name);
+		PackageEntity pkg = (PackageEntity) entity.getAncestorOfType(PackageEntity.class);
+		String functionName = entity.getQualifiedName();
+		if (pkg!=null) {
+			functionName = functionName.substring(pkg.getQualifiedName().length()+1);
+		}
+		name = name + "("+functionName+")";
+		return name;
+	}
+
+
 	private int getFunctionEntityIdNoException(Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
 		if (ancestor == null)

39d0771d71b254d4a742c9b33825fcaff09bb24e
@@ -38,14 +38,14 @@ import depends.matrix.core.DependencyMatrix;
 import depends.matrix.core.DependencyPair;
 import depends.matrix.core.DependencyValue;
 
-public class ExcelFormatDependencyDumper extends AbstractFormatDependencyDumper {
+public class ExcelXlsFormatDependencyDumper extends AbstractFormatDependencyDumper {
 	private HSSFWorkbook workbook;
 	private HSSFSheet sheet;
 	@Override
 	public String getFormatName() {
-		return "excel";
+		return "xls";
 	}
-	public ExcelFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+	public ExcelXlsFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
 		super(dependencyMatrix, projectName,outputDir);
 	}
 

726e7cf33488092f65880606f55825fe308d1233
@@ -24,6 +24,11 @@ SOFTWARE.
 
 package depends.entity;
 
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -32,11 +37,13 @@ import java.util.List;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
+import depends.util.TemporaryFile;
 
 /**
- * ContainerEntity for example file, class, method, etc.
- * they could contain vars, functions, ecpressions, type parameters, etc.
+ * ContainerEntity for example file, class, method, etc. they could contain
+ * vars, functions, ecpressions, type parameters, etc.
  */
 public abstract class ContainerEntity extends DecoratedEntity {
 	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
@@ -47,14 +54,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<Expression> expressionList;
 	private Collection<String> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
+
 	public ContainerEntity() {
 		vars = new ArrayList<>();
 		functions = new ArrayList<>();
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
 		expressions = new HashMap<>();
-		expressionList = new  ArrayList<>();
+		expressionList = new ArrayList<>();
 	}
+
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
@@ -62,14 +71,12 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
 		expressions = new HashMap<>();
-		expressionList = new  ArrayList<>();
+		expressionList = new ArrayList<>();
 	}
-	
-
 
 	public void addVar(VarEntity var) {
 		if (logger.isDebugEnabled()) {
-			logger.debug("var found: "+var.getRawName() +  ":" + var.getRawType());
+			logger.debug("var found: " + var.getRawName() + ":" + var.getRawType());
 		}
 		this.vars.add(var);
 	}
@@ -95,18 +102,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		expressionList.add(expression);
 	}
 
-	
-
 	/**
-	 * For all data in the class, infer their types.
-	 * Should be override in sub-classes 
+	 * For all data in the class, infer their types. Should be override in
+	 * sub-classes
 	 */
 	public void inferLocalLevelEntities(Inferer inferer) {
 		super.inferLocalLevelEntities(inferer);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelEntities(inferer);
 		}
-		for (FunctionEntity func:this.functions) {
+		for (FunctionEntity func : this.functions) {
 			func.inferLocalLevelEntities(inferer);
 		}
 		resolvedMixins = identiferToContainerEntity(inferer, mixins);
@@ -119,85 +124,139 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		ArrayList<ContainerEntity> r = new ArrayList<>();
 		for (String identifier : identifiers) {
 			Entity entity = inferer.resolveName(this, identifier, true);
-			if (entity==null) {
+			if (entity == null) {
 				continue;
 			}
 			if (entity instanceof ContainerEntity)
-				r.add((ContainerEntity)entity);
+				r.add((ContainerEntity) entity);
 		}
 		return r;
 	}
 
 	/**
 	 * Resolve all expression's type
+	 * 
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
 		for (Expression expression : expressionList) {
-			//1. if expression's type existed, break;
+			// 1. if expression's type existed, break;
 			if (expression.getType() != null)
 				continue;
-			if (expression.isDot){ //wait for previous
+			if (expression.isDot) { // wait for previous
 				continue;
 			}
-			if (expression.rawType==null && expression.identifier ==null)
+			if (expression.rawType == null && expression.identifier == null)
 				continue;
-			
-			//2. if expression's rawType existed, directly infer type by rawType
-			//   if expression's rawType does not existed, infer type based on identifiers
+
+			// 2. if expression's rawType existed, directly infer type by rawType
+			// if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
-				if (expression.getType() !=null) {
-					 continue;
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType), null, inferer);
+				if (expression.getType() != null) {
+					continue;
 				}
 			}
-			if (expression.identifier!=null) { 
+			if (expression.identifier != null) {
 				Entity entity = inferer.resolveName(this, expression.identifier, true);
-				if (entity!=null) {
-					expression.setType(entity.getType(),entity,inferer);
+				if (entity != null) {
+					expression.setType(entity.getType(), entity, inferer);
 					continue;
 				}
 				if (expression.isCall) {
 					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
-					if (func!=null) {
-						expression.setType(func.getType(),func,inferer);
+					if (func != null) {
+						expression.setType(func.getType(), func, inferer);
 					}
-				}else {
-					
+				} else {
+
 					VarEntity varEntity = this.lookupVarInVisibleScope(expression.identifier);
-					if (varEntity!=null) {
-						expression.setType( varEntity.getType(),varEntity,inferer);
+					if (varEntity != null) {
+						expression.setType(varEntity.getType(), varEntity, inferer);
 					}
 				}
 			}
 		}
 	}
 
-	public void cleanExpression() {
-		this.expressions = null;
+	public void cacheExpressions() {
+		this.expressions = new HashMap<>();
+		cacheExpressionListToFile();
+		this.expressionList = new ArrayList<>();
 	}
 
+	public void clearExpressions() {
+		this.expressions = new HashMap<>();
+		this.expressionList = new ArrayList<>();
+	}
+	
+	private void cacheExpressionListToFile() {
+		try {
+			FileOutputStream fileOut = new FileOutputStream(TemporaryFile.getInstance().exprPath(this.id));
+			ObjectOutputStream out = new ObjectOutputStream(fileOut);
+			out.writeObject(this.expressionList);
+			out.close();
+			fileOut.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	public void reloadExpression(EntityRepo repo) {
+		try
+	      {
+	         FileInputStream fileIn = new FileInputStream(TemporaryFile.getInstance().exprPath(this.id));
+	         ObjectInputStream in = new ObjectInputStream(fileIn);
+	         expressionList = (ArrayList<Expression>) in.readObject();
+	         if (expressionList==null) expressionList = new ArrayList<>();
+	         for (Expression expr:expressionList) {
+	        	 expr.reload(repo,expressionList);
+	         }
+	         in.close();
+	         fileIn.close();
+	      }catch(IOException | ClassNotFoundException i)
+	      {
+	         return;
+	      }
+	}
+	
 	public TypeEntity getLastExpressionType() {
-		for (int i=this.expressionList.size()-1;i>=0;i--) {
-			Expression expr= this.expressionList.get(i);
+		//TODO: 
+		/*
+    java.lang.NullPointerException
+	at depends.entity.ContainerEntity.getLastExpressionType(ContainerEntity.java:228)
+	at depends.entity.FunctionEntity.inferLocalLevelEntities(FunctionEntity.java:92)
+	at depends.entity.ContainerEntity.inferLocalLevelEntities(ContainerEntity.java:118)
+	at depends.entity.TypeEntity.inferLocalLevelEntities(TypeEntity.java:69)
+	at depends.entity.Entity.inferEntities(Entity.java:171)
+	at depends.entity.Entity.inferEntities(Entity.java:173)
+	at depends.relations.Inferer.resolveTypes(Inferer.java:91)
+	at depends.relations.Inferer.resolveAllBindings(Inferer.java:78)
+	at depends.extractor.AbstractLangProcessor.resolveBindings(AbstractLangProcessor.java:112)
+	at depends.extractor.AbstractLangProcessor.buildDependencies(AbstractLangProcessor.java:101)
+	at depends.Main.executeCommand(Main.java:121)
+	at depends.Main.main(Main.java:60) 
+		 * */
+		for (int i = this.expressionList.size() - 1; i >= 0; i--) {
+			Expression expr = this.expressionList.get(i);
 			if (expr.isStatement)
 				return expr.getType();
 		}
 		return null;
 	}
-	
+
 	public List<Expression> expressionList() {
 		return expressionList;
 	}
 
 	public boolean containsExpression() {
-		return expressions.size()>0;
+		return expressions.size() > 0;
 	}
 
-
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();
-		for (Expression exp:expressionList) {
+		for (Expression exp : expressionList) {
 			sb.append(exp.toString()).append("\n");
 		}
 		return sb.toString();
@@ -206,21 +265,22 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	
 	/**
-	 * The entry point of lookup functions. It will treat multi-declare entities and normal
-	 * entity differently.
-	 * - for multiDeclare entity, it means to lookup all entities
-	 * - for normal entity, it means to lookup entities from current scope still root 
+	 * The entry point of lookup functions. It will treat multi-declare entities and
+	 * normal entity differently. - for multiDeclare entity, it means to lookup all
+	 * entities - for normal entity, it means to lookup entities from current scope
+	 * still root
+	 * 
 	 * @param functionName
 	 * @return
 	 */
 	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
-		if (this.getMutliDeclare()!=null) {
-			for (ContainerEntity fromEntity:this.getMutliDeclare().getEntities()) {
+		if (this.getMutliDeclare() != null) {
+			for (ContainerEntity fromEntity : this.getMutliDeclare().getEntities()) {
 				FunctionEntity f = lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
-				if (f!=null)
+				if (f != null)
 					return f;
 			}
-		}else {
+		} else {
 			ContainerEntity fromEntity = this;
 			return lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
 		}
@@ -229,6 +289,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	/**
 	 * lookup function bottom up till the most outside container
+	 * 
 	 * @param functionName
 	 * @param fromEntity
 	 * @return
@@ -244,11 +305,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 		return null;
 	}
-	
+
 	/**
-	 * lookup function in local entity. 
-	 * It could be override such as the type entity (it should also lookup the 
-	 * inherit/implemented types
+	 * lookup function in local entity. It could be override such as the type entity
+	 * (it should also lookup the inherit/implemented types
+	 * 
 	 * @param functionName
 	 * @return
 	 */
@@ -261,10 +322,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	/**
-	 * The entry point of lookup var. It will treat multi-declare entities and normal
-	 * entity differently.
-	 * - for multiDeclare entity, it means to lookup all entities
-	 * - for normal entity, it means to lookup entities from current scope still root 
+	 * The entry point of lookup var. It will treat multi-declare entities and
+	 * normal entity differently. - for multiDeclare entity, it means to lookup all
+	 * entities - for normal entity, it means to lookup entities from current scope
+	 * still root
+	 * 
 	 * @param varName
 	 * @return
 	 */
@@ -274,7 +336,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	/**
-	 * To found the var. 
+	 * To found the var.
+	 * 
 	 * @param fromEntity
 	 * @param varName
 	 * @return
@@ -292,7 +355,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public VarEntity lookupVarLocally(String varName) {
-		for (VarEntity var:getVars()) {
+		for (VarEntity var : getVars()) {
 			if (var.getRawName().equals(varName))
 				return var;
 		}
@@ -309,8 +372,4 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 
 
-
-
-
-	
 }

726e7cf33488092f65880606f55825fe308d1233
@@ -24,18 +24,19 @@ SOFTWARE.
 
 package depends.entity;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.neo4j.ogm.annotation.Id;
 
+import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
 
-public class Expression {
+public class Expression implements Serializable{
+	private static final long serialVersionUID = 1L;
 	@Id
 	public Integer id;
-	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
-	public Expression parent;
 	public String text; // for debug purpose
 	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
@@ -49,11 +50,19 @@ public class Expression {
 	public boolean isStatement = false; //statement is only used for return type calcuation in some langs such as ruby
 	                                    //they will not be treat as real expressions in case of relation calculation
 	public boolean deriveTypeFromChild = true;
-	private TypeEntity type; // the type we care - for relation calculation. 
+	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
+	
+	private Integer parentId = -1; 
+	private List<Integer> deducedTypeVarsId = new ArrayList<>();
+	private List<Integer> deducedTypeFunctionsId = new ArrayList<>();
+	
+	private transient Expression parent;
+	private transient TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
-	private Entity referredEntity;
-	private List<VarEntity> deducedTypeVars;
-	private List<FunctionEntity> deducedTypeFunctions;
+	private transient Entity referredEntity;
+	
+	private transient List<VarEntity> deducedTypeVars = new ArrayList<>();
+	private transient List<FunctionEntity> deducedTypeFunctions= new ArrayList<>();
 	public TypeEntity getType() {
 		return type;
 	}
@@ -82,6 +91,10 @@ public class Expression {
 			deduceTheParentType(inferer);
 	}
 	
+	public Expression() {
+		deducedTypeVars = new ArrayList<>();
+		deducedTypeFunctions = new ArrayList<>();
+	}
 	public Expression(Integer id) {
 		this.id = id;
 		deducedTypeVars = new ArrayList<>();
@@ -176,9 +189,49 @@ public class Expression {
 
 	public void addDeducedTypeVar(VarEntity var) {
 		this.deducedTypeVars.add(var);
+		this.deducedTypeVarsId.add(var.getId());
 	}
 
 	public void addDeducedTypeFunction(FunctionEntity function) {
 		this.deducedTypeFunctions.add(function);
+		this.deducedTypeFunctionsId.add(function.id);
+	}
+
+	public void setParent(Expression parent) {
+		this.parent = parent;
+		if (parent!=null)
+			this.parentId = parent.id;
+		if (parent!=null) {
+			if (parent.deduceTypeBasedId==null) 
+				parent.deduceTypeBasedId = id;
+			if (parent.isSet) {
+				parent.deduceTypeBasedId = id;
+			}
+		}
+	}
+
+	public void reload(EntityRepo repo, ArrayList<Expression> expressionList) {
+		this.deducedTypeFunctions = new ArrayList<>();
+		this.deducedTypeVars = new ArrayList<>();
+		if (parentId!=-1) {
+			for (Expression expr:expressionList) {
+				if (expr.id==parentId) {
+					parent = expr;
+					break;
+				}
+			}
+		}
+		
+		if (deducedTypeFunctionsId!=null) {
+			for (Integer funcId:this.deducedTypeFunctionsId) {
+				this.deducedTypeFunctions.add((FunctionEntity) repo.getEntity(funcId));
+			}
+		}
+		
+		if (deducedTypeVarsId!=null) {
+			for (Integer varId:this.deducedTypeVarsId) {
+				this.deducedTypeVars.add((VarEntity) repo.getEntity(varId));
+			}
+		}
 	}
 }
\ No newline at end of file

726e7cf33488092f65880606f55825fe308d1233
@@ -118,7 +118,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
-        dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
+        //dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
         System.out.println("dependencie data generating done successfully...");	 	
     }
 

726e7cf33488092f65880606f55825fe308d1233
@@ -265,7 +265,9 @@ public abstract class HandlerContext {
 		Entity e = entityStack.peek();
 		if (e instanceof ContainerEntity) {
 			ContainerEntity container = (ContainerEntity)e;
-			container.cleanExpression();
+			if (!inferer.isEagerExpressionResolve()) {
+				container.cacheExpressions();
+			}
 		}
 		entityStack.pop();
 	}

726e7cf33488092f65880606f55825fe308d1233
@@ -61,12 +61,8 @@ public class ExpressionUsage {
 		Expression expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
 		context.lastContainer().addExpression(ctx,expression);
-
-		if (parent!=null) {
-			if (parent.deduceTypeBasedId==null) parent.deduceTypeBasedId = expression.id;
-			expression.parent = parent;
-		}
-		
+		expression.setParent(parent);
+	
 		
 		if (isTerminalExpression(ctx)) {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);

726e7cf33488092f65880606f55825fe308d1233
@@ -46,16 +46,9 @@ public class ExpressionUsage {
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());
 		context.lastContainer().addExpression(ctx,expression);
-//		try {
-//			expression.text = ctx.getText(); //for debug purpose. no actual effect
-//		}catch (Exception e) {
-//			expression.text = "error during getText";
-//		}
-		expression.parent = parent;
-		if (expression.parent!=null) {
-			if (expression.parent.deduceTypeBasedId==null) 
-				expression.parent.deduceTypeBasedId = expression.id;
-		}
+
+		expression.setParent(parent);
+
 		
 		if (ctx.primary()!=null) {
 			tryFillExpressionTypeAndIdentifier(ctx.primary(),expression);

726e7cf33488092f65880606f55825fe308d1233
@@ -44,15 +44,8 @@ public class ExpressionUsage {
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.getText();
-		expression.parent = parent;
-		if (expression.parent!=null) {
-			if (expression.parent.deduceTypeBasedId==null) 
-				expression.parent.deduceTypeBasedId = expression.id;
-			/* Set operation always use the 2nd expr's type*/
-			if (expression.parent.isSet) {
-				expression.parent.deduceTypeBasedId = expression.id;
-			}
-		}
+		expression.setParent(parent);
+
 		context.lastContainer().addExpression(ctx,expression);
 		if (ctx instanceof AtomContext) {
 			AtomContext atom = (AtomContext)ctx;

726e7cf33488092f65880606f55825fe308d1233
@@ -75,18 +75,11 @@ public class ExpressionUsage {
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.toString();
-		expression.parent = parent;
+		expression.setParent(parent);
 		if (ctx instanceof NewlineNode) {
 			expression.isStatement = true;
 		}
-		if (expression.parent!=null) {
-			if (expression.parent.deduceTypeBasedId==null) 
-				expression.parent.deduceTypeBasedId = expression.id;
-			/* Set operation always use the 2nd expr's type*/
-			if (expression.parent.isSet) {
-				expression.parent.deduceTypeBasedId = expression.id;
-			}
-		}
+
 		context.lastContainer().addExpression(ctx,expression);
 		if (ctx instanceof ILiteralNode && !(ctx instanceof ListNode)) {
 			expression.identifier = "<literal>";

726e7cf33488092f65880606f55825fe308d1233
@@ -36,13 +36,18 @@ import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
+import depends.entity.repo.EntityRepo;
 
 public class RelationCounter {
 
 	private Iterator<Entity> iterator;
+	private Inferer inferer;
+	private EntityRepo repo;
 
-	public RelationCounter(Iterator<Entity> iterator) {
+	public RelationCounter(Iterator<Entity> iterator, Inferer inferer, EntityRepo repo) {
 		this.iterator = iterator;
+		this.inferer = inferer;
+		this.repo = repo;
 	}
 	
 	public void computeRelations() {
@@ -65,7 +70,13 @@ public class RelationCounter {
 	}
 
 	
+
 	private void computeContainerRelations(ContainerEntity entity) {
+		System.out.println("resolve expression of entity " + entity.getDisplayName());
+		if (!inferer.isEagerExpressionResolve()) {
+			entity.reloadExpression(repo);
+			entity.resolveExpressions(inferer);
+		}
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
@@ -117,6 +128,7 @@ public class RelationCounter {
 		for (Entity usedEntity:usedEntities) {
 			entity.addRelation(new Relation(DependencyType.USE,usedEntity));
 		}
+		entity.clearExpressions();
 	}
 
 	private void computeTypeRelations(TypeEntity type) {

726e7cf33488092f65880606f55825fe308d1233
@@ -10,6 +10,7 @@ import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
 import depends.relations.Inferer;
+import depends.util.TemporaryFile;
 
 public abstract class CppParserTest extends ParserTest{
 	protected EntityRepo repo;
@@ -20,6 +21,7 @@ public abstract class CppParserTest extends ParserTest{
     	repo = new InMemoryEntityRepo();
     	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType(),false);
     	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
+    	TemporaryFile.reset();
     }
 	
 	public CppFileParser createParser(String src) {

726e7cf33488092f65880606f55825fe308d1233
@@ -8,6 +8,7 @@ import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaFileParser;
 import depends.extractor.java.JavaImportLookupStrategy;
 import depends.relations.Inferer;
+import depends.util.TemporaryFile;
 
 public abstract class JavaParserTest  extends ParserTest{
 	protected  EntityRepo entityRepo ;
@@ -16,6 +17,7 @@ public abstract class JavaParserTest  extends ParserTest{
 	public void init() {
 		entityRepo = new InMemoryEntityRepo();
 		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(),new JavaBuiltInType(),false);
+    	TemporaryFile.reset();
 	}
 	
 	public JavaFileParser createParser(String src) {

726e7cf33488092f65880606f55825fe308d1233
@@ -5,6 +5,7 @@ import java.util.List;
 
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
+import depends.util.TemporaryFile;
 
 public abstract class MavenParserTest {
 
@@ -20,6 +21,8 @@ public abstract class MavenParserTest {
 		
 		this.repo = p.getEntityRepo();
 		this.inferer = p.inferer;
+    	TemporaryFile.reset();
+
     }
 	
 	public PomFileParser createParser(String src) {

726e7cf33488092f65880606f55825fe308d1233
@@ -9,6 +9,7 @@ import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
 import depends.relations.Inferer;
 import depends.util.FileUtil;
+import depends.util.TemporaryFile;
 
 public abstract class PythonParserTest extends ParserTest implements ParserCreator {
 
@@ -24,6 +25,8 @@ public abstract class PythonParserTest extends ParserTest implements ParserCreat
 		
 		this.repo = p.getEntityRepo();
 		this.inferer = p.inferer;
+    	TemporaryFile.reset();
+		
     }
 	
 	public PythonFileParser createParser(String src) {

726e7cf33488092f65880606f55825fe308d1233
@@ -12,6 +12,7 @@ import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
+import depends.util.TemporaryFile;
 public abstract class RubyParserTest extends ParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
@@ -19,6 +20,7 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 	public void init() {
 		entityRepo = new InMemoryEntityRepo();
 		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType(),true);
+    	TemporaryFile.reset();
 	}
 	
 	public FileParser createFileParser(String src) {

c3e4b3a4fc2adb7d51b05cd5c325dbcf8fe87618
@@ -30,7 +30,6 @@ import javax.xml.bind.annotation.XmlElement;
 import javax.xml.bind.annotation.XmlRootElement;
 import java.util.Map;
 
-@XmlRootElement(name = "cell")
 public class JCellObject {
     private int src;
     private int dest;

7545793da4fccfc898807820f12e37b8213995c1
@@ -0,0 +1,27 @@
+package depends.format.json;
+
+public class DetailItem {
+
+	private String src;
+	private String dest;
+	private String type;
+
+	public DetailItem(String src, String dest, String type) {
+		this.src = src;
+		this.dest = dest;
+		this.type = type;
+	}
+
+	public String getSrc() {
+		return src;
+	}
+
+	public String getDest() {
+		return dest;
+	}
+
+	public String getType() {
+		return type;
+	}
+
+}

7545793da4fccfc898807820f12e37b8213995c1
@@ -28,12 +28,15 @@ package depends.format.json;
 import javax.xml.bind.annotation.XmlAttribute;
 import javax.xml.bind.annotation.XmlElement;
 import javax.xml.bind.annotation.XmlRootElement;
+
+import java.util.List;
 import java.util.Map;
 
 public class JCellObject {
     private int src;
     private int dest;
     private Map<String, Float> values;
+    private List<DetailItem> details;
 
     public int getSrc() {
         return src;
@@ -61,4 +64,12 @@ public class JCellObject {
     public Map<String, Float> getValues() {
         return values;
     }
+
+	public List<DetailItem> getDetails() {
+		return details;
+	}
+
+	public void setDetails(List<DetailItem> details) {
+		this.details = details;
+	}
 }

7545793da4fccfc898807820f12e37b8213995c1
@@ -30,6 +30,7 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.PackageEntity;
+import depends.entity.PackageNamePrefixRemover;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
@@ -65,16 +66,15 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 		FileEntity file = (FileEntity) entity.getAncestorOfType(FileEntity.class);
 		String name = stripper.stripFilename(file.getRawName());
 		name = filenameWritter.reWrite(name);
-		PackageEntity pkg = (PackageEntity) entity.getAncestorOfType(PackageEntity.class);
-		String functionName = entity.getQualifiedName();
-		if (pkg!=null) {
-			functionName = functionName.substring(pkg.getQualifiedName().length()+1);
-		}
+		String functionName = PackageNamePrefixRemover.remove(entity);
 		name = name + "("+functionName+")";
 		return name;
 	}
 
 
+
+
+
 	private int getFunctionEntityIdNoException(Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
 		if (ancestor == null)

7545793da4fccfc898807820f12e37b8213995c1
@@ -0,0 +1,72 @@
+package depends.format.json;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import depends.format.excel.ExcelXlsxFormatDependencyDumper;
+import depends.matrix.core.DependencyMatrix;
+
+public class JsonFormatDependencyDumperTest {
+	DependencyMatrix dependencyMatrix;
+	 @Rule
+	  public TemporaryFolder folder= new TemporaryFolder();
+	 
+	 @Before
+	 public void init() {
+		 int SIZE = 3000;
+			dependencyMatrix = new DependencyMatrix(SIZE*100);
+			for (int i=0;i<SIZE;i++)
+				dependencyMatrix.addNode(""+i,i);
+			System.out.print("here1");
+			
+			for (int i=0;i<SIZE;i++) {
+				System.out.println("in "+i);
+				for (int j=0;j<1500;j++) {
+					dependencyMatrix.addDependency("t", i, j, 0, new ArrayList<>());
+				}
+			}
+			System.out.print("here2"); 
+	 }
+	@Test
+	public void testJson() throws IOException {
+		
+		String projectName = "test";
+		String outputDir =  folder.getRoot().getAbsolutePath();
+		outputDir = "/tmp/";
+		JsonFormatDependencyDumper dumper = new JsonFormatDependencyDumper(dependencyMatrix, projectName, outputDir);
+		dumper.output();
+		System.out.println(outputDir+File.separator+"test.json");
+		
+	}
+
+	@Test
+	public void testGson() throws IOException {
+		
+		String projectName = "test";
+		String outputDir =  folder.getRoot().getAbsolutePath();
+		outputDir = "/tmp/";
+		GsonFormatDependencyDumper dumper = new GsonFormatDependencyDumper(dependencyMatrix, projectName, outputDir);
+		dumper.output();
+		System.out.println(outputDir+File.separator+"test.gson");
+		
+	}
+	
+	@Ignore
+	public void testExcel() throws IOException {
+		String projectName = "test";
+		String outputDir =  folder.getRoot().getAbsolutePath();
+		outputDir = "/tmp/";
+		ExcelXlsxFormatDependencyDumper dumper = new ExcelXlsxFormatDependencyDumper(dependencyMatrix, projectName, outputDir);
+		dumper.output();
+		System.out.println(outputDir+File.separator+"test.xlsx");
+		
+	}
+	
+}

627d0b94e4442b328d78cdb3173b0e414350e4b7
@@ -59,7 +59,9 @@ public class DependsCommand {
     private String[] includes = new String[] {};
 	@Option(names = {"--auto-include"},split=",", description = "auto include all paths under the source path (please notice the potential side effect)")
 	private boolean autoInclude = false;
-    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+	@Option(names = {"--detail"},split=",", description = "add detail dependency information to output (only applicable for JSON output format)")
+	private boolean detail = false;	
+	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
 	}
@@ -112,4 +114,7 @@ public class DependsCommand {
 	public boolean isAutoInclude () {
 		return autoInclude;
 	}
+	public boolean isDetail () {
+		return detail;
+	}
 }

627d0b94e4442b328d78cdb3173b0e414350e4b7
@@ -25,24 +25,23 @@ SOFTWARE.
 package depends.format.json;
 
 
-import javax.xml.bind.annotation.XmlAttribute;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.bind.annotation.XmlRootElement;
-
 import java.util.List;
 import java.util.Map;
 
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.annotation.JsonInclude.Include;
+
 public class JCellObject {
     private int src;
     private int dest;
     private Map<String, Float> values;
+    @JsonInclude(Include.NON_NULL)
     private List<DetailItem> details;
 
     public int getSrc() {
         return src;
     }
 
-    @XmlAttribute(name = "src")
     public void setSrc(int src) {
         this.src = src;
     }
@@ -51,7 +50,6 @@ public class JCellObject {
         return dest;
     }
 
-    @XmlAttribute(name = "dest")
     public void setDest(int dest) {
         this.dest = dest;
     }
@@ -60,7 +58,6 @@ public class JCellObject {
         this.values = values;
     }
 
-    @XmlElement
     public Map<String, Float> getValues() {
         return values;
     }

acf62e63143ce117b2a0a298295a4ecbdf403a2e
@@ -27,12 +27,8 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
-import org.neo4j.ogm.annotation.Id;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
 
 import depends.relations.Inferer;
 import depends.relations.Relation;
@@ -45,7 +41,6 @@ import depends.relations.Relation;
  */
 public abstract class Entity {
 	
-    @Id
     Integer id=-1;
 	String qualifiedName = null;
 	String rawName = "";

acf62e63143ce117b2a0a298295a4ecbdf403a2e
@@ -27,12 +27,10 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.neo4j.ogm.annotation.Id;
 
 import depends.relations.Inferer;
 
 public class Expression {
-	@Id
 	public Integer id;
 	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;

acf62e63143ce117b2a0a298295a4ecbdf403a2e
@@ -35,7 +35,6 @@ import org.codehaus.plexus.util.FileUtils;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
-import depends.entity.repo.Neo4jEntityRepo;
 import depends.generator.DependencyGenerator;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.transform.OrderedMatrixGenerator;

acf62e63143ce117b2a0a298295a4ecbdf403a2e
@@ -4,7 +4,6 @@ import java.util.ArrayList;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
-import depends.entity.repo.Neo4jEntityRepo;
 
 import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;

acf62e63143ce117b2a0a298295a4ecbdf403a2e
@@ -2,7 +2,6 @@ package depends.extractor.java;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
-import depends.entity.repo.Neo4jEntityRepo;
 import depends.extractor.ParserTest;
 import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaFileParser;

acf62e63143ce117b2a0a298295a4ecbdf403a2e
@@ -34,7 +34,7 @@ public class JsonFormatDependencyDumperTest {
 			}
 			System.out.print("here2"); 
 	 }
-	@Test
+	 @Ignore
 	public void testJson() throws IOException {
 		
 		String projectName = "test";
@@ -46,18 +46,6 @@ public class JsonFormatDependencyDumperTest {
 		
 	}
 
-	@Test
-	public void testGson() throws IOException {
-		
-		String projectName = "test";
-		String outputDir =  folder.getRoot().getAbsolutePath();
-		outputDir = "/tmp/";
-		GsonFormatDependencyDumper dumper = new GsonFormatDependencyDumper(dependencyMatrix, projectName, outputDir);
-		dumper.output();
-		System.out.println(outputDir+File.separator+"test.gson");
-		
-	}
-	
 	@Ignore
 	public void testExcel() throws IOException {
 		String projectName = "test";

a2c4289495228f1ab1290be3da1cc817258fd805
@@ -46,7 +46,7 @@ public class OrderedMatrixGenerator  {
 			}
 		});
 	    
-	    DependencyMatrix ordered = new DependencyMatrix();
+	    DependencyMatrix ordered = new DependencyMatrix((int)(matrix.getDependencyPairs().size()/0.75+1));
 		HashMap<String, Integer> nodesMap = new HashMap<>();
 		for (int id=0;id<reMappedNodes.size();id++) {
 			nodesMap.put(reMappedNodes.get(id), id);

a2c4289495228f1ab1290be3da1cc817258fd805
@@ -20,7 +20,7 @@ public class JsonFormatDependencyDumperTest {
 	 
 	 @Before
 	 public void init() {
-		 int SIZE = 3000;
+		 int SIZE = 4000;
 			dependencyMatrix = new DependencyMatrix(SIZE*100);
 			for (int i=0;i<SIZE;i++)
 				dependencyMatrix.addNode(""+i,i);

e6e78726ec09b36570b0d97c754f4e768ea684d4
@@ -30,6 +30,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 
 import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.core.DependencyDetail;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.core.DependencyPair;
 import depends.matrix.core.DependencyValue;
@@ -65,7 +66,9 @@ public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDu
             int dst = dependencyPair.getTo();
         	writer.println("======="+files.get(src) + " -> " + files.get(dst) + "=========");
         	for (DependencyValue dependency:dependencyPair.getDependencies()) {
-        	writer.println("["+dependency.getType()+"]"+dependency.getDetails()+"\n");
+        		for (DependencyDetail item:dependency.getDetails()) {
+                	writer.println("["+dependency.getType()+"]"+item);
+        		}
         	}
         }		
 	}

07a803db91f6f468a0778546bbb4c80b878ce771
@@ -117,6 +117,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
+        entityRepo = null;
         dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
         System.out.println("dependencie data generating done successfully...");	 	
     }

6984e05975f9373d4e85fa81df47bf200627f754
@@ -140,4 +140,16 @@ public class FileEntity extends TypeEntity {
 		return importedNames;
 	}
 
+	public void cacheAllExpressions() {
+		cacheChildExpressions(this);
+	}
+
+	private void cacheChildExpressions(ContainerEntity containerEntity) {
+		this.cacheExpressions();
+		for (Entity child:containerEntity.getChildren()) {
+			if (child instanceof ContainerEntity) {
+				cacheChildExpressions((ContainerEntity)child);
+			}
+		}
+	}
 }

6984e05975f9373d4e85fa81df47bf200627f754
@@ -49,6 +49,7 @@ public class PythonFileParser implements FileParser {
 	    
 		fileEntity = entityRepo.getEntity(fileFullPath);
 		fileEntity.inferEntities(inferer);
+		((FileEntity)fileEntity).cacheAllExpressions();
 	}
 
 }

6984e05975f9373d4e85fa81df47bf200627f754
@@ -82,6 +82,7 @@ public class JRubyFileParser implements FileParser {
 			node.accept(new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator));
 			fileEntity = entityRepo.getEntity(fileFullPath);
 			fileEntity.inferEntities(inferer);
+			((FileEntity)fileEntity).cacheAllExpressions();
 		}catch(Exception e) {
 			System.err.println("parsing error in "+fileFullPath);
 		}

6984e05975f9373d4e85fa81df47bf200627f754
@@ -72,11 +72,8 @@ public class RelationCounter {
 	
 
 	private void computeContainerRelations(ContainerEntity entity) {
-		System.out.println("resolve expression of entity " + entity.getDisplayName());
-		if (!inferer.isEagerExpressionResolve()) {
-			entity.reloadExpression(repo);
-			entity.resolveExpressions(inferer);
-		}
+		entity.reloadExpression(repo);
+		entity.resolveExpressions(inferer);
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));

d65d3aad028f14df38972cd9679af3ad059a996c
@@ -42,6 +42,10 @@ public class PythonFileParser implements FileParser {
         CharStream input = CharStreams.fromFileName(fileFullPath);
         Lexer lexer = new Python3Lexer(input);
         CommonTokenStream tokens = new CommonTokenStream(lexer);
+        
+//        Python2Parser parser = new Python2Parser(tokens);
+//        Python2BaseListener bridge = new Python2BaseListener();
+        
         Python3Parser parser = new Python3Parser(tokens);
         Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();

16f682865e559a81bdf1b4ed8bdc7a224a3dfbbd
@@ -26,13 +26,14 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
-
+import java.util.List;
 
 import depends.relations.Inferer;
 
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
 	private String originName;
+	private List<Entity> referPath = new ArrayList<>();
 	public AliasEntity() {
 		
 	}
@@ -45,6 +46,11 @@ public class AliasEntity extends Entity {
 		Entity entity = inferer.resolveName(this, originName, true);
 		while(entity instanceof AliasEntity) {
 			AliasEntity aliasEntity = (AliasEntity)entity;
+			if (this.referPath.contains(aliasEntity)) {
+				entity = null;
+				break;
+			}
+			this.referPath.add(aliasEntity);
 			entity = inferer.resolveName(aliasEntity, aliasEntity.originName,true);
 			if (entity==null) break;
 			if (entity.equals(this)) {

df85ab0c0516af11202b3a5180ea3bfc13ef1491
@@ -53,7 +53,7 @@ public class DependsCommand {
     private boolean stripLeadingPath = false;
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
-	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
+	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
     private String namePathPattern="default";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};

b8f9df99bc80f96b919ac4155b65a005fa055b35
@@ -51,10 +51,15 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
+	@Option(names = {"--additional-strip-paths"}, split=",", description = "(Only valid in case of -s swith parameter)" +
+			"The additional path to be stripped since parameter <src>.  "
+			+ "Depends will strip based on length (no matter the prefix is same as the paraemter).")
+	private String[] additionalStrippedPaths = new String[]{};
+
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
-    private String namePathPattern="default";
+    private String namePathPattern="";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
 	@Option(names = {"--auto-include"},split=",", description = "auto include all paths under the source path (please notice the potential side effect)")
@@ -117,4 +122,10 @@ public class DependsCommand {
 	public boolean isDetail () {
 		return detail;
 	}
+	public String[] getAdditionalStrippedPaths() {
+		return additionalStrippedPaths;
+	}
+	public void setAdditionalStrippedPaths(String[] additionalStrippedPaths) {
+		this.additionalStrippedPaths = additionalStrippedPaths;
+	}
 }

b8f9df99bc80f96b919ac4155b65a005fa055b35
@@ -0,0 +1,10 @@
+package depends;
+
+public class ParameterException extends Exception {
+	public ParameterException(String message) {
+		super( message);
+	}
+
+	private static final long serialVersionUID = 1L;
+
+}

57c503c3c73449ea92cc6724d5ee4b31560cf138
@@ -130,6 +130,9 @@ abstract public class AbstractLangProcessor {
 			public void visit(File file) {
 				String fileFullPath = file.getAbsolutePath();
 				fileFullPath = FileUtil.uniqFilePath(fileFullPath);
+				if (!fileFullPath.startsWith(inputSrcPath)) {
+					return;
+				}
 	            FileParser fileParser = createFileParser(fileFullPath);
 	            try {
 	                System.out.println("parsing " + fileFullPath 

a11589b4c77d6b7e160aaf42c4e43b68cf307ff2
@@ -52,10 +52,8 @@ public class DependsCommand {
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
 	@Option(names = {"--additional-strip-paths"}, split=",", description = "(Only valid in case of -s swith parameter)" +
-			"The additional path to be stripped since parameter <src>.  "
-			+ "Depends will strip based on length (no matter the prefix is same as the paraemter).")
+			"The additional path to be stripped since parameter <src>.  ")
 	private String[] additionalStrippedPaths = new String[]{};
-
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")

0930bcc29e0373a50dd49307f487792844e719e7
@@ -52,10 +52,7 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 			Entity imported = repo.getEntity(importedItem.getContent());
 			if (imported==null) continue;
 			if (imported instanceof PackageEntity) { 
-				//expand import of package to all classes under the package due to we dis-courage the behavior
-				for (Entity child:imported.getChildren()) {
-					result.add(child);
-				}
+				//ignore wildcard import relation
 			}else {
 				result.add(imported);
 			}
@@ -65,7 +62,20 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 
 	@Override
 	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
-		return getImportedRelationEntities(importedList,repo);
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) continue;
+			if (imported instanceof PackageEntity) { 
+				//expand import of package to all classes under the package due to we dis-courage the behavior
+				for (Entity child:imported.getChildren()) {
+					result.add(child);
+				}
+			}else {
+				result.add(imported);
+			}
+		}
+		return result;
 	}
 
 	@Override

61edc7a615a530bdbb27d3a53d524021c890e2f6
@@ -51,9 +51,9 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
-	@Option(names = {"--additional-strip-paths"}, split=",", description = "(Only valid in case of -s swith parameter)" +
-			"The additional path to be stripped since parameter <src>.  ")
-	private String[] additionalStrippedPaths = new String[]{};
+	@Option(names = {"--strip-paths"}, split=",", description =  "The path(s) to be stripped. if -s enabled, the path(s) start after <src>. "
+			+ "Otherwise, the path(s) should be valid.")
+	private String[] strippedPaths = new String[]{};
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
@@ -120,10 +120,10 @@ public class DependsCommand {
 	public boolean isDetail () {
 		return detail;
 	}
-	public String[] getAdditionalStrippedPaths() {
-		return additionalStrippedPaths;
+	public String[] getStrippedPaths() {
+		return strippedPaths;
 	}
-	public void setAdditionalStrippedPaths(String[] additionalStrippedPaths) {
-		this.additionalStrippedPaths = additionalStrippedPaths;
+	public void setStrippedPaths(String[] strippedPaths) {
+		this.strippedPaths = strippedPaths;
 	}
 }

19905e02bef259e154ffb4601b513ac813222244
@@ -139,6 +139,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
+
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
 			if (expression.getType() != null)

19905e02bef259e154ffb4601b513ac813222244
@@ -69,7 +69,11 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 			if (imported instanceof PackageEntity) { 
 				//expand import of package to all classes under the package due to we dis-courage the behavior
 				for (Entity child:imported.getChildren()) {
-					result.add(child);
+					if (child instanceof FileEntity) {
+						child.getChildren().forEach(item->result.add(item));
+					}else {
+						result.add(child);
+					}
 				}
 			}else {
 				result.add(imported);

19905e02bef259e154ffb4601b513ac813222244
@@ -0,0 +1,54 @@
+package depends.extractor.java;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.entity.TypeEntity;
+import depends.extractor.FileParser;
+
+public class JavaExpressionCreatorTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_should_found_creator_with_full_path() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/java-code-examples/JavaExpressionCreator/A.java",
+	    		"./src/test/resources/java-code-examples/JavaExpressionCreator/b/B.java",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity entity = (entityRepo.getEntity("A.foo"));
+	    this.assertContainsRelation(entity, DependencyType.CREATE, "b.B");
+	}
+	
+	
+	@Test
+	public void test_should_found_creator_with_imported_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/java-code-examples/JavaExpressionCreator/X.java",
+	    		"./src/test/resources/java-code-examples/JavaExpressionCreator/b/B.java",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity entity = (entityRepo.getEntity("X.foo"));
+	    this.assertContainsRelation(entity, DependencyType.CREATE, "b.B");
+	}
+	
+	
+	
+}

19905e02bef259e154ffb4601b513ac813222244
@@ -0,0 +1,35 @@
+package depends.extractor.java;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.TypeEntity;
+import depends.extractor.FileParser;
+
+public class JavaFileImportTest extends JavaParserTest{
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_wildcard_import_should_be_lookedup() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/java-code-examples/JavaFileImportExample/a/Importing.java",
+	    		"./src/test/resources/java-code-examples/JavaFileImportExample/b/B.java",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    TypeEntity type = (TypeEntity)(entityRepo.getEntity("a.Importing"));
+	    this.assertContainsRelation(type, DependencyType.INHERIT, "b.B");
+	}
+	
+	
+}

19905e02bef259e154ffb4601b513ac813222244
@@ -0,0 +1,5 @@
+public class A{
+	void foo() {
+		Object x = new b.B();
+	}
+}
\ No newline at end of file

19905e02bef259e154ffb4601b513ac813222244
@@ -0,0 +1,6 @@
+import b.*;
+public class X{
+	void foo() {
+		Object x = new B();
+	}
+}
\ No newline at end of file

19905e02bef259e154ffb4601b513ac813222244
@@ -0,0 +1,4 @@
+package b;
+public class B{
+	
+}
\ No newline at end of file

19905e02bef259e154ffb4601b513ac813222244
@@ -0,0 +1,6 @@
+package a;
+import b.*;
+
+class Importing extends B{
+
+}
\ No newline at end of file

19905e02bef259e154ffb4601b513ac813222244
@@ -0,0 +1,5 @@
+package b;
+
+class B{
+
+}
\ No newline at end of file

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -206,4 +206,29 @@ public abstract class Entity {
 		child.setParent(parent);
 		parent.addChild(child);
 	}
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((id == null) ? 0 : id.hashCode());
+		return result;
+	}
+	
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		Entity other = (Entity) obj;
+		if (id == null) {
+			if (other.id != null)
+				return false;
+		} else if (!id.equals(other.id))
+			return false;
+		return true;
+	}
+	
 }

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -35,6 +35,7 @@ import org.codehaus.plexus.util.FileUtils;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
+import depends.format.detail.UnsolvedSymbolDumper;
 import depends.generator.DependencyGenerator;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.transform.OrderedMatrixGenerator;
@@ -77,6 +78,7 @@ abstract public class AbstractLangProcessor {
 	private String inputSrcPath;
 	public String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
+	private Set<UnsolvedBindings> unsolved;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
@@ -108,9 +110,10 @@ abstract public class AbstractLangProcessor {
  	 */
     private void resolveBindings() {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-        Set<String> unsolved = inferer.resolveAllBindings();
-        if (unsolved.size()>0)
-        	System.err.println("The following items are unsolved." + unsolved);
+        this.unsolved =inferer.resolveAllBindings();
+        if (getUnsolved().size()>0) {
+        	System.err.println("There are " + getUnsolved().size() + " items are unsolved." );
+        }
         System.out.println("types and bindings resolved successfully...");
     }
     
@@ -178,5 +181,8 @@ abstract public class AbstractLangProcessor {
 		this.dependencyGenerator = dependencyGenerator;
 	}
 	public abstract List<String> supportedRelations();
+	public Set<UnsolvedBindings> getUnsolved() {
+		return unsolved;
+	}
 
 }

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -28,10 +28,12 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
+import depends.extractor.UnsolvedBindings;
 import depends.importtypes.FileImport;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
@@ -92,12 +94,15 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 	}
 
 	@Override
-	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			if (!(importedItem instanceof FileImport)) {
 				Entity imported = repo.getEntity(importedItem.getContent());
-				if (imported==null) continue;
+				if (imported==null) {
+					unsolvedBindings.add(new UnsolvedBindings(importedItem.getContent(),null));
+					continue;
+				}
 				result.add(imported);
 			}
 		}

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -26,10 +26,12 @@ package depends.extractor.empty;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
+import depends.extractor.UnsolvedBindings;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
@@ -47,7 +49,7 @@ public class EmptyImportLookupStategy implements ImportLookupStrategy {
 	}
 
 	@Override
-	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
+	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
 		return new ArrayList<Entity>();
 	}
 

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -26,11 +26,13 @@ package depends.extractor.java;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.PackageEntity;
 import depends.entity.repo.EntityRepo;
+import depends.extractor.UnsolvedBindings;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
@@ -61,11 +63,14 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	}
 
 	@Override
-	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			Entity imported = repo.getEntity(importedItem.getContent());
-			if (imported==null) continue;
+			if (imported==null) {
+				unsolvedBindings.add(new UnsolvedBindings(importedItem.getContent(),null));
+				continue;
+			}
 			if (imported instanceof PackageEntity) { 
 				//expand import of package to all classes under the package due to we dis-courage the behavior
 				for (Entity child:imported.getChildren()) {

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -0,0 +1,29 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.ContainerEntity;
+import depends.extractor.UnsolvedBindings;
+
+public class UnsolvedSymbolsTest extends JavaParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test_missing_import() throws IOException {
+        String src = "./src/test/resources/java-code-examples/UnsolvedSymbols/MissingImport.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        Set<UnsolvedBindings> missing = inferer.resolveAllBindings();
+        assertEquals(1,missing.size());
+        assertEquals("a.b",missing.iterator().next().getRawName());
+	}
+
+}

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -0,0 +1,4 @@
+import a.b;
+public class MissingImport{
+	
+}
\ No newline at end of file

b85b588c09022c409e4fadb03776162541d770df
@@ -64,6 +64,8 @@ public class DependsCommand {
 	private boolean autoInclude = false;
 	@Option(names = {"--detail"},split=",", description = "add detail dependency information to output (only applicable for JSON output format)")
 	private boolean detail = false;	
+	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
+	private boolean autoStub = false;	
 	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
@@ -126,4 +128,7 @@ public class DependsCommand {
 	public void setStrippedPaths(String[] strippedPaths) {
 		this.strippedPaths = strippedPaths;
 	}
+	public boolean isAutoStub() {
+		return autoStub;
+	}
 }

b85b588c09022c409e4fadb03776162541d770df
@@ -95,7 +95,7 @@ public class FileEntity extends TypeEntity {
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
 		this.importedRelationEntities = inferer.getImportedRelationEntities(importedNames);
-		this.importedTypes = inferer.getImportedTypes(importedNames);
+		this.importedTypes = inferer.getImportedTypes(importedNames,this);
 		this.importedFiles = inferer.getImportedFiles(importedNames);
 
 		super.inferLocalLevelEntities(inferer);

b85b588c09022c409e4fadb03776162541d770df
@@ -0,0 +1,26 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class GenericTypeTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void test_parameter() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("foo"), DependencyType.CALL, "GetMax");
+	}
+
+}

aa24d5986c6687569e1ec50e46d9f9d6e6e26e7b
@@ -25,7 +25,11 @@ SOFTWARE.
 package depends;
 
 import java.util.ArrayList;
+import java.util.List;
+
+import depends.deptypes.DependencyType;
 import depends.extractor.LangProcessorRegistration;
+import edu.emory.mathcs.backport.java.util.Arrays;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
@@ -37,6 +41,11 @@ public class DependsCommand {
 		public SupportedLangs() { super( LangProcessorRegistration.getRegistry().getLangs()); }
 	}
 	
+	public static class SupportedTypes extends ArrayList<String> {
+		private static final long serialVersionUID = 1L;
+		public SupportedTypes() { super( DependencyType.allDependencies()); }
+	}
+	
 	@Parameters(index = "0", completionCandidates = DependsCommand.SupportedLangs.class, description = "The lanauge of project files: [${COMPLETION-CANDIDATES}]")
     private String lang;
 	@Parameters(index = "1", description = "The directory to be analyzed")
@@ -66,7 +75,9 @@ public class DependsCommand {
 	private boolean detail = false;	
 	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
 	private boolean autoStub = false;	
-	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+    @Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
+    private String[] typeFilter=new String[]{};
+    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
 	}
@@ -131,4 +142,10 @@ public class DependsCommand {
 	public boolean isAutoStub() {
 		return autoStub;
 	}
+	public List<String> getTypeFilter() {
+		if (typeFilter.length==0) {
+			return DependencyType.allDependencies();
+		}
+		return java.util.Arrays.asList(typeFilter);
+	}
 }

aa24d5986c6687569e1ec50e46d9f9d6e6e26e7b
@@ -79,6 +79,7 @@ abstract public class AbstractLangProcessor {
 	public String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> unsolved;
+	private List<String> typeFilter;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
@@ -95,9 +96,10 @@ abstract public class AbstractLangProcessor {
      * @param includeDir 
      * @param inputDir 
      */
-	public void buildDependencies(String inputDir, String[] includeDir) {
+	public void buildDependencies(String inputDir, String[] includeDir,List<String> typeFilter) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
+		this.typeFilter = typeFilter;
         parseAllFiles();
         resolveBindings();
         identifyDependencies();
@@ -119,7 +121,7 @@ abstract public class AbstractLangProcessor {
     
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
-        dependencyMatrix  = dependencyGenerator.build(entityRepo);
+        dependencyMatrix  = dependencyGenerator.build(entityRepo,typeFilter);
         entityRepo = null;
 		System.out.println("reorder dependency matrix...");	
         dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();

aa24d5986c6687569e1ec50e46d9f9d6e6e26e7b
@@ -0,0 +1,73 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.format.dot;
+
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+
+import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.DependencyPair;
+
+public class DotFullnameDependencyDumper extends  AbstractFormatDependencyDumper{
+	ArrayList<String> files  = null;
+	@Override
+	public String getFormatName() {
+		return "dotx";
+	}
+	public DotFullnameDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+	@Override
+	public boolean output() {
+		PrintWriter writer;
+		try {
+			writer = new PrintWriter(composeFilename()+".dot");
+			files = matrix.getNodes();
+			
+			writer.println("digraph");
+			writer.println("{");
+	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
+
+	        addRelations(writer,dependencyPairs); 
+			writer.println("}");
+			writer.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
+		for (DependencyPair dependencyPair:dependencyPairs) {
+            int src = dependencyPair.getFrom();
+            int dst = dependencyPair.getTo();
+        	writer.println("\t\""+files.get(src) + "\" -> \"" + files.get(dst) + "\";");
+        }		
+	}
+}

aa24d5986c6687569e1ec50e46d9f9d6e6e26e7b
@@ -42,8 +42,8 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	 * @return the generated dependency matrix
 	 */
 	@Override
-	public DependencyMatrix build(EntityRepo entityRepo) {
-		DependencyMatrix dependencyMatrix = new DependencyMatrix();
+	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
 		Iterator<Entity> iterator = entityRepo.getEntities();
 		System.out.println("Start create dependencies matrix....");
 		while(iterator.hasNext()) {

aa24d5986c6687569e1ec50e46d9f9d6e6e26e7b
@@ -25,19 +25,19 @@ SOFTWARE.
 package depends.generator;
 
 import java.util.Iterator;
+import java.util.List;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
-import depends.entity.PackageEntity;
 import depends.entity.PackageNamePrefixRemover;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
 
 public class FunctionDependencyGenerator extends DependencyGenerator {
-	public DependencyMatrix build(EntityRepo entityRepo) {
-		DependencyMatrix dependencyMatrix = new DependencyMatrix();
+	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
 		Iterator<Entity> iterator = entityRepo.getEntities();
 		while(iterator.hasNext()) {
 			Entity entity = iterator.next();

aa24d5986c6687569e1ec50e46d9f9d6e6e26e7b
@@ -26,7 +26,7 @@ public class ForwardDeclareTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         FileDependencyGenerator dependencyGenerator= new FileDependencyGenerator();
-        dependencyGenerator.build(repo);
+        //TODO: to be complete
 	}
 	
 }

bb887997ab2826a6488d5d700a4fc8ce367d06f8
@@ -78,7 +78,7 @@ public class RelationCounter {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
 			for (Entity type:var.getResolvedTypeParameters()) {
-				entity.addRelation(new Relation(DependencyType.USE,type));
+				var.addRelation(new Relation(DependencyType.PARAMETER,type));
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {

bb887997ab2826a6488d5d700a4fc8ce367d06f8
@@ -21,7 +21,6 @@ public class CppExpressionTest extends CppParserTest{
         inferer.resolveAllBindings();
         Entity e = repo.getEntity("foo");
         this.assertContainsRelation(e, DependencyType.PARAMETER,"ClassA");
-        this.assertContainsRelation(e, DependencyType.CONTAIN,"ClassA");
         this.assertContainsRelation(e, DependencyType.CAST,"ClassA");
         this.assertContainsRelation(e, DependencyType.CALL,"ClassA");
         this.assertContainsRelation(e, DependencyType.CREATE,"ClassA");
@@ -29,6 +28,7 @@ public class CppExpressionTest extends CppParserTest{
         this.assertContainsRelation(e, DependencyType.USE,"foo.a2");
         this.assertContainsRelation(e, DependencyType.USE,"foo.a3");
         this.assertContainsRelation(e, DependencyType.USE,"foo.a");        
+        this.assertContainsRelation(e, DependencyType.CONTAIN,"ClassA");
 	}
 
 }

bb887997ab2826a6488d5d700a4fc8ce367d06f8
@@ -1,6 +1,4 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
 import java.io.IOException;
 
 import org.junit.Before;
@@ -15,12 +13,12 @@ public class GenericTypeTest extends CppParserTest{
     }
 	
 	@Test
-	public void test_parameter() throws IOException {
+	public void test_genericTypes() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("foo"), DependencyType.CALL, "GetMax");
+        this.assertContainsRelation(repo.getEntity("xStack"), DependencyType.PARAMETER, "X");
 	}
 
 }

bb887997ab2826a6488d5d700a4fc8ce367d06f8
@@ -6,6 +6,8 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
+
 public class JavaGenericTypeTest extends JavaParserTest{
 	@Before
 	public void setUp() {
@@ -18,6 +20,7 @@ public class JavaGenericTypeTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(2,entityRepo.getEntity("x.GenericTypeTest").getRelations().size());
+        this.assertContainsRelation(entityRepo.getEntity("x.GenericTypeTest.v"),
+        		DependencyType.PARAMETER, "x.Parent2.Enum");
 	}
 }

bb887997ab2826a6488d5d700a4fc8ce367d06f8
@@ -86,7 +86,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(16,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
+        assertEquals(15,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
 	@Test
@@ -95,7 +95,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(2,entityRepo.getEntity("JDepObject").getRelations().size());
+        this.assertContainsRelation(entityRepo.getEntity("JDepObject.cells"),DependencyType.PARAMETER, "JCellObject");
 	}
 	
 }

ea0cf029286c322a92de1f33ae11f00071de3a91
@@ -141,7 +141,7 @@ public class ExpressionUsage {
 	private String getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
 		IASTExpression f = methodCall.getFunctionNameExpression();
 		if (f instanceof IASTIdExpression) {
-			return ((IASTIdExpression)f).getName().toString();
+			return ((IASTIdExpression)f).getName().toString().replace("::", ".");
 		}
 		return null;
 	}

ea0cf029286c322a92de1f33ae11f00071de3a91
@@ -0,0 +1,24 @@
+package depends.extractor.cpp;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class AliasTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void test_genericTypes() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/Alias.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "F.foo");
+	}
+
+}

660a4ca1672387e472d4afdcb4b32f06add02260
@@ -1,4 +1,6 @@
 package depends.extractor.cpp;
+import static org.junit.Assert.assertNotNull;
+
 import java.io.IOException;
 
 import org.junit.Before;
@@ -13,12 +15,33 @@ public class GenericTypeTest extends CppParserTest{
     }
 	
 	@Test
-	public void test_genericTypes() throws IOException {
+	public void test_templateSpecializationOfStruct() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity("hash"));
+	}
+
+    @Test
+	public void test_genericTypesVarDefinition() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
         this.assertContainsRelation(repo.getEntity("xStack"), DependencyType.PARAMETER, "X");
 	}
+	
+    @Test
+	public void test_extendGenericTypes() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
+	}
+	
+	
+	
 
 }

4f47c91b8afdbec29e73ee4d3c49a1d54963e8ff
@@ -16,7 +16,7 @@ public class GenericTypeTest extends CppParserTest{
 	
 	@Test
 	public void test_templateSpecializationOfStruct() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	    String src = "./src/test/resources/cpp-code-examples/template/TempateStructure.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
@@ -24,8 +24,8 @@ public class GenericTypeTest extends CppParserTest{
 	}
 
     @Test
-	public void test_genericTypesVarDefinition() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	public void test_genericTypesVarParameterReference() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
@@ -33,8 +33,8 @@ public class GenericTypeTest extends CppParserTest{
 	}
 	
     @Test
-	public void test_extendGenericTypes() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	public void test_genericTypesExtends() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();

0f27f45e35c0714b1aac19ddfd898a40c77838e0
@@ -185,7 +185,7 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void addTypeParameter(List<String> typeArguments) {
+	public void addTypeParameter(List<GenericTypeArgument> typeArguments) {
 		System.err.println("error: addTypeParameter should not been invoked");
 		super.addTypeParameter(typeArguments);
 	}
@@ -197,7 +197,7 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void addTypeParameter(String typeName) {
+	public void addTypeParameter(GenericTypeArgument typeName) {
 		System.err.println("error: addTypeParameter should not been invoked");
 		super.addTypeParameter(typeName);
 	}

0f27f45e35c0714b1aac19ddfd898a40c77838e0
@@ -29,12 +29,13 @@ import java.util.List;
 import java.util.Stack;
 import java.util.stream.Collectors;
 
+import depends.entity.AliasEntity;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.PackageEntity;
-import depends.entity.AliasEntity;
+import depends.entity.GenericTypeArgument;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
@@ -208,12 +209,12 @@ public abstract class HandlerContext {
 		
 	}
 
-	public void foundTypeParametes(String typeName) {
+	public void foundTypeParametes(GenericTypeArgument typeName) {
 		lastContainer().addTypeParameter(typeName);
 	}
 
 
-	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<String> typeArguments) {
+	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericTypeArgument> typeArguments) {
 		return varNames.stream().map(item->foundVarDefinition(item,type,typeArguments)).collect(Collectors.toList());
 	}
 	
@@ -234,7 +235,7 @@ public abstract class HandlerContext {
 	
 
 
-	public VarEntity foundVarDefinition(String varName, String type, List<String> typeArguments) {
+	public VarEntity foundVarDefinition(String varName, String type, List<GenericTypeArgument> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);	

0f27f45e35c0714b1aac19ddfd898a40c77838e0
@@ -28,6 +28,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.FunctionEntity;
+import depends.entity.GenericTypeArgument;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.java.JavaParser.AnnotationConstantRestContext;
@@ -192,7 +193,7 @@ public class JavaListener extends JavaParserBaseListener {
 		FunctionEntity method = context.foundMethodDeclarator(methodName, returnedType, throwedType);
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		if (ctx.typeParameters() != null) {
-			List<String> parameters = TypeParameterContextHelper.getTypeParameters(ctx.typeParameters());
+			List<GenericTypeArgument> parameters = TypeParameterContextHelper.getTypeParameters(ctx.typeParameters());
 			method.addTypeParameter(parameters);
 		}
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",context.lastContainer());
@@ -255,7 +256,7 @@ public class JavaListener extends JavaParserBaseListener {
 	public void enterFieldDeclaration(FieldDeclarationContext ctx) {
 		List<String> varNames = VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators());
 		String type = ClassTypeContextHelper.getClassName(ctx.typeType());
-		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		List<VarEntity> vars = context.foundVarDefinitions(varNames, type,typeArguments);
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterFieldDeclaration(ctx);
@@ -265,7 +266,7 @@ public class JavaListener extends JavaParserBaseListener {
 
 	@Override
 	public void enterConstDeclaration(ConstDeclarationContext ctx) {
-		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		annotationProcessor.processAnnotationModifier(ctx, InterfaceBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
@@ -304,14 +305,14 @@ public class JavaListener extends JavaParserBaseListener {
 	// TODO: all modifier have not processed yet.
 	@Override
 	public void enterLocalVariableDeclaration(LocalVariableDeclarationContext ctx) {
-		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		super.enterLocalVariableDeclaration(ctx);
 	}
 
 	public void enterEnhancedForControl(EnhancedForControlContext ctx) {
-		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		super.enterEnhancedForControl(ctx);
@@ -322,7 +323,7 @@ public class JavaListener extends JavaParserBaseListener {
 //    ;
 	@Override
 	public void enterResource(ResourceContext ctx) {
-		List<String> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
+		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
 		context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
 				IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER()),typeArguments);
 		super.enterResource(ctx);
@@ -354,10 +355,10 @@ public class JavaListener extends JavaParserBaseListener {
 			TypeParameterContext typeParam = typeParameters.typeParameter(i);
 			if (typeParam.typeBound() != null) {
 				for (int j = 0; j < typeParam.typeBound().typeType().size(); j++) {
-					context.foundTypeParametes(ClassTypeContextHelper.getClassName(typeParam.typeBound().typeType(j)));
+					context.foundTypeParametes(new GenericTypeArgument(ClassTypeContextHelper.getClassName(typeParam.typeBound().typeType(j))));
 				}
 			}
-			context.currentType().addTypeParameter(typeParam.IDENTIFIER().getText());
+			context.currentType().addTypeParameter(new GenericTypeArgument(typeParam.IDENTIFIER().getText()));
 		}
 	}
 	

0f27f45e35c0714b1aac19ddfd898a40c77838e0
@@ -27,15 +27,16 @@ package depends.extractor.java.context;
 import java.util.ArrayList;
 import java.util.List;
 
+import depends.entity.GenericTypeArgument;
 import depends.extractor.java.JavaParser.TypeParameterContext;
 import depends.extractor.java.JavaParser.TypeParametersContext;
 
 public class TypeParameterContextHelper {
 
-	public static List<String> getTypeParameters(TypeParametersContext typeParameters) {
-		ArrayList<String> r = new ArrayList<>();
+	public static List<GenericTypeArgument> getTypeParameters(TypeParametersContext typeParameters) {
+		ArrayList<GenericTypeArgument> r = new ArrayList<>();
 		for(TypeParameterContext param:typeParameters.typeParameter()) {
-			r.add(param.IDENTIFIER().getText());
+			r.add(new GenericTypeArgument(param.IDENTIFIER().getText()));
 		}
 		return r;
 	}

e4aee9821aa7bdbf986ca83374d8825100bd1e05
@@ -23,4 +23,18 @@ public class JavaGenericTypeTest extends JavaParserTest{
         this.assertContainsRelation(entityRepo.getEntity("x.GenericTypeTest.v"),
         		DependencyType.PARAMETER, "x.Parent2.Enum");
 	}
+	
+	@Test
+	public void test_GenericTypeEmbededShouldBeIdentified() throws IOException {
+        String src = "./src/test/resources/java-code-examples/GenericTypeEmbededTest.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest"),
+        		DependencyType.CONTAIN, "MyHashMap");
+        this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyList");
+        this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyArray");
+	}
 }

e4aee9821aa7bdbf986ca83374d8825100bd1e05
@@ -0,0 +1,15 @@
+class MyHashMap<T1, T2>{
+	
+}
+
+class MyList<T> {
+	
+}
+
+class MyArray<T>{
+	
+}
+
+class GenericTypeEmbededTest{
+	MyHashMap<String, MyList<MyArray<Integer>> > data; 
+}
\ No newline at end of file

9b475588a45e0b9b3047abd7c885c4a453bbe838
@@ -7,6 +7,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.extractor.java.JavaFileParser;
 
 public class GenericTypeTest extends CppParserTest{
     @Before
@@ -41,6 +42,20 @@ public class GenericTypeTest extends CppParserTest{
         this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
 	}
 	
+    
+    @Test
+	public void test_GenericTypeEmbededShouldBeIdentified() throws IOException {
+        String src = "./src/test/resources/cpp-code-examples/template/EmbededTemplates.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest"),
+        		DependencyType.CONTAIN, "MyHashMap");
+        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyList");
+        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyArray");
+	}
 	
 	
 

798ea0a62faa74ceb61b5966b9724fd7e37b0c56
@@ -7,6 +7,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
 import depends.extractor.java.JavaFileParser;
 
 public class GenericTypeTest extends CppParserTest{
@@ -57,6 +58,25 @@ public class GenericTypeTest extends CppParserTest{
         		DependencyType.PARAMETER, "MyArray");
 	}
 	
+    @Test
+	public void test_TemplateWithDots() throws IOException {
+        String src = "./src/test/resources/cpp-code-examples/template/TemplateWithDots.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity("foo.t2"));
+	}
+	
+    @Test
+	public void test_TemplateInReturn() throws IOException {
+        String src = "./src/test/resources/cpp-code-examples/template/TemplateInReturnValue.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        FunctionEntity func = (FunctionEntity)repo.getEntity("get");
+      	this.assertContainsRelation(func, DependencyType.RETURN, "std.tuple_element.type");
+	}
+	
 	
 
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -32,12 +32,12 @@ import depends.relations.Inferer;
 
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
-	private String originName;
+	private GenericName originName;
 	private List<Entity> referPath = new ArrayList<>();
 	public AliasEntity() {
 		
 	}
-	public AliasEntity(String simpleName, Entity parent, Integer id, String originTypeName) {
+	public AliasEntity(GenericName simpleName, Entity parent, Integer id, GenericName originTypeName) {
 		super(simpleName, parent, id);
 		this.originName = originTypeName;
 	}
@@ -90,21 +90,21 @@ public class AliasEntity extends Entity {
 		return origin.getFunctions();
 	}
 
-	protected FunctionEntity lookupFunctionLocally(String functionName) {
+	protected FunctionEntity lookupFunctionLocally(GenericName functionName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
 		return origin.lookupFunctionLocally(functionName);
 	}
 
-	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+	public FunctionEntity lookupFunctionInVisibleScope(GenericName functionName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
 		return origin.lookupFunctionInVisibleScope(functionName);
 	}
 
-	public VarEntity lookupVarsInVisibleScope(String varName) {
+	public VarEntity lookupVarsInVisibleScope(GenericName varName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -28,6 +28,6 @@ import java.util.UUID;
 
 public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock(Entity parent, Integer id) {
-    	super(UUID.randomUUID().toString(),  parent, id);
+    	super(new GenericName(UUID.randomUUID().toString()),  parent, id);
 	}
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -39,7 +39,7 @@ public class CandidateTypes extends TypeEntity {
 		candidateTypes = new ArrayList<>();
 	}
 	public CandidateTypes(List<TypeEntity> candidateTypes) {
-		super("candidateTypes", null, -1);
+		super(new GenericName("candidateTypes"), null, -1);
 		this.candidateTypes = candidateTypes;
 	}
 
@@ -79,7 +79,7 @@ public class CandidateTypes extends TypeEntity {
 		return inheritedType;
 	}
  	@Override
- 	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+ 	public FunctionEntity lookupFunctionInVisibleScope(GenericName functionName) {
  		for (TypeEntity type:candidateTypes) {
 			FunctionEntity f = type.lookupFunctionInVisibleScope(functionName);
 			if (f!=null) return f;
@@ -88,7 +88,7 @@ public class CandidateTypes extends TypeEntity {
 	}
  	
 	@Override
-	public VarEntity lookupVarInVisibleScope(String varName) {
+	public VarEntity lookupVarInVisibleScope(GenericName varName) {
 		for (TypeEntity type:candidateTypes) {
 			VarEntity v = type.lookupVarInVisibleScope(varName);
 			if (v!=null) return v;
@@ -119,13 +119,13 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void addImplements(String typeName) {
+	public void addImplements(GenericName typeName) {
 		System.err.println("error: addImplements should not been invoked");
 		super.addImplements(typeName);
 	}
 
 	@Override
-	public void addExtends(String typeName) {
+	public void addExtends(GenericName typeName) {
 		System.err.println("error: addExtends should not been invoked");
 		super.addExtends(typeName);
 	}
@@ -173,7 +173,7 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void addMixin(String moduleName) {
+	public void addMixin(GenericName moduleName) {
 		System.err.println("error: addMixin should not been invoked");
 		super.addMixin(moduleName);
 	}
@@ -185,19 +185,19 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void addTypeParameter(List<GenericTypeArgument> typeArguments) {
+	public void addTypeParameter(List<GenericName> typeArguments) {
 		System.err.println("error: addTypeParameter should not been invoked");
 		super.addTypeParameter(typeArguments);
 	}
 
 	@Override
-	public void addAnnotation(String name) {
+	public void addAnnotation(GenericName name) {
 		System.err.println("error: addAnnotation should not been invoked");
 		super.addAnnotation(name);
 	}
 
 	@Override
-	public void addTypeParameter(GenericTypeArgument typeName) {
+	public void addTypeParameter(GenericName typeName) {
 		System.err.println("error: addTypeParameter should not been invoked");
 		super.addTypeParameter(typeName);
 	}
@@ -215,19 +215,19 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public boolean isGenericTypeParameter(String rawType) {
+	public boolean isGenericTypeParameter(GenericName rawType) {
 		System.err.println("error: isGenericTypeParameter should not been invoked");
 		return super.isGenericTypeParameter(rawType);
 	}
 
 	@Override
-	protected Collection<Entity> identiferToEntities(Inferer inferer, Collection<String> identifiers) {
+	protected Collection<Entity> identiferToEntities(Inferer inferer, Collection<GenericName> identifiers) {
 		System.err.println("error: identiferToTypes should not been invoked");
 		return super.identiferToEntities(inferer, identifiers);
 	}
 
 	@Override
-	public String getRawName() {
+	public GenericName getRawName() {
 		System.err.println("error: getRawName should not been invoked");
 		return super.getRawName();
 	}
@@ -284,7 +284,7 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void setRawName(String rawName) {
+	public void setRawName(GenericName rawName) {
 		System.err.println("error: setRawName should not been invoked");
 		super.setRawName(rawName);
 	}

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -52,7 +52,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Object, Expression> expressions;
 	private ArrayList<Expression> expressionList;
-	private Collection<String> mixins;
+	private Collection<GenericName> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
 
 	public ContainerEntity() {
@@ -64,7 +64,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		expressionList = new ArrayList<>();
 	}
 
-	public ContainerEntity(String rawName, Entity parent, Integer id) {
+	public ContainerEntity(GenericName rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
 		functions = new ArrayList<>();
@@ -120,9 +120,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 	}
 
-	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<String> identifiers) {
+	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<GenericName> identifiers) {
 		ArrayList<ContainerEntity> r = new ArrayList<>();
-		for (String identifier : identifiers) {
+		for (GenericName identifier : identifiers) {
 			Entity entity = inferer.resolveName(this, identifier, true);
 			if (entity == null) {
 				continue;
@@ -223,22 +223,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	public TypeEntity getLastExpressionType() {
-		//TODO: 
-		/*
-    java.lang.NullPointerException
-	at depends.entity.ContainerEntity.getLastExpressionType(ContainerEntity.java:228)
-	at depends.entity.FunctionEntity.inferLocalLevelEntities(FunctionEntity.java:92)
-	at depends.entity.ContainerEntity.inferLocalLevelEntities(ContainerEntity.java:118)
-	at depends.entity.TypeEntity.inferLocalLevelEntities(TypeEntity.java:69)
-	at depends.entity.Entity.inferEntities(Entity.java:171)
-	at depends.entity.Entity.inferEntities(Entity.java:173)
-	at depends.relations.Inferer.resolveTypes(Inferer.java:91)
-	at depends.relations.Inferer.resolveAllBindings(Inferer.java:78)
-	at depends.extractor.AbstractLangProcessor.resolveBindings(AbstractLangProcessor.java:112)
-	at depends.extractor.AbstractLangProcessor.buildDependencies(AbstractLangProcessor.java:101)
-	at depends.Main.executeCommand(Main.java:121)
-	at depends.Main.main(Main.java:60) 
-		 * */
 		for (int i = this.expressionList.size() - 1; i >= 0; i--) {
 			Expression expr = this.expressionList.get(i);
 			if (expr.isStatement)
@@ -274,7 +258,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param functionName
 	 * @return
 	 */
-	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+	public FunctionEntity lookupFunctionInVisibleScope(GenericName functionName) {
 		if (this.getMutliDeclare() != null) {
 			for (ContainerEntity fromEntity : this.getMutliDeclare().getEntities()) {
 				FunctionEntity f = lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
@@ -295,7 +279,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param fromEntity
 	 * @return
 	 */
-	private FunctionEntity lookupFunctionBottomUpTillTopContainer(String functionName, ContainerEntity fromEntity) {
+	private FunctionEntity lookupFunctionBottomUpTillTopContainer(GenericName functionName, ContainerEntity fromEntity) {
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {
 				FunctionEntity func = ((ContainerEntity) fromEntity).lookupFunctionLocally(functionName);
@@ -314,7 +298,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param functionName
 	 * @return
 	 */
-	public FunctionEntity lookupFunctionLocally(String functionName) {
+	public FunctionEntity lookupFunctionLocally(GenericName functionName) {
 		for (FunctionEntity func : getFunctions()) {
 			if (func.getRawName().equals(functionName))
 				return func;
@@ -331,7 +315,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param varName
 	 * @return
 	 */
-	public VarEntity lookupVarInVisibleScope(String varName) {
+	public VarEntity lookupVarInVisibleScope(GenericName varName) {
 		ContainerEntity fromEntity = this;
 		return lookupVarBottomUpTillTopContainer(varName, fromEntity);
 	}
@@ -343,7 +327,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param varName
 	 * @return
 	 */
-	private VarEntity lookupVarBottomUpTillTopContainer(String varName, ContainerEntity fromEntity) {
+	private VarEntity lookupVarBottomUpTillTopContainer(GenericName varName, ContainerEntity fromEntity) {
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {
 				VarEntity var = ((ContainerEntity) fromEntity).lookupVarLocally(varName);
@@ -355,15 +339,19 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return null;
 	}
 
-	public VarEntity lookupVarLocally(String varName) {
+	public VarEntity lookupVarLocally(GenericName varName) {
 		for (VarEntity var : getVars()) {
 			if (var.getRawName().equals(varName))
 				return var;
 		}
 		return null;
 	}
+	
+	public VarEntity lookupVarLocally(String varName) {
+		return this.lookupVarLocally(new GenericName(varName));
+	}
 
-	public void addMixin(String moduleName) {
+	public void addMixin(GenericName moduleName) {
 		mixins.add(moduleName);
 	}
 

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -27,7 +27,7 @@ package depends.entity;
 public class EmptyTypeEntity extends TypeEntity {
 
 	public EmptyTypeEntity() {
-		super("", null, -1);
+		super(new GenericName(""), null, -1);
 	}
 
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -43,7 +43,7 @@ public abstract class Entity {
 	
     Integer id=-1;
 	String qualifiedName = null;
-	String rawName = "";
+	GenericName rawName = new GenericName("");
 	Entity parent;
 	private MultiDeclareEntities mutliDeclare = null;
 	private Set<Entity> children = new HashSet<>();
@@ -51,7 +51,7 @@ public abstract class Entity {
 	private Entity actualReferTo = null;
 
 	public Entity() {};
-    public Entity(String rawName, Entity parent, Integer id) {
+    public Entity(GenericName rawName, Entity parent, Integer id) {
 		this.qualifiedName = null;
 		this.rawName = rawName;
 		this.parent = parent;
@@ -71,26 +71,26 @@ public abstract class Entity {
 	private void deduceQualifiedName() {
 		rawName = rawName.replace("::","." );
 		if (this.rawName.startsWith(".")) {
-			this.qualifiedName = this.rawName.substring(1);
+			this.qualifiedName = this.rawName.getUniqueName().substring(1);
 			return; //already qualified
 		}
 		if (parent==null) {
-			this.qualifiedName = this.rawName;
+			this.qualifiedName = this.rawName.getUniqueName();
 			return;
 		}
 		if (parent.getQualifiedName(true)==null) {
-			this.qualifiedName = this.rawName;
+			this.qualifiedName = this.rawName.getUniqueName();
 			return;
 		}
 		if (parent.getQualifiedName(true).isEmpty()) {
-			this.qualifiedName = rawName;
+			this.qualifiedName = rawName.getUniqueName();
 			return;
 		}
-		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName;
+		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName.getUniqueName();
 	}
 
 
-	public String getRawName() {
+	public GenericName getRawName() {
 		return rawName;
 	}
 
@@ -126,7 +126,7 @@ public abstract class Entity {
 		this.qualifiedName = qualifiedName;
 	}
 
-	public void setRawName(String rawName) {
+	public void setRawName(GenericName rawName) {
 		this.rawName = rawName;
 	}
 	
@@ -175,7 +175,7 @@ public abstract class Entity {
 	}
 
 	public String getDisplayName() {
-		return getRawName();
+		return getRawName().getUniqueName();
 	}
 
 	public MultiDeclareEntities getMutliDeclare() {

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -36,8 +36,8 @@ public class Expression implements Serializable{
 	private static final long serialVersionUID = 1L;
 	public Integer id;
 	public String text; // for debug purpose
-	public String rawType; //the raw type name
-	public String identifier; // the varName, or method name, etc.
+	public GenericName rawType; //the raw type name
+	public GenericName identifier; // the varName, or method name, etc.
 	public boolean isSet = false; // is a set relation from right to leftHand
 	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
 	public boolean isCall = false;

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -43,7 +43,7 @@ public class FileEntity extends TypeEntity {
 	public FileEntity() {}
 
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
-		super(fullName, null, fileId);
+		super(new GenericName(fullName), null, fileId);
 		setQualifiedName(fullName);
 		this.isInProjectScope = isInProjectScope;
 	}

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -25,11 +25,11 @@ SOFTWARE.
 package depends.entity;
 
 public class FunctionCall {
-	private String rawName;
-	public FunctionCall(String rawName){
+	private GenericName rawName;
+	public FunctionCall(GenericName rawName){
 		this.rawName = rawName;
 	}
-	public String getRawName() {
+	public GenericName getRawName() {
 		return rawName;
 	}
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -31,15 +31,15 @@ import java.util.List;
 import depends.relations.Inferer;
 
 public class FunctionEntity extends ContainerEntity{
-	private List<String> returnTypeIdentifiers = new ArrayList<>();
+	private List<GenericName> returnTypeIdentifiers = new ArrayList<>();
 	Collection<VarEntity> parameters;
-    Collection<String> throwTypesIdentifiers = new ArrayList<>(); 
+    Collection<GenericName> throwTypesIdentifiers = new ArrayList<>(); 
 	private Collection<Entity> returnTypes = new ArrayList<>();
 	private Collection<Entity> throwTypes = new ArrayList<>();
 	public FunctionEntity() {
 		this.parameters = new ArrayList<>();
 	}
-    public FunctionEntity(String simpleName, Entity parent, Integer id, String returnType) {
+    public FunctionEntity(GenericName simpleName, Entity parent, Integer id, GenericName returnType) {
 		super(simpleName, parent,id);
 		this.returnTypes = new ArrayList<>();
 		returnTypeIdentifiers = new ArrayList<>();
@@ -61,7 +61,7 @@ public class FunctionEntity extends ContainerEntity{
 		return null;
 	}
 
-	public void addReturnType(String returnType) {
+	public void addReturnType(GenericName returnType) {
 		if (returnType==null) return;
 		this.returnTypeIdentifiers.add(returnType);
 	}
@@ -74,7 +74,7 @@ public class FunctionEntity extends ContainerEntity{
 		}
 	}
 
-	public void addThrowTypes(List<String> throwedType) {
+	public void addThrowTypes(List<GenericName> throwedType) {
 		throwTypesIdentifiers.addAll(throwedType);
 	}
 	
@@ -100,7 +100,7 @@ public class FunctionEntity extends ContainerEntity{
 		return throwTypes;
 	}
 	@Override
-	public VarEntity lookupVarInVisibleScope(String varName) {
+	public VarEntity lookupVarInVisibleScope(GenericName varName) {
 		for (VarEntity param:parameters) {
 			if (varName.equals(param.getRawName())) {
 				return param;
@@ -117,11 +117,12 @@ public class FunctionEntity extends ContainerEntity{
 		return f.getRawName()+"("+this.getQualifiedName()+")";
 	}
 	@Override
-	public VarEntity lookupVarLocally(String varName) {
+	public VarEntity lookupVarLocally(GenericName varName) {
 		for (VarEntity var:this.parameters) {
 			if (var.getRawName().equals(varName))
 				return var;
 		}
 		return super.lookupVarLocally(varName);
 	}
+
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -32,11 +32,11 @@ import depends.relations.Inferer;
 public class TypeEntity extends ContainerEntity {
 	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
 	Collection<TypeEntity> implementedTypes = new ArrayList<>();
-	Collection<String> inhertedTypeIdentifiers;
-	Collection<String> implementedIdentifiers;
+	Collection<GenericName> inhertedTypeIdentifiers;
+	Collection<GenericName> implementedIdentifiers;
 	TypeEntity inheritedType;
 	public TypeEntity() {}
-	public TypeEntity(String simpleName, Entity parent, Integer id) {
+	public TypeEntity(GenericName simpleName, Entity parent, Integer id) {
 		super(simpleName, parent, id);
 		inhertedTypeIdentifiers = new ArrayList<>();
 		implementedIdentifiers = new ArrayList<>();
@@ -69,7 +69,7 @@ public class TypeEntity extends ContainerEntity {
 		super.inferLocalLevelEntities(inferer);
 	}
 
-	public void addImplements(String typeName) {
+	public void addImplements(GenericName typeName) {
 		if (typeName==null) {
 			return;
 		}
@@ -82,7 +82,7 @@ public class TypeEntity extends ContainerEntity {
 		this.implementedIdentifiers.add(typeName);
 	}
 
-	public void addExtends(String typeName) {
+	public void addExtends(GenericName typeName) {
 		if (typeName==null) {
 			return;
 		}
@@ -108,12 +108,12 @@ public class TypeEntity extends ContainerEntity {
 	}
 
 	@Override
-	public FunctionEntity lookupFunctionLocally(String functionName) {
+	public FunctionEntity lookupFunctionLocally(GenericName functionName) {
 		Collection<TypeEntity> searchedTypes = new ArrayList<>();
 		return lookupFunctionLocally(functionName,searchedTypes);
 	}
 
-	private FunctionEntity lookupFunctionLocally(String functionName, Collection<TypeEntity> searched) {
+	private FunctionEntity lookupFunctionLocally(GenericName functionName, Collection<TypeEntity> searched) {
 		if (searched.contains(this)) return null;
 		searched.add(this);
 		FunctionEntity func = super.lookupFunctionLocally(functionName);
@@ -135,12 +135,12 @@ public class TypeEntity extends ContainerEntity {
 	}
 	
 	@Override
-	public VarEntity lookupVarLocally(String varName) {
+	public VarEntity lookupVarLocally(GenericName varName) {
 		Collection<TypeEntity> searchedTypes = new ArrayList<>();
 		return lookupVarLocally(varName,searchedTypes);
 	}
 	
-	private VarEntity lookupVarLocally(String varName, Collection<TypeEntity> searched) {
+	private VarEntity lookupVarLocally(GenericName varName, Collection<TypeEntity> searched) {
 		if (searched.contains(this)) return null;
 		searched.add(this);
 		VarEntity var = super.lookupVarLocally(varName);

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -30,23 +30,23 @@ import java.util.List;
 import depends.relations.Inferer;
 
 public class VarEntity extends ContainerEntity {
-	private String rawType;
+	private GenericName rawType;
 	private TypeEntity type;
 	private List<FunctionCall> functionCalls;
 	public VarEntity() {
 		
 	}
-	public VarEntity(String simpleName,  String rawType, Entity parent, int id) {
+	public VarEntity(GenericName simpleName,  GenericName rawType, Entity parent, int id) {
 		super(simpleName,  parent,id);
 		this.rawType = rawType;
 		functionCalls = new ArrayList<>();
 	}
 
-	public void setRawType(String rawType) {
+	public void setRawType(GenericName rawType) {
 		this.rawType =rawType;
 	}
 	
-	public String getRawType() {
+	public GenericName getRawType() {
 		return rawType;
 	}
 
@@ -80,7 +80,7 @@ public class VarEntity extends ContainerEntity {
 		return functionCalls;
 	}
 
-	public void addFunctionCall(String fname) {
+	public void addFunctionCall(GenericName fname) {
 		this.functionCalls.add(new FunctionCall(fname));
 	}
 

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -27,6 +27,7 @@ package depends.entity.repo;
 import java.util.Iterator;
 
 import depends.entity.Entity;
+import depends.entity.GenericName;
 
 public interface EntityRepo extends IdGenerator {
 	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
@@ -35,6 +36,8 @@ public interface EntityRepo extends IdGenerator {
 
 	Entity getEntity(Integer entityId);
 
+	Entity getEntity(GenericName rawName);
+
 	void add(Entity entity);
 
 	Iterator<Entity> getEntities();
@@ -42,4 +45,5 @@ public interface EntityRepo extends IdGenerator {
 	void update(Entity entity);
 
 
+
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -6,6 +6,7 @@ import java.util.LinkedList;
 import java.util.List;
 
 import depends.entity.Entity;
+import depends.entity.GenericName;
 import depends.entity.MultiDeclareEntities;
 
 public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo {
@@ -34,7 +35,7 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	public void add(Entity entity) {
 		allEntitiesByOrder.add(entity);
 		allEntitiesById.put(entity.getId(), entity);
-		String name = entity.getRawName();
+		String name = entity.getRawName().getUniqueName();
 		if (entity.getQualifiedName() != null && !(entity.getQualifiedName().isEmpty())) {
 			name = entity.getQualifiedName();
 		}
@@ -61,10 +62,11 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 
 	@Override
 	public void update(Entity entity) {
-		// TODO Auto-generated method stub
-		
 	}
 
-
+	@Override
+	public Entity getEntity(GenericName rawName) {
+		return this.getEntity(rawName.getUniqueName());
+	}
 
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -35,7 +35,7 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.PackageEntity;
-import depends.entity.GenericTypeArgument;
+import depends.entity.GenericName;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
@@ -72,7 +72,7 @@ public abstract class HandlerContext {
 	 * @return
 	 */
 	public TypeEntity foundNewType(String classOrInterfaceName) {
-		TypeEntity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
+		TypeEntity currentTypeEntity = new TypeEntity(new GenericName(classOrInterfaceName), this.latestValidContainer(),
 			idGenerator.generateId());
 		pushToStack(currentTypeEntity);
 	 	entityRepo.add(currentTypeEntity);
@@ -83,8 +83,8 @@ public abstract class HandlerContext {
 	public void foundNewTypeAlias(String aliasName, String originalName) {
 		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
 		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
-		AliasEntity currentTypeEntity = new AliasEntity(aliasName, this.latestValidContainer(),
-				idGenerator.generateId(),originalName );
+		AliasEntity currentTypeEntity = new AliasEntity(new GenericName(aliasName), this.latestValidContainer(),
+				idGenerator.generateId(),new GenericName(originalName) );
 	 	entityRepo.add(currentTypeEntity);
 		return ;		
 	}
@@ -99,8 +99,8 @@ public abstract class HandlerContext {
 	 * @return the new function enity
 	 */
 	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
-		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
-				idGenerator.generateId(),returnType);
+		FunctionEntity functionEntity = new FunctionEntity(new GenericName(methodName), this.latestValidContainer(),
+				idGenerator.generateId(),new GenericName(returnType));
 		entityRepo.add(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
@@ -209,12 +209,12 @@ public abstract class HandlerContext {
 		
 	}
 
-	public void foundTypeParametes(GenericTypeArgument typeName) {
+	public void foundTypeParametes(GenericName typeName) {
 		lastContainer().addTypeParameter(typeName);
 	}
 
 
-	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericTypeArgument> typeArguments) {
+	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericName> typeArguments) {
 		return varNames.stream().map(item->foundVarDefinition(item,type,typeArguments)).collect(Collectors.toList());
 	}
 	
@@ -235,7 +235,7 @@ public abstract class HandlerContext {
 	
 
 
-	public VarEntity foundVarDefinition(String varName, String type, List<GenericTypeArgument> typeArguments) {
+	public VarEntity foundVarDefinition(String varName, String type, List<GenericName> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);	

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -28,7 +28,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.FunctionEntity;
-import depends.entity.GenericTypeArgument;
+import depends.entity.GenericName;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.java.JavaParser.AnnotationConstantRestContext;
@@ -193,7 +193,7 @@ public class JavaListener extends JavaParserBaseListener {
 		FunctionEntity method = context.foundMethodDeclarator(methodName, returnedType, throwedType);
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		if (ctx.typeParameters() != null) {
-			List<GenericTypeArgument> parameters = TypeParameterContextHelper.getTypeParameters(ctx.typeParameters());
+			List<GenericName> parameters = TypeParameterContextHelper.getTypeParameters(ctx.typeParameters());
 			method.addTypeParameter(parameters);
 		}
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",context.lastContainer());
@@ -256,7 +256,7 @@ public class JavaListener extends JavaParserBaseListener {
 	public void enterFieldDeclaration(FieldDeclarationContext ctx) {
 		List<String> varNames = VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators());
 		String type = ClassTypeContextHelper.getClassName(ctx.typeType());
-		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		List<VarEntity> vars = context.foundVarDefinitions(varNames, type,typeArguments);
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterFieldDeclaration(ctx);
@@ -266,7 +266,7 @@ public class JavaListener extends JavaParserBaseListener {
 
 	@Override
 	public void enterConstDeclaration(ConstDeclarationContext ctx) {
-		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		annotationProcessor.processAnnotationModifier(ctx, InterfaceBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
@@ -305,14 +305,14 @@ public class JavaListener extends JavaParserBaseListener {
 	// TODO: all modifier have not processed yet.
 	@Override
 	public void enterLocalVariableDeclaration(LocalVariableDeclarationContext ctx) {
-		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		super.enterLocalVariableDeclaration(ctx);
 	}
 
 	public void enterEnhancedForControl(EnhancedForControlContext ctx) {
-		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
+		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
 		super.enterEnhancedForControl(ctx);
@@ -323,7 +323,7 @@ public class JavaListener extends JavaParserBaseListener {
 //    ;
 	@Override
 	public void enterResource(ResourceContext ctx) {
-		List<GenericTypeArgument> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
+		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
 		context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
 				IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER()),typeArguments);
 		super.enterResource(ctx);
@@ -355,10 +355,10 @@ public class JavaListener extends JavaParserBaseListener {
 			TypeParameterContext typeParam = typeParameters.typeParameter(i);
 			if (typeParam.typeBound() != null) {
 				for (int j = 0; j < typeParam.typeBound().typeType().size(); j++) {
-					context.foundTypeParametes(new GenericTypeArgument(ClassTypeContextHelper.getClassName(typeParam.typeBound().typeType(j))));
+					context.foundTypeParametes(new GenericName(ClassTypeContextHelper.getClassName(typeParam.typeBound().typeType(j))));
 				}
 			}
-			context.currentType().addTypeParameter(new GenericTypeArgument(typeParam.IDENTIFIER().getText()));
+			context.currentType().addTypeParameter(new GenericName(typeParam.IDENTIFIER().getText()));
 		}
 	}
 	

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -27,16 +27,16 @@ package depends.extractor.java.context;
 import java.util.ArrayList;
 import java.util.List;
 
-import depends.entity.GenericTypeArgument;
+import depends.entity.GenericName;
 import depends.extractor.java.JavaParser.TypeParameterContext;
 import depends.extractor.java.JavaParser.TypeParametersContext;
 
 public class TypeParameterContextHelper {
 
-	public static List<GenericTypeArgument> getTypeParameters(TypeParametersContext typeParameters) {
-		ArrayList<GenericTypeArgument> r = new ArrayList<>();
+	public static List<GenericName> getTypeParameters(TypeParametersContext typeParameters) {
+		ArrayList<GenericName> r = new ArrayList<>();
 		for(TypeParameterContext param:typeParameters.typeParameter()) {
-			r.add(new GenericTypeArgument(param.IDENTIFIER().getText()));
+			r.add(new GenericName(param.IDENTIFIER().getText()));
 		}
 		return r;
 	}

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -64,7 +64,7 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 
 	private String getFunctionEntityDisplayName(FunctionEntity entity) {
 		FileEntity file = (FileEntity) entity.getAncestorOfType(FileEntity.class);
-		String name = stripper.stripFilename(file.getRawName());
+		String name = stripper.stripFilename(file.getRawName().getUniqueName());
 		name = filenameWritter.reWrite(name);
 		String functionName = PackageNamePrefixRemover.remove(entity);
 		name = name + "("+functionName+")";

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -8,6 +8,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.ContainerEntity;
+import depends.entity.FunctionEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 import depends.relations.Inferer;
@@ -29,7 +30,7 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    ContainerEntity function = (ContainerEntity)(entityRepo.getEntity("Class.test"));
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
 	    VarEntity var = function.lookupVarLocally("var_int");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
@@ -37,7 +38,7 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    assertEquals("Class",var.getType().getRawName());
 	    
 
-	    function = (ContainerEntity)(entityRepo.getEntity("Class"));
+	    function = (FunctionEntity)(entityRepo.getEntity("Class"));
 	    var = function.lookupVarLocally("inst_var");
 	    assertEquals("Class",var.getType().getRawName());
 	    
@@ -56,7 +57,7 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    ContainerEntity function = (ContainerEntity)(entityRepo.getEntity("Class.operator_is_call"));
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.operator_is_call"));
 	    VarEntity var = function.lookupVarLocally("var_compose");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 	    

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -29,7 +29,6 @@ import java.util.List;
 
 import depends.deptypes.DependencyType;
 import depends.extractor.LangProcessorRegistration;
-import edu.emory.mathcs.backport.java.util.Arrays;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -28,6 +28,6 @@ import java.util.UUID;
 
 public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock(Entity parent, Integer id) {
-    	super(new GenericName(UUID.randomUUID().toString()),  parent, id);
+    	super(GenericName.build(UUID.randomUUID().toString()),  parent, id);
 	}
 }

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -39,7 +39,7 @@ public class CandidateTypes extends TypeEntity {
 		candidateTypes = new ArrayList<>();
 	}
 	public CandidateTypes(List<TypeEntity> candidateTypes) {
-		super(new GenericName("candidateTypes"), null, -1);
+		super(GenericName.build("candidateTypes"), null, -1);
 		this.candidateTypes = candidateTypes;
 	}
 

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -348,7 +348,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	public VarEntity lookupVarLocally(String varName) {
-		return this.lookupVarLocally(new GenericName(varName));
+		return this.lookupVarLocally(GenericName.build(varName));
 	}
 
 	public void addMixin(GenericName moduleName) {

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -27,7 +27,7 @@ package depends.entity;
 public class EmptyTypeEntity extends TypeEntity {
 
 	public EmptyTypeEntity() {
-		super(new GenericName(""), null, -1);
+		super(GenericName.build(""), null, -1);
 	}
 
 }

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -43,7 +43,7 @@ public abstract class Entity {
 	
     Integer id=-1;
 	String qualifiedName = null;
-	GenericName rawName = new GenericName("");
+	GenericName rawName = GenericName.build("");
 	Entity parent;
 	private MultiDeclareEntities mutliDeclare = null;
 	private Set<Entity> children = new HashSet<>();
@@ -71,22 +71,22 @@ public abstract class Entity {
 	private void deduceQualifiedName() {
 		rawName = rawName.replace("::","." );
 		if (this.rawName.startsWith(".")) {
-			this.qualifiedName = this.rawName.getUniqueName().substring(1);
+			this.qualifiedName = this.rawName.uniqName().substring(1);
 			return; //already qualified
 		}
 		if (parent==null) {
-			this.qualifiedName = this.rawName.getUniqueName();
+			this.qualifiedName = this.rawName.uniqName();
 			return;
 		}
 		if (parent.getQualifiedName(true)==null) {
-			this.qualifiedName = this.rawName.getUniqueName();
+			this.qualifiedName = this.rawName.uniqName();
 			return;
 		}
 		if (parent.getQualifiedName(true).isEmpty()) {
-			this.qualifiedName = rawName.getUniqueName();
+			this.qualifiedName = rawName.uniqName();
 			return;
 		}
-		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName.getUniqueName();
+		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName.uniqName();
 	}
 
 
@@ -175,7 +175,7 @@ public abstract class Entity {
 	}
 
 	public String getDisplayName() {
-		return getRawName().getUniqueName();
+		return getRawName().uniqName();
 	}
 
 	public MultiDeclareEntities getMutliDeclare() {

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -43,7 +43,7 @@ public class FileEntity extends TypeEntity {
 	public FileEntity() {}
 
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
-		super(new GenericName(fullName), null, fileId);
+		super(GenericName.build(fullName), null, fileId);
 		setQualifiedName(fullName);
 		this.isInProjectScope = isInProjectScope;
 	}

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -35,7 +35,7 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	public void add(Entity entity) {
 		allEntitiesByOrder.add(entity);
 		allEntitiesById.put(entity.getId(), entity);
-		String name = entity.getRawName().getUniqueName();
+		String name = entity.getRawName().uniqName();
 		if (entity.getQualifiedName() != null && !(entity.getQualifiedName().isEmpty())) {
 			name = entity.getQualifiedName();
 		}
@@ -66,7 +66,7 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 
 	@Override
 	public Entity getEntity(GenericName rawName) {
-		return this.getEntity(rawName.getUniqueName());
+		return this.getEntity(rawName.uniqName());
 	}
 
 }

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -35,7 +35,6 @@ import org.codehaus.plexus.util.FileUtils;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
-import depends.format.detail.UnsolvedSymbolDumper;
 import depends.generator.DependencyGenerator;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.transform.OrderedMatrixGenerator;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -66,25 +66,30 @@ public abstract class HandlerContext {
 	}
 
 	
+
+	public TypeEntity foundNewType(GenericName name) {
+		TypeEntity currentTypeEntity = new TypeEntity(name, this.latestValidContainer(),
+				idGenerator.generateId());
+			pushToStack(currentTypeEntity);
+		 	entityRepo.add(currentTypeEntity);
+		 	currentFileEntity.addType(currentTypeEntity);
+			return currentTypeEntity;		
+	}
+	
 	/**
 	 * Tell the context object that a new type founded.
-	 * @param classOrInterfaceName
+	 * @param name
 	 * @return
 	 */
-	public TypeEntity foundNewType(String classOrInterfaceName) {
-		TypeEntity currentTypeEntity = new TypeEntity(new GenericName(classOrInterfaceName), this.latestValidContainer(),
-			idGenerator.generateId());
-		pushToStack(currentTypeEntity);
-	 	entityRepo.add(currentTypeEntity);
-	 	currentFileEntity.addType(currentTypeEntity);
-		return currentTypeEntity;
+	public TypeEntity foundNewType(String name) {
+		return foundNewType(GenericName.build(name));
 	}
 
 	public void foundNewTypeAlias(String aliasName, String originalName) {
 		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
 		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
-		AliasEntity currentTypeEntity = new AliasEntity(new GenericName(aliasName), this.latestValidContainer(),
-				idGenerator.generateId(),new GenericName(originalName) );
+		AliasEntity currentTypeEntity = new AliasEntity(GenericName.build(aliasName), this.latestValidContainer(),
+				idGenerator.generateId(),GenericName.build(originalName) );
 	 	entityRepo.add(currentTypeEntity);
 		return ;		
 	}
@@ -99,17 +104,17 @@ public abstract class HandlerContext {
 	 * @return the new function enity
 	 */
 	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
-		FunctionEntity functionEntity = new FunctionEntity(new GenericName(methodName), this.latestValidContainer(),
-				idGenerator.generateId(),new GenericName(returnType));
+		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
+				idGenerator.generateId(),GenericName.build(returnType));
 		entityRepo.add(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
-		functionEntity.addThrowTypes(throwedType);
+		functionEntity.addThrowTypes(throwedType.stream().map(item->GenericName.build(item)).collect(Collectors.toList()));
 		return functionEntity;
 	}
 	
 	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName) {
-		FunctionEntity functionEntity = new FunctionEntity(methodName, containerEntity,
+		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), containerEntity,
 				idGenerator.generateId(),null);
 		entityRepo.add(functionEntity);
 		containerEntity.addFunction(functionEntity);
@@ -189,14 +194,18 @@ public abstract class HandlerContext {
 	}
 
 	public void foundAnnotation(String name) {
-		lastContainer().addAnnotation(name);
+		lastContainer().addAnnotation(GenericName.build(name));
 	}
 
-	public void foundImplements(String typeName) {
+	public void foundImplements(GenericName typeName) {
 		currentType().addImplements(typeName);
 	}
 
-	public void foundExtends(String typeName) {
+	public void foundExtends(String className) {
+		foundExtends(GenericName.build(className));
+	}
+	
+	public void foundExtends(GenericName typeName) {
 		if (currentType()==null) {
 			System.out.println("error: type do not exist");
 			return ;
@@ -204,8 +213,13 @@ public abstract class HandlerContext {
 		currentType().addExtends(typeName);
 	}
 
-	public void foundMixin(String moduleName) {
-		lastContainer().addMixin(moduleName);
+	public void foundMixin(String name) {
+		foundMixin(GenericName.build(name));
+		
+	}
+	
+	public void foundMixin(GenericName name) {
+		lastContainer().addMixin(name);
 		
 	}
 
@@ -215,7 +229,7 @@ public abstract class HandlerContext {
 
 
 	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericName> typeArguments) {
-		return varNames.stream().map(item->foundVarDefinition(item,type,typeArguments)).collect(Collectors.toList());
+		return varNames.stream().map(item->foundVarDefinition(item,GenericName.build(type),typeArguments)).collect(Collectors.toList());
 	}
 	
 	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
@@ -224,9 +238,9 @@ public abstract class HandlerContext {
 			container = currentFile();
 		}
 		
-		VarEntity var = getVar(container,varName);
+		VarEntity var = getVar(container,GenericName.build(varName));
 		if (var!=null) return var;
-		var = new VarEntity(varName, null, container, idGenerator.generateId());
+		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
 		container.addVar(var);
 		entityRepo.add(var);
 
@@ -235,8 +249,8 @@ public abstract class HandlerContext {
 	
 
 
-	public VarEntity foundVarDefinition(String varName, String type, List<GenericName> typeArguments) {
-		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
+	public VarEntity foundVarDefinition(String varName, GenericName type, List<GenericName> typeArguments) {
+		VarEntity var = new VarEntity(GenericName.build(varName), type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);	
 		entityRepo.add(var);
@@ -245,13 +259,13 @@ public abstract class HandlerContext {
 	
 	public VarEntity addMethodParameter(String paramName) {
 		if (currentFunction()==null) return null;
-		VarEntity varEntity = new VarEntity(paramName,null,currentFunction(),idGenerator.generateId());
+		VarEntity varEntity = new VarEntity(GenericName.build(paramName),null,currentFunction(),idGenerator.generateId());
 		currentFunction().addParameter(varEntity);
 		return varEntity;
 	}
 
 	public void foundEnumConstDefinition(String varName) {
-		String type = lastContainer().getRawName();
+		GenericName type = lastContainer().getRawName();
 		foundVarDefinition(varName,type,new ArrayList<>());
 	}
 	
@@ -273,14 +287,14 @@ public abstract class HandlerContext {
 		entityStack.pop();
 	}
 	
-	private VarEntity getVar(ContainerEntity container, String varName) {
+	private VarEntity getVar(ContainerEntity container, GenericName varName) {
 		Entity entity = inferer.resolveName(container, varName, true); //TODO: should be check based on local/class/global
 		if (entity ==null ) return null;
 		if (entity instanceof VarEntity) return (VarEntity)entity;
 		return null;
 	}
 
-	public Entity foundEntityWithName(String rawName) {
+	public Entity foundEntityWithName(GenericName rawName) {
 		return inferer.resolveName(lastContainer(), rawName, true);
 	}
 }
\ No newline at end of file

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -32,6 +32,7 @@ import java.util.Set;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
+import depends.entity.GenericName;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.UnsolvedBindings;
 import depends.importtypes.FileImport;
@@ -56,12 +57,12 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (importedItem instanceof FileEntity) {
 				FileEntity importedFile = (FileEntity) repo.getEntity(file);
 				if (importedFile==null) continue;
-				 Entity entity = inferer.resolveName(importedFile,name, false);
+				 Entity entity = inferer.resolveName(importedFile,GenericName.build(name), false);
 				if (entity!=null) return entity;
 				Collection<Entity> namespaces = fileEntity.getImportedTypes();
 				for (Entity ns:namespaces) {
 					String nameWithPrefix = ns.getQualifiedName() + "." + name;
-					entity = inferer.resolveName(importedFile,nameWithPrefix, false);
+					entity = inferer.resolveName(importedFile,GenericName.build(nameWithPrefix), false);
 					if (entity!=null) return entity;				
 				}
 			}	
@@ -73,8 +74,8 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;
 			if (!(file instanceof FileEntity)) continue;
-			if (fileSet.contains(file.getRawName())) continue;
-			fileSet.add(file.getRawName());
+			if (fileSet.contains(file.getRawName().uniqName())) continue;
+			fileSet.add(file.getRawName().uniqName());
 			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles(),repo);
 		}
 	}

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -36,6 +36,7 @@ import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
 import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 
 import depends.entity.Expression;
+import depends.entity.GenericName;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.HandlerContext;
 
@@ -52,7 +53,7 @@ public class ExpressionUsage {
 		Expression expression = new Expression(idGenerator.generateId());
 		context.lastContainer().addExpression(declarator,expression);
 		expression.isCall = true;
-		expression.identifier = functionName;
+		expression.identifier = GenericName.build(functionName);
 	}
 	
 	public void foundExpression(IASTExpression ctx) {
@@ -90,23 +91,23 @@ public class ExpressionUsage {
 			expression.isCall = true;
 		}
 		if (ctx instanceof ICPPASTNewExpression) {
-			expression.rawType = ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
+			expression.rawType = GenericName.build(ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId()));
 			expression.isCall = true;
 			expression.deriveTypeFromChild = false;
 		}
 
 		if (ctx instanceof IASTCastExpression) {
 			expression.isCast=true;
-			expression.rawType = ASTStringUtilExt.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
+			expression.rawType = GenericName.build(ASTStringUtilExt.getTypeIdString(((IASTCastExpression)ctx).getTypeId()));
 			expression.deriveTypeFromChild = false;
 
 		}
 		if (expression.isDot) {
 			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
 			if (op2 instanceof IASTIdExpression)
-				expression.identifier = ((IASTIdExpression)op2).getName().toString();
+				expression.identifier = GenericName.build(((IASTIdExpression)op2).getName().toString());
 			else if (op2 instanceof IASTLiteralExpression)
-				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
+				expression.identifier = GenericName.build(((IASTLiteralExpression)op2).getRawSignature());
 			else if (op2 instanceof IASTFunctionCallExpression)
 				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
 			return;
@@ -126,22 +127,22 @@ public class ExpressionUsage {
 		//1. we only handle leaf node. if there is still expression,
 		//   the type will be determined by child node in the expression
 		if (ctx instanceof IASTIdExpression){
-			expression.identifier = ((IASTIdExpression) ctx).getName().toString();
+			expression.identifier = GenericName.build(((IASTIdExpression) ctx).getName().toString());
 		}else if (ctx instanceof IASTLiteralExpression) {
 		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = "<Literal>";
-			expression.rawType =  "<Built-in>";
+			expression.identifier = GenericName.build("<Literal>");
+			expression.rawType =  GenericName.build("<Built-in>");
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly
-			expression.rawType = ASTStringUtilExt.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
+			expression.rawType = GenericName.build(ASTStringUtilExt.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId()));
 			//TODO: check
 		}
 	}
 
-	private String getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
+	private GenericName getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
 		IASTExpression f = methodCall.getFunctionNameExpression();
 		if (f instanceof IASTIdExpression) {
-			return ((IASTIdExpression)f).getName().toString().replace("::", ".");
+			return GenericName.build(((IASTIdExpression)f).getName().toString().replace("::", "."));
 		}
 		return null;
 	}

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -84,7 +84,7 @@ public class JavaListener extends JavaParserBaseListener {
 	// Package
 	@Override
 	public void enterPackageDeclaration(PackageDeclarationContext ctx) {
-		context.foundNewPackage(sureDotStartName(QualitiedNameContextHelper.getName(ctx.qualifiedName())));
+		context.foundNewPackage(QualitiedNameContextHelper.getName(ctx.qualifiedName()));
 		super.enterPackageDeclaration(ctx);
 	}
 
@@ -103,16 +103,16 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterClassDeclaration(ClassDeclarationContext ctx) {
 		if (ctx.IDENTIFIER()==null) return;
-		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
 		// implements
 		if (ctx.typeList() != null) {
 			for (int i = 0; i < ctx.typeList().typeType().size(); i++) {
-				context.foundImplements(sureDotStartName(ClassTypeContextHelper.getClassName(ctx.typeList().typeType().get(i))));
+				context.foundImplements(GenericName.build(ClassTypeContextHelper.getClassName(ctx.typeList().typeType().get(i))));
 			}
 		}
 		// extends relation
 		if (ctx.typeType() != null) {
-			context.foundExtends(sureDotStartName(ClassTypeContextHelper.getClassName(ctx.typeType())));
+			context.foundExtends(GenericName.build(ClassTypeContextHelper.getClassName(ctx.typeType())));
 		}
 
 		if (ctx.typeParameters() != null) {
@@ -130,14 +130,14 @@ public class JavaListener extends JavaParserBaseListener {
 
 	@Override
 	public void enterEnumDeclaration(EnumDeclarationContext ctx) {
-		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
 		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterEnumDeclaration(ctx);
 	}
 
 	@Override
 	public void enterAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
-		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
 		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterAnnotationTypeDeclaration(ctx);
 	}
@@ -154,7 +154,7 @@ public class JavaListener extends JavaParserBaseListener {
 	 */
 	@Override
 	public void enterInterfaceDeclaration(InterfaceDeclarationContext ctx) {
-		context.foundNewType(sureDotStartName(ctx.IDENTIFIER().getText()));
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
 		// type parameters
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
@@ -325,7 +325,7 @@ public class JavaListener extends JavaParserBaseListener {
 	public void enterResource(ResourceContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
 		context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
-				IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER()),typeArguments);
+				GenericName.build(IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER())),typeArguments);
 		super.enterResource(ctx);
 	}
 
@@ -355,18 +355,12 @@ public class JavaListener extends JavaParserBaseListener {
 			TypeParameterContext typeParam = typeParameters.typeParameter(i);
 			if (typeParam.typeBound() != null) {
 				for (int j = 0; j < typeParam.typeBound().typeType().size(); j++) {
-					context.foundTypeParametes(new GenericName(ClassTypeContextHelper.getClassName(typeParam.typeBound().typeType(j))));
+					context.foundTypeParametes(GenericName.build(ClassTypeContextHelper.getClassName(typeParam.typeBound().typeType(j))));
 				}
 			}
-			context.currentType().addTypeParameter(new GenericName(typeParam.IDENTIFIER().getText()));
+			context.currentType().addTypeParameter(GenericName.build(typeParam.IDENTIFIER().getText()));
 		}
 	}
 	
-	private String sureDotStartName(String name) {
-//		if (name==null) return null;
-//		if (name.contains(".") && !name.startsWith(".")) {
-//			name = "." + name;
-//		}
-		return name;
-	}
+
 }

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -36,6 +36,7 @@ import org.antlr.v4.runtime.RuleContext;
 import org.codehaus.plexus.util.StringUtils;
 
 import depends.entity.ContainerEntity;
+import depends.entity.GenericName;
 import depends.extractor.java.JavaParser.AnnotationContext;
 
 public class AnnotationProcessor {
@@ -43,7 +44,7 @@ public class AnnotationProcessor {
 	public AnnotationProcessor() {
 	}
 
-	public void processAnnotationModifier(RuleContext ctx, Class rootClass,
+	public void processAnnotationModifier(RuleContext ctx, @SuppressWarnings("rawtypes") Class rootClass,
 		String toAnnotationPath,ContainerEntity container) {
 		List<ContainerEntity> list  = new ArrayList<>() ;
 		list.add(container);
@@ -51,7 +52,7 @@ public class AnnotationProcessor {
 				toAnnotationPath, list);
 	}
 	
-	public void processAnnotationModifier(RuleContext ctx, Class rootClass,
+	public void processAnnotationModifier(RuleContext ctx, @SuppressWarnings("rawtypes") Class rootClass,
 			String toAnnotationPath, List<?> containers) {
 
 		while (true) {
@@ -78,7 +79,7 @@ public class AnnotationProcessor {
 			for (Object item : contexts) {
 				AnnotationContext annotation = (AnnotationContext) item;
 				String name = QualitiedNameContextHelper.getName(annotation.qualifiedName());
-				containers.stream().forEach(container->((ContainerEntity)container).addAnnotation(name));
+				containers.stream().forEach(container->((ContainerEntity)container).addAnnotation(GenericName.build(name)));
 			}
 		} catch (Exception e) {
 			return;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -27,6 +27,7 @@ package depends.extractor.java.context;
 import org.antlr.v4.runtime.RuleContext;
 
 import depends.entity.Expression;
+import depends.entity.GenericName;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.HandlerContext;
 import depends.extractor.java.JavaParser.ExpressionContext;
@@ -79,20 +80,20 @@ public class ExpressionUsage {
 		}
 		//new 
 		if (ctx.NEW()!=null && ctx.creator()!=null) {
-			expression.rawType = CreatorContextHelper.getCreatorType(ctx.creator());
+			expression.rawType = GenericName.build(CreatorContextHelper.getCreatorType(ctx.creator()));
 			expression.isCall = true;
 			expression.deriveTypeFromChild = false;
 		}
 		
 		if (ctx.typeCast()!=null) {
 			expression.isCast=true;
-			expression.rawType = ctx.typeCast().typeType().getText();
+			expression.rawType = GenericName.build(ctx.typeCast().typeType().getText());
 			expression.deriveTypeFromChild = false;
 		}
 		
 		if (ctx.bop!=null && ctx.bop.getText().equals("instanceof")) {
 			expression.isCast=true;
-			expression.rawType = ctx.typeType().getText();
+			expression.rawType = GenericName.build(ctx.typeType().getText());
 			expression.deriveTypeFromChild = false;
 		}
 		
@@ -102,26 +103,26 @@ public class ExpressionUsage {
 		
 		if (expression.isDot) {
 			if (ctx.IDENTIFIER()!=null)
-				expression.identifier = ctx.IDENTIFIER().getText();
+				expression.identifier = GenericName.build(ctx.IDENTIFIER().getText());
 			else if (ctx.methodCall()!=null)
 				expression.identifier = getMethodCallIdentifier(ctx.methodCall());
 			else if (ctx.THIS()!=null)
-				expression.identifier = "this";
+				expression.identifier = GenericName.build("this");
 			else if (ctx.innerCreator()!=null) //innner creator like new List(){}
-				expression.identifier =  ctx.innerCreator().IDENTIFIER().getText();
+				expression.identifier =  GenericName.build(ctx.innerCreator().IDENTIFIER().getText());
 			else if (ctx.SUPER()!=null)
-				expression.identifier = "super";
+				expression.identifier = GenericName.build("super");
 			return;
 		}
 	}
 
-	private String getMethodCallIdentifier(MethodCallContext methodCall) {
+	private GenericName getMethodCallIdentifier(MethodCallContext methodCall) {
 		if (methodCall.THIS()!=null) {
-			return "this";
+			return GenericName.build("this");
 		}else if (methodCall.SUPER()!=null) {
-			return "super";
+			return GenericName.build("super");
 		}else {
-			return methodCall.IDENTIFIER().getText();
+			return GenericName.build(methodCall.IDENTIFIER().getText());
 		}
 	}
 
@@ -175,18 +176,18 @@ public class ExpressionUsage {
 		//   the type will be determined by child node in the expression
 		if (ctx.literal()!=null) {
 		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
-			expression.rawType = "<Built-in>";
-			expression.identifier = "<Literal>";
+			expression.rawType = GenericName.build("<Built-in>");
+			expression.identifier = GenericName.build("<Literal>");
 		}else if (ctx.IDENTIFIER()!=null) {
 		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = ctx.IDENTIFIER().getText();
+			expression.identifier = GenericName.build(ctx.IDENTIFIER().getText());
 		}else if (ctx.typeTypeOrVoid()!=null) {
 		//3. if given type directly
-			expression.rawType = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
+			expression.rawType = GenericName.build(ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid()));
 		}else if (ctx.THIS()!=null){
-			expression.identifier = "this";
+			expression.identifier = GenericName.build("this");
 		}else if (ctx.SUPER()!=null){
-			expression.identifier = "super";
+			expression.identifier = GenericName.build("super");
 		}
 	}
 

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -30,6 +30,7 @@ import java.util.List;
 import org.antlr.v4.runtime.tree.TerminalNode;
 
 import depends.entity.FunctionEntity;
+import depends.entity.GenericName;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.java.JavaParser.FormalParameterContext;
@@ -77,8 +78,8 @@ public class FormalParameterListContextHelper {
 	}
 
 	private void foundParameterDefintion(TypeTypeContext typeType, TerminalNode identifier, List<VariableModifierContext> variableModifier) {
-		String type = ClassTypeContextHelper.getClassName(typeType);
-		String varName = identifier.getText();
+		GenericName type = GenericName.build(ClassTypeContextHelper.getClassName(typeType));
+		GenericName varName = GenericName.build(identifier.getText());
 		VarEntity varEntity = new VarEntity(varName,type,container,idGenerator.generateId());
 		container.addParameter(varEntity);
 		

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -36,7 +36,7 @@ public class TypeParameterContextHelper {
 	public static List<GenericName> getTypeParameters(TypeParametersContext typeParameters) {
 		ArrayList<GenericName> r = new ArrayList<>();
 		for(TypeParameterContext param:typeParameters.typeParameter()) {
-			r.add(new GenericName(param.IDENTIFIER().getText()));
+			r.add(GenericName.build(param.IDENTIFIER().getText()));
 		}
 		return r;
 	}

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -8,6 +8,7 @@ import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
+import depends.entity.GenericName;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
@@ -52,17 +53,17 @@ public class ExpressionUsage {
 			if (atom.NUMBER()!=null ||
 					atom.STRING()!=null &&
 					atom.STRING().size()>0) {
-				expression.identifier = "<literal>";
-				expression.rawType = Inferer.buildInType.getQualifiedName();
+				expression.identifier = GenericName.build("<literal>");
+				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
 			}else if (atom.getText().equals("True")||
 					atom.getText().equals("False")) {
-				expression.identifier = "<boolean>";
-				expression.rawType = Inferer.buildInType.getQualifiedName();
+				expression.identifier = GenericName.build("<boolean>");
+				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
 			}else if (atom.getText().equals("None")) {
-				expression.identifier = "<null>";
-				expression.rawType = Inferer.buildInType.getQualifiedName();
+				expression.identifier = GenericName.build("<null>");
+				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
 			}else if (atom.NAME()!=null) {
-				expression.identifier = atom.NAME().getText();
+				expression.identifier = GenericName.build(atom.NAME().getText());
 			}
 		}
 		
@@ -79,13 +80,13 @@ public class ExpressionUsage {
 			Atom_exprContext expr = ((Atom_exprContext)ctx);
 			if (expr.func_call()!=null) {
 				//TODO: should be refined later. Currently only a.b.c could be solved.
-				expression.identifier = expr.atom_expr().getText();
+				expression.identifier = GenericName.build(expr.atom_expr().getText());
 				String callPrefix = expr.atom_expr().getText();
 				//call with variables
 				if (callPrefix.contains(".")) {
 					int pos = callPrefix.lastIndexOf('.');
-					String functionName = callPrefix.substring(pos+1);
-					String preFix = callPrefix.substring(0,pos);
+					GenericName functionName = GenericName.build(callPrefix.substring(pos+1));
+					GenericName preFix = GenericName.build(callPrefix.substring(0,pos));
 					Entity prefixEntity = context.foundEntityWithName(preFix);
 					if (prefixEntity instanceof VarEntity) {
 						((VarEntity)prefixEntity).addFunctionCall(functionName);
@@ -104,7 +105,7 @@ public class ExpressionUsage {
 			}
 			else if (expr.member_access()!=null) {
 				expression.isDot = true;
-				expression.identifier = expr.member_access().NAME().getText();
+				expression.identifier = GenericName.build(expr.member_access().NAME().getText());
 			}
 			//TODO: member access in python should be handled seperately. they could be different types;
 		}else if (ctx instanceof Return_stmtContext) {

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -50,6 +50,7 @@ import org.jrubyparser.ast.VCallNode;
 import depends.entity.ContainerEntity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
+import depends.entity.GenericName;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.ruby.RubyHandlerContext;
@@ -82,23 +83,23 @@ public class ExpressionUsage {
 
 		context.lastContainer().addExpression(ctx,expression);
 		if (ctx instanceof ILiteralNode && !(ctx instanceof ListNode)) {
-			expression.identifier = "<literal>";
-			expression.rawType = Inferer.buildInType.getQualifiedName();
+			expression.identifier = GenericName.build("<literal>");
+			expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
 		} else if (ctx instanceof TrueNode || ctx instanceof FalseNode) {
-			expression.identifier = "<boolean>";
-			expression.rawType = Inferer.buildInType.getQualifiedName();
+			expression.identifier = GenericName.build("<boolean>");
+			expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
 		}else if (ctx instanceof AndNode || ctx instanceof OrNode) {
-			expression.identifier = "<logical>";
-			expression.rawType = Inferer.buildInType.getQualifiedName();
+			expression.identifier = GenericName.build("<logical>");
+			expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
 		}else if (ctx instanceof ConstNode)  {
-			expression.rawType = helper.getName(ctx);
-			expression.identifier = helper.getName(ctx);
+			expression.rawType = GenericName.build(helper.getName(ctx));
+			expression.identifier = GenericName.build(helper.getName(ctx));
 		} else if (ctx instanceof LocalVarNode ||
 				ctx instanceof GlobalVarNode ||
 				ctx instanceof ClassVarNode||
 				ctx instanceof InstVarNode ||
 				ctx instanceof Colon3Node)  {
-			expression.identifier = helper.getName(ctx);
+			expression.identifier = GenericName.build(helper.getName(ctx));
 		} 
 		if (ctx instanceof AssignableNode) {
 			expression.isSet = true;
@@ -109,7 +110,7 @@ public class ExpressionUsage {
 				expression.isCreate = true;
 				List<Node> childNodes = ctx.childNodes();
 				if (childNodes.size()>0) {
-					expression.identifier = helper.getName(ctx.childNodes().get(0));
+					expression.identifier = GenericName.build(helper.getName(ctx.childNodes().get(0)));
 				}else {
 					expression.identifier = context.currentType().getRawName();
 				}
@@ -119,11 +120,11 @@ public class ExpressionUsage {
 				expression.isThrow = true;
 				expression.deriveTypeFromChild = true;
 			} else if (helper.isArithMeticOperator(name)) {
-				expression.identifier = "<operator>";
-				expression.rawType = Inferer.buildInType.getQualifiedName();
+				expression.identifier = GenericName.build("<operator>");
+				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
 			}else {
-				expression.identifier = name;
-				expression.rawType = helper.getReciever(ctx);
+				expression.identifier = GenericName.build(name);
+				expression.rawType = GenericName.build(helper.getReciever(ctx));
 				if (expression.rawType!=null) {
 					expression.isDot = true;
 				}

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -64,6 +64,7 @@ import org.jrubyparser.util.NoopVisitor;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
+import depends.entity.GenericName;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserCreator;
@@ -164,12 +165,12 @@ public class JRubyVisitor extends NoopVisitor {
 		if (helper.isCommonOperator(fname))return;
 		Node varNode = node.getReceiver();
 		
-		String varName = helper.getName(varNode);
+		GenericName varName = GenericName.build(helper.getName(varNode));
 		if (varName==null) return;
 		Entity var = context.foundEntityWithName(varName);
 		if (var != null && var instanceof VarEntity) {
 			VarEntity varEntity = (VarEntity) var;
-			varEntity.addFunctionCall(fname);
+			varEntity.addFunctionCall(GenericName.build(fname));
 		}
 	}
 
@@ -205,7 +206,7 @@ public class JRubyVisitor extends NoopVisitor {
 			//will be handled by context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
 		} else if (varNode instanceof ConstNode) {
 			String className = ((INameNode) varNode).getName();
-			Entity entity = context.foundEntityWithName(className);
+			Entity entity = context.foundEntityWithName(GenericName.build(className));
 			if (entity != null && entity instanceof ContainerEntity) {
 				context.foundMethodDeclarator(((ContainerEntity) entity), node.getName());
 				handled = true;
@@ -213,7 +214,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 		} else if (varNode instanceof INameNode) {
 			String varName = ((INameNode) varNode).getName();
-			Entity var = context.foundEntityWithName(varName);
+			Entity var = context.foundEntityWithName(GenericName.build(varName));
 			if (var != null && var instanceof ContainerEntity) {
 				context.foundMethodDeclarator(((ContainerEntity) var), node.getName());
 				handled = true;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -5,10 +5,7 @@ import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Set;
 
-import depends.deptypes.DependencyType;
 import depends.format.AbstractFormatDependencyDumper;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.core.DependencyPair;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -64,7 +64,7 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 
 	private String getFunctionEntityDisplayName(FunctionEntity entity) {
 		FileEntity file = (FileEntity) entity.getAncestorOfType(FileEntity.class);
-		String name = stripper.stripFilename(file.getRawName().getUniqueName());
+		String name = stripper.stripFilename(file.getRawName().uniqName());
 		name = filenameWritter.reWrite(name);
 		String functionName = PackageNamePrefixRemover.remove(entity);
 		name = name + "("+functionName+")";

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -42,7 +42,7 @@ public abstract class ParserTest {
 	    ContainerEntity container = (ContainerEntity)entity;
 		ArrayList<VarEntity> vars = container.getVars();
 	    for (VarEntity var:vars) {
-	    	if (var.getRawName().equals(name)) {
+	    	if (var.getRawName().uniqName().equals(name)) {
 	    		return;
 	    	}
 	    }
@@ -52,7 +52,7 @@ public abstract class ParserTest {
 	protected void assertContainsParametersWithRawName(FunctionEntity function, String name) {
 		Collection<VarEntity> vars = function.getParameters();
 	    for (VarEntity var:vars) {
-	    	if (var.getRawName().equals(name)) {
+	    	if (var.getRawName().uniqName().equals(name)) {
 	    		return;
 	    	}
 	    }
@@ -62,7 +62,7 @@ public abstract class ParserTest {
 	protected void assertContainReturnType(FunctionEntity function, String name) {
 		Collection<Entity> types = function.getReturnTypes();
 	    for (Entity type:types) {
-	    	if (type.getRawName().equals(name)) {
+	    	if (type.getRawName().uniqName().equals(name)) {
 	    		return;
 	    	}
 	    }

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -25,7 +25,6 @@ public class ForwardDeclareTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        FileDependencyGenerator dependencyGenerator= new FileDependencyGenerator();
         //TODO: to be complete
 	}
 	

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -8,7 +8,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
-import depends.extractor.java.JavaFileParser;
 
 public class GenericTypeTest extends CppParserTest{
     @Before

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -69,7 +69,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals("abc",((AliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName());
+        assertEquals("abc",((AliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName().uniqName());
         
 	}
 	

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -2,7 +2,6 @@ package depends.extractor.cpp;
 import java.io.IOException;
 
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -5,8 +5,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.Entity;
-
 public class JavaCylicInheritTest extends JavaParserTest{
 	@Before
 	public void setUp() {

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -7,7 +7,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
-import depends.entity.TypeEntity;
 import depends.extractor.FileParser;
 
 public class JavaExpressionCreatorTest extends JavaParserTest{

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -1,6 +1,5 @@
 package depends.extractor.java;
 
-import static org.junit.Assert.assertEquals;
 import java.io.IOException;
 
 import org.junit.Before;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -5,8 +5,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.Entity;
-
 public class JavaParseErrorFileTest extends JavaParserTest{
 	@Before
 	public void setUp() {
@@ -19,7 +17,6 @@ public class JavaParseErrorFileTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        Entity classEntity = entityRepo.getEntity("FieldVar");
 	}
 	
 	@Test
@@ -28,7 +25,6 @@ public class JavaParseErrorFileTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        Entity classEntity = entityRepo.getEntity("FieldVar");
 	}
 	
 	

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -8,7 +8,6 @@ import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.ContainerEntity;
 import depends.extractor.UnsolvedBindings;
 
 public class UnsolvedSymbolsTest extends JavaParserTest {

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -3,19 +3,16 @@ package depends.extractor.python;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.io.File;
 import java.io.IOException;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.CandidateTypes;
-import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
-import depends.util.FileUtil;
 
 public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	@Before

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -1,6 +1,5 @@
 package depends.extractor.python;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
@@ -8,7 +7,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.CandidateTypes;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -1,18 +1,12 @@
 package depends.extractor.python;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 import java.io.IOException;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
-import depends.entity.CandidateTypes;
 import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 
 public class ShouldGetRelationInSamePackageTest extends PythonParserTest {

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -7,8 +7,8 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.ContainerEntity;
 import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 import depends.relations.Inferer;
@@ -35,15 +35,15 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
 
 	    var = function.lookupVarLocally("var_c");
-	    assertEquals("Class",var.getType().getRawName());
+	    assertEquals("Class",var.getType().getRawName().uniqName());
 	    
 
-	    function = (FunctionEntity)(entityRepo.getEntity("Class"));
-	    var = function.lookupVarLocally("inst_var");
-	    assertEquals("Class",var.getType().getRawName());
+	    TypeEntity classEntity = (TypeEntity)(entityRepo.getEntity("Class"));
+	    var = classEntity.lookupVarLocally("inst_var");
+	    assertEquals("Class",var.getType().getRawName().uniqName());
 	    
-	    var = function.lookupVarLocally("class_var");
-	    assertEquals("Class",var.getType().getRawName());
+	    var = classEntity.lookupVarLocally("class_var");
+	    assertEquals("Class",var.getType().getRawName().uniqName());
 	}
 	
 	@Test

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -7,7 +7,6 @@ import java.util.ArrayList;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
-import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
 import depends.format.excel.ExcelXlsxFormatDependencyDumper;

07a4dc79c6771732a39735d3f688e2dab25bc660
@@ -184,23 +184,12 @@ public class CandidateTypes extends TypeEntity {
 		return super.getResolvedMixins();
 	}
 
-	@Override
-	public void addTypeParameter(List<GenericName> typeArguments) {
-		System.err.println("error: addTypeParameter should not been invoked");
-		super.addTypeParameter(typeArguments);
-	}
-
 	@Override
 	public void addAnnotation(GenericName name) {
 		System.err.println("error: addAnnotation should not been invoked");
 		super.addAnnotation(name);
 	}
 
-	@Override
-	public void addTypeParameter(GenericName typeName) {
-		System.err.println("error: addTypeParameter should not been invoked");
-		super.addTypeParameter(typeName);
-	}
 
 	@Override
 	public Collection<Entity> getResolvedTypeParameters() {

07a4dc79c6771732a39735d3f688e2dab25bc660
@@ -361,4 +361,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 
 
+
+
+
 }

07a4dc79c6771732a39735d3f688e2dab25bc660
@@ -125,4 +125,5 @@ public class FunctionEntity extends ContainerEntity{
 		return super.lookupVarLocally(varName);
 	}
 
+
 }

80f7b6e10f97eabe1f34240c31b5434168d284b0
@@ -84,8 +84,13 @@ public class FunctionEntity extends ContainerEntity{
 			param.fillCandidateTypes(inferer);
 			param.inferLocalLevelEntities(inferer);
 		}
-		if (returnTypes.size()<returnTypeIdentifiers.size())
+		if (returnTypes.size()<returnTypeIdentifiers.size()) {
 			returnTypes = identiferToEntities(inferer,this.returnTypeIdentifiers);
+			for ( GenericName returnTypeName: returnTypeIdentifiers) {
+				Collection<Entity> typeEntities = typeParametersToEntities(inferer, returnTypeName);
+				this.appendTypeParameters(typeEntities);
+			}
+		}
 		if (throwTypes.size()<throwTypesIdentifiers.size())
 			throwTypes = identiferToEntities(inferer,this.throwTypesIdentifiers);
 		super.inferLocalLevelEntities(inferer);
@@ -93,6 +98,17 @@ public class FunctionEntity extends ContainerEntity{
 			this.returnTypes.add(this.getLastExpressionType());
 		}
 	}
+	
+
+	private Collection<Entity> typeParametersToEntities(Inferer inferer,GenericName name) {
+		ArrayList<Entity> r = new ArrayList<>();
+		for (GenericName typeParameter:name.getArguments()) {
+			toEntityList(inferer, r,typeParameter);
+		}
+		return r;
+	}
+
+	
 	public Collection<VarEntity> getParameters() {
 		return parameters;
 	}

80f7b6e10f97eabe1f34240c31b5434168d284b0
@@ -113,6 +113,26 @@ public abstract class HandlerContext {
 		return functionEntity;
 	}
 	
+	public FunctionEntity foundMethodDeclarator(String methodName, GenericName returnType, List<String> throwedType) {
+		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
+				idGenerator.generateId(),returnType);
+		entityRepo.add(functionEntity);
+		this.typeOrFileContainer().addFunction(functionEntity);
+		pushToStack(functionEntity);
+		functionEntity.addThrowTypes(throwedType.stream().map(item->GenericName.build(item)).collect(Collectors.toList()));
+		return functionEntity;
+	}
+	
+	public FunctionEntity foundMethodDeclarator(String methodName) {
+		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
+				idGenerator.generateId(),null);
+		entityRepo.add(functionEntity);
+		this.typeOrFileContainer().addFunction(functionEntity);
+		pushToStack(functionEntity);
+		return functionEntity;		
+	}
+
+	
 	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), containerEntity,
 				idGenerator.generateId(),null);

80f7b6e10f97eabe1f34240c31b5434168d284b0
@@ -0,0 +1,57 @@
+package depends.extractor.cpp.cdt;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.cdt.core.dom.ast.ASTVisitor;
+import org.eclipse.cdt.core.dom.ast.IASTDeclSpecifier;
+import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTName;
+import org.eclipse.cdt.core.dom.ast.IASTNode;
+import org.eclipse.cdt.core.dom.ast.IASTTypeId;
+import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateParameter;
+import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTTemplateId;
+
+import depends.entity.GenericName;
+
+class TemplateParameterASTVisitor extends ASTVisitor{
+
+	private List<GenericName> parameters;
+
+	public TemplateParameterASTVisitor(List<GenericName> parameters) {
+		super(true);
+		this.parameters = parameters;
+	}
+	
+	
+
+	@Override
+	public int visit(IASTName name) {
+		if (name instanceof CPPASTTemplateId) {
+			final CPPASTTemplateId templateId = (CPPASTTemplateId) name;
+			for (IASTNode argument:templateId.getTemplateArguments()) {
+				if (argument instanceof IASTTypeId) {
+					IASTDeclSpecifier decl = ((IASTTypeId) argument).getDeclSpecifier();
+					String parameterName = ASTStringUtilExt.getName(decl);
+					parameterName = parameterName.replace("...", "");
+					parameters.add(GenericName.build(parameterName));
+				} else if (argument instanceof IASTIdExpression){
+					String parameterName = ASTStringUtilExt.getName(((IASTIdExpression)argument).getName());
+					parameters.add(GenericName.build(parameterName));
+				}else {
+					System.err.println ("TODO: unknown template arguments");
+				}
+			}		}
+		return super.visit(name);
+	}
+
+
+
+	@Override
+	public int visit(ICPPASTTemplateParameter templateParameter) {
+		System.out.println(templateParameter.getRawSignature());
+		return super.visit(templateParameter);
+	}
+
+	
+}
\ No newline at end of file

80f7b6e10f97eabe1f34240c31b5434168d284b0
@@ -192,7 +192,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDefnNode(DefnNode node) {
-		context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
+		context.foundMethodDeclarator(node.getName());
 		super.visitDefnNode(node);
 		context.exitLastedEntity();
 		return null;
@@ -223,7 +223,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 		if (!handled) {
 			// fallback to add it to last container
-			context.foundMethodDeclarator(node.getName(), null, new ArrayList<>());
+			context.foundMethodDeclarator(node.getName());
 		}
 		super.visitDefsNode(node);
 		context.exitLastedEntity();

80f7b6e10f97eabe1f34240c31b5434168d284b0
@@ -148,6 +148,9 @@ public class RelationCounter {
 		for (Entity throwType:func.getThrowTypes()) {
 			func.addRelation(new Relation(DependencyType.THROW,throwType));
 		}
+		for (Entity type:func.getResolvedTypeParameters()) {
+			func.addRelation(new Relation(DependencyType.PARAMETER,type));
+		}
 	}
 
 	private void computeImports(FileEntity file) {

80f7b6e10f97eabe1f34240c31b5434168d284b0
@@ -1,4 +1,5 @@
 package depends.extractor.cpp;
+
 import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
@@ -9,73 +10,70 @@ import org.junit.Test;
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 
-public class GenericTypeTest extends CppParserTest{
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-	
+public class GenericTypeTest extends CppParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+
 	@Test
 	public void test_templateSpecializationOfStruct() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/template/TempateStructure.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
-        inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity("hash"));
+		String src = "./src/test/resources/cpp-code-examples/template/TempateStructure.cpp";
+		CppFileParser parser = createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		assertNotNull(repo.getEntity("hash"));
 	}
 
-    @Test
+	@Test
 	public void test_genericTypesVarParameterReference() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
-        inferer.resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("xStack"), DependencyType.PARAMETER, "X");
+		String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
+		CppFileParser parser = createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		this.assertContainsRelation(repo.getEntity("xStack"), DependencyType.PARAMETER, "X");
 	}
-	
-    @Test
+
+	@Test
 	public void test_genericTypesExtends() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
-        inferer.resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
+		String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
+		CppFileParser parser = createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
 	}
-	
-    
-    @Test
+
+	@Test
 	public void test_GenericTypeEmbededShouldBeIdentified() throws IOException {
-        String src = "./src/test/resources/cpp-code-examples/template/EmbededTemplates.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
-        inferer.resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest"),
-        		DependencyType.CONTAIN, "MyHashMap");
-        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"),
-        		DependencyType.PARAMETER, "MyList");
-        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"),
-        		DependencyType.PARAMETER, "MyArray");
+		String src = "./src/test/resources/cpp-code-examples/template/EmbededTemplates.cpp";
+		CppFileParser parser = createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest"), DependencyType.CONTAIN, "MyHashMap");
+		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyList");
+		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyArray");
 	}
-	
-    @Test
+
+	@Test
 	public void test_TemplateWithDots() throws IOException {
-        String src = "./src/test/resources/cpp-code-examples/template/TemplateWithDots.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
-        inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity("foo.t2"));
+		String src = "./src/test/resources/cpp-code-examples/template/TemplateWithDots.cpp";
+		CppFileParser parser = createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		assertNotNull(repo.getEntity("foo.t2"));
 	}
-	
-    @Test
+
+	@Test
 	public void test_TemplateInReturn() throws IOException {
-        String src = "./src/test/resources/cpp-code-examples/template/TemplateInReturnValue.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
-        inferer.resolveAllBindings();
-        FunctionEntity func = (FunctionEntity)repo.getEntity("get");
-      	this.assertContainsRelation(func, DependencyType.RETURN, "std.tuple_element.type");
+		String src = "./src/test/resources/cpp-code-examples/template/TemplateInReturnValue.cpp";
+		CppFileParser parser = createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		FunctionEntity func = (FunctionEntity) repo.getEntity("get");
+		this.assertContainsRelation(func, DependencyType.RETURN, "std.tuple_element.type");
+		this.assertContainsRelation(repo.getEntity("get"), DependencyType.PARAMETER, "Index");
+		this.assertContainsRelation(repo.getEntity("get"), DependencyType.PARAMETER, "std.tuple");
+		this.assertContainsRelation(repo.getEntity("get"), DependencyType.PARAMETER, "Domains");
 	}
-	
-	
 
 }

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -147,31 +147,31 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			if (expression.isDot) { // wait for previous
 				continue;
 			}
-			if (expression.rawType == null && expression.identifier == null)
+			if (expression.getRawType() == null && expression.getIdentifier() == null)
 				continue;
 
 			// 2. if expression's rawType existed, directly infer type by rawType
 			// if expression's rawType does not existed, infer type based on identifiers
-			if (expression.rawType != null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType), null, inferer);
+			if (expression.getRawType() != null) {
+				expression.setType(inferer.inferTypeFromName(this, expression.getRawType()), null, inferer);
 				if (expression.getType() != null) {
 					continue;
 				}
 			}
-			if (expression.identifier != null) {
-				Entity entity = inferer.resolveName(this, expression.identifier, true);
+			if (expression.getIdentifier() != null) {
+				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;
 				}
 				if (expression.isCall) {
-					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
+					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.getIdentifier());
 					if (func != null) {
 						expression.setType(func.getType(), func, inferer);
 					}
 				} else {
 
-					VarEntity varEntity = this.lookupVarInVisibleScope(expression.identifier);
+					VarEntity varEntity = this.lookupVarInVisibleScope(expression.getIdentifier());
 					if (varEntity != null) {
 						expression.setType(varEntity.getType(), varEntity, inferer);
 					}

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -36,8 +36,8 @@ public class Expression implements Serializable{
 	private static final long serialVersionUID = 1L;
 	public Integer id;
 	public String text; // for debug purpose
-	public GenericName rawType; //the raw type name
-	public GenericName identifier; // the varName, or method name, etc.
+	private GenericName rawType; //the raw type name
+	private GenericName identifier; // the varName, or method name, etc.
 	public boolean isSet = false; // is a set relation from right to leftHand
 	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
 	public boolean isCall = false;
@@ -232,4 +232,55 @@ public class Expression implements Serializable{
 			}
 		}
 	}
+
+	public GenericName getIdentifier() {
+		return this.identifier;
+	}
+
+	public GenericName getRawType() {
+		return this.rawType;
+	}
+
+	public void setIdentifier(String name) {
+		if (!validName(name)){
+			return;
+		}
+		this.identifier = GenericName.build(name);
+	}
+
+	private boolean validName(String name) {
+		if (name==null) return false;
+		if (name.equals("<Literal>")) return true;
+		if (name.equals("<Built-In>")) return true;
+		if (name.equals("<built-in>")) return true;
+		if (name.equals("built-in")) return true;
+		return name.matches("([a-zA-Z0-9_]|(\\.))*");
+	}
+
+	public void setIdentifier(GenericName name) {
+		if (name==null) return;
+		if (!validName(name.getName())){
+			return;
+		}
+		this.identifier = name;
+	}
+
+	public void setRawType(GenericName name) {
+		if (name==null) return;
+		if (!validName(name.getName())){
+			return;
+		}
+		this.rawType = name;
+		
+	}
+
+	public void setRawType(String name) {
+		if (name==null) return;
+		if (!validName(name)){
+			return;
+		}
+		this.rawType = GenericName.build(name);
+	}
+	
+	
 }
\ No newline at end of file

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -82,8 +82,6 @@ abstract public class AbstractLangProcessor {
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
-
-		//entityRepo = new Neo4jEntityRepo();
 		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
 	}
 	

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -53,7 +53,7 @@ public class ExpressionUsage {
 		Expression expression = new Expression(idGenerator.generateId());
 		context.lastContainer().addExpression(declarator,expression);
 		expression.isCall = true;
-		expression.identifier = GenericName.build(functionName);
+		expression.setIdentifier(functionName);
 	}
 	
 	public void foundExpression(IASTExpression ctx) {
@@ -87,29 +87,29 @@ public class ExpressionUsage {
 
 		//method call
 		if (ctx instanceof IASTFunctionCallExpression) {
-			expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)ctx);
+			expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression)ctx));
 			expression.isCall = true;
 		}
 		if (ctx instanceof ICPPASTNewExpression) {
-			expression.rawType = GenericName.build(ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId()));
+			expression.setRawType(GenericName.build(ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId())));
 			expression.isCall = true;
 			expression.deriveTypeFromChild = false;
 		}
 
 		if (ctx instanceof IASTCastExpression) {
 			expression.isCast=true;
-			expression.rawType = GenericName.build(ASTStringUtilExt.getTypeIdString(((IASTCastExpression)ctx).getTypeId()));
+			expression.setRawType(GenericName.build(ASTStringUtilExt.getTypeIdString(((IASTCastExpression)ctx).getTypeId())));
 			expression.deriveTypeFromChild = false;
 
 		}
 		if (expression.isDot) {
 			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
 			if (op2 instanceof IASTIdExpression)
-				expression.identifier = GenericName.build(((IASTIdExpression)op2).getName().toString());
+				expression.setIdentifier(((IASTIdExpression)op2).getName().toString());
 			else if (op2 instanceof IASTLiteralExpression)
-				expression.identifier = GenericName.build(((IASTLiteralExpression)op2).getRawSignature());
+				expression.setIdentifier(((IASTLiteralExpression)op2).getRawSignature());
 			else if (op2 instanceof IASTFunctionCallExpression)
-				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
+				expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression)op2));
 			return;
 		}		
 	}
@@ -123,18 +123,17 @@ public class ExpressionUsage {
 	}
 	
 	private void tryFillExpressionTypeAndIdentifier(IASTExpression ctx, Expression expression) {
-		
 		//1. we only handle leaf node. if there is still expression,
 		//   the type will be determined by child node in the expression
 		if (ctx instanceof IASTIdExpression){
-			expression.identifier = GenericName.build(((IASTIdExpression) ctx).getName().toString());
+			expression.setIdentifier(((IASTIdExpression) ctx).getName().toString());
 		}else if (ctx instanceof IASTLiteralExpression) {
 		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = GenericName.build("<Literal>");
-			expression.rawType =  GenericName.build("<Built-in>");
+			expression.setIdentifier("<Literal>");
+			expression.setRawType("<Built-in>");
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly
-			expression.rawType = GenericName.build(ASTStringUtilExt.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId()));
+			expression.setRawType(ASTStringUtilExt.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId()));
 			//TODO: check
 		}
 	}

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -75,25 +75,25 @@ public class ExpressionUsage {
  */
 		//method call
 		if (ctx.methodCall()!=null) {
-			expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+			expression.setIdentifier(getMethodCallIdentifier(ctx.methodCall()));
 			expression.isCall = true;
 		}
 		//new 
 		if (ctx.NEW()!=null && ctx.creator()!=null) {
-			expression.rawType = GenericName.build(CreatorContextHelper.getCreatorType(ctx.creator()));
+			expression.setRawType(CreatorContextHelper.getCreatorType(ctx.creator()));
 			expression.isCall = true;
 			expression.deriveTypeFromChild = false;
 		}
 		
 		if (ctx.typeCast()!=null) {
 			expression.isCast=true;
-			expression.rawType = GenericName.build(ctx.typeCast().typeType().getText());
+			expression.setRawType(ctx.typeCast().typeType().getText());
 			expression.deriveTypeFromChild = false;
 		}
 		
 		if (ctx.bop!=null && ctx.bop.getText().equals("instanceof")) {
 			expression.isCast=true;
-			expression.rawType = GenericName.build(ctx.typeType().getText());
+			expression.setRawType(ctx.typeType().getText());
 			expression.deriveTypeFromChild = false;
 		}
 		
@@ -103,15 +103,15 @@ public class ExpressionUsage {
 		
 		if (expression.isDot) {
 			if (ctx.IDENTIFIER()!=null)
-				expression.identifier = GenericName.build(ctx.IDENTIFIER().getText());
+				expression.setIdentifier(ctx.IDENTIFIER().getText());
 			else if (ctx.methodCall()!=null)
-				expression.identifier = getMethodCallIdentifier(ctx.methodCall());
+				expression.setIdentifier(getMethodCallIdentifier(ctx.methodCall()));
 			else if (ctx.THIS()!=null)
-				expression.identifier = GenericName.build("this");
+				expression.setIdentifier("this");
 			else if (ctx.innerCreator()!=null) //innner creator like new List(){}
-				expression.identifier =  GenericName.build(ctx.innerCreator().IDENTIFIER().getText());
+				expression.setIdentifier(ctx.innerCreator().IDENTIFIER().getText());
 			else if (ctx.SUPER()!=null)
-				expression.identifier = GenericName.build("super");
+				expression.setIdentifier("super");
 			return;
 		}
 	}
@@ -176,18 +176,18 @@ public class ExpressionUsage {
 		//   the type will be determined by child node in the expression
 		if (ctx.literal()!=null) {
 		//2. if it is a build-in type like "hello"(string), 10(integer), etc.
-			expression.rawType = GenericName.build("<Built-in>");
-			expression.identifier = GenericName.build("<Literal>");
+			expression.setRawType("<Built-in>");
+			expression.setIdentifier("<Literal>");
 		}else if (ctx.IDENTIFIER()!=null) {
 		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = GenericName.build(ctx.IDENTIFIER().getText());
+			expression.setIdentifier(ctx.IDENTIFIER().getText());
 		}else if (ctx.typeTypeOrVoid()!=null) {
 		//3. if given type directly
-			expression.rawType = GenericName.build(ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid()));
+			expression.setRawType(ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid()));
 		}else if (ctx.THIS()!=null){
-			expression.identifier = GenericName.build("this");
+			expression.setIdentifier("this");
 		}else if (ctx.SUPER()!=null){
-			expression.identifier = GenericName.build("super");
+			expression.setIdentifier("super");
 		}
 	}
 

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -26,91 +26,86 @@ public class ExpressionUsage {
 	Inferer inferer;
 	private PythonHandlerContext context;
 	private PythonParserHelper helper;
-	public ExpressionUsage(PythonHandlerContext context,IdGenerator idGenerator, PythonParserHelper helper, Inferer inferer) {
+
+	public ExpressionUsage(PythonHandlerContext context, IdGenerator idGenerator, PythonParserHelper helper,
+			Inferer inferer) {
 		this.context = context;
 		this.idGenerator = idGenerator;
 		this.inferer = inferer;
 		this.helper = helper;
 	}
-	
+
 	public Expression foundExpression(ParserRuleContext ctx) {
-		if (!context.lastContainer().containsExpression()){
+		if (!context.lastContainer().containsExpression()) {
 			if (!isStartOfContainerRule(ctx)) {
 				return null;
 			}
 		}
 		Expression expression = findExpression(ctx);
-		if (expression!=null) return expression;
+		if (expression != null)
+			return expression;
 		Expression parent = findParentInStack(ctx);
-		/* create expression and link it with parent*/
+		/* create expression and link it with parent */
 		expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.getText();
 		expression.setParent(parent);
 
-		context.lastContainer().addExpression(ctx,expression);
+		context.lastContainer().addExpression(ctx, expression);
 		if (ctx instanceof AtomContext) {
-			AtomContext atom = (AtomContext)ctx;
-			if (atom.NUMBER()!=null ||
-					atom.STRING()!=null &&
-					atom.STRING().size()>0) {
-				expression.identifier = GenericName.build("<literal>");
-				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
-			}else if (atom.getText().equals("True")||
-					atom.getText().equals("False")) {
-				expression.identifier = GenericName.build("<boolean>");
-				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
-			}else if (atom.getText().equals("None")) {
-				expression.identifier = GenericName.build("<null>");
-				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
-			}else if (atom.NAME()!=null) {
-				expression.identifier = GenericName.build(atom.NAME().getText());
+			AtomContext atom = (AtomContext) ctx;
+			if (atom.NUMBER() != null || atom.STRING() != null && atom.STRING().size() > 0) {
+				expression.setIdentifier("<literal>");
+				expression.setRawType(Inferer.buildInType.getQualifiedName());
+			} else if (atom.getText().equals("True") || atom.getText().equals("False")) {
+				expression.setIdentifier("<boolean>");
+				expression.setRawType(Inferer.buildInType.getQualifiedName());
+			} else if (atom.getText().equals("None")) {
+				expression.setIdentifier("<null>");
+				expression.setRawType(Inferer.buildInType.getQualifiedName());
+			} else if (atom.NAME() != null) {
+				expression.setIdentifier(atom.NAME().getText());
 			}
 		}
-		
-		
+
 		if (ctx instanceof Expr_stmtContext) {
-			Expr_stmtContext expr = ((Expr_stmtContext)ctx);
-			if ((expr.expr_stmt_rhs()!=null)||
-					(expr.augassign()!=null)||
-					(expr.annassign()!=null))
-			{
+			Expr_stmtContext expr = ((Expr_stmtContext) ctx);
+			if ((expr.expr_stmt_rhs() != null) || (expr.augassign() != null) || (expr.annassign() != null)) {
 				expression.isSet = true;
 			}
-		}else if (ctx instanceof Atom_exprContext) {
-			Atom_exprContext expr = ((Atom_exprContext)ctx);
-			if (expr.func_call()!=null) {
-				//TODO: should be refined later. Currently only a.b.c could be solved.
-				expression.identifier = GenericName.build(expr.atom_expr().getText());
+		} else if (ctx instanceof Atom_exprContext) {
+			Atom_exprContext expr = ((Atom_exprContext) ctx);
+			if (expr.func_call() != null) {
+				// TODO: should be refined later. Currently only a.b.c could be solved.
+				expression.setIdentifier(expr.atom_expr().getText());
 				String callPrefix = expr.atom_expr().getText();
-				//call with variables
+				// call with variables
 				if (callPrefix.contains(".")) {
 					int pos = callPrefix.lastIndexOf('.');
-					GenericName functionName = GenericName.build(callPrefix.substring(pos+1));
-					GenericName preFix = GenericName.build(callPrefix.substring(0,pos));
+					GenericName functionName = GenericName.build(callPrefix.substring(pos + 1));
+					GenericName preFix = GenericName.build(callPrefix.substring(0, pos));
 					Entity prefixEntity = context.foundEntityWithName(preFix);
 					if (prefixEntity instanceof VarEntity) {
-						((VarEntity)prefixEntity).addFunctionCall(functionName);
+						((VarEntity) prefixEntity).addFunctionCall(functionName);
 						expression.isCall = true;
 					}
 				}
 				if (!expression.isCall) {
-					Entity typeEntity = context.foundEntityWithName(expression.identifier);
-					if (typeEntity instanceof TypeEntity &&
-							typeEntity.getId()>0) {
+					Entity typeEntity = context.foundEntityWithName(expression.getIdentifier());
+					if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
 						expression.isCreate = true;
-					}else {
+					} else {
 						expression.isCall = true;
 					}
 				}
-			}
-			else if (expr.member_access()!=null) {
+			} else if (expr.member_access() != null) {
 				expression.isDot = true;
-				expression.identifier = GenericName.build(expr.member_access().NAME().getText());
+				expression.setIdentifier(expr.member_access().NAME().getText());
 			}
-			//TODO: member access in python should be handled seperately. they could be different types;
-		}else if (ctx instanceof Return_stmtContext) {
-			deduceReturnTypeInCaseOfReturn(ctx,expression);
-		}else if (ctx instanceof Raise_stmtContext) {
+			// TODO: member access in python should be handled seperately. they could be
+			// different types;
+		} else if (ctx instanceof Return_stmtContext) {
+			deduceReturnTypeInCaseOfReturn(ctx, expression);
+		} else if (ctx instanceof Raise_stmtContext) {
 			expression.isThrow = true;
 			expression.deriveTypeFromChild = true;
 		}
@@ -119,67 +114,73 @@ public class ExpressionUsage {
 	}
 
 	/**
-	 * To judge whether is an 'real' expression 
+	 * To judge whether is an 'real' expression
+	 * 
 	 * @param ctx
 	 * @return
 	 */
 	private boolean isStartOfContainerRule(ParserRuleContext ctx) {
-		return ctx instanceof SuiteContext ||
-				ctx instanceof TestContext ||
-				ctx instanceof Expr_stmtContext;
+		return ctx instanceof SuiteContext || ctx instanceof TestContext || ctx instanceof Expr_stmtContext;
 	}
 
-
 	/**
-	 * Auto deduce variable type from assignment.
-	 * for example:
-	 *       c = C.new  then c is type of C
+	 * Auto deduce variable type from assignment. for example: c = C.new then c is
+	 * type of C
+	 * 
 	 * @param node
 	 * @param expression
 	 */
 	private void deduceVarTypeInCaseOfAssignment(ParserRuleContext node, Expression expression) {
 		ParserRuleContext parentNode = node.getParent();
 		if (parentNode instanceof Expr_stmtContext) {
-			Expr_stmtContext expr = (Expr_stmtContext)parentNode;
-			if (expr.expr_stmt_rhs()!=null) {
+			Expr_stmtContext expr = (Expr_stmtContext) parentNode;
+			if (expr.expr_stmt_rhs() != null) {
 				ContainerEntity scope = helper.getScopeOfVar(expr, this.context);
-				if (scope==null) return;
+				if (scope == null)
+					return;
 				String varName = null;
-				//TODO: should handle list properly;
+				// TODO: should handle list properly;
 				List<String> names = helper.getName(expr.testlist_star_expr());
-				if (names.size()==1)
+				if (names.size() == 1)
 					varName = names.get(0);
-				if (varName==null) return;
-				VarEntity var = scope.lookupVarLocally(varName );
-				if (var!=null) {
+				if (varName == null)
+					return;
+				VarEntity var = scope.lookupVarLocally(varName);
+				if (var != null) {
 					expression.addDeducedTypeVar(var);
 				}
 			}
 		}
 	}
-	
+
 	private void deduceReturnTypeInCaseOfReturn(ParserRuleContext ctx, Expression expression) {
 		FunctionEntity currentFunction = context.currentFunction();
-		if (currentFunction ==null) return;
+		if (currentFunction == null)
+			return;
 		if (ctx instanceof Return_stmtContext) {
 			expression.addDeducedTypeFunction(currentFunction);
 		}
 	}
-	
+
 	private Expression findParentInStack(ParserRuleContext ctx) {
-		if (ctx==null) return null;
-		if (ctx.getParent()==null) return null;
-		if (context.lastContainer()==null) {
+		if (ctx == null)
+			return null;
+		if (ctx.getParent() == null)
+			return null;
+		if (context.lastContainer() == null) {
 			return null;
 		}
-		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
+		if (context.lastContainer().expressions().containsKey(ctx.getParent()))
+			return context.lastContainer().expressions().get(ctx.getParent());
 		return findParentInStack(ctx.getParent());
 	}
-	
+
 	private Expression findExpression(ParserRuleContext ctx) {
-		if (ctx==null) return null;
-		if (ctx.getParent()==null) return null;
-		if (context.lastContainer()==null) {
+		if (ctx == null)
+			return null;
+		if (ctx.getParent() == null)
+			return null;
+		if (context.lastContainer() == null) {
 			return null;
 		}
 		return context.lastContainer().expressions().get(ctx);

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -61,19 +61,25 @@ public class ExpressionUsage {
 	IdGenerator idGenerator;
 	Inferer inferer;
 	private RubyParserHelper helper;
-	public ExpressionUsage(RubyHandlerContext context,IdGenerator idGenerator, RubyParserHelper helper, Inferer inferer) {
+
+	public ExpressionUsage(RubyHandlerContext context, IdGenerator idGenerator, RubyParserHelper helper,
+			Inferer inferer) {
 		this.context = context;
 		this.idGenerator = idGenerator;
 		this.inferer = inferer;
 		this.helper = helper;
 	}
+
 	public Expression foundExpression(Node ctx) {
-		if (ctx instanceof RootNode) return null;
-		if (ctx instanceof BlockNode) return null;
+		if (ctx instanceof RootNode)
+			return null;
+		if (ctx instanceof BlockNode)
+			return null;
 		Expression expression = findExpression(ctx);
-		if (expression!=null) return expression;
+		if (expression != null)
+			return expression;
 		Expression parent = findParentInStack(ctx);
-		/* create expression and link it with parent*/
+		/* create expression and link it with parent */
 		expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.toString();
 		expression.setParent(parent);
@@ -81,56 +87,52 @@ public class ExpressionUsage {
 			expression.isStatement = true;
 		}
 
-		context.lastContainer().addExpression(ctx,expression);
+		context.lastContainer().addExpression(ctx, expression);
 		if (ctx instanceof ILiteralNode && !(ctx instanceof ListNode)) {
-			expression.identifier = GenericName.build("<literal>");
-			expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
+			expression.setIdentifier("<literal>");
+			expression.setRawType(Inferer.buildInType.getQualifiedName());
 		} else if (ctx instanceof TrueNode || ctx instanceof FalseNode) {
-			expression.identifier = GenericName.build("<boolean>");
-			expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
-		}else if (ctx instanceof AndNode || ctx instanceof OrNode) {
-			expression.identifier = GenericName.build("<logical>");
-			expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
-		}else if (ctx instanceof ConstNode)  {
-			expression.rawType = GenericName.build(helper.getName(ctx));
-			expression.identifier = GenericName.build(helper.getName(ctx));
-		} else if (ctx instanceof LocalVarNode ||
-				ctx instanceof GlobalVarNode ||
-				ctx instanceof ClassVarNode||
-				ctx instanceof InstVarNode ||
-				ctx instanceof Colon3Node)  {
-			expression.identifier = GenericName.build(helper.getName(ctx));
-		} 
+			expression.setIdentifier("<boolean>");
+			expression.setRawType(Inferer.buildInType.getQualifiedName());
+		} else if (ctx instanceof AndNode || ctx instanceof OrNode) {
+			expression.setIdentifier("<logical>");
+			expression.setRawType(Inferer.buildInType.getQualifiedName());
+		} else if (ctx instanceof ConstNode) {
+			expression.setRawType(helper.getName(ctx));
+			expression.setIdentifier(helper.getName(ctx));
+		} else if (ctx instanceof LocalVarNode || ctx instanceof GlobalVarNode || ctx instanceof ClassVarNode
+				|| ctx instanceof InstVarNode || ctx instanceof Colon3Node) {
+			expression.setIdentifier(helper.getName(ctx));
+		}
 		if (ctx instanceof AssignableNode) {
 			expression.isSet = true;
-		}else if (helper.isFunctionCall(ctx)) {
+		} else if (helper.isFunctionCall(ctx)) {
 			String name = helper.getName(ctx);
 			expression.isCall = true;
 			if (name.equals("new")) {
 				expression.isCreate = true;
 				List<Node> childNodes = ctx.childNodes();
-				if (childNodes.size()>0) {
-					expression.identifier = GenericName.build(helper.getName(ctx.childNodes().get(0)));
-				}else {
-					expression.identifier = context.currentType().getRawName();
+				if (childNodes.size() > 0) {
+					expression.setIdentifier(helper.getName(ctx.childNodes().get(0)));
+				} else {
+					expression.setIdentifier(context.currentType().getRawName());
 				}
-				expression.rawType = expression.identifier ;
+				expression.setRawType(expression.getIdentifier());
 				expression.deriveTypeFromChild = false;
 			} else if (name.equals("raise")) {
 				expression.isThrow = true;
 				expression.deriveTypeFromChild = true;
 			} else if (helper.isArithMeticOperator(name)) {
-				expression.identifier = GenericName.build("<operator>");
-				expression.rawType = GenericName.build(Inferer.buildInType.getQualifiedName());
-			}else {
-				expression.identifier = GenericName.build(name);
-				expression.rawType = GenericName.build(helper.getReciever(ctx));
-				if (expression.rawType!=null) {
+				expression.setIdentifier("<operator>");
+				expression.setRawType(Inferer.buildInType.getQualifiedName());
+			} else {
+				expression.setIdentifier(name);
+				expression.setRawType(helper.getReciever(ctx));
+				if (expression.getRawType() != null) {
 					expression.isDot = true;
 				}
-				
-				if (ctx instanceof VCallNode ||
-						ctx instanceof FCallNode) {
+
+				if (ctx instanceof VCallNode || ctx instanceof FCallNode) {
 					expression.deriveTypeFromChild = false;
 				}
 			}
@@ -140,46 +142,52 @@ public class ExpressionUsage {
 		return expression;
 	}
 
-
 	/**
-	 * Auto deduce variable type from assignment.
-	 * for example:
-	 *       c = C.new  then c is type of C
+	 * Auto deduce variable type from assignment. for example: c = C.new then c is
+	 * type of C
+	 * 
 	 * @param node
 	 * @param expression
 	 */
 	private void deduceVarTypeInCaseOfAssignment(Node node, Expression expression) {
 		Node parentNode = node.getParent();
 		if (parentNode instanceof AssignableNode) {
-			ContainerEntity scope = helper.getScopeOfVar((AssignableNode)parentNode, this.context);
+			ContainerEntity scope = helper.getScopeOfVar((AssignableNode) parentNode, this.context);
 			VarEntity var = scope.lookupVarLocally(helper.getName(parentNode));
-			if (var!=null) {
+			if (var != null) {
 				expression.addDeducedTypeVar(var);
 			}
 		}
 	}
+
 	private void deduceReturnTypeInCaseOfReturn(Node ctx, Expression expression) {
 		FunctionEntity currentFunction = context.currentFunction();
-		if (currentFunction ==null) return;
+		if (currentFunction == null)
+			return;
 		if (ctx instanceof ReturnNode) {
 			expression.addDeducedTypeFunction(currentFunction);
 		}
 	}
-	
+
 	private Expression findParentInStack(Node ctx) {
-		if (ctx==null) return null;
-		if (ctx.getParent()==null) return null;
-		if (context.lastContainer()==null) {
+		if (ctx == null)
+			return null;
+		if (ctx.getParent() == null)
+			return null;
+		if (context.lastContainer() == null) {
 			return null;
 		}
-		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
+		if (context.lastContainer().expressions().containsKey(ctx.getParent()))
+			return context.lastContainer().expressions().get(ctx.getParent());
 		return findParentInStack(ctx.getParent());
 	}
-	
+
 	private Expression findExpression(Node ctx) {
-		if (ctx==null) return null;
-		if (ctx.getParent()==null) return null;
-		if (context.lastContainer()==null) {
+		if (ctx == null)
+			return null;
+		if (ctx.getParent() == null)
+			return null;
+		if (context.lastContainer() == null) {
 			return null;
 		}
 		return context.lastContainer().expressions().get(ctx);

0533771ccd160d4a99805aba4430868ff3fe1297
@@ -49,7 +49,6 @@ class TemplateParameterASTVisitor extends ASTVisitor{
 
 	@Override
 	public int visit(ICPPASTTemplateParameter templateParameter) {
-		System.out.println(templateParameter.getRawSignature());
 		return super.visit(templateParameter);
 	}
 

0533771ccd160d4a99805aba4430868ff3fe1297
@@ -51,7 +51,6 @@ public class PomLocator {
 		sb.append("-");
 		sb.append(pomParent.version);
 		sb.append(".pom");
-		System.out.println(sb.toString());
 		for (String includePath:includePaths) {
 			String path = includePath+File.separator+sb.toString();
 			if (FileUtil.existFile(path)) {

3cc5f49916278bbee16c90c01c2b08160616fde8
@@ -6,12 +6,14 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.commons.io.FileUtils;
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.AliasEntity;
 import depends.extractor.cpp.CppFileParser;
+import depends.util.FileUtil;
 
 public class IncludeRelationTest extends CppParserTest{
     @Before
@@ -89,4 +91,21 @@ public class IncludeRelationTest extends CppParserTest{
 	    this.assertContainsRelation(this.repo.getEntity("foo"), DependencyType.CALL, "bar");
 	    this.assertNotContainsRelation(this.repo.getEntity("foo2"), DependencyType.CALL, "bar");
 	}
+	
+	@Test
+	public void should_find_include_relation_in_conditional_macro_block() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/includeTest3/inc_macro_test.c",
+	    		"./src/test/resources/cpp-code-examples/includeTest3/fx.h",
+	    		"./src/test/resources/cpp-code-examples/includeTest3/fy.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[1]));
+	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[2]));
+	} 
 }

ae104912354ee27ca24cc838b0e3aed3d90091a5
@@ -37,7 +37,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+        assertEquals(4,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
 	
 	

822bd7fd28c95c7a5a686bc84af6f952eae3ec83
@@ -291,7 +291,7 @@ public abstract class HandlerContext {
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();
 
-	private void pushToStack(Entity entity) {
+	protected void pushToStack(Entity entity) {
 		entityStack.push(entity);
 	}
 	

822bd7fd28c95c7a5a686bc84af6f952eae3ec83
@@ -34,6 +34,7 @@ import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
+import depends.entity.FunctionEntityImpl;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
@@ -151,6 +152,12 @@ public class RelationCounter {
 		for (Entity type:func.getResolvedTypeParameters()) {
 			func.addRelation(new Relation(DependencyType.PARAMETER,type));
 		}
+		if (func instanceof FunctionEntityImpl) {
+			FunctionEntityImpl funcImpl = (FunctionEntityImpl)func;
+			if(funcImpl.getImplemented()!=null) {
+				func.addRelation(new Relation(DependencyType.IMPLEMENT,funcImpl.getImplemented()));
+			}
+		}
 	}
 
 	private void computeImports(FileEntity file) {

822bd7fd28c95c7a5a686bc84af6f952eae3ec83
@@ -0,0 +1,42 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.ContainerEntity;
+import depends.entity.Entity;
+import depends.entity.FunctionEntityImpl;
+import depends.entity.MultiDeclareEntities;
+import depends.extractor.cpp.cdt.CdtCppFileParser;
+
+public class ImplementRelationTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_detect_implements_from_source_to_header() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relationImplements/A.cpp",
+	    		"./src/test/resources/cpp-code-examples/relationImplements/A.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    MultiDeclareEntities multiDeclare = (MultiDeclareEntities)( repo.getEntity("foo"));
+	    List<Entity> f = multiDeclare.getEntities().stream().filter(item->item.getClass().equals(FunctionEntityImpl.class)).collect(Collectors.toList());
+        this.assertContainsRelation(f.get(0),DependencyType.IMPLEMENT,"foo");
+	}
+	
+}
\ No newline at end of file

4d1742fa08b667932fac3972d52eafcafcb3d830
@@ -18,7 +18,7 @@ public class CppParameterParserTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        assertEquals(5,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

4d1742fa08b667932fac3972d52eafcafcb3d830
@@ -25,7 +25,7 @@ public class DuplicateDeclarationTest extends CppParserTest {
 				    parser.parse();
 			    }
 			    inferer.resolveAllBindings();
-		        assertEquals(7,repo.getEntity("X.invoke").getRelations().size());
+		        assertEquals(8,repo.getEntity("X.invoke").getRelations().size());
 		}
 
 

4d1742fa08b667932fac3972d52eafcafcb3d830
@@ -24,7 +24,7 @@ public class MacroRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(3,repo.getEntity("foo").getRelations().size());
+        assertEquals(4,repo.getEntity("foo").getRelations().size());
 	}
 	
 	

4d1742fa08b667932fac3972d52eafcafcb3d830
@@ -26,7 +26,7 @@ public class UsingTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         Entity e = repo.getEntity("foo");
-        assertEquals(3,e.getRelations().size());
+        assertEquals(4,e.getRelations().size());
 	}
 	
 	@Test
@@ -41,6 +41,6 @@ public class UsingTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         Entity e = repo.getEntity("bar");
-        assertEquals(3,e.getRelations().size());
+        assertEquals(4,e.getRelations().size());
 	}
 }

ed49e71ca2c6cc8fc001ed4881d113f73510ddaa
@@ -74,7 +74,9 @@ public class DependsCommand {
 	private boolean detail = false;	
 	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
 	private boolean autoStub = false;	
-    @Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
+	@Option(names = {"--call-as-impl"}, description = "(only for C/C++)convert the call relation to implementation instead of declaration")
+	private boolean callAsImpl = false;	
+	@Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
     private String[] typeFilter=new String[]{};
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
@@ -147,4 +149,7 @@ public class DependsCommand {
 		}
 		return java.util.Arrays.asList(typeFilter);
 	}
+	public boolean isCallAsImpl() {
+		return callAsImpl;
+	}
 }

ed49e71ca2c6cc8fc001ed4881d113f73510ddaa
@@ -0,0 +1,10 @@
+package depends.entity;
+
+public class FunctionEntityProto  extends FunctionEntity{
+	public FunctionEntityProto() {
+		super();
+	}
+    public FunctionEntityProto(GenericName simpleName, Entity parent, Integer id, GenericName returnType) {
+		super(simpleName,parent,id,returnType);
+	}
+}

ed49e71ca2c6cc8fc001ed4881d113f73510ddaa
@@ -79,7 +79,6 @@ abstract public class AbstractLangProcessor {
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> unsolved;
 	private List<String> typeFilter;
-
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
 		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
@@ -93,23 +92,24 @@ abstract public class AbstractLangProcessor {
      * @param includeDir 
      * @param inputDir 
      */
-	public void buildDependencies(String inputDir, String[] includeDir,List<String> typeFilter) {
+	public void buildDependencies(String inputDir, String[] includeDir,List<String> typeFilter,boolean callAsImpl) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
         parseAllFiles();
-        resolveBindings();
+        resolveBindings(callAsImpl);
         identifyDependencies();
 	}
 
 
 	/**
 	 * 
+	 * @param callAsImpl 
 	 * @return unsolved bindings
  	 */
-    private void resolveBindings() {
+    private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-        this.unsolved =inferer.resolveAllBindings();
+        this.unsolved =inferer.resolveAllBindings(callAsImpl);
         if (getUnsolved().size()>0) {
         	System.err.println("There are " + getUnsolved().size() + " items are unsolved." );
         }

ed49e71ca2c6cc8fc001ed4881d113f73510ddaa
@@ -27,6 +27,8 @@ package depends.relations;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.List;
+import java.util.stream.Collectors;
 
 import depends.deptypes.DependencyType;
 import depends.entity.ContainerEntity;
@@ -35,6 +37,8 @@ import depends.entity.Expression;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.FunctionEntityImpl;
+import depends.entity.FunctionEntityProto;
+import depends.entity.MultiDeclareEntities;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
@@ -44,11 +48,13 @@ public class RelationCounter {
 	private Iterator<Entity> iterator;
 	private Inferer inferer;
 	private EntityRepo repo;
+	private boolean callAsImpl;
 
-	public RelationCounter(Iterator<Entity> iterator, Inferer inferer, EntityRepo repo) {
+	public RelationCounter(Iterator<Entity> iterator, Inferer inferer, EntityRepo repo, boolean callAsImpl) {
 		this.iterator = iterator;
 		this.inferer = inferer;
 		this.repo = repo;
+		this.callAsImpl = callAsImpl;
 	}
 	
 	public void computeRelations() {
@@ -103,8 +109,23 @@ public class RelationCounter {
 			}
 			boolean matched = false;
 			if (expression.isCall) {
-				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
-				matched = true;
+				if (callAsImpl && referredEntity instanceof FunctionEntityProto) {
+					Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
+					if (multiDeclare instanceof MultiDeclareEntities) {
+						MultiDeclareEntities m = (MultiDeclareEntities)multiDeclare;
+						List<ContainerEntity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
+						.collect(Collectors.toList());
+						for (Entity e:entities) {
+							entity.addRelation(new Relation(DependencyType.CALL,e));
+							matched = true;
+						}
+					}
+				}
+				if (!matched) {
+					entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
+					matched = true;
+				}
+
 			}
 			if (expression.isCreate) {
 				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));

ae7c68dea03147c62dd76dfd4abc3de1eaf3e443
@@ -53,7 +53,8 @@ public class FileEntity extends TypeEntity {
 	}
 
 	public void addImport(Import imported) {
-		importedNames.add(imported);
+		if (!importedNames.contains(imported))
+			importedNames.add(imported);
 	}
 	
 	/**

ae7c68dea03147c62dd76dfd4abc3de1eaf3e443
@@ -32,19 +32,31 @@ import java.util.List;
 import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
+import org.eclipse.cdt.core.dom.ast.IMacroBinding;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
+import org.eclipse.cdt.core.index.IIndex;
+import org.eclipse.cdt.core.index.IIndexFileLocation;
+import org.eclipse.cdt.core.model.ILanguage;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
+import org.eclipse.cdt.core.parser.IParserLogService;
 import org.eclipse.cdt.core.parser.IScanner;
+import org.eclipse.cdt.core.parser.IScannerInfo;
 import org.eclipse.cdt.core.parser.NullLogService;
 import org.eclipse.cdt.core.parser.ParserLanguage;
 import org.eclipse.cdt.core.parser.ParserMode;
 import org.eclipse.cdt.core.parser.ScannerInfo;
+import org.eclipse.cdt.internal.core.dom.IIncludeFileResolutionHeuristics;
 import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
 import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
 import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
+import org.eclipse.cdt.internal.core.index.CIndex;
+import org.eclipse.cdt.internal.core.index.IIndexFragment;
+import org.eclipse.cdt.internal.core.parser.IMacroDictionary;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
+import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContent;
+import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContentProvider;
 
 @SuppressWarnings("deprecation")
 public class CDTParser {
@@ -80,13 +92,30 @@ public class CDTParser {
 
 	
 	private IASTTranslationUnit getTranslationUnitofCPP(String file, String content) {
+		IScannerInfo scannerInfo = new ScannerInfo(new HashMap<>(), sysIncludePath.toArray(new String[] {}));
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
-				.getInstance();
+				.getInstance(scannerInfo);
+		InternalFileContentProvider ifcp = new InternalFileContentProvider() {
+			@Override
+			public InternalFileContent getContentForInclusion(String filePath, IMacroDictionary macroDictionary) {
+				return (InternalFileContent) FileContent.createForExternalFileLocation(filePath);
+			}
+
+			@Override
+			public InternalFileContent getContentForInclusion(IIndexFileLocation ifl, String astPath) {
+				return (InternalFileContent) FileContent.create(ifl);
+			}
+		};
+
+
+		IParserLogService log = new NullLogService();
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath.toArray(new String[] {})), ParserLanguage.CPP,
-				new NullLogService(), configuration, null);
+				content.toCharArray()),scannerInfo, ParserLanguage.CPP,
+				log, configuration, ifcp);
+		scanner.setProcessInactiveCode(true);
+		scanner.setComputeImageLocations(true);
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
-				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),
+				scanner, ParserMode.COMPLETE_PARSE, log,
 				new GPPParserExtensionConfigurationExtension(), null);
 		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
 		return astTranslationUnit;

ae7c68dea03147c62dd76dfd4abc3de1eaf3e443
@@ -0,0 +1,26 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class MacroTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void macro_should_be_expanded() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/macros/Macro.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertNotNull(this.repo.getEntity("Macro"));
+	}
+
+}

dbbf80236fdfe6b22ccbc08d0343900cae193f34
@@ -35,9 +35,7 @@ import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
 import org.eclipse.cdt.core.dom.ast.IMacroBinding;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
-import org.eclipse.cdt.core.index.IIndex;
 import org.eclipse.cdt.core.index.IIndexFileLocation;
-import org.eclipse.cdt.core.model.ILanguage;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
 import org.eclipse.cdt.core.parser.IParserLogService;
@@ -47,17 +45,16 @@ import org.eclipse.cdt.core.parser.NullLogService;
 import org.eclipse.cdt.core.parser.ParserLanguage;
 import org.eclipse.cdt.core.parser.ParserMode;
 import org.eclipse.cdt.core.parser.ScannerInfo;
-import org.eclipse.cdt.internal.core.dom.IIncludeFileResolutionHeuristics;
 import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
 import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
 import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
-import org.eclipse.cdt.internal.core.index.CIndex;
-import org.eclipse.cdt.internal.core.index.IIndexFragment;
 import org.eclipse.cdt.internal.core.parser.IMacroDictionary;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContent;
 import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContentProvider;
 
+import depends.util.FileUtil;
+
 @SuppressWarnings("deprecation")
 public class CDTParser {
 	List<String> sysIncludePath = new ArrayList<>();
@@ -81,18 +78,44 @@ public class CDTParser {
 	NullLogService NULL_LOG = new NullLogService();
 	Map<String, String> macroMap = new HashMap<>();
 	public IASTTranslationUnit parse(String file   ) {
-		CodeReader cr;
 		try {
-			cr = new CodeReader(file);
-			return getTranslationUnitofCPP(file,new String(cr.buffer));
+			return getTranslationUnitofCPP(file);
 		} catch (IOException e) {
 		}
 		return new CASTTranslationUnit();
 	}
 
 	
-	private IASTTranslationUnit getTranslationUnitofCPP(String file, String content) {
-		IScannerInfo scannerInfo = new ScannerInfo(new HashMap<>(), sysIncludePath.toArray(new String[] {}));
+	private IASTTranslationUnit getTranslationUnitofCPP(String file) throws IOException {
+		for (String p:sysIncludePath) {
+			if (!FileUtil.isDirectory(p)) {
+				IScanner scanner = buildScanner(p);
+				AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
+						scanner, ParserMode.COMPLETE_PARSE,  new NullLogService(),
+						new GPPParserExtensionConfigurationExtension(), null);
+				sourceCodeParser.parse();
+				Map<String, IMacroBinding> macros = scanner.getMacroDefinitions();
+				for (String key:macros.keySet()) {
+					 String exp = new String(macros.get(key).getExpansion());
+					 if (exp.length()>0) {
+						 macroMap.put(key, exp);
+					 }
+					
+				}
+			}
+		}
+		IScanner scanner = buildScanner(file);
+		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
+				scanner, ParserMode.COMPLETE_PARSE,  new NullLogService(),
+				new GPPParserExtensionConfigurationExtension(), null);
+		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
+		return astTranslationUnit;
+	}
+
+	private IScanner buildScanner(String file) throws IOException {
+		CodeReader cr = new CodeReader(file);
+		String content = new String(cr.buffer);
+		IScannerInfo scannerInfo = new ScannerInfo(macroMap, sysIncludePath.toArray(new String[] {}));
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
 				.getInstance(scannerInfo);
 		InternalFileContentProvider ifcp = new InternalFileContentProvider() {
@@ -106,19 +129,14 @@ public class CDTParser {
 				return (InternalFileContent) FileContent.create(ifl);
 			}
 		};
-
-
-		IParserLogService log = new NullLogService();
+		ParserLanguage lang = ParserLanguage.CPP;
+		if (file.endsWith(".c"))
+			lang = ParserLanguage.C;
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()),scannerInfo, ParserLanguage.CPP,
-				log, configuration, ifcp);
+				content.toCharArray()),scannerInfo, lang,
+				 new NullLogService(), configuration, ifcp);
 		scanner.setProcessInactiveCode(true);
-		scanner.setComputeImageLocations(true);
-		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
-				scanner, ParserMode.COMPLETE_PARSE, log,
-				new GPPParserExtensionConfigurationExtension(), null);
-		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
-		return astTranslationUnit;
+		return scanner;
 	}
 
 }

dbbf80236fdfe6b22ccbc08d0343900cae193f34
@@ -37,7 +37,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals(4,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+        assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
 	
 	

8a5e41b6fffda85f642c62d91a3918e5487e4643
@@ -38,7 +38,6 @@ import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.index.IIndexFileLocation;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
-import org.eclipse.cdt.core.parser.IParserLogService;
 import org.eclipse.cdt.core.parser.IScanner;
 import org.eclipse.cdt.core.parser.IScannerInfo;
 import org.eclipse.cdt.core.parser.NullLogService;

8a5e41b6fffda85f642c62d91a3918e5487e4643
@@ -26,7 +26,7 @@ package depends.extractor.cpp.cdt;
 
 import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
 
-class GPPParserExtensionConfigurationExtension extends GPPParserExtensionConfiguration {
+public class GPPParserExtensionConfigurationExtension extends GPPParserExtensionConfiguration {
 
 	@Override
 	public boolean supportKnRC() {

82bcbbee9f557eef74efd2a3cbff58cd6e4ccd5e
@@ -120,12 +120,22 @@ public class CDTParser {
 		InternalFileContentProvider ifcp = new InternalFileContentProvider() {
 			@Override
 			public InternalFileContent getContentForInclusion(String filePath, IMacroDictionary macroDictionary) {
-				return (InternalFileContent) FileContent.createForExternalFileLocation(filePath);
+				InternalFileContent c = FileCache.getInstance().get(filePath);
+				if (c==null) { 
+					c = (InternalFileContent) FileContent.createForExternalFileLocation(filePath);
+					FileCache.getInstance().put(filePath,c);
+				}
+				return c;
 			}
 
 			@Override
 			public InternalFileContent getContentForInclusion(IIndexFileLocation ifl, String astPath) {
-				return (InternalFileContent) FileContent.create(ifl);
+				InternalFileContent c = FileCache.getInstance().get(ifl);
+				if (c==null) { 
+					c = (InternalFileContent) FileContent.create(ifl);
+					FileCache.getInstance().put(ifl,c);
+				}
+				return c;
 			}
 		};
 		ParserLanguage lang = ParserLanguage.CPP;

82bcbbee9f557eef74efd2a3cbff58cd6e4ccd5e
@@ -27,7 +27,8 @@ package depends.extractor.cpp.cdt;
 import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
 
 public class GPPParserExtensionConfigurationExtension extends GPPParserExtensionConfiguration {
-
+
+	
 	@Override
 	public boolean supportKnRC() {
 		return false;

82bcbbee9f557eef74efd2a3cbff58cd6e4ccd5e
@@ -1,5 +1,8 @@
 package depends.extractor.cpp;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
 
@@ -7,6 +10,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.entity.MultiDeclareEntities;
 
 public class MacroTest extends CppParserTest{
     @Before
@@ -16,11 +20,33 @@ public class MacroTest extends CppParserTest{
 	
 	@Test
 	public void macro_should_be_expanded() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/macros/Macro.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
-        inferer.resolveAllBindings();
+	    String[] srcs = new String[] {
+	    		 "./src/test/resources/cpp-code-examples/macros/Macro.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    
         assertNotNull(this.repo.getEntity("Macro"));
 	}
 
+	@Test
+	public void header_file_can_only_be_count_once() throws IOException {
+	    String[] srcs = new String[] {
+	    		 "./src/test/resources/cpp-code-examples/macros/Macro.cpp",
+	    		 "./src/test/resources/cpp-code-examples/macros/Macro2.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    
+        assertFalse(repo.getEntity("foo") instanceof MultiDeclareEntities);
+	}
+
 }

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -39,6 +39,8 @@ public class CppProcessor extends AbstractLangProcessor {
     private static final String LANG = "cpp";
     private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh", ".cxx",".hxx"};
     PreprocessorHandler preprocessorHandler;
+    
+    MacroRepo macroRepo = null;
     public CppProcessor() {
     	super(false);
     }
@@ -57,8 +59,12 @@ public class CppProcessor extends AbstractLangProcessor {
 
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
+		if (macroRepo==null) {
+	    	macroRepo = new MacroRepo();
+	    	macroRepo.buildDefaultMap(super.includePaths());
+		}
     	preprocessorHandler = new PreprocessorHandler(super.includePaths());
-		return new CdtCppFileParser(fileFullPath,entityRepo,preprocessorHandler,inferer);
+		return new CdtCppFileParser(fileFullPath,entityRepo,preprocessorHandler,inferer,macroRepo);
 	}
 
 	@Override

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -27,36 +27,22 @@ package depends.extractor.cpp.cdt;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
-import org.eclipse.cdt.core.dom.ast.IMacroBinding;
-import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
-import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
-import org.eclipse.cdt.core.index.IIndexFileLocation;
-import org.eclipse.cdt.core.parser.CodeReader;
-import org.eclipse.cdt.core.parser.FileContent;
 import org.eclipse.cdt.core.parser.IScanner;
-import org.eclipse.cdt.core.parser.IScannerInfo;
 import org.eclipse.cdt.core.parser.NullLogService;
-import org.eclipse.cdt.core.parser.ParserLanguage;
 import org.eclipse.cdt.core.parser.ParserMode;
-import org.eclipse.cdt.core.parser.ScannerInfo;
 import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
 import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
 import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
-import org.eclipse.cdt.internal.core.parser.IMacroDictionary;
-import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
-import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContent;
-import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContentProvider;
 
-import depends.util.FileUtil;
+import depends.extractor.cpp.Scanner;
 
 @SuppressWarnings("deprecation")
 public class CDTParser {
-	List<String> sysIncludePath = new ArrayList<>();
+	protected List<String> sysIncludePath = new ArrayList<>();
 
 	public CDTParser() {
 	}
@@ -75,9 +61,10 @@ public class CDTParser {
 		}
 	}
 	NullLogService NULL_LOG = new NullLogService();
-	Map<String, String> macroMap = new HashMap<>();
-	public IASTTranslationUnit parse(String file   ) {
+	protected Map<String, String> macroMap ;
+	public IASTTranslationUnit parse(String file, Map<String, String> macroMap   ) {
 		try {
+			this.macroMap = macroMap;
 			return getTranslationUnitofCPP(file);
 		} catch (IOException e) {
 		}
@@ -85,67 +72,18 @@ public class CDTParser {
 	}
 
 	
-	private IASTTranslationUnit getTranslationUnitofCPP(String file) throws IOException {
-		for (String p:sysIncludePath) {
-			if (!FileUtil.isDirectory(p)) {
-				IScanner scanner = buildScanner(p);
-				AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
-						scanner, ParserMode.COMPLETE_PARSE,  new NullLogService(),
-						new GPPParserExtensionConfigurationExtension(), null);
-				sourceCodeParser.parse();
-				Map<String, IMacroBinding> macros = scanner.getMacroDefinitions();
-				for (String key:macros.keySet()) {
-					 String exp = new String(macros.get(key).getExpansion());
-					 if (exp.length()>0) {
-						 macroMap.put(key, exp);
-					 }
-					
-				}
-			}
-		}
-		IScanner scanner = buildScanner(file);
+	public IASTTranslationUnit getTranslationUnitofCPP(String file) throws IOException {
+		
+		IScanner scanner = Scanner.buildScanner(file,macroMap);
+		if (scanner==null) return null;
+
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
 				scanner, ParserMode.COMPLETE_PARSE,  new NullLogService(),
 				new GPPParserExtensionConfigurationExtension(), null);
-		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
-		return astTranslationUnit;
+		IASTTranslationUnit tu =  sourceCodeParser.parse();
+		return tu;
 	}
 
-	private IScanner buildScanner(String file) throws IOException {
-		CodeReader cr = new CodeReader(file);
-		String content = new String(cr.buffer);
-		IScannerInfo scannerInfo = new ScannerInfo(macroMap, sysIncludePath.toArray(new String[] {}));
-		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
-				.getInstance(scannerInfo);
-		InternalFileContentProvider ifcp = new InternalFileContentProvider() {
-			@Override
-			public InternalFileContent getContentForInclusion(String filePath, IMacroDictionary macroDictionary) {
-				InternalFileContent c = FileCache.getInstance().get(filePath);
-				if (c==null) { 
-					c = (InternalFileContent) FileContent.createForExternalFileLocation(filePath);
-					FileCache.getInstance().put(filePath,c);
-				}
-				return c;
-			}
 
-			@Override
-			public InternalFileContent getContentForInclusion(IIndexFileLocation ifl, String astPath) {
-				InternalFileContent c = FileCache.getInstance().get(ifl);
-				if (c==null) { 
-					c = (InternalFileContent) FileContent.create(ifl);
-					FileCache.getInstance().put(ifl,c);
-				}
-				return c;
-			}
-		};
-		ParserLanguage lang = ParserLanguage.CPP;
-		if (file.endsWith(".c"))
-			lang = ParserLanguage.C;
-		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()),scannerInfo, lang,
-				 new NullLogService(), configuration, ifcp);
-		scanner.setProcessInactiveCode(true);
-		return scanner;
-	}
 
 }

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -19,7 +19,7 @@ public class ConstructFunctionReturnValueTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -33,7 +33,7 @@ public class ConstructFunctionReturnValueTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -21,7 +21,7 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -36,7 +36,7 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -51,7 +51,7 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -68,7 +68,7 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler ,inferer);
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -15,15 +15,17 @@ public abstract class CppParserTest extends ParserTest{
 	protected EntityRepo repo;
 	protected Inferer inferer;
     protected PreprocessorHandler preprocessorHandler;
+	private MacroRepo macroRepo;
 
 	public void init() {
     	repo = new InMemoryEntityRepo();
     	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType(),false);
     	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
     	TemporaryFile.reset();
+    	macroRepo = new MacroRepo();
     }
 	
 	public CppFileParser createParser(String src) {
-		return new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		return new  CdtCppFileParser(src,repo, preprocessorHandler,inferer,macroRepo );
 	}
 }

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -30,7 +30,7 @@ public class ImplementRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    CppFileParser parser =createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -48,5 +48,23 @@ public class MacroTest extends CppParserTest{
 	    
         assertFalse(repo.getEntity("foo") instanceof MultiDeclareEntities);
 	}
+	
+	
+	@Test
+	public void intermediate_file_include_should_work() throws IOException {
+	    String[] srcs = new String[] {
+	    		 "./src/test/resources/cpp-code-examples/macros/Macro3.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    
+        assertNotNull(repo.getEntity("Macro3.bar"));
+	}
+	
+	
 
 }

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -20,7 +20,7 @@ public class TypeDefTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = new  CdtCppFileParser(src,repo, preprocessorHandler,inferer );
+		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

afc64d54694e15059c6e391c8b46b03f16fe447b
@@ -27,6 +27,7 @@ package depends.extractor;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -127,6 +128,7 @@ abstract public class AbstractLangProcessor {
 
     private final void parseAllFiles() {
         System.out.println("start parsing files...");		
+        Set<String> phase2Files = new HashSet<>();
     	FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor(){
 			@Override
 			public void visit(File file) {
@@ -135,24 +137,39 @@ abstract public class AbstractLangProcessor {
 				if (!fileFullPath.startsWith(inputSrcPath)) {
 					return;
 				}
-	            FileParser fileParser = createFileParser(fileFullPath);
-	            try {
-	                System.out.println("parsing " + fileFullPath 
-	                		+ "...");		
-	                fileParser.parse();
-	            } catch (IOException e) {
-	                e.printStackTrace();
-	            }	
+				if (isPhase2Files(fileFullPath)) {
+					
+				}else {
+					parseFile(fileFullPath);
+				}
 			}
     		
     	});
     	fileTransversal.extensionFilter(this.fileSuffixes());
 		fileTransversal.travers(this.inputSrcPath);
+		for (String f:phase2Files) {
+			parseFile(f);
+		}
         System.out.println("all files procceed successfully...");		
 
 	}
     
 
+	protected void parseFile(String fileFullPath) {
+        FileParser fileParser = createFileParser(fileFullPath);
+        try {
+            System.out.println("parsing " + fileFullPath 
+            		+ "...");		
+            fileParser.parse();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }	
+	}
+	
+	protected boolean isPhase2Files(String fileFullPath) {
+		return false;
+	}
+	
 	public List<String> includePaths() {
 		ArrayList<String> r = new ArrayList<String>();
 		for (String path:includeDirs) {

afc64d54694e15059c6e391c8b46b03f16fe447b
@@ -36,15 +36,15 @@ import depends.extractor.cpp.cdt.PreprocessorHandler;
 import depends.relations.ImportLookupStrategy;
 
 public class CppProcessor extends AbstractLangProcessor {
-    private static final String LANG = "cpp";
-    private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh", ".cxx",".hxx"};
-    PreprocessorHandler preprocessorHandler;
-    
-    MacroRepo macroRepo = null;
-    public CppProcessor() {
-    	super(false);
-    }
+	private static final String LANG = "cpp";
+	private static final String[] SUFFIX = new String[] { ".cpp", ".cc", ".c", ".h", ".hpp", ".hh", ".cxx", ".hxx" };
+	PreprocessorHandler preprocessorHandler;
 
+	MacroRepo macroRepo = null;
+
+	public CppProcessor() {
+		super(false);
+	}
 
 	@Override
 	public String supportedLanguage() {
@@ -56,15 +56,14 @@ public class CppProcessor extends AbstractLangProcessor {
 		return SUFFIX;
 	}
 
-
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
-		if (macroRepo==null) {
-	    	macroRepo = new MacroRepo();
-	    	macroRepo.buildDefaultMap(super.includePaths());
+		if (macroRepo == null) {
+			macroRepo = new MacroRepo();
+			macroRepo.buildDefaultMap(super.includePaths());
 		}
-    	preprocessorHandler = new PreprocessorHandler(super.includePaths());
-		return new CdtCppFileParser(fileFullPath,entityRepo,preprocessorHandler,inferer,macroRepo);
+		preprocessorHandler = new PreprocessorHandler(super.includePaths());
+		return new CdtCppFileParser(fileFullPath, entityRepo, preprocessorHandler, inferer, macroRepo);
 	}
 
 	@Override
@@ -72,12 +71,11 @@ public class CppProcessor extends AbstractLangProcessor {
 		return new CppImportLookupStrategy();
 	}
 
-
 	@Override
 	public BuiltInType getBuiltInType() {
 		return new CppBuiltInType();
 	}
-	
+
 	@Override
 	public List<String> supportedRelations() {
 		ArrayList<String> depedencyTypes = new ArrayList<>();
@@ -94,5 +92,14 @@ public class CppProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(CAST);
 		depedencyTypes.add(THROW);
 		return depedencyTypes;
-	}	
+	}
+
+	@Override
+	protected boolean isPhase2Files(String fileFullPath) {
+		if (fileFullPath.endsWith(".h") || fileFullPath.endsWith(".hh") || fileFullPath.endsWith(".hpp")
+				|| fileFullPath.endsWith(".hxx"))
+			return true;
+		return false;
+	}
+
 }

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -49,6 +49,7 @@ public abstract class Entity {
 	private Set<Entity> children = new HashSet<>();
     ArrayList<Relation> relations = new ArrayList<>();
 	private Entity actualReferTo = null;
+	private boolean inScope = true;
 
 	public Entity() {};
     public Entity(GenericName rawName, Entity parent, Integer id) {
@@ -230,5 +231,11 @@ public abstract class Entity {
 			return false;
 		return true;
 	}
+	public void setInScope(boolean value) {
+		this.inScope  = value;
+	}
+	public boolean inScope() {
+		return inScope;
+	}
 	
 }

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -24,6 +24,7 @@ SOFTWARE.
 
 package depends.entity.repo;
 
+import java.util.Collection;
 import java.util.Iterator;
 
 import depends.entity.Entity;
@@ -40,10 +41,12 @@ public interface EntityRepo extends IdGenerator {
 
 	void add(Entity entity);
 
-	Iterator<Entity> getEntities();
+	Iterator<Entity> entityIterator();
 
 	void update(Entity entity);
 
+	Collection<Entity> getEntities();
+
 
 
 }

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -1,5 +1,6 @@
 package depends.entity.repo;
 
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -56,10 +57,11 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	}
 
 	@Override
-	public Iterator<Entity> getEntities() {
+	public Iterator<Entity> entityIterator() {
 		return allEntitiesByOrder.iterator();
 	}
 
+	
 	@Override
 	public void update(Entity entity) {
 	}
@@ -69,4 +71,9 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 		return this.getEntity(rawName.uniqName());
 	}
 
+	@Override
+	public Collection<Entity> getEntities() {
+		return allEntitiesByOrder;
+	}
+
 }

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -33,6 +33,8 @@ import java.util.Set;
 
 import org.codehaus.plexus.util.FileUtils;
 
+import depends.entity.Entity;
+import depends.entity.FileEntity;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
@@ -98,11 +100,20 @@ abstract public class AbstractLangProcessor {
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
         parseAllFiles();
+        markAllEntitiesScope();
         resolveBindings(callAsImpl);
         identifyDependencies();
 	}
 
 
+	private void markAllEntitiesScope() {
+		entityRepo.getEntities().stream().forEach(entity->{
+			Entity file = entity.getAncestorOfType(FileEntity.class);
+			if (!file.getQualifiedName().startsWith(this.inputSrcPath)) {
+				entity.setInScope(false);
+			}
+		});
+	}
 	/**
 	 * 
 	 * @param callAsImpl 

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -44,10 +44,11 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	@Override
 	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
-		Iterator<Entity> iterator = entityRepo.getEntities();
+		Iterator<Entity> iterator = entityRepo.entityIterator();
 		System.out.println("Start create dependencies matrix....");
 		while(iterator.hasNext()) {
 			Entity entity = iterator.next();
+			if (!entity.inScope()) continue;
 			if (entity instanceof FileEntity){
 				String name = stripper.stripFilename(entity.getDisplayName());
 				name = filenameWritter.reWrite(name);

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -38,9 +38,10 @@ import depends.relations.Relation;
 public class FunctionDependencyGenerator extends DependencyGenerator {
 	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
-		Iterator<Entity> iterator = entityRepo.getEntities();
+		Iterator<Entity> iterator = entityRepo.entityIterator();
 		while(iterator.hasNext()) {
 			Entity entity = iterator.next();
+			if (!entity.inScope()) continue;
 			if (entity instanceof FunctionEntity) {
 				String name = getFunctionEntityDisplayName((FunctionEntity)entity);
 				dependencyMatrix.addNode(name,entity.getId());

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -60,7 +60,7 @@ public class RelationCounter {
 	public void computeRelations() {
 		while(iterator.hasNext()) {
 			Entity entity= iterator.next();
-
+			if (!entity.inScope()) continue;
 			if (entity instanceof FileEntity) {
 				computeImports((FileEntity)entity);
 			}

377ef8bb91c46220aad62e34bb76bc19b47da9f2
@@ -59,6 +59,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
         	for (Relation relation:entity.getRelations()) {
         		Entity relatedEntity = relation.getEntity();
         		if (relatedEntity==null) continue;
+        		if (!relatedEntity.inScope()) continue;
         		if (relatedEntity instanceof CandidateTypes) {
         			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
         			for (TypeEntity candidateType:candidateTypes) {

377ef8bb91c46220aad62e34bb76bc19b47da9f2
@@ -50,7 +50,10 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 			if (entityFrom == -1)
 				continue;
 			for (Relation relation : entity.getRelations()) {
-				if (relation.getEntity().getId() >= 0) {
+				Entity relatedEntity = relation.getEntity();
+        		if (relatedEntity==null) continue;
+        		if (!relatedEntity.inScope()) continue;
+				if (relatedEntity.getId() >= 0) {
 					int entityTo = getFunctionEntityIdNoException(relation.getEntity());
 					if (entityTo == -1)
 						continue;

ad3304fccba6662eb9a8fd3d3d428f95305d530a
@@ -59,7 +59,6 @@ public class FileDependencyGenerator extends DependencyGenerator{
         	for (Relation relation:entity.getRelations()) {
         		Entity relatedEntity = relation.getEntity();
         		if (relatedEntity==null) continue;
-        		if (!relatedEntity.inScope()) continue;
         		if (relatedEntity instanceof CandidateTypes) {
         			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
         			for (TypeEntity candidateType:candidateTypes) {
@@ -89,6 +88,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null)
 			return -1;
+		if (!ancestor.inScope()) return -1;
 		return ancestor.getId();
 	}
 

ad3304fccba6662eb9a8fd3d3d428f95305d530a
@@ -52,7 +52,6 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 			for (Relation relation : entity.getRelations()) {
 				Entity relatedEntity = relation.getEntity();
         		if (relatedEntity==null) continue;
-        		if (!relatedEntity.inScope()) continue;
 				if (relatedEntity.getId() >= 0) {
 					int entityTo = getFunctionEntityIdNoException(relation.getEntity());
 					if (entityTo == -1)
@@ -76,13 +75,11 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 	}
 
 
-
-
-
 	private int getFunctionEntityIdNoException(Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
 		if (ancestor == null)
 			return -1;
+		if (!ancestor.inScope()) return -1;
 		return ancestor.getId();
 	}
 

4795536acf50163115018b25d37621a354588d94
@@ -66,6 +66,10 @@ public class Expression implements Serializable{
 	}
 
 	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
+		if (this.referredEntity==null && referredEntity!=null) {
+			this.referredEntity  = referredEntity;
+		}
+		
 		if (type instanceof CandidateTypes) {
 			return ;
 		}
@@ -80,11 +84,9 @@ public class Expression implements Serializable{
 			}
 			changedType = true;
 		}
-		if (this.referredEntity==null && referredEntity!=null) {
-			this.referredEntity  = referredEntity;
-		}
 		if (this.referredEntity==null)
 			this.referredEntity = this.type;
+
 		if (changedType)
 			deduceTheParentType(inferer);
 	}

4795536acf50163115018b25d37621a354588d94
@@ -98,56 +98,65 @@ public class RelationCounter {
 			entity.addRelation(new Relation(DependencyType.MIXIN,mixin));
 		}
 		
-		HashSet<Entity> usedEntities = new HashSet<>();
 		for (Expression expression:entity.expressionList()){
 			if (expression.isStatement) {
 				continue;
 			}
 			Entity referredEntity = expression.getReferredEntity();
-			if (referredEntity==null) {
-				continue;
+			addRelationFromExpression(entity, expression, referredEntity);
+		}
+		
+
+		entity.clearExpressions();
+	}
+
+	private void addRelationFromExpression(ContainerEntity entity, Expression expression, Entity referredEntity) {
+		
+		if (referredEntity==null) {
+			return;
+		}
+
+		if (referredEntity instanceof MultiDeclareEntities) {
+			for (ContainerEntity e:((MultiDeclareEntities)referredEntity).getEntities()) {
+				addRelationFromExpression(entity,expression,e);
 			}
-			boolean matched = false;
-			if (expression.isCall) {
-				if (callAsImpl && referredEntity instanceof FunctionEntityProto) {
-					Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
-					if (multiDeclare instanceof MultiDeclareEntities) {
-						MultiDeclareEntities m = (MultiDeclareEntities)multiDeclare;
-						List<ContainerEntity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
-						.collect(Collectors.toList());
-						for (Entity e:entities) {
-							entity.addRelation(new Relation(DependencyType.CALL,e));
-							matched = true;
-						}
+			return;
+		}
+		boolean matched = false;
+		if (expression.isCall) {
+			if (callAsImpl && referredEntity instanceof FunctionEntityProto) {
+				Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
+				if (multiDeclare instanceof MultiDeclareEntities) {
+					MultiDeclareEntities m = (MultiDeclareEntities)multiDeclare;
+					List<ContainerEntity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
+					.collect(Collectors.toList());
+					for (Entity e:entities) {
+						entity.addRelation(new Relation(DependencyType.CALL,e));
+						matched = true;
 					}
 				}
-				if (!matched) {
-					entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
-					matched = true;
-				}
-
-			}
-			if (expression.isCreate) {
-				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
-				matched = true;
 			}
-			if (expression.isThrow) {
-				entity.addRelation(new Relation(DependencyType.THROW,referredEntity));
+			if (!matched) {
+				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
 				matched = true;
 			}
-			if (expression.isCast) { 
-				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
-				matched = true;
-			}
-			if (!matched)  {
-				usedEntities.add(expression.getReferredEntity());
-			}
+
 		}
-		
-		for (Entity usedEntity:usedEntities) {
-			entity.addRelation(new Relation(DependencyType.USE,usedEntity));
+		if (expression.isCreate) {
+			entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
+			matched = true;
+		}
+		if (expression.isThrow) {
+			entity.addRelation(new Relation(DependencyType.THROW,referredEntity));
+			matched = true;
+		}
+		if (expression.isCast) { 
+			entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
+			matched = true;
+		}
+		if (!matched)  {
+			entity.addRelation(new Relation(DependencyType.USE,referredEntity));
 		}
-		entity.clearExpressions();
 	}
 
 	private void computeTypeRelations(TypeEntity type) {

4795536acf50163115018b25d37621a354588d94
@@ -1,4 +1,6 @@
 package depends.extractor.cpp;
+import static org.junit.Assert.fail;
+
 import java.io.IOException;
 
 import org.junit.Before;
@@ -20,5 +22,7 @@ public class AliasTest extends CppParserTest{
         inferer.resolveAllBindings();
         this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "F.foo");
 	}
+	
+
 
 }

4795536acf50163115018b25d37621a354588d94
@@ -86,7 +86,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(15,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
+        assertEquals(16,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
 	@Test

ef273b33e595e038828d320bd8f38248be854e54
@@ -46,8 +46,9 @@ public class TypeEntity extends ContainerEntity {
 	public void inferLocalLevelEntities(Inferer inferer) {
 		inheritedTypes = new ArrayList<>();
 		identiferToEntities(inferer, this.inhertedTypeIdentifiers).forEach(item -> {
-			if (item instanceof TypeEntity) {
-				inheritedTypes.add((TypeEntity) item);
+			Entity typeItem = getTypeEntity(item);
+			if (typeItem !=null) {
+				inheritedTypes.add((TypeEntity) typeItem);
 			}else {
 				System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
 			}
@@ -57,8 +58,9 @@ public class TypeEntity extends ContainerEntity {
 		implementedTypes = new ArrayList<>();
 		identiferToEntities(inferer, this.implementedIdentifiers)
 				.forEach(item -> {
-					if (item instanceof TypeEntity) {
-						implementedTypes.add((TypeEntity) item);
+					Entity typeItem = getTypeEntity(item);
+					if (typeItem !=null) {
+						implementedTypes.add((TypeEntity) typeItem);
 					}else {
 						System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
 					}
@@ -69,6 +71,13 @@ public class TypeEntity extends ContainerEntity {
 		super.inferLocalLevelEntities(inferer);
 	}
 
+	private Entity getTypeEntity(Entity item) {
+		if (item==null) return null;
+		if (item instanceof TypeEntity) return item;
+		if (item instanceof MultiDeclareEntities) return ((MultiDeclareEntities)item).getType();
+		if (item instanceof AliasEntity) return item.getType();
+		return null;
+	}
 	public void addImplements(GenericName typeName) {
 		if (typeName==null) {
 			return;

ef273b33e595e038828d320bd8f38248be854e54
@@ -23,6 +23,29 @@ public class AliasTest extends CppParserTest{
         this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "F.foo");
 	}
 	
-
+	@Test
+	public void test_refer_to_alias_type_should_work() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/AliasType.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("C"), DependencyType.INHERIT, "A");
+	}
+	
+	@Test
+	public void test_multi_declares_should_only_count_actual_referred() {
+		fail("to be implemented");
+	}
+	
+	@Test
+	public void test_header_files_not_contains_include_should_be_resolved() {
+		/*非规范的include形式，和include顺序有关，例如
+		 A header file contains 
+		     class T
+		 A.hpp // the file use T, but not include T, because it always use after previous header file  
+		     typedef T1 T;
+		 * */
+		fail("to be implemented");
+	}
 
 }

f6364da09d70d8ef4c1c35e9b7017ef47a19b98c
@@ -33,8 +33,18 @@ public class AliasTest extends CppParserTest{
 	}
 	
 	@Test
-	public void test_multi_declares_should_only_count_actual_referred() {
-		fail("to be implemented");
+	public void test_multi_declares_should_only_count_actual_referred() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/MultiDeclareRef.h",
+	    		"./src/test/resources/cpp-code-examples/MultiDeclareRef.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "foo");
 	}
 	
 	@Test

818a9643005ff2b996f40eb6bf6c90c4a4a12c41
@@ -45,34 +45,43 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import depends.util.FileTraversal;
 import depends.util.FileUtil;
+
 abstract public class AbstractLangProcessor {
 	/**
 	 * The name of the lang
+	 * 
 	 * @return
 	 */
 	public abstract String supportedLanguage();
+
 	/**
 	 * The file suffixes in the lang
+	 * 
 	 * @return
 	 */
 	public abstract String[] fileSuffixes();
 
 	/**
-	 * Strategy of how to lookup  types and entities in the lang.
+	 * Strategy of how to lookup types and entities in the lang.
+	 * 
 	 * @return
 	 */
 	public abstract ImportLookupStrategy getImportLookupStrategy();
+
 	/**
-	 * The builtInType of the lang. 
+	 * The builtInType of the lang.
+	 * 
 	 * @return
 	 */
 	public abstract BuiltInType getBuiltInType();
+
 	/**
 	 * The language specific file parser
+	 * 
 	 * @param fileFullPath
 	 * @return
 	 */
-    protected abstract FileParser createFileParser(String fileFullPath);
+	protected abstract FileParser createFileParser(String fileFullPath);
 
 	public Inferer inferer;
 	protected EntityRepo entityRepo;
@@ -82,65 +91,70 @@ abstract public class AbstractLangProcessor {
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> unsolved;
 	private List<String> typeFilter;
+
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
+		inferer = new Inferer(entityRepo, getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
 	}
-	
-    /**
-     * The process steps of build dependencies.
-     * Step 1: parse all files, add entities and expression into repositories
-     * Step 2: resolve bindings of files (if not resolved yet)
-     * Step 3: identify dependencies 
-     * @param includeDir 
-     * @param inputDir 
-     */
-	public void buildDependencies(String inputDir, String[] includeDir,List<String> typeFilter,boolean callAsImpl) {
+
+	/**
+	 * The process steps of build dependencies. Step 1: parse all files, add
+	 * entities and expression into repositories Step 2: resolve bindings of files
+	 * (if not resolved yet) Step 3: identify dependencies
+	 * 
+	 * @param includeDir
+	 * @param inputDir
+	 */
+	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
-        parseAllFiles();
-        markAllEntitiesScope();
-        resolveBindings(callAsImpl);
-        identifyDependencies();
+		parseAllFiles();
+		markAllEntitiesScope();
+		resolveBindings(callAsImpl);
+		identifyDependencies();
 	}
 
-
 	private void markAllEntitiesScope() {
-		entityRepo.getEntities().stream().forEach(entity->{
+		entityRepo.getEntities().stream().forEach(entity -> {
 			Entity file = entity.getAncestorOfType(FileEntity.class);
-			if (!file.getQualifiedName().startsWith(this.inputSrcPath)) {
-				entity.setInScope(false);
+			try {
+				if (!file.getQualifiedName().startsWith(this.inputSrcPath)) {
+					entity.setInScope(false);
+				}
+			} catch (Exception e) {
+
 			}
 		});
 	}
+
 	/**
 	 * 
-	 * @param callAsImpl 
+	 * @param callAsImpl
 	 * @return unsolved bindings
- 	 */
-    private void resolveBindings(boolean callAsImpl) {
+	 */
+	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-        this.unsolved =inferer.resolveAllBindings(callAsImpl);
-        if (getUnsolved().size()>0) {
-        	System.err.println("There are " + getUnsolved().size() + " items are unsolved." );
-        }
-        System.out.println("types and bindings resolved successfully...");
-    }
-    
-    private void identifyDependencies(){
-		System.out.println("dependencie data generating...");	
-        dependencyMatrix  = dependencyGenerator.build(entityRepo,typeFilter);
-        entityRepo = null;
-		System.out.println("reorder dependency matrix...");	
-        dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
-        System.out.println("dependencie data generating done successfully...");	 	
-    }
-
-    private final void parseAllFiles() {
-        System.out.println("start parsing files...");		
-        Set<String> phase2Files = new HashSet<>();
-    	FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor(){
+		this.unsolved = inferer.resolveAllBindings(callAsImpl);
+		if (getUnsolved().size() > 0) {
+			System.err.println("There are " + getUnsolved().size() + " items are unsolved.");
+		}
+		System.out.println("types and bindings resolved successfully...");
+	}
+
+	private void identifyDependencies() {
+		System.out.println("dependencie data generating...");
+		dependencyMatrix = dependencyGenerator.build(entityRepo, typeFilter);
+		entityRepo = null;
+		System.out.println("reorder dependency matrix...");
+		dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
+		System.out.println("dependencie data generating done successfully...");
+	}
+
+	private final void parseAllFiles() {
+		System.out.println("start parsing files...");
+		Set<String> phase2Files = new HashSet<>();
+		FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor() {
 			@Override
 			public void visit(File file) {
 				String fileFullPath = file.getAbsolutePath();
@@ -149,46 +163,44 @@ abstract public class AbstractLangProcessor {
 					return;
 				}
 				if (isPhase2Files(fileFullPath)) {
-					
-				}else {
+
+				} else {
 					parseFile(fileFullPath);
 				}
 			}
-    		
-    	});
-    	fileTransversal.extensionFilter(this.fileSuffixes());
+
+		});
+		fileTransversal.extensionFilter(this.fileSuffixes());
 		fileTransversal.travers(this.inputSrcPath);
-		for (String f:phase2Files) {
+		for (String f : phase2Files) {
 			parseFile(f);
 		}
-        System.out.println("all files procceed successfully...");		
+		System.out.println("all files procceed successfully...");
 
 	}
-    
 
 	protected void parseFile(String fileFullPath) {
-        FileParser fileParser = createFileParser(fileFullPath);
-        try {
-            System.out.println("parsing " + fileFullPath 
-            		+ "...");		
-            fileParser.parse();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }	
+		FileParser fileParser = createFileParser(fileFullPath);
+		try {
+			System.out.println("parsing " + fileFullPath + "...");
+			fileParser.parse();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
 	}
-	
+
 	protected boolean isPhase2Files(String fileFullPath) {
 		return false;
 	}
-	
+
 	public List<String> includePaths() {
 		ArrayList<String> r = new ArrayList<String>();
-		for (String path:includeDirs) {
+		for (String path : includeDirs) {
 			if (FileUtils.fileExists(path)) {
 				if (!r.contains(path))
 					r.add(path);
 			}
-			path = this.inputSrcPath +File.separator+path;
+			path = this.inputSrcPath + File.separator + path;
 			if (FileUtils.fileExists(path)) {
 				if (!r.contains(path))
 					r.add(path);
@@ -196,10 +208,11 @@ abstract public class AbstractLangProcessor {
 		}
 		return r;
 	}
-	
+
 	public DependencyMatrix getDependencies() {
 		return dependencyMatrix;
 	}
+
 	public EntityRepo getEntityRepo() {
 		return this.entityRepo;
 	}
@@ -207,7 +220,9 @@ abstract public class AbstractLangProcessor {
 	public void setDependencyGenerator(DependencyGenerator dependencyGenerator) {
 		this.dependencyGenerator = dependencyGenerator;
 	}
+
 	public abstract List<String> supportedRelations();
+
 	public Set<UnsolvedBindings> getUnsolved() {
 		return unsolved;
 	}

818a9643005ff2b996f40eb6bf6c90c4a4a12c41
@@ -4,6 +4,7 @@ import static org.junit.Assert.fail;
 import java.io.IOException;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
@@ -47,7 +48,7 @@ public class AliasTest extends CppParserTest{
         this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "foo");
 	}
 	
-	@Test
+	@Ignore
 	public void test_header_files_not_contains_include_should_be_resolved() {
 		/*非规范的include形式，和include顺序有关，例如
 		 A header file contains 
@@ -55,6 +56,7 @@ public class AliasTest extends CppParserTest{
 		 A.hpp // the file use T, but not include T, because it always use after previous header file  
 		     typedef T1 T;
 		 * */
+		//TODO: 
 		fail("to be implemented");
 	}
 

f96a8bfd551c8586e328ea00855389b525821749
@@ -42,6 +42,10 @@ public class DependencyType {
 	public static final String THROW = "Throw";
 	public static final String ANNOTATION = "Annotation";
 	public static final String MIXIN = "MixIn";
+	public static final String PomParent = "Parent";
+	public static final String PomPlugin = "Plugin";
+	public static final String PomDependency = "Dependency";
+	
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();
@@ -60,6 +64,9 @@ public class DependencyType {
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
 		depedencyTypes.add(MIXIN);
+		depedencyTypes.add(PomParent);
+		depedencyTypes.add(PomPlugin);
+		depedencyTypes.add(PomDependency);
 		return depedencyTypes;
 	}
 }

f96a8bfd551c8586e328ea00855389b525821749
@@ -129,6 +129,7 @@ public abstract class Entity {
 
 	public void setRawName(GenericName rawName) {
 		this.rawName = rawName;
+		deduceQualifiedName();
 	}
 	
 	public final String getQualifiedName() {

f96a8bfd551c8586e328ea00855389b525821749
@@ -135,7 +135,7 @@ abstract public class AbstractLangProcessor {
 	 */
 	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-		this.unsolved = inferer.resolveAllBindings(callAsImpl);
+		this.unsolved = inferer.resolveAllBindings(callAsImpl,this);
 		if (getUnsolved().size() > 0) {
 			System.err.println("There are " + getUnsolved().size() + " items are unsolved.");
 		}
@@ -227,4 +227,8 @@ abstract public class AbstractLangProcessor {
 		return unsolved;
 	}
 
+	public String getRelationMapping(String relation) {
+		return relation;
+	}
+
 }

f96a8bfd551c8586e328ea00855389b525821749
@@ -83,4 +83,6 @@ public class JavaProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(ANNOTATION);
 		return depedencyTypes;
 	}
+	
+
 }

f96a8bfd551c8586e328ea00855389b525821749
@@ -42,6 +42,7 @@ import depends.entity.MultiDeclareEntities;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
+import depends.extractor.AbstractLangProcessor;
 
 public class RelationCounter {
 
@@ -49,12 +50,14 @@ public class RelationCounter {
 	private Inferer inferer;
 	private EntityRepo repo;
 	private boolean callAsImpl;
+	private AbstractLangProcessor langProcessor;
 
-	public RelationCounter(Iterator<Entity> iterator, Inferer inferer, EntityRepo repo, boolean callAsImpl) {
+	public RelationCounter(Iterator<Entity> iterator, Inferer inferer, EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor) {
 		this.iterator = iterator;
 		this.inferer = inferer;
 		this.repo = repo;
 		this.callAsImpl = callAsImpl;
+		this.langProcessor = langProcessor;
 	}
 	
 	public void computeRelations() {
@@ -83,19 +86,19 @@ public class RelationCounter {
 		entity.resolveExpressions(inferer);
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
-				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
+				entity.addRelation(buildRelation(DependencyType.CONTAIN,var.getType()));
 			for (Entity type:var.getResolvedTypeParameters()) {
-				var.addRelation(new Relation(DependencyType.PARAMETER,type));
+				var.addRelation(buildRelation(DependencyType.PARAMETER,type));
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {
-			entity.addRelation(new Relation(DependencyType.ANNOTATION,type));
+			entity.addRelation(buildRelation(DependencyType.ANNOTATION,type));
 		}
 		for (Entity type:entity.getResolvedTypeParameters()) {
-			entity.addRelation(new Relation(DependencyType.USE,type));
+			entity.addRelation(buildRelation(DependencyType.USE,type));
 		}
 		for (ContainerEntity mixin:entity.getResolvedMixins()) {
-			entity.addRelation(new Relation(DependencyType.MIXIN,mixin));
+			entity.addRelation(buildRelation(DependencyType.MIXIN,mixin));
 		}
 		
 		for (Expression expression:entity.expressionList()){
@@ -131,61 +134,67 @@ public class RelationCounter {
 					List<ContainerEntity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
 					.collect(Collectors.toList());
 					for (Entity e:entities) {
-						entity.addRelation(new Relation(DependencyType.CALL,e));
+						entity.addRelation(buildRelation(DependencyType.CALL,e));
 						matched = true;
 					}
 				}
 			}
 			if (!matched) {
-				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
+				entity.addRelation(buildRelation(DependencyType.CALL,referredEntity));
 				matched = true;
 			}
 
 		}
 		if (expression.isCreate) {
-			entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
+			entity.addRelation(buildRelation(DependencyType.CREATE,referredEntity));
 			matched = true;
 		}
 		if (expression.isThrow) {
-			entity.addRelation(new Relation(DependencyType.THROW,referredEntity));
+			entity.addRelation(buildRelation(DependencyType.THROW,referredEntity));
 			matched = true;
 		}
 		if (expression.isCast) { 
-			entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
+			entity.addRelation(buildRelation(DependencyType.CAST,referredEntity));
 			matched = true;
 		}
 		if (!matched)  {
-			entity.addRelation(new Relation(DependencyType.USE,referredEntity));
+			entity.addRelation(buildRelation(DependencyType.USE,referredEntity));
 		}
 	}
 
+	private Relation buildRelation(String type, Entity referredEntity) {
+		if (this.langProcessor==null)
+			return new Relation(type,referredEntity);
+		return new Relation(langProcessor.getRelationMapping(type),referredEntity);
+	}
+
 	private void computeTypeRelations(TypeEntity type) {
 		for (TypeEntity superType:type.getInheritedTypes()) {
-			type.addRelation(new Relation(DependencyType.INHERIT,superType));
+			type.addRelation(buildRelation(DependencyType.INHERIT,superType));
 		}
 		for (TypeEntity interfaceType:type.getImplementedTypes()) {
-			type.addRelation(new Relation(DependencyType.IMPLEMENT,interfaceType));
+			type.addRelation(buildRelation(DependencyType.IMPLEMENT,interfaceType));
 		}
 	}
 
 	private void computeFunctionRelations(FunctionEntity func) {
 		for (Entity returnType:func.getReturnTypes()) {
-			func.addRelation(new Relation(DependencyType.RETURN,returnType.getActualReferTo()));
+			func.addRelation(buildRelation(DependencyType.RETURN,returnType.getActualReferTo()));
 		}
 		for (VarEntity parameter:func.getParameters()) {
 			if (parameter.getType()!=null) 
-				func.addRelation(new Relation(DependencyType.PARAMETER,parameter.getActualReferTo()));
+				func.addRelation(buildRelation(DependencyType.PARAMETER,parameter.getActualReferTo()));
 		}
 		for (Entity throwType:func.getThrowTypes()) {
-			func.addRelation(new Relation(DependencyType.THROW,throwType));
+			func.addRelation(buildRelation(DependencyType.THROW,throwType));
 		}
 		for (Entity type:func.getResolvedTypeParameters()) {
-			func.addRelation(new Relation(DependencyType.PARAMETER,type));
+			func.addRelation(buildRelation(DependencyType.PARAMETER,type));
 		}
 		if (func instanceof FunctionEntityImpl) {
 			FunctionEntityImpl funcImpl = (FunctionEntityImpl)func;
 			if(funcImpl.getImplemented()!=null) {
-				func.addRelation(new Relation(DependencyType.IMPLEMENT,funcImpl.getImplemented()));
+				func.addRelation(buildRelation(DependencyType.IMPLEMENT,funcImpl.getImplemented()));
 			}
 		}
 	}
@@ -197,9 +206,9 @@ public class RelationCounter {
 			if (imported instanceof FileEntity)
 			{
 				if (((FileEntity)imported).isInProjectScope())
-					file.addRelation(new Relation(DependencyType.IMPORT,imported));
+					file.addRelation(buildRelation(DependencyType.IMPORT,imported));
 			}else {
-				file.addRelation(new Relation(DependencyType.IMPORT,imported));
+				file.addRelation(buildRelation(DependencyType.IMPORT,imported));
 			}
 		}
 	}

f96a8bfd551c8586e328ea00855389b525821749
@@ -24,7 +24,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(0,repo.getEntity("org.log4j-test.log4j(1.2.12)").getRelations().size());
+        assertEquals(0,repo.getEntity("org.log4j-test.log4j_1.2.12_").getRelations().size());
 	}
 	
 	
@@ -39,7 +39,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4(2.12.4)"));
+        assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4_2.12.4_"));
 	}
 	
 	@Test
@@ -53,7 +53,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
     	/*
         <project.version>1.00</project.version>
         <activeio-version>3.1.4</activeio-version>
@@ -75,7 +75,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
     	/*
         <project.version>1.00</project.version>
         <activeio-version>3.1.4</activeio-version>
@@ -95,7 +95,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
         assertEquals("13",entity.getProperty("project.version"));
 	}
 }
\ No newline at end of file

60e961d4b1f2cc6040a442a9503a9f4af7a8a335
@@ -0,0 +1,34 @@
+package depends.extractor.pom;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class DependencyTest extends MavenParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_extract_dep_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/to.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	}
+	
+	
+}
\ No newline at end of file

60e961d4b1f2cc6040a442a9503a9f4af7a8a335
@@ -4,10 +4,11 @@ import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.repo.EntityRepo;
+import depends.extractor.ParserTest;
 import depends.relations.Inferer;
 import depends.util.TemporaryFile;
 
-public abstract class MavenParserTest {
+public abstract class MavenParserTest extends ParserTest{
 
 	protected EntityRepo repo;
 	private PomProcessor p;

7be48f87c6c3298c6cb5bca15a6a56605fd8212b
@@ -30,5 +30,20 @@ public class DependencyTest extends MavenParserTest{
 	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
 	}
 	
+	@Test
+	public void should_extract_plugin_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/plugin.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	}
+	
 	
 }
\ No newline at end of file

6571df64e908777bd8949cd85afa4b0f5311b9a8
@@ -252,11 +252,13 @@ public class Expression implements Serializable{
 
 	private boolean validName(String name) {
 		if (name==null) return false;
-		if (name.equals("<Literal>")) return true;
-		if (name.equals("<Built-In>")) return true;
-		if (name.equals("<built-in>")) return true;
-		if (name.equals("built-in")) return true;
-		return name.matches("([a-zA-Z0-9_]|(\\.))*");
+		if (name.toLowerCase().equals("<literal>")) return true;
+		if (name.toLowerCase().equals("<built-in>")) return true;
+		boolean result = name.matches("([a-zA-Z0-9_]|(\\.)|(\\-))*");
+		if (result==false) {
+			System.err.println("expression name " + name);
+		}
+		return true;
 	}
 
 	public void setIdentifier(GenericName name) {

6571df64e908777bd8949cd85afa4b0f5311b9a8
@@ -105,9 +105,9 @@ public class ExpressionUsage {
 		if (expression.isDot) {
 			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
 			if (op2 instanceof IASTIdExpression)
-				expression.setIdentifier(((IASTIdExpression)op2).getName().toString());
+				expression.setIdentifier(ASTStringUtilExt.getName(((IASTIdExpression)op2).getName()));
 			else if (op2 instanceof IASTLiteralExpression)
-				expression.setIdentifier(((IASTLiteralExpression)op2).getRawSignature());
+				expression.setIdentifier(ASTStringUtilExt.getName((IASTLiteralExpression)op2));
 			else if (op2 instanceof IASTFunctionCallExpression)
 				expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression)op2));
 			return;
@@ -126,7 +126,7 @@ public class ExpressionUsage {
 		//1. we only handle leaf node. if there is still expression,
 		//   the type will be determined by child node in the expression
 		if (ctx instanceof IASTIdExpression){
-			expression.setIdentifier(((IASTIdExpression) ctx).getName().toString());
+			expression.setIdentifier(ASTStringUtilExt.getName(((IASTIdExpression)ctx).getName()));
 		}else if (ctx instanceof IASTLiteralExpression) {
 		//2. if it is a var name, dertermine the type based on context.
 			expression.setIdentifier("<Literal>");
@@ -141,7 +141,7 @@ public class ExpressionUsage {
 	private GenericName getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
 		IASTExpression f = methodCall.getFunctionNameExpression();
 		if (f instanceof IASTIdExpression) {
-			return GenericName.build(((IASTIdExpression)f).getName().toString().replace("::", "."));
+			return GenericName.build(ASTStringUtilExt.getName(((IASTIdExpression)f).getName()));
 		}
 		return null;
 	}

6571df64e908777bd8949cd85afa4b0f5311b9a8
@@ -0,0 +1,51 @@
+package depends.extractor.pom;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_extract_dep_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent/parent-group/a-parent/1.0/a-parent-1.0.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent/to.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	}
+	
+	@Test
+	public void should_extract_plugin_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent/parent-group/a-parent/1.0/a-parent-1.0.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent/plugin.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	}
+	
+	
+}
\ No newline at end of file

6571df64e908777bd8949cd85afa4b0f5311b9a8
@@ -0,0 +1,49 @@
+package depends.extractor.pom;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class DependencyWithPropertiesTest extends MavenParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_extract_dep_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyWithProperties/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithProperties/to.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	}
+	
+	@Test
+	public void should_extract_plugin_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyWithProperties/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithProperties/plugin.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	}
+	
+	
+}
\ No newline at end of file

6571df64e908777bd8949cd85afa4b0f5311b9a8
@@ -17,6 +17,7 @@ public abstract class MavenParserTest extends ParserTest{
 	public void init() {
 		List<String> includeDir = new ArrayList<>();
 		includeDir.add("./src/test/resources/maven-code-examples/");
+		includeDir.add("./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent");
 		this.p = new PomProcessor();
 		p.includeDirs = includeDir.toArray(new String[] {});
 		

ff26192c2be15023d7081348a59f01833bf64f06
@@ -1,6 +1,8 @@
 package depends.extractor.pom;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
 
@@ -8,6 +10,8 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.entity.MultiDeclareEntities;
 
 public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
     @Before
@@ -28,6 +32,7 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
+	    assertFalse(repo.getEntity("parent-group.a-parent_1.0_") instanceof MultiDeclareEntities);
 	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
 	}
 	

406b53d3840de487c2b4565bfc990212b46552af
@@ -0,0 +1,40 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.extractor.pom;
+
+import depends.entity.GenericName;
+
+public class PomCoords  {
+	public PomCoords() {
+	}
+
+	public String groupId;
+	public String artifactId;
+	public String version;
+	public String getPath() {
+		return groupId+"."+artifactId+"_" +version+"_" ;
+	}
+
+}

406b53d3840de487c2b4565bfc990212b46552af
@@ -35,5 +35,10 @@ public class PomParent extends Import {
 	public String groupId;
 	public String artifactId;
 	public String version;
+	public void buildFrom(PomCoords pomCoords) {
+		this.groupId = pomCoords.groupId;
+		this.artifactId = pomCoords.groupId;
+		this.version = pomCoords.version;
+	}
 
 }

406b53d3840de487c2b4565bfc990212b46552af
@@ -1,8 +1,5 @@
 package depends.extractor.pom;
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
 
@@ -10,7 +7,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
-import depends.entity.Entity;
 import depends.entity.MultiDeclareEntities;
 
 public class DependencyWithPropertiesOfParentTest extends MavenParserTest{

406b53d3840de487c2b4565bfc990212b46552af
@@ -0,0 +1,46 @@
+package depends.extractor.pom;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class DependencyWithoutVersionTest extends MavenParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_extract_dep_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/to.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	}
+	
+	@Test
+	public void should_extract_plugin_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/plugin.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	}
+	
+	
+}
\ No newline at end of file

b11253d8af444193832a39661bb94f71bb57ca4f
@@ -24,7 +24,11 @@ SOFTWARE.
 
 package depends.extractor.pom;
 
+import java.io.File;
+import java.util.List;
+
 import depends.entity.GenericName;
+import depends.util.FileUtil;
 
 public class PomCoords  {
 	public PomCoords() {
@@ -36,5 +40,34 @@ public class PomCoords  {
 	public String getPath() {
 		return groupId+"."+artifactId+"_" +version+"_" ;
 	}
+	public void fillFromIfNull(PomParent pomParent) {
+		if (groupId==null) groupId = pomParent.groupId;
+		if (artifactId==null) artifactId = pomParent.artifactId;
+		if (version==null) version = pomParent.version;
+	}
+	public GenericName getGenericNamePath() {
+		return new GenericName(getPath());
+	}
+	public void sureFillVersion(List<String> includePaths) {
+		if (version!=null) return;
+		StringBuilder sb = new StringBuilder();
+		sb.append(this.groupId.replace(".", File.separator));
+		sb.append(File.separator);
+		sb.append(this.artifactId);
+		sb.append(File.separator);
+		
+		for (String includePath:includePaths) {
+			String path = includePath+File.separator+sb.toString();
+			if (FileUtil.existFile(path)) {
+				File f = new File(path);
+				String max = "";
+				for (String d:f.list()) {
+					if (d.compareTo(max)>0)
+						max = d;
+				}
+				version = max;
+			}
+		}
+	}
 
 }

b11253d8af444193832a39661bb94f71bb57ca4f
@@ -37,8 +37,9 @@ public class PomParent extends Import {
 	public String version;
 	public void buildFrom(PomCoords pomCoords) {
 		this.groupId = pomCoords.groupId;
-		this.artifactId = pomCoords.groupId;
+		this.artifactId = pomCoords.artifactId;
 		this.version = pomCoords.version;
+		this.setContent(pomCoords.getPath());
 	}
 
 }

b11253d8af444193832a39661bb94f71bb57ca4f
@@ -16,7 +16,7 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 	public void should_extract_dep_relation() throws IOException {
 	    String[] srcs = new String[] {
 	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/from.pom",
-	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/to.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/a-dep-group/a-artifact/0.2/to.pom",
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -31,7 +31,7 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 	public void should_extract_plugin_relation() throws IOException {
 	    String[] srcs = new String[] {
 	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/from.pom",
-	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/plugin.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyWithoutVersion/aplugins/aplugin/0.1/plugin.pom",
 	    	    };
 	    
 	    for (String src:srcs) {

b11253d8af444193832a39661bb94f71bb57ca4f
@@ -18,6 +18,8 @@ public abstract class MavenParserTest extends ParserTest{
 		List<String> includeDir = new ArrayList<>();
 		includeDir.add("./src/test/resources/maven-code-examples/");
 		includeDir.add("./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent");
+		includeDir.add("./src/test/resources/maven-code-examples/dependencyWithoutVersion");
+		
 		this.p = new PomProcessor();
 		p.includeDirs = includeDir.toArray(new String[] {});
 		

70a678537832952f5bf42e6c44372a60e63821ab
@@ -34,22 +34,22 @@ public class PomCoords  {
 	public PomCoords() {
 	}
 
-	public String groupId;
-	public String artifactId;
-	public String version;
+	public String groupId = "";
+	public String artifactId = "";
+	public String version = "";
 	public String getPath() {
 		return groupId+"."+artifactId+"_" +version+"_" ;
 	}
 	public void fillFromIfNull(PomParent pomParent) {
-		if (groupId==null) groupId = pomParent.groupId;
-		if (artifactId==null) artifactId = pomParent.artifactId;
-		if (version==null) version = pomParent.version;
+		if (groupId=="") groupId = pomParent.groupId;
+		if (artifactId=="") artifactId = pomParent.artifactId;
+		if (version=="") version = pomParent.version;
 	}
 	public GenericName getGenericNamePath() {
 		return new GenericName(getPath());
 	}
 	public void sureFillVersion(List<String> includePaths) {
-		if (version!=null) return;
+		if (version!="") return;
 		StringBuilder sb = new StringBuilder();
 		sb.append(this.groupId.replace(".", File.separator));
 		sb.append(File.separator);

70a678537832952f5bf42e6c44372a60e63821ab
@@ -32,9 +32,9 @@ public class PomParent extends Import {
 		super(content);
 	}
 
-	public String groupId;
-	public String artifactId;
-	public String version;
+	public String groupId = "";
+	public String artifactId = "";
+	public String version = "";
 	public void buildFrom(PomCoords pomCoords) {
 		this.groupId = pomCoords.groupId;
 		this.artifactId = pomCoords.artifactId;

1dbf851df92f6e8022cc693b2f5948026c516fa7
@@ -255,9 +255,9 @@ public class Expression implements Serializable{
 		if (name.toLowerCase().equals("<literal>")) return true;
 		if (name.toLowerCase().equals("<built-in>")) return true;
 		boolean result = name.matches("([a-zA-Z0-9_]|(\\.)|(\\-))*");
-		if (result==false) {
-			System.err.println("expression name " + name);
-		}
+//		if (result==false) {
+//			System.err.println("expression name " + name);
+//		}
 		return true;
 	}
 

84d5c9beae5aacabc4f46f0a0163f984335b21ba
@@ -304,7 +304,9 @@ public abstract class HandlerContext {
 				container.cacheExpressions();
 			}
 		}
-		entityStack.pop();
+		//we never pop up the lastest one (FileEntity)
+		if (entityStack.size()>1)
+			entityStack.pop();
 	}
 	
 	private VarEntity getVar(ContainerEntity container, GenericName varName) {

271e68b9fcad9ff8cb867ab708b71fbe44928dea
@@ -6,6 +6,7 @@ import java.util.List;
 import org.eclipse.cdt.core.dom.ast.ASTVisitor;
 import org.eclipse.cdt.core.dom.ast.IASTDeclSpecifier;
 import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
 import org.eclipse.cdt.core.dom.ast.IASTName;
 import org.eclipse.cdt.core.dom.ast.IASTNode;
 import org.eclipse.cdt.core.dom.ast.IASTTypeId;
@@ -38,6 +39,8 @@ class TemplateParameterASTVisitor extends ASTVisitor{
 				} else if (argument instanceof IASTIdExpression){
 					String parameterName = ASTStringUtilExt.getName(((IASTIdExpression)argument).getName());
 					parameters.add(GenericName.build(parameterName));
+				} else if (argument instanceof IASTLiteralExpression){
+					parameters.add(GenericName.build("<Literal>"));
 				}else {
 					System.err.println ("TODO: unknown template arguments");
 				}

fd397a0f13a3c1627a0dcbd6099f66104dbf64be
@@ -186,6 +186,9 @@ abstract public class AbstractLangProcessor {
 			fileParser.parse();
 		} catch (IOException e) {
 			e.printStackTrace();
+		} catch (Exception e) {
+			System.err.println("error occoured during parse file " + fileFullPath);
+			e.printStackTrace();
 		}
 	}
 

0b82d62bc4ae4654adacde93509845d43bf5ae17
@@ -149,7 +149,7 @@ public class FileEntity extends TypeEntity {
 		this.cacheExpressions();
 		for (Entity child:containerEntity.getChildren()) {
 			if (child instanceof ContainerEntity) {
-				cacheChildExpressions((ContainerEntity)child);
+				((ContainerEntity)child).cacheExpressions();
 			}
 		}
 	}

0d2f9238499aaaff77c317200c54ce303dba8445
@@ -139,7 +139,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
-
+		if(expressionList.size()>10000) return;
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
 			if (expression.getType() != null)

0d2f9238499aaaff77c317200c54ce303dba8445
@@ -0,0 +1,25 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class InheritTypeTest extends JavaParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void should_handle_inherited_type_correctly() throws IOException {
+        String src = "./src/test/resources/java-code-examples/InheritTest.java";
+        JavaFileParser parser =createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertEquals(1,entityRepo.getEntity("InheritTest").getRelations().size());
+	}
+}

0d2f9238499aaaff77c317200c54ce303dba8445
@@ -0,0 +1,7 @@
+class A{
+	A(){}
+}
+
+public class InheritTest extends A{
+	
+}
\ No newline at end of file

b217ef7aaa6067b1ee40c9d34574875056bd682c
@@ -37,7 +37,7 @@ import depends.relations.ImportLookupStrategy;
 
 public class CppProcessor extends AbstractLangProcessor {
 	private static final String LANG = "cpp";
-	private static final String[] SUFFIX = new String[] { ".cpp", ".cc", ".c", ".h", ".hpp", ".hh", ".cxx", ".hxx" };
+	private static final String[] SUFFIX = new String[] { ".cpp", ".cc", ".c", ".c++", ".h", ".hpp", ".hh", ".cxx", ".hxx" };
 	PreprocessorHandler preprocessorHandler;
 
 	MacroRepo macroRepo = null;

b3123721086227b5c892a7c4ad0709c77b88d7be
@@ -29,6 +29,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -50,7 +51,10 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	private HashMap<Object, Expression> expressions;
+	WeakReference<HashMap<Object, Expression>> expressionWeakReference = new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
+	//private HashMap<Object, Expression> expressions;
+	
+	
 	private ArrayList<Expression> expressionList;
 	private Collection<GenericName> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
@@ -60,7 +64,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		functions = new ArrayList<>();
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
-		expressions = new HashMap<>();
 		expressionList = new ArrayList<>();
 	}
 
@@ -70,7 +73,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		functions = new ArrayList<>();
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
-		expressions = new HashMap<>();
 		expressionList = new ArrayList<>();
 	}
 
@@ -94,11 +96,13 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public HashMap<Object, Expression> expressions() {
-		return expressions;
+		HashMap<Object, Expression> r = expressionWeakReference.get();
+		if (r==null) return new HashMap<>();
+		return r;
 	}
 
 	public void addExpression(Object key, Expression expression) {
-		expressions.put(key, expression);
+		expressions().put(key, expression);
 		expressionList.add(expression);
 	}
 
@@ -181,13 +185,19 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
-		this.expressions = new HashMap<>();
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
 		cacheExpressionListToFile();
+		this.expressionList.clear();
+		this.expressionList=null;
 		this.expressionList = new ArrayList<>();
 	}
 
 	public void clearExpressions() {
-		this.expressions = new HashMap<>();
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
+		this.expressionList.clear();
+		this.expressionList=null;
 		this.expressionList = new ArrayList<>();
 	}
 	
@@ -236,7 +246,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public boolean containsExpression() {
-		return expressions.size() > 0;
+		return expressions().size() > 0;
 	}
 
 	public String dumpExpressions() {
@@ -358,10 +368,4 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public Collection<ContainerEntity> getResolvedMixins() {
 		return resolvedMixins;
 	}
-
-
-
-
-
-
 }

8177ac46f304e681acd77cd5b787d4bbdb8717dc
@@ -86,7 +86,7 @@ abstract public class AbstractLangProcessor {
 	public Inferer inferer;
 	protected EntityRepo entityRepo;
 	DependencyMatrix dependencyMatrix;
-	private String inputSrcPath;
+	protected String inputSrcPath;
 	public String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> unsolved;

8177ac46f304e681acd77cd5b787d4bbdb8717dc
@@ -38,12 +38,13 @@ import depends.relations.ImportLookupStrategy;
 public class CppProcessor extends AbstractLangProcessor {
 	private static final String LANG = "cpp";
 	private static final String[] SUFFIX = new String[] { ".cpp", ".cc", ".c", ".c++", ".h", ".hpp", ".hh", ".cxx", ".hxx" };
-	PreprocessorHandler preprocessorHandler;
+	PreprocessorHandler preprocessorHandler = null;
 
 	MacroRepo macroRepo = null;
 
 	public CppProcessor() {
 		super(false);
+
 	}
 
 	@Override
@@ -62,7 +63,9 @@ public class CppProcessor extends AbstractLangProcessor {
 			macroRepo = new MacroRepo();
 			macroRepo.buildDefaultMap(super.includePaths());
 		}
-		preprocessorHandler = new PreprocessorHandler(super.includePaths());
+		if (preprocessorHandler==null) {
+			preprocessorHandler = new PreprocessorHandler(super.inputSrcPath,super.includePaths());
+		}
 		return new CdtCppFileParser(fileFullPath, entityRepo, preprocessorHandler, inferer, macroRepo);
 	}
 

8177ac46f304e681acd77cd5b787d4bbdb8717dc
@@ -24,10 +24,7 @@ SOFTWARE.
 
 package depends.extractor.cpp.cdt;
 
-import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
@@ -42,24 +39,6 @@ import depends.extractor.cpp.Scanner;
 
 @SuppressWarnings("deprecation")
 public class CDTParser {
-	protected List<String> sysIncludePath = new ArrayList<>();
-
-	public CDTParser() {
-	}
-	
-	public CDTParser(List<String> includesPath) {
-		for (String f:includesPath) {
-			File file = new File(f);
-			if (file.exists()) {
-				try {
-					sysIncludePath.add(file.getCanonicalPath());
-				} catch (IOException e) {
-				}
-			}else {
-				//System.err.println("include path " + f + " does not exist!");
-			}
-		}
-	}
 	NullLogService NULL_LOG = new NullLogService();
 	protected Map<String, String> macroMap ;
 	public IASTTranslationUnit parse(String file, Map<String, String> macroMap   ) {

8177ac46f304e681acd77cd5b787d4bbdb8717dc
@@ -20,7 +20,7 @@ public abstract class CppParserTest extends ParserTest{
 	public void init() {
     	repo = new InMemoryEntityRepo();
     	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType(),false);
-    	preprocessorHandler = new PreprocessorHandler(new ArrayList<>());
+    	preprocessorHandler = new PreprocessorHandler("./src/test/resources/cpp-code-examples/",new ArrayList<>());
     	TemporaryFile.reset();
     	macroRepo = new MacroRepo();
     }

757d605ac61d7e8cec2352eb42756b8af8de032d
@@ -51,51 +51,62 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	WeakReference<HashMap<Object, Expression>> expressionWeakReference = new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
-	//private HashMap<Object, Expression> expressions;
-	
-	
+	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
 	private ArrayList<Expression> expressionList;
 	private Collection<GenericName> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
 
+	private ArrayList<VarEntity> vars() {
+		if (vars==null)
+			vars = new ArrayList<>();
+		return this.vars;
+	}
+	
+	private Collection<GenericName> mixins() {
+		if (mixins==null)
+			mixins = new ArrayList<>();
+		return this.mixins;
+	}
+
+	private ArrayList<FunctionEntity> functions() {
+		if (functions==null)
+			functions = new ArrayList<>();
+		return this.functions;
+	}
+	
 	public ContainerEntity() {
-		vars = new ArrayList<>();
-		functions = new ArrayList<>();
-		mixins = new ArrayList<>();
-		resolvedMixins = new ArrayList<>();
-		expressionList = new ArrayList<>();
 	}
 
 	public ContainerEntity(GenericName rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
-		vars = new ArrayList<>();
-		functions = new ArrayList<>();
-		mixins = new ArrayList<>();
-		resolvedMixins = new ArrayList<>();
-		expressionList = new ArrayList<>();
 	}
 
 	public void addVar(VarEntity var) {
 		if (logger.isDebugEnabled()) {
 			logger.debug("var found: " + var.getRawName() + ":" + var.getRawType());
 		}
-		this.vars.add(var);
+		this.vars().add(var);
 	}
 
 	public ArrayList<VarEntity> getVars() {
-		return this.vars;
+		if (vars==null)
+			return new ArrayList<>();
+		return this.vars();
 	}
 
 	public void addFunction(FunctionEntity functionEntity) {
-		this.functions.add(functionEntity);
+		this.functions().add(functionEntity);
 	}
 
 	public ArrayList<FunctionEntity> getFunctions() {
+		if (functions==null)
+			return new ArrayList<>();
 		return this.functions;
 	}
 
 	public HashMap<Object, Expression> expressions() {
+		if (expressionWeakReference==null)
+			expressionWeakReference= new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
 		HashMap<Object, Expression> r = expressionWeakReference.get();
 		if (r==null) return new HashMap<>();
 		return r;
@@ -103,7 +114,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	public void addExpression(Object key, Expression expression) {
 		expressions().put(key, expression);
-		expressionList.add(expression);
+		expressionList().add(expression);
 	}
 
 	/**
@@ -112,19 +123,26 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 */
 	public void inferLocalLevelEntities(Inferer inferer) {
 		super.inferLocalLevelEntities(inferer);
-		for (VarEntity var : this.vars) {
+		for (VarEntity var : this.vars()) {
 			var.inferLocalLevelEntities(inferer);
 		}
-		for (FunctionEntity func : this.functions) {
+		for (FunctionEntity func : this.getFunctions()) {
 			func.inferLocalLevelEntities(inferer);
 		}
-		resolvedMixins = identiferToContainerEntity(inferer, mixins);
+		resolvedMixins = identiferToContainerEntity(inferer, getMixins());
 		if (inferer.isEagerExpressionResolve()) {
 			this.resolveExpressions(inferer);
 		}
 	}
 
+	private Collection<GenericName> getMixins() {
+		if (mixins==null)
+			return new ArrayList<>();
+		return mixins;
+	}
+
 	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<GenericName> identifiers) {
+		if (identifiers.size()==0) return null;
 		ArrayList<ContainerEntity> r = new ArrayList<>();
 		for (GenericName identifier : identifiers) {
 			Entity entity = inferer.resolveName(this, identifier, true);
@@ -143,6 +161,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
+		if (expressionList==null) return;
 		if(expressionList.size()>10000) return;
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
@@ -185,6 +204,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
 		this.expressions().clear();
 		this.expressionWeakReference.clear();
 		cacheExpressionListToFile();
@@ -194,6 +215,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void clearExpressions() {
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
 		this.expressions().clear();
 		this.expressionWeakReference.clear();
 		this.expressionList.clear();
@@ -233,6 +256,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	public TypeEntity getLastExpressionType() {
+		if (expressionList==null) return null;
 		for (int i = this.expressionList.size() - 1; i >= 0; i--) {
 			Expression expr = this.expressionList.get(i);
 			if (expr.isStatement)
@@ -242,6 +266,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public List<Expression> expressionList() {
+		if (expressionList==null) 
+			expressionList = new ArrayList<>();
 		return expressionList;
 	}
 
@@ -250,6 +276,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public String dumpExpressions() {
+		if (expressionList==null) return "";
 		StringBuilder sb = new StringBuilder();
 		for (Expression exp : expressionList) {
 			sb.append(exp.toString()).append("\n");
@@ -362,10 +389,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void addMixin(GenericName moduleName) {
-		mixins.add(moduleName);
+		mixins().add(moduleName);
 	}
 
 	public Collection<ContainerEntity> getResolvedMixins() {
+		if (resolvedMixins==null) return new ArrayList<>();
 		return resolvedMixins;
 	}
 }

757d605ac61d7e8cec2352eb42756b8af8de032d
@@ -46,8 +46,8 @@ public abstract class Entity {
 	GenericName rawName = GenericName.build("");
 	Entity parent;
 	private MultiDeclareEntities mutliDeclare = null;
-	private Set<Entity> children = new HashSet<>();
-    ArrayList<Relation> relations = new ArrayList<>();
+	private Set<Entity> children;
+    ArrayList<Relation> relations;
 	private Entity actualReferTo = null;
 	private boolean inScope = true;
 
@@ -58,11 +58,16 @@ public abstract class Entity {
 		this.parent = parent;
 		this.id = id;
 		if (parent!=null)
-			parent.children.add(this);
+			parent.children().add(this);
 		deduceQualifiedName();
 	}
 
-    /**
+    private Set<Entity> children() {
+    	if (children==null)
+    		children = new HashSet<>();
+		return children;
+	}
+	/**
      * Rule 1: if it start with '.' , then the name is equal to raw name
      * Rule 2: if parent not exists, the name is equal to raw name
      * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
@@ -100,15 +105,19 @@ public abstract class Entity {
     }
 
     public void addRelation(Relation relation) {
+    	if (relations==null)
+    		relations = new ArrayList<>();
         relations.add(relation);
     }
 
     public ArrayList<Relation> getRelations() {
+    	if (relations==null)
+    		return new ArrayList<>();
         return relations;
     }
 
     public void addChild(Entity child) {
-        children.add(child);
+        children().add(child);
     }
 
 	public Entity getParent() {
@@ -120,6 +129,8 @@ public abstract class Entity {
 	}
 	
 	public Collection<Entity> getChildren() {
+		if (children==null)
+			return new HashSet<>();
 		return children;
 	}
 	
@@ -166,7 +177,7 @@ public abstract class Entity {
 	 * */
 	public void inferEntities(Inferer inferer) {
 		inferLocalLevelEntities(inferer);
-		for (Entity child:children) {
+		for (Entity child:this.getChildren()) {
 			child.inferEntities(inferer);
 		}
 	}

757d605ac61d7e8cec2352eb42756b8af8de032d
@@ -45,19 +45,23 @@ public class TypeEntity extends ContainerEntity {
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
 		inheritedTypes = new ArrayList<>();
-		identiferToEntities(inferer, this.inhertedTypeIdentifiers).forEach(item -> {
-			Entity typeItem = getTypeEntity(item);
-			if (typeItem !=null) {
-				inheritedTypes.add((TypeEntity) typeItem);
-			}else {
-				System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
-			}
-		});
+		Collection<Entity> r = identiferToEntities(inferer, this.inhertedTypeIdentifiers);
+		if (r!=null) {
+			r.forEach(item -> {
+				Entity typeItem = getTypeEntity(item);
+				if (typeItem !=null) {
+					inheritedTypes.add((TypeEntity) typeItem);
+				}else {
+					System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
+				}
+			});
+		}
 		inheritedTypes.remove(this);
 
 		implementedTypes = new ArrayList<>();
-		identiferToEntities(inferer, this.implementedIdentifiers)
-				.forEach(item -> {
+		r = identiferToEntities(inferer, this.implementedIdentifiers);
+		if (r!=null) {
+				r.forEach(item -> {
 					Entity typeItem = getTypeEntity(item);
 					if (typeItem !=null) {
 						implementedTypes.add((TypeEntity) typeItem);
@@ -65,6 +69,7 @@ public class TypeEntity extends ContainerEntity {
 						System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
 					}
 				});
+		}
 		implementedTypes.remove(this);
 		if (inheritedTypes.size() > 0)
 			inheritedType = inheritedTypes.iterator().next();

757d605ac61d7e8cec2352eb42756b8af8de032d
@@ -39,7 +39,6 @@ public class VarEntity extends ContainerEntity {
 	public VarEntity(GenericName simpleName,  GenericName rawType, Entity parent, int id) {
 		super(simpleName,  parent,id);
 		this.rawType = rawType;
-		functionCalls = new ArrayList<>();
 	}
 
 	public void setRawType(GenericName rawType) {
@@ -77,15 +76,22 @@ public class VarEntity extends ContainerEntity {
 	}
 
 	public List<FunctionCall> getCalledFunctions() {
-		return functionCalls;
+		if (this.functionCalls!=null)
+			return functionCalls;
+		return new ArrayList<>();
 	}
 
 	public void addFunctionCall(GenericName fname) {
+		if (this.functionCalls==null)
+		{
+			functionCalls = new ArrayList<>();
+		}
 		this.functionCalls.add(new FunctionCall(fname));
 	}
 
 	public void fillCandidateTypes(Inferer inferer) {
 		if (type!=null) return ; //it is a strong type lang, do not need deduce candidate types
+		if (functionCalls==null) return;
 		if (functionCalls.size()==0) return; //no information avaliable for type deduction
 		if (this.rawType==null) {
 			this.type = new CandidateTypes(inferer.calculateCandidateTypes(this,this.functionCalls));

a3c2b61023b98080fe98c63e2af86332e49e771f
@@ -60,7 +60,7 @@ public class CppProcessor extends AbstractLangProcessor {
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
 		if (macroRepo == null) {
-			macroRepo = new MacroRepo();
+			macroRepo = new MacroFileRepo(entityRepo);
 			macroRepo.buildDefaultMap(super.includePaths());
 		}
 		if (preprocessorHandler==null) {

a3c2b61023b98080fe98c63e2af86332e49e771f
@@ -0,0 +1,67 @@
+package depends.extractor.cpp;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
+
+import depends.entity.repo.EntityRepo;
+import depends.util.TemporaryFile;
+
+public class MacroFileRepo extends MacroRepo{
+	private EntityRepo entityRepo;
+
+	public MacroFileRepo(EntityRepo entityRepo) {
+		this.entityRepo = entityRepo;
+	}
+
+	@Override
+	public Map<String, String> get(String incl) {
+		Integer fileId = entityRepo.getEntity(incl).getId();
+
+		try
+	      {
+	         FileInputStream fileIn = new FileInputStream(TemporaryFile.getInstance().macroPath(fileId));
+	         ObjectInputStream in = new ObjectInputStream(fileIn);
+	         @SuppressWarnings("unchecked")
+			Map<String, String> macros = (Map<String, String>) in.readObject();
+	         if (macros==null) macros = new HashMap<>();
+	         in.close();
+	         fileIn.close();
+	         return macros;
+	      }catch(IOException | ClassNotFoundException i)
+	      {
+	         return new HashMap<>();
+	      }	
+	}
+
+	@Override
+	public void putMacros(String fileFullPath, Map<String, String> macroMap,
+			IASTPreprocessorMacroDefinition[] macroDefinitions) {
+		if (macroDefinitions.length==0 && macroMap.size()==0) return;
+		Integer fileId = entityRepo.getEntity(fileFullPath).getId();
+		
+		Map<String, String> macros = get(fileFullPath);
+		macros.putAll(macroMap);
+		for (IASTPreprocessorMacroDefinition def:macroDefinitions) {
+			macros.put(def.getName().toString(), new String(def.getExpansion()));
+		}
+		
+		try {
+			FileOutputStream fileOut = new FileOutputStream(TemporaryFile.getInstance().macroPath(fileId));
+			ObjectOutputStream out = new ObjectOutputStream(fileOut);
+			out.writeObject(macros);
+			out.close();
+			fileOut.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		
+	}
+
+}

a3c2b61023b98080fe98c63e2af86332e49e771f
@@ -0,0 +1,52 @@
+package depends.extractor.cpp;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
+import org.eclipse.cdt.core.dom.ast.IMacroBinding;
+import org.eclipse.cdt.core.parser.IScanner;
+import org.eclipse.cdt.core.parser.NullLogService;
+import org.eclipse.cdt.core.parser.ParserMode;
+import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
+import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
+
+import depends.extractor.cpp.cdt.GPPParserExtensionConfigurationExtension;
+import depends.util.FileUtil;
+
+public class MacroMemoryRepo extends MacroRepo{
+
+	private Map<String, Map<String, String>> fileMacroDefinition = new HashMap<>();
+
+	private void put(String file, Map<String, String> macros) {
+		Map<String, String> existingMacros = fileMacroDefinition.get(file);
+		if (existingMacros==null)
+			fileMacroDefinition.put(file, macros);
+		else
+			existingMacros.putAll(macros);
+	}
+	private void put(String file, IASTPreprocessorMacroDefinition[] macroDefinitions) {
+		Map<String, String> macros = new HashMap<>();
+		for (IASTPreprocessorMacroDefinition def:macroDefinitions) {
+			macros.put(def.getName().toString().intern(), new String(def.getExpansion()).intern());
+		}
+		Map<String, String>  existingMacros = fileMacroDefinition.get(file);
+		if (existingMacros==null)
+			fileMacroDefinition.put(file, macros);
+		else
+			existingMacros.putAll(macros);
+	}
+
+	@Override
+	public Map<String, String> get(String file) {
+		return fileMacroDefinition.get(file);
+	}
+	@Override
+	public void putMacros(String fileFullPath,Map<String, String> macroMap, IASTPreprocessorMacroDefinition[] macroDefinitions) {
+		put(fileFullPath,macroMap);
+		put(fileFullPath,macroDefinitions);
+	}
+
+	
+}

a3c2b61023b98080fe98c63e2af86332e49e771f
@@ -22,7 +22,9 @@ public abstract class CppParserTest extends ParserTest{
     	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType(),false);
     	preprocessorHandler = new PreprocessorHandler("./src/test/resources/cpp-code-examples/",new ArrayList<>());
     	TemporaryFile.reset();
-    	macroRepo = new MacroRepo();
+//    	macroRepo = new MacroMemoryRepo();
+    	macroRepo = new MacroFileRepo(repo);
+
     }
 	
 	public CppFileParser createParser(String src) {

0b69920b98ab66961541e2b72fe100252b2ed520
@@ -78,7 +78,9 @@ public class DependsCommand {
 	private boolean callAsImpl = false;	
 	@Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
     private String[] typeFilter=new String[]{};
-    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+	@Option(names = {"--external-deps"}, description = "Output external dependencies")
+	private boolean outputExternalDependencies = false;	
+	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
 	}
@@ -152,4 +154,7 @@ public class DependsCommand {
 	public boolean isCallAsImpl() {
 		return callAsImpl;
 	}
+	public boolean isOutputExternalDependencies() {
+		return outputExternalDependencies;
+	}
 }

0b69920b98ab66961541e2b72fe100252b2ed520
@@ -89,7 +89,7 @@ abstract public class AbstractLangProcessor {
 	protected String inputSrcPath;
 	public String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
-	private Set<UnsolvedBindings> unsolved;
+	private Set<UnsolvedBindings> potentialExternalDependencies;
 	private List<String> typeFilter;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
@@ -135,9 +135,9 @@ abstract public class AbstractLangProcessor {
 	 */
 	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-		this.unsolved = inferer.resolveAllBindings(callAsImpl,this);
-		if (getUnsolved().size() > 0) {
-			System.err.println("There are " + getUnsolved().size() + " items are unsolved.");
+		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
+		if (getExternalDependencies().size() > 0) {
+			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
 		}
 		System.out.println("types and bindings resolved successfully...");
 	}
@@ -226,8 +226,8 @@ abstract public class AbstractLangProcessor {
 
 	public abstract List<String> supportedRelations();
 
-	public Set<UnsolvedBindings> getUnsolved() {
-		return unsolved;
+	public Set<UnsolvedBindings> getExternalDependencies() {
+		return potentialExternalDependencies;
 	}
 
 	public String getRelationMapping(String relation) {

9e4cf852447ec6ccae313633f2f6a5581c818879
@@ -53,6 +53,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<FunctionEntity> functions;
 	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
 	private ArrayList<Expression> expressionList;
+	private int expressionCount = 0;
 	private Collection<GenericName> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
 
@@ -225,6 +226,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	private void cacheExpressionListToFile() {
+		expressionCount = this.expressionList.size();
+		if (expressionCount ==0) return;
 		try {
 			FileOutputStream fileOut = new FileOutputStream(TemporaryFile.getInstance().exprPath(this.id));
 			ObjectOutputStream out = new ObjectOutputStream(fileOut);
@@ -238,6 +241,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	@SuppressWarnings("unchecked")
 	public void reloadExpression(EntityRepo repo) {
+		if (expressionCount ==0) return;
 		try
 	      {
 	         FileInputStream fileIn = new FileInputStream(TemporaryFile.getInstance().exprPath(this.id));

9e4cf852447ec6ccae313633f2f6a5581c818879
@@ -37,6 +37,7 @@ import depends.relations.Inferer;
  */
 public class MultiDeclareEntities extends ContainerEntity {
 	List<ContainerEntity> entities = new ArrayList<>();
+	private boolean containsTypeEntity = false;
 	public MultiDeclareEntities(Entity entity, int id ) {
 		super(entity.getRawName(), entity.getParent(), id);
 		add(entity);
@@ -51,6 +52,7 @@ public class MultiDeclareEntities extends ContainerEntity {
 
 	public void add(Entity entity) {
 		entity.setMutliDeclare(this);
+		if (entity instanceof TypeEntity) this.containsTypeEntity = true;
 		if (entity instanceof ContainerEntity)
 			entities.add((ContainerEntity)entity);
 	}
@@ -76,4 +78,8 @@ public class MultiDeclareEntities extends ContainerEntity {
 		}
 		return null;
 	}
+
+	public boolean isContainsTypeEntity() {
+		return containsTypeEntity;
+	}
 }

9e4cf852447ec6ccae313633f2f6a5581c818879
@@ -5,6 +5,8 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
 
 import depends.entity.Entity;
 import depends.entity.GenericName;
@@ -12,8 +14,8 @@ import depends.entity.MultiDeclareEntities;
 
 public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo {
 
-	private HashMap<String, Entity> allEntieisByName;
-	private HashMap<Integer, Entity> allEntitiesById;
+	private Map<String, Entity> allEntieisByName;
+	private Map<Integer, Entity> allEntitiesById;
 	private List<Entity> allEntitiesByOrder;
 
 	public InMemoryEntityRepo() {

ac667382e1c7de19897e263e07f5130bf7babb7c
@@ -26,6 +26,7 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -41,6 +42,8 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
+	HashMap<Integer, HashSet<String>> includedFiles = new HashMap<>();
+
 	@Override
 	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
 		String importedString = fileEntity.importedSuffixMatch(name);
@@ -49,8 +52,8 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (r!=null) return r;
 		}
 		
-		HashSet<String> fileSet = new HashSet<>();
-		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
+		
+		HashSet<String> fileSet = findIncludedFiles(fileEntity, repo);
 		
 		for (String file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
@@ -70,6 +73,15 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
+	private HashSet<String> findIncludedFiles(FileEntity fileEntity, EntityRepo repo) {
+		HashSet<String> fileSet = this.includedFiles.get(fileEntity.getId());
+		if (fileSet!=null) return fileSet;
+		fileSet = new HashSet<>();
+		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
+		includedFiles.put(fileEntity.getId(),fileSet);
+		return fileSet;
+	}
+
 	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles, EntityRepo repo) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;

fdd899ac54368bb8e0edcf3e65855b12d8d82892
@@ -19,8 +19,8 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	private List<Entity> allEntitiesByOrder;
 
 	public InMemoryEntityRepo() {
-		allEntieisByName = new HashMap<>();
-		allEntitiesById = new HashMap<>();
+		allEntieisByName = new TreeMap<>();
+		allEntitiesById = new TreeMap<>();
 		allEntitiesByOrder = new LinkedList<>();
 	}
 

fdd899ac54368bb8e0edcf3e65855b12d8d82892
@@ -60,7 +60,7 @@ public class CppProcessor extends AbstractLangProcessor {
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
 		if (macroRepo == null) {
-			macroRepo = new MacroFileRepo(entityRepo);
+			macroRepo = new MacroEhcacheRepo(entityRepo);
 			macroRepo.buildDefaultMap(super.includePaths());
 		}
 		if (preprocessorHandler==null) {

fdd899ac54368bb8e0edcf3e65855b12d8d82892
@@ -0,0 +1,57 @@
+package depends.extractor.cpp;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
+
+import depends.entity.repo.EntityRepo;
+import net.sf.ehcache.Cache;
+import net.sf.ehcache.CacheManager;
+import net.sf.ehcache.Element;
+
+public class MacroEhcacheRepo extends MacroRepo {
+	private EntityRepo entityRepo;
+	CacheManager cacheManager;
+	Cache cache;
+
+	public MacroEhcacheRepo(EntityRepo entityRepo) {
+		this.entityRepo = entityRepo;
+		cacheManager = CacheManager.create();
+		cache = cacheManager.getCache("macros");
+	}
+
+	@Override
+	public Map<String, String> get(String incl) {
+		Integer fileId = entityRepo.getEntity(incl).getId();
+		Element cacheElement = cache.get(buildKey(fileId));
+		if (cacheElement ==null)
+			return new HashMap<>();
+		@SuppressWarnings("unchecked")
+		Map<String, String> macros = (Map<String, String>) (cacheElement.getObjectValue());
+		if (macros == null)
+			macros = new HashMap<>();
+		return macros;
+	}
+
+	@Override
+	public void putMacros(String fileFullPath, Map<String, String> macroMap,
+			IASTPreprocessorMacroDefinition[] macroDefinitions) {
+		if (macroDefinitions.length == 0 && macroMap.size() == 0)
+			return;
+		Integer fileId = entityRepo.getEntity(fileFullPath).getId();
+
+		Map<String, String> macros = get(fileFullPath);
+		macros.putAll(macroMap);
+		for (IASTPreprocessorMacroDefinition def : macroDefinitions) {
+			macros.put(def.getName().toString(), new String(def.getExpansion()));
+		}
+		Element cacheElement = new Element(buildKey(fileId), macros);
+		cache.put(cacheElement);
+	}
+
+	private String buildKey(Integer fileId) {
+		return "macro" + fileId;
+	}
+
+}

fdd899ac54368bb8e0edcf3e65855b12d8d82892
@@ -23,7 +23,8 @@ public abstract class CppParserTest extends ParserTest{
     	preprocessorHandler = new PreprocessorHandler("./src/test/resources/cpp-code-examples/",new ArrayList<>());
     	TemporaryFile.reset();
 //    	macroRepo = new MacroMemoryRepo();
-    	macroRepo = new MacroFileRepo(repo);
+//    	macroRepo = new MacroFileRepo(repo);
+    	macroRepo = new MacroEhcacheRepo(repo);
 
     }
 	

2d90871f912b249b9fa616cccfa2c76e54911a80
@@ -297,13 +297,6 @@ public abstract class HandlerContext {
 	
 	
 	public void exitLastedEntity() {
-		Entity e = entityStack.peek();
-		if (e instanceof ContainerEntity) {
-			ContainerEntity container = (ContainerEntity)e;
-			if (!inferer.isEagerExpressionResolve()) {
-				container.cacheExpressions();
-			}
-		}
 		//we never pop up the lastest one (FileEntity)
 		if (entityStack.size()>1)
 			entityStack.pop();

86c9b59cce7f1555ce2012fa711c011d9d2a3d10
@@ -26,7 +26,6 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -42,8 +41,6 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
-	HashMap<Integer, HashSet<String>> includedFiles = new HashMap<>();
-
 	@Override
 	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
 		String importedString = fileEntity.importedSuffixMatch(name);
@@ -52,8 +49,8 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (r!=null) return r;
 		}
 		
-		
-		HashSet<String> fileSet = findIncludedFiles(fileEntity, repo);
+		HashSet<String> fileSet = new HashSet<>();
+		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
 		
 		for (String file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
@@ -73,15 +70,6 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
-	private HashSet<String> findIncludedFiles(FileEntity fileEntity, EntityRepo repo) {
-		HashSet<String> fileSet = this.includedFiles.get(fileEntity.getId());
-		if (fileSet!=null) return fileSet;
-		fileSet = new HashSet<>();
-		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
-		includedFiles.put(fileEntity.getId(),fileSet);
-		return fileSet;
-	}
-
 	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles, EntityRepo repo) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;

f1dcc068bf118e3da747c9fa81dab838b0f95803
@@ -39,7 +39,8 @@ public class MultiDeclareEntities extends ContainerEntity {
 	List<ContainerEntity> entities = new ArrayList<>();
 	private boolean containsTypeEntity = false;
 	public MultiDeclareEntities(Entity entity, int id ) {
-		super(entity.getRawName(), entity.getParent(), id);
+		setQualifiedName(entity.getQualifiedName());
+		setRawName(entity.getRawName());
 		add(entity);
 	}
 

f1dcc068bf118e3da747c9fa81dab838b0f95803
@@ -28,6 +28,7 @@ import java.util.Collection;
 import java.util.Iterator;
 
 import depends.entity.Entity;
+import depends.entity.FileEntity;
 import depends.entity.GenericName;
 
 public interface EntityRepo extends IdGenerator {
@@ -47,6 +48,10 @@ public interface EntityRepo extends IdGenerator {
 
 	Collection<Entity> getEntities();
 
+	Iterator<Entity> sortedFileIterator();
+
+	void addFile(FileEntity currentFileEntity);
+
 
 
 }

f1dcc068bf118e3da747c9fa81dab838b0f95803
@@ -1,27 +1,49 @@
 package depends.entity.repo;
 
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
 import java.util.TreeMap;
 
 import depends.entity.Entity;
+import depends.entity.FileEntity;
 import depends.entity.GenericName;
 import depends.entity.MultiDeclareEntities;
 
+
 public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo {
 
+	public class EntityＭapIterator implements Iterator<Entity>{
+
+		private Iterator<Entry<Integer, Entity>> entryIterator;
+
+		public EntityＭapIterator(Set<Entry<Integer, Entity>> entries) {
+			this.entryIterator = entries.iterator();
+		}
+		@Override
+		public boolean hasNext() {
+			return entryIterator.hasNext();
+		}
+
+		@Override
+		public Entity next() {
+			return entryIterator.next().getValue();
+		}
+		
+	}
+	
 	private Map<String, Entity> allEntieisByName;
 	private Map<Integer, Entity> allEntitiesById;
-	private List<Entity> allEntitiesByOrder;
+	private List<Entity> allFileEntitiesByOrder;
 
 	public InMemoryEntityRepo() {
 		allEntieisByName = new TreeMap<>();
 		allEntitiesById = new TreeMap<>();
-		allEntitiesByOrder = new LinkedList<>();
+		allFileEntitiesByOrder = new LinkedList<>();
 	}
 
 	@Override
@@ -36,7 +58,6 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 
 	@Override
 	public void add(Entity entity) {
-		allEntitiesByOrder.add(entity);
 		allEntitiesById.put(entity.getId(), entity);
 		String name = entity.getRawName().uniqName();
 		if (entity.getQualifiedName() != null && !(entity.getQualifiedName().isEmpty())) {
@@ -60,7 +81,7 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 
 	@Override
 	public Iterator<Entity> entityIterator() {
-		return allEntitiesByOrder.iterator();
+		return new EntityＭapIterator(allEntitiesById.entrySet());
 	}
 
 	
@@ -75,7 +96,17 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 
 	@Override
 	public Collection<Entity> getEntities() {
-		return allEntitiesByOrder;
+		return allEntitiesById.values();
+	}
+
+	@Override
+	public Iterator<Entity> sortedFileIterator() {
+		return allFileEntitiesByOrder.iterator();
+	}
+
+	@Override
+	public void addFile(FileEntity fileEntity) {
+		allFileEntitiesByOrder.add(fileEntity);
 	}
 
 }

f1dcc068bf118e3da747c9fa81dab838b0f95803
@@ -62,6 +62,7 @@ public abstract class HandlerContext {
 		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
 		pushToStack(currentFileEntity);
 		entityRepo.add(currentFileEntity);
+		entityRepo.addFile(currentFileEntity);
 		return currentFileEntity;
 	}
 

f1dcc068bf118e3da747c9fa81dab838b0f95803
@@ -26,8 +26,10 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import depends.entity.Entity;
@@ -49,8 +51,7 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (r!=null) return r;
 		}
 		
-		HashSet<String> fileSet = new HashSet<>();
-		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
+		HashSet<String> fileSet = getIncludedFiles(fileEntity);
 		
 		for (String file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
@@ -70,13 +71,25 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
-	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles, EntityRepo repo) {
+	private Map<Integer, HashSet<String> > includedFiles  = new HashMap<>();
+	private  HashSet<String> getIncludedFiles(FileEntity fileEntity) {
+
+		if (includedFiles.containsKey(fileEntity.getId())) {
+				return includedFiles.get(fileEntity.getId());
+		}
+		HashSet<String> fileSet = new HashSet<>();
+		foundIncludedFiles(fileSet, fileEntity.getImportedFiles());
+		includedFiles.put(fileEntity.getId(), fileSet);
+		return fileSet;
+	}
+
+	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;
 			if (!(file instanceof FileEntity)) continue;
 			if (fileSet.contains(file.getRawName().uniqName())) continue;
 			fileSet.add(file.getRawName().uniqName());
-			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles(),repo);
+			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles());
 		}
 	}
 	

f1dcc068bf118e3da747c9fa81dab838b0f95803
@@ -15,9 +15,9 @@ public class ForwardDeclareTest extends CppParserTest{
 	@Test
 	public void should_slove_forward_declare_in_cpp() throws IOException {
 	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/forwardDeclare/App.cpp",
 	    		"./src/test/resources/cpp-code-examples/forwardDeclare/Mutex.h",
 	    		"./src/test/resources/cpp-code-examples/forwardDeclare/App.h",
-	    		"./src/test/resources/cpp-code-examples/forwardDeclare/App.cpp",
 	    	    };
 	    
 	    for (String src:srcs) {

b48185e08400c5b39608b6118fdb7744d99cf8ee
@@ -91,6 +91,7 @@ abstract public class AbstractLangProcessor {
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> potentialExternalDependencies;
 	private List<String> typeFilter;
+	private List<String> includePaths;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
@@ -104,11 +105,13 @@ abstract public class AbstractLangProcessor {
 	 * 
 	 * @param includeDir
 	 * @param inputDir
+	 * @param b 
 	 */
-	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl) {
+	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl, boolean isCollectUnsolvedBindings) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
+		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
 		parseAllFiles();
 		markAllEntitiesScope();
 		resolveBindings(callAsImpl);
@@ -197,19 +200,28 @@ abstract public class AbstractLangProcessor {
 	}
 
 	public List<String> includePaths() {
-		ArrayList<String> r = new ArrayList<String>();
+		if (this.includePaths ==null) {
+			this.includePaths = buildIncludePath();
+		}
+		return includePaths;
+	}
+
+	private List<String> buildIncludePath() {
+		includePaths = new ArrayList<String>();
 		for (String path : includeDirs) {
 			if (FileUtils.fileExists(path)) {
-				if (!r.contains(path))
-					r.add(path);
+				path = FileUtil.uniqFilePath(path);
+				if (!includePaths.contains(path))
+					includePaths.add(path);
 			}
 			path = this.inputSrcPath + File.separator + path;
 			if (FileUtils.fileExists(path)) {
-				if (!r.contains(path))
-					r.add(path);
+				path = FileUtil.uniqFilePath(path);
+				if (!includePaths.contains(path))
+					includePaths.add(path);
 			}
 		}
-		return r;
+		return includePaths;
 	}
 
 	public DependencyMatrix getDependencies() {

b48185e08400c5b39608b6118fdb7744d99cf8ee
@@ -25,6 +25,8 @@ SOFTWARE.
 package depends.extractor.cpp.cdt;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
@@ -41,6 +43,16 @@ import depends.extractor.cpp.Scanner;
 public class CDTParser {
 	NullLogService NULL_LOG = new NullLogService();
 	protected Map<String, String> macroMap ;
+	
+	protected List<String> sysIncludePath = new ArrayList<>();
+	
+	public CDTParser() {
+	}
+	
+	public CDTParser(List<String> includesPath) {
+	        this.sysIncludePath = includesPath;
+	}
+	
 	public IASTTranslationUnit parse(String file, Map<String, String> macroMap   ) {
 		try {
 			this.macroMap = macroMap;
@@ -53,7 +65,7 @@ public class CDTParser {
 	
 	public IASTTranslationUnit getTranslationUnitofCPP(String file) throws IOException {
 		
-		IScanner scanner = Scanner.buildScanner(file,macroMap);
+		IScanner scanner = Scanner.buildScanner(file,macroMap,sysIncludePath,false);
 		if (scanner==null) return null;
 
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(

b48185e08400c5b39608b6118fdb7744d99cf8ee
@@ -0,0 +1,30 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+
+public class ParseErrorTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void full_qualified_names_should_be_resolved() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/parseError/error1.c",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	}
+	
+}

b48185e08400c5b39608b6118fdb7744d99cf8ee
@@ -20,6 +20,7 @@ public class UnsolvedSymbolsTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/UnsolvedSymbols/MissingImport.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
+        inferer.setCollectUnsolvedBindings(true);
         Set<UnsolvedBindings> missing = inferer.resolveAllBindings();
         assertEquals(1,missing.size());
         assertEquals("a.b",missing.iterator().next().getRawName());

cca69513864525be6168935c908e4c8e130b38c2
@@ -27,6 +27,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 
 import depends.relations.Inferer;
@@ -302,5 +303,18 @@ public class CandidateTypes extends TypeEntity {
 		System.err.println("error: getDisplayName should not been invoked");
 		return super.getDisplayName();
 	}
+	@Override
+	public Entity getByName(String name, HashSet<Entity> searched) {
+		Entity entity = super.getByName(name, searched);
+		if (entity!=null) return entity;
+		for (TypeEntity type:getCandidateTypes()) {
+			if (searched.contains(type)) continue;
+			Entity e = type.getByName(name, searched);
+			if (e !=null) return e;
+		}
+		return null;
+	}
+	
+	
  	
 }

cca69513864525be6168935c908e4c8e130b38c2
@@ -26,6 +26,7 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -50,7 +51,7 @@ public abstract class Entity {
     ArrayList<Relation> relations;
 	private Entity actualReferTo = null;
 	private boolean inScope = true;
-
+	private HashMap<String, Entity> visibleNames = new HashMap<>();
 	public Entity() {};
     public Entity(GenericName rawName, Entity parent, Integer id) {
 		this.qualifiedName = null;
@@ -58,8 +59,10 @@ public abstract class Entity {
 		this.parent = parent;
 		this.id = id;
 		if (parent!=null)
-			parent.children().add(this);
+			parent.addChild(this);
 		deduceQualifiedName();
+		visibleNames.put(rawName.getName(), this);
+		visibleNames.put(qualifiedName, this);
 	}
 
     private Set<Entity> children() {
@@ -117,7 +120,9 @@ public abstract class Entity {
     }
 
     public void addChild(Entity child) {
-        children().add(child);
+    	children().add(child);
+		visibleNames.put(child.getRawName().getName(), child);
+		visibleNames.put(child.getQualifiedName(), child);
     }
 
 	public Entity getParent() {
@@ -249,5 +254,10 @@ public abstract class Entity {
 	public boolean inScope() {
 		return inScope;
 	}
+	public Entity getByName(String name, HashSet<Entity> searched) {
+		if (searched.contains(this)) return null;
+		searched.add(this);
+		return visibleNames.get(name);
+	}
 	
 }

cca69513864525be6168935c908e4c8e130b38c2
@@ -26,6 +26,7 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -153,4 +154,29 @@ public class FileEntity extends TypeEntity {
 			}
 		}
 	}
+	
+	
+	@Override
+	public Entity getByName(String name, HashSet<Entity> searched) {
+		Entity entity = super.getByName(name, searched);
+		if (entity!=null) return entity;
+		for (TypeEntity type:getDeclaredTypes()) {
+			if (type.getRawName().getName().equals(name)||
+				suffixMatch(name,type.getQualifiedName())) {
+				return type;
+			}
+		}
+		return null;
+	}
+	
+	private boolean suffixMatch(String name, String qualifiedName) {
+		if (qualifiedName.contains(".")) {
+			if (!name.startsWith(".")) name = "." +name;
+			return qualifiedName.endsWith(name);
+		}
+		else {
+			return qualifiedName.equals(name);
+		}
+	}
+
 }

cca69513864525be6168935c908e4c8e130b38c2
@@ -26,6 +26,7 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 
 import depends.relations.Inferer;
@@ -83,4 +84,19 @@ public class MultiDeclareEntities extends ContainerEntity {
 	public boolean isContainsTypeEntity() {
 		return containsTypeEntity;
 	}
+
+	@Override
+	public Entity getByName(String name, HashSet<Entity> searched) {
+		Entity entity = super.getByName(name, searched);
+		if (entity!=null) return entity;
+		if (isContainsTypeEntity()) {
+			for (Entity declaredEntitiy : getEntities()) {
+				if (declaredEntitiy instanceof TypeEntity && 
+						declaredEntitiy.getRawName().getName().equals(name)) {
+					return declaredEntitiy;
+				}
+			}
+		}
+		return null;
+	}
 }

cca69513864525be6168935c908e4c8e130b38c2
@@ -26,6 +26,7 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 
 import depends.relations.Inferer;
 
@@ -179,4 +180,23 @@ public class TypeEntity extends ContainerEntity {
 	public TypeEntity getType() {
 		return this;
 	}
+	@Override
+	public Entity getByName(String name, HashSet<Entity> searched) {
+		Entity entity = super.getByName(name, searched);
+		if (entity!=null)
+			return entity;
+		for (TypeEntity child:getInheritedTypes()) {
+			if (searched.contains(child)) continue;
+			entity = child.getByName(name, searched);
+			if (entity!=null) return entity;
+		}
+		for (TypeEntity child:getImplementedTypes()) {
+			if (searched.contains(child)) continue;
+			entity = child.getByName(name,searched);
+			if (entity!=null) return entity;
+		}
+		return null;
+	}
+	
+	
 }

cca69513864525be6168935c908e4c8e130b38c2
@@ -137,4 +137,17 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[3])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
+	
+	@Test
+	public void should_parse_import_with_prefix_dots2() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing2.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	}
 }

f9df158464aa3deee528e6da9e7f218b1b05bc36
@@ -32,6 +32,8 @@ import java.util.List;
 import java.util.Set;
 
 import org.codehaus.plexus.util.FileUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
@@ -92,7 +94,8 @@ abstract public class AbstractLangProcessor {
 	private Set<UnsolvedBindings> potentialExternalDependencies;
 	private List<String> typeFilter;
 	private List<String> includePaths;
-
+	private static Logger logger = LoggerFactory.getLogger(AbstractLangProcessor.class);
+	
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
 		inferer = new Inferer(entityRepo, getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
@@ -138,6 +141,7 @@ abstract public class AbstractLangProcessor {
 	 */
 	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
+		logger.warn("debug: Resolve types and bindings of variables, methods and expressions....");
 		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
 		if (getExternalDependencies().size() > 0) {
 			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
@@ -152,6 +156,7 @@ abstract public class AbstractLangProcessor {
 		System.out.println("reorder dependency matrix...");
 		dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
 		System.out.println("dependencie data generating done successfully...");
+		logger.warn("debug: dependencie data generating done successfully...");
 	}
 
 	private final void parseAllFiles() {

4113fef975f81e65cc901ea58f49f977b52f7b2c
@@ -51,9 +51,9 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (r!=null) return r;
 		}
 		
-		HashSet<String> fileSet = getIncludedFiles(fileEntity);
+		HashSet<Integer> fileSet = getIncludedFiles(fileEntity);
 		
-		for (String file:fileSet) {
+		for (Integer file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
 			if (importedItem instanceof FileEntity) {
 				FileEntity importedFile = (FileEntity) repo.getEntity(file);
@@ -71,24 +71,24 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
-	private Map<Integer, HashSet<String> > includedFiles  = new HashMap<>();
-	private  HashSet<String> getIncludedFiles(FileEntity fileEntity) {
+	private Map<Integer, HashSet<Integer> > includedFiles  = new HashMap<>();
+	private  HashSet<Integer> getIncludedFiles(FileEntity fileEntity) {
 
 		if (includedFiles.containsKey(fileEntity.getId())) {
 				return includedFiles.get(fileEntity.getId());
 		}
-		HashSet<String> fileSet = new HashSet<>();
+		HashSet<Integer> fileSet = new HashSet<>();
 		foundIncludedFiles(fileSet, fileEntity.getImportedFiles());
 		includedFiles.put(fileEntity.getId(), fileSet);
 		return fileSet;
 	}
 
-	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles) {
+	private void foundIncludedFiles(HashSet<Integer> fileSet, Collection<Entity> importedFiles) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;
 			if (!(file instanceof FileEntity)) continue;
-			if (fileSet.contains(file.getRawName().uniqName())) continue;
-			fileSet.add(file.getRawName().uniqName());
+			if (fileSet.contains(file.getId())) continue;
+			fileSet.add(file.getId());
 			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles());
 		}
 	}

353ef8bebfdf15e39d81c702dfce9eb886498769
@@ -51,7 +51,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
+	HashMap<Object, Expression> expressions;
 	private ArrayList<Expression> expressionList;
 	private int expressionCount = 0;
 	private Collection<GenericName> mixins;
@@ -106,11 +106,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public HashMap<Object, Expression> expressions() {
-		if (expressionWeakReference==null)
-			expressionWeakReference= new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
-		HashMap<Object, Expression> r = expressionWeakReference.get();
-		if (r==null) return new HashMap<>();
-		return r;
+		if (expressions==null) 
+			expressions= new HashMap<>();
+		return expressions;
 	}
 
 	public void addExpression(Object key, Expression expression) {
@@ -205,27 +203,18 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
-		if (expressionWeakReference==null) return;
-		if (expressionList==null) return;
-		this.expressions().clear();
-		this.expressionWeakReference.clear();
+		this.expressions=null;
 		cacheExpressionListToFile();
-		this.expressionList.clear();
 		this.expressionList=null;
-		this.expressionList = new ArrayList<>();
 	}
 
 	public void clearExpressions() {
-		if (expressionWeakReference==null) return;
-		if (expressionList==null) return;
-		this.expressions().clear();
-		this.expressionWeakReference.clear();
-		this.expressionList.clear();
+		this.expressions=null;
 		this.expressionList=null;
-		this.expressionList = new ArrayList<>();
 	}
 	
 	private void cacheExpressionListToFile() {
+		if(this.expressionList==null) return;
 		expressionCount = this.expressionList.size();
 		if (expressionCount ==0) return;
 		try {

c3cf8f5b11ec32748fdcb7453dfe32ef97cd4c2c
@@ -248,9 +248,12 @@ public abstract class Entity {
 			return false;
 		return true;
 	}
+	
 	public void setInScope(boolean value) {
 		this.inScope  = value;
+		children().forEach(child->child.setInScope(value));
 	}
+	
 	public boolean inScope() {
 		return inScope;
 	}

c3cf8f5b11ec32748fdcb7453dfe32ef97cd4c2c
@@ -46,7 +46,7 @@ public interface EntityRepo extends IdGenerator {
 
 	void update(Entity entity);
 
-	Collection<Entity> getEntities();
+	Collection<Entity> getFileEntities();
 
 	Iterator<Entity> sortedFileIterator();
 

c3cf8f5b11ec32748fdcb7453dfe32ef97cd4c2c
@@ -95,8 +95,8 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	}
 
 	@Override
-	public Collection<Entity> getEntities() {
-		return allEntitiesById.values();
+	public Collection<Entity> getFileEntities() {
+		return allFileEntitiesByOrder;
 	}
 
 	@Override

c3cf8f5b11ec32748fdcb7453dfe32ef97cd4c2c
@@ -119,7 +119,7 @@ abstract public class AbstractLangProcessor {
 	}
 
 	private void markAllEntitiesScope() {
-		entityRepo.getEntities().stream().forEach(entity -> {
+		entityRepo.getFileEntities().stream().forEach(entity -> {
 			Entity file = entity.getAncestorOfType(FileEntity.class);
 			try {
 				if (!file.getQualifiedName().startsWith(this.inputSrcPath)) {

c3cf8f5b11ec32748fdcb7453dfe32ef97cd4c2c
@@ -46,14 +46,14 @@ import depends.extractor.AbstractLangProcessor;
 
 public class RelationCounter {
 
-	private Iterator<Entity> iterator;
+	private Collection<Entity> entities;
 	private Inferer inferer;
 	private EntityRepo repo;
 	private boolean callAsImpl;
 	private AbstractLangProcessor langProcessor;
 
-	public RelationCounter(Iterator<Entity> iterator, Inferer inferer, EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor) {
-		this.iterator = iterator;
+	public RelationCounter(Collection<Entity> iterator, Inferer inferer, EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor) {
+		this.entities = iterator;
 		this.inferer = inferer;
 		this.repo = repo;
 		this.callAsImpl = callAsImpl;
@@ -61,22 +61,26 @@ public class RelationCounter {
 	}
 	
 	public void computeRelations() {
-		while(iterator.hasNext()) {
-			Entity entity= iterator.next();
-			if (!entity.inScope()) continue;
-			if (entity instanceof FileEntity) {
-				computeImports((FileEntity)entity);
-			}
-			else if (entity instanceof FunctionEntity) {
-				computeFunctionRelations((FunctionEntity)entity);
-			}
-			else if (entity instanceof TypeEntity) {
-				computeTypeRelations((TypeEntity)entity);
-			}
-			if (entity instanceof ContainerEntity) {
-				computeContainerRelations((ContainerEntity)entity);
-			}
+		entities.forEach(entity->
+		computeRelationOf(entity));
+	}
+
+	private void computeRelationOf(Entity entity) {
+		if (!entity.inScope())
+			return;
+		if (entity instanceof FileEntity) {
+			computeImports((FileEntity)entity);
+		}
+		else if (entity instanceof FunctionEntity) {
+			computeFunctionRelations((FunctionEntity)entity);
+		}
+		else if (entity instanceof TypeEntity) {
+			computeTypeRelations((TypeEntity)entity);
+		}
+		if (entity instanceof ContainerEntity) {
+			computeContainerRelations((ContainerEntity)entity);
 		}
+		entity.getChildren().forEach(child->computeRelationOf(child));
 	}
 
 	

03cc80253f0f34d6829653116d6f6c05204021ea
@@ -51,7 +51,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	HashMap<Object, Expression> expressions;
+	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
 	private ArrayList<Expression> expressionList;
 	private int expressionCount = 0;
 	private Collection<GenericName> mixins;
@@ -106,9 +106,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public HashMap<Object, Expression> expressions() {
-		if (expressions==null) 
-			expressions= new HashMap<>();
-		return expressions;
+		if (expressionWeakReference==null)
+			expressionWeakReference= new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
+		HashMap<Object, Expression> r = expressionWeakReference.get();
+		if (r==null) return new HashMap<>();
+		return r;
 	}
 
 	public void addExpression(Object key, Expression expression) {
@@ -203,18 +205,27 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
-		this.expressions=null;
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
 		cacheExpressionListToFile();
+		this.expressionList.clear();
 		this.expressionList=null;
+		this.expressionList = new ArrayList<>();
 	}
 
 	public void clearExpressions() {
-		this.expressions=null;
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
+		this.expressionList.clear();
 		this.expressionList=null;
+		this.expressionList = new ArrayList<>();
 	}
 	
 	private void cacheExpressionListToFile() {
-		if(this.expressionList==null) return;
 		expressionCount = this.expressionList.size();
 		if (expressionCount ==0) return;
 		try {

327f8cccd04bd195fe6a6abc437c2b35c41ba456
@@ -26,6 +26,7 @@ package depends.extractor;
 
 import java.io.File;
 import java.io.IOException;
+import java.lang.management.ManagementFactory;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -115,10 +116,20 @@ abstract public class AbstractLangProcessor {
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
 		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
+		logger.info("Start parsing files...");
 		parseAllFiles();
 		markAllEntitiesScope();
+		if (logger.isInfoEnabled()) {
+			logger.info("Resolve types and bindings of variables, methods and expressions.... " + this.inputSrcPath);
+			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
+		}
 		resolveBindings(callAsImpl);
+		if (logger.isInfoEnabled()) {
+			System.gc();
+			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
+		}
 		identifyDependencies();
+		logger.info("Dependencie data generating done successfully...");
 	}
 
 	private void markAllEntitiesScope() {
@@ -141,7 +152,6 @@ abstract public class AbstractLangProcessor {
 	 */
 	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-		logger.warn("debug: Resolve types and bindings of variables, methods and expressions....");
 		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
 		if (getExternalDependencies().size() > 0) {
 			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
@@ -155,12 +165,11 @@ abstract public class AbstractLangProcessor {
 		entityRepo = null;
 		System.out.println("reorder dependency matrix...");
 		dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
-		System.out.println("dependencie data generating done successfully...");
-		logger.warn("debug: dependencie data generating done successfully...");
+		System.out.println("Dependencie data generating done successfully...");
 	}
 
 	private final void parseAllFiles() {
-		System.out.println("start parsing files...");
+		System.out.println("Start parsing files...");
 		Set<String> phase2Files = new HashSet<>();
 		FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor() {
 			@Override

36ce0aa6a67d5d41772caf5bf076c107dc7ea9ba
@@ -203,6 +203,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			}
 		}
 	}
+	
+	public void cacheChildExpressions() {
+		cacheExpressions();
+		for (Entity child:getChildren()) {
+			if (child instanceof ContainerEntity) {
+				((ContainerEntity)child).cacheChildExpressions();
+			}
+		}
+	}
+
 
 	public void cacheExpressions() {
 		if (expressionWeakReference==null) return;

36ce0aa6a67d5d41772caf5bf076c107dc7ea9ba
@@ -143,19 +143,10 @@ public class FileEntity extends TypeEntity {
 	}
 
 	public void cacheAllExpressions() {
-		cacheChildExpressions(this);
+		this.cacheChildExpressions();
 	}
 
-	private void cacheChildExpressions(ContainerEntity containerEntity) {
-		this.cacheExpressions();
-		for (Entity child:containerEntity.getChildren()) {
-			if (child instanceof ContainerEntity) {
-				((ContainerEntity)child).cacheExpressions();
-			}
-		}
-	}
-	
-	
+
 	@Override
 	public Entity getByName(String name, HashSet<Entity> searched) {
 		Entity entity = super.getByName(name, searched);

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -188,7 +188,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;
 				}
-				if (expression.isCall) {
+				if (expression.isCall()) {
 					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.getIdentifier());
 					if (func != null) {
 						expression.setType(func.getType(), func, inferer);

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -40,7 +40,15 @@ public class Expression implements Serializable{
 	private GenericName identifier; // the varName, or method name, etc.
 	public boolean isSet = false; // is a set relation from right to leftHand
 	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
-	public boolean isCall = false;
+	public boolean isCall() {
+		return isCall;
+	}
+
+	public void setCall(boolean isCall) {
+		this.isCall = isCall;
+	}
+
+	private boolean isCall = false;
 	public boolean isLogic = false;
 	public boolean isCreate = false;
 	public boolean isCast = false;
@@ -147,7 +155,7 @@ public class Expression implements Serializable{
 		}
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {
-			if (parent.isCall) {
+			if (parent.isCall()) {
 				FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 				if (func!=null) {
 					parent.setType(func.getType(), func,inferer);

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -150,7 +150,7 @@ abstract public class AbstractLangProcessor {
 	 * @param callAsImpl
 	 * @return unsolved bindings
 	 */
-	private void resolveBindings(boolean callAsImpl) {
+	public void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
 		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
 		if (getExternalDependencies().size() > 0) {

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -52,12 +52,16 @@ public class ExpressionUsage {
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());
 		context.lastContainer().addExpression(declarator,expression);
-		expression.isCall = true;
+		expression.setCall(true);
 		expression.setIdentifier(functionName);
 	}
 	
 	public void foundExpression(IASTExpression ctx) {
 		Expression parent = findParentInStack(ctx);
+		//If parent already a call 
+		if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast)) {
+			return;
+		}
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
@@ -71,7 +75,7 @@ public class ExpressionUsage {
 		}
 		
 		expression.isSet = isSet(ctx);
-		expression.isCall = (ctx instanceof IASTFunctionCallExpression)?true:false;
+		expression.setCall((ctx instanceof IASTFunctionCallExpression)?true:false);
 		expression.isLogic = isLogic(ctx);
 		if (ctx instanceof ICPPASTNewExpression){
 			expression.isCreate = true;
@@ -88,11 +92,11 @@ public class ExpressionUsage {
 		//method call
 		if (ctx instanceof IASTFunctionCallExpression) {
 			expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression)ctx));
-			expression.isCall = true;
+			expression.setCall(true);
 		}
 		if (ctx instanceof ICPPASTNewExpression) {
 			expression.setRawType(GenericName.build(ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId())));
-			expression.isCall = true;
+			expression.setCall(true);
 			expression.deriveTypeFromChild = false;
 		}
 

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -57,7 +57,7 @@ public class ExpressionUsage {
 		}
 		
 		expression.isSet = isSet(ctx);
-		expression.isCall = ctx.methodCall()==null?false:true;
+		expression.setCall(ctx.methodCall()==null?false:true);
 		expression.isLogic = isLogic(ctx);
 		expression.isDot = isDot(ctx);
 		if (ctx.creator()!=null ||ctx.innerCreator()!=null){
@@ -76,12 +76,12 @@ public class ExpressionUsage {
 		//method call
 		if (ctx.methodCall()!=null) {
 			expression.setIdentifier(getMethodCallIdentifier(ctx.methodCall()));
-			expression.isCall = true;
+			expression.setCall(true);
 		}
 		//new 
 		if (ctx.NEW()!=null && ctx.creator()!=null) {
 			expression.setRawType(CreatorContextHelper.getCreatorType(ctx.creator()));
-			expression.isCall = true;
+			expression.setCall(true);
 			expression.deriveTypeFromChild = false;
 		}
 		

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -86,15 +86,15 @@ public class ExpressionUsage {
 					Entity prefixEntity = context.foundEntityWithName(preFix);
 					if (prefixEntity instanceof VarEntity) {
 						((VarEntity) prefixEntity).addFunctionCall(functionName);
-						expression.isCall = true;
+						expression.setCall(true);
 					}
 				}
-				if (!expression.isCall) {
+				if (!expression.isCall()) {
 					Entity typeEntity = context.foundEntityWithName(expression.getIdentifier());
 					if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
 						expression.isCreate = true;
 					} else {
-						expression.isCall = true;
+						expression.setCall(true);
 					}
 				}
 			} else if (expr.member_access() != null) {

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -108,7 +108,7 @@ public class ExpressionUsage {
 			expression.isSet = true;
 		} else if (helper.isFunctionCall(ctx)) {
 			String name = helper.getName(ctx);
-			expression.isCall = true;
+			expression.setCall(true);
 			if (name.equals("new")) {
 				expression.isCreate = true;
 				List<Node> childNodes = ctx.childNodes();

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -130,7 +130,8 @@ public class RelationCounter {
 			return;
 		}
 		boolean matched = false;
-		if (expression.isCall) {
+		if (expression.isCall()) {
+			/* if it is a FunctionEntityProto, add Relation to all Impl Entities*/
 			if (callAsImpl && referredEntity instanceof FunctionEntityProto) {
 				Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
 				if (multiDeclare instanceof MultiDeclareEntities) {
@@ -143,10 +144,8 @@ public class RelationCounter {
 					}
 				}
 			}
-			if (!matched) {
-				entity.addRelation(buildRelation(DependencyType.CALL,referredEntity));
-				matched = true;
-			}
+			entity.addRelation(buildRelation(DependencyType.CALL,referredEntity));
+			matched = true;
 
 		}
 		if (expression.isCreate) {
@@ -162,7 +161,16 @@ public class RelationCounter {
 			matched = true;
 		}
 		if (!matched)  {
-			entity.addRelation(buildRelation(DependencyType.USE,referredEntity));
+			if (callAsImpl && repo.getEntity(referredEntity.getQualifiedName()) instanceof MultiDeclareEntities) {
+				MultiDeclareEntities m =  (MultiDeclareEntities)(repo.getEntity(referredEntity.getQualifiedName()));
+				for (Entity e:m.getEntities()) {
+					entity.addRelation(buildRelation(DependencyType.USE,e));
+					matched = true;
+				}
+			}
+			else {
+				entity.addRelation(buildRelation(DependencyType.USE,referredEntity));
+			}
 		}
 	}
 

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -0,0 +1,73 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.entity.FunctionEntityImpl;
+import depends.entity.FunctionEntityProto;
+import depends.entity.VarEntity;
+import depends.relations.Relation;
+
+public class RelationToImplementationTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_convert_call_relation_to_impl() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/A.h",
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/B.c",
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/A.c",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings(true,null);
+	    Entity bar = repo.getEntity("bar");
+	    int matchCount = 0;
+	    for (Relation relation:bar.getRelations()) {
+	    	if (relation.getEntity() instanceof FunctionEntityProto) {
+	    		matchCount++;
+	    	}
+	    	if (relation.getEntity() instanceof FunctionEntityImpl) {
+	    		matchCount++;
+	    	}
+	    }
+	    assertEquals(2, matchCount);
+	}
+	
+	
+	@Test
+	public void should_convert_var_relation_to_impl() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/A.h",
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/B.c",
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/A.c",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings(true,null);
+	    Entity bar = repo.getEntity("baz");
+	    int matchCount = 0;
+	    for (Relation relation:bar.getRelations()) {
+	    	if (relation.getEntity() instanceof VarEntity) {
+	    		matchCount++;
+	    	}
+	    }
+	    assertEquals(2, matchCount);
+	}
+}

d84bc1571b2d6c8b8665786b268e9c438254a613
@@ -59,8 +59,10 @@ public class ExpressionUsage {
 	public void foundExpression(IASTExpression ctx) {
 		Expression parent = findParentInStack(ctx);
 		//If parent already a call 
-		if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast)) {
-			return;
+		if (parent!=null ) {
+			if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast)) {
+				return;
+			}
 		}
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());

23659135c34b9001b295def775ca28131d6a0944
@@ -40,6 +40,7 @@ public class DependencyType {
 	public static final String CREATE = "Create";
 	public static final String CAST = "Cast";
 	public static final String THROW = "Throw";
+	public static final String IMPLLINK = "ImplLink";
 	public static final String ANNOTATION = "Annotation";
 	public static final String MIXIN = "MixIn";
 	public static final String PomParent = "Parent";
@@ -64,6 +65,7 @@ public class DependencyType {
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
 		depedencyTypes.add(MIXIN);
+		depedencyTypes.add(IMPLLINK);
 		depedencyTypes.add(PomParent);
 		depedencyTypes.add(PomPlugin);
 		depedencyTypes.add(PomDependency);

23659135c34b9001b295def775ca28131d6a0944
@@ -94,6 +94,7 @@ public class CppProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(USE);
 		depedencyTypes.add(CAST);
 		depedencyTypes.add(THROW);
+		depedencyTypes.add(IMPLLINK);
 		return depedencyTypes;
 	}
 

23659135c34b9001b295def775ca28131d6a0944
@@ -139,7 +139,7 @@ public class RelationCounter {
 					List<ContainerEntity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
 					.collect(Collectors.toList());
 					for (Entity e:entities) {
-						entity.addRelation(buildRelation(DependencyType.CALL,e));
+						entity.addRelation(buildRelation(DependencyType.IMPLLINK,e));
 						matched = true;
 					}
 				}
@@ -161,10 +161,15 @@ public class RelationCounter {
 			matched = true;
 		}
 		if (!matched)  {
-			if (callAsImpl && repo.getEntity(referredEntity.getQualifiedName()) instanceof MultiDeclareEntities) {
+			if (callAsImpl && repo.getEntity(referredEntity.getQualifiedName()) instanceof MultiDeclareEntities &&
+					(referredEntity instanceof VarEntity ||referredEntity instanceof FunctionEntity)) {
 				MultiDeclareEntities m =  (MultiDeclareEntities)(repo.getEntity(referredEntity.getQualifiedName()));
 				for (Entity e:m.getEntities()) {
-					entity.addRelation(buildRelation(DependencyType.USE,e));
+					if (e==referredEntity) {
+						entity.addRelation(buildRelation(DependencyType.USE,e));
+					}else {
+						entity.addRelation(buildRelation(DependencyType.IMPLLINK,e));
+					}
 					matched = true;
 				}
 			}

23659135c34b9001b295def775ca28131d6a0944
@@ -70,4 +70,28 @@ public class RelationToImplementationTest extends CppParserTest{
 	    }
 	    assertEquals(2, matchCount);
 	}
+	
+	
+	@Test
+	public void should_not_count_local_var() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/A.h",
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/B.c",
+	    		"./src/test/resources/cpp-code-examples/relation_to_impl/A.c",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings(true,null);
+	    Entity bar = repo.getEntity("qux");
+	    int matchCount = 0;
+	    for (Relation relation:bar.getRelations()) {
+	    	if (relation.getEntity() instanceof VarEntity) {
+	    		matchCount++;
+	    	}
+	    }
+	    assertEquals(1, matchCount);
+	}
 }

731d2d7915c1cd8fa25f3744683167959fee21b1
@@ -74,8 +74,6 @@ public class DependsCommand {
 	private boolean detail = false;	
 	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
 	private boolean autoStub = false;	
-	@Option(names = {"--call-as-impl"}, description = "(only for C/C++)convert the call relation to implementation instead of declaration")
-	private boolean callAsImpl = false;	
 	@Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
     private String[] typeFilter=new String[]{};
 	@Option(names = {"--external-deps"}, description = "Output external dependencies")
@@ -151,9 +149,6 @@ public class DependsCommand {
 		}
 		return java.util.Arrays.asList(typeFilter);
 	}
-	public boolean isCallAsImpl() {
-		return callAsImpl;
-	}
 	public boolean isOutputExternalDependencies() {
 		return outputExternalDependencies;
 	}

b1bf37ebe644f4a625073ccf771a1417bdfd2805
@@ -85,10 +85,14 @@ public class Expression implements Serializable{
 		if (this.type==null && type!=null) {
 			this.type = type;
 			for (VarEntity var:deducedTypeVars) {
-				var.setType(this.type);
+				if (var!=null) {
+					var.setType(this.type);
+				}
 			}
 			for (FunctionEntity func:deducedTypeFunctions) {
-				func.addReturnType(this.type);
+				if (func!=null) {
+					func.addReturnType(this.type);
+				}
 			}
 			changedType = true;
 		}

8c02ab483a07fc0343f1359988fb2cdffa62481d
@@ -51,7 +51,7 @@ public abstract class Entity {
     ArrayList<Relation> relations;
 	private Entity actualReferTo = null;
 	private boolean inScope = true;
-	private HashMap<String, Entity> visibleNames = new HashMap<>();
+	protected HashMap<String, Entity> visibleNames = new HashMap<>();
 	public Entity() {};
     public Entity(GenericName rawName, Entity parent, Integer id) {
 		this.qualifiedName = null;

8fcd25200e5fdde5f09fd81f5aadd68c5bd16546
@@ -259,7 +259,7 @@ public abstract class HandlerContext {
 			container = currentFile();
 		}
 		
-		VarEntity var = getVar(container,GenericName.build(varName));
+		VarEntity var = getVarInLocalFile(container,GenericName.build(varName));
 		if (var!=null) return var;
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
 		container.addVar(var);
@@ -268,7 +268,20 @@ public abstract class HandlerContext {
 		return var;
 	}
 	
-
+	public VarEntity foundGlobalVarDefinition(ContainerEntity container,String varName) {
+		if (container==null) {
+			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
+			container = currentFile();
+		}
+		
+		VarEntity var = getVarInLocalFile(container,GenericName.build(varName));
+		if (var!=null) return var;
+		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
+		container.addVar(var);
+		var.setQualifiedName(var.getRawName().toString());
+		entityRepo.add(var);
+		return var;
+	}
 
 	public VarEntity foundVarDefinition(String varName, GenericName type, List<GenericName> typeArguments) {
 		VarEntity var = new VarEntity(GenericName.build(varName), type, lastContainer(), idGenerator.generateId());
@@ -303,9 +316,10 @@ public abstract class HandlerContext {
 			entityStack.pop();
 	}
 	
-	private VarEntity getVar(ContainerEntity container, GenericName varName) {
-		Entity entity = inferer.resolveName(container, varName, true); //TODO: should be check based on local/class/global
+	private VarEntity getVarInLocalFile(ContainerEntity container, GenericName varName) {
+		Entity entity = inferer.resolveName(container, varName, false); 
 		if (entity ==null ) return null;
+		if (!entity.getAncestorOfType(FileEntity.class).equals(currentFileEntity)) return null;
 		if (entity instanceof VarEntity) return (VarEntity)entity;
 		return null;
 	}

8fcd25200e5fdde5f09fd81f5aadd68c5bd16546
@@ -0,0 +1,37 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+
+public class PythonGlobalVarTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_detect_global_reference() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/global_test/file1.py",
+	    		"./src/test/resources/python-code-examples/global_test/file2.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings(true,null);
+        Entity foo = repo.getEntity(withPackageName(srcs[0],"foo"));
+        this.assertContainsRelation(foo, DependencyType.IMPLLINK, "global_var");
+	}
+	
+
+}

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.util.List;
 

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import depends.entity.repo.BuiltInType;
 

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.io.IOException;
 
@@ -12,6 +12,8 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
+import depends.extractor.python.Python3Lexer;
+import depends.extractor.python.Python3Parser;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.relations.Inferer;
 

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -10,8 +10,9 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.TypeEntity;
+import depends.extractor.python3.PythonFileParser;
 
-public class PythonClassTest extends PythonParserTest {
+public class PythonClassTest extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import static org.junit.Assert.assertEquals;
 
@@ -9,8 +9,9 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
+import depends.extractor.python3.PythonFileParser;
 
-public class PythonDecoratorTest extends PythonParserTest {
+public class PythonDecoratorTest extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.io.IOException;
 
@@ -7,8 +7,9 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
+import depends.extractor.python3.PythonFileParser;
 
-public class PythonFuncCallTest extends PythonParserTest {
+public class PythonFuncCallTest extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -9,8 +9,9 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.FunctionEntity;
+import depends.extractor.python3.PythonFileParser;
 
-public class PythonFunctionTest extends PythonParserTest {
+public class PythonFunctionTest extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -10,8 +10,9 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
+import depends.extractor.python3.PythonFileParser;
 
-public class PythonGlobalVarTest extends PythonParserTest {
+public class PythonGlobalVarTest extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.io.IOException;
 
@@ -7,9 +7,10 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
+import depends.extractor.python3.PythonFileParser;
 import depends.util.FileUtil;
 
-public class PythonImportTest extends PythonParserTest {
+public class PythonImportTest extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.io.IOException;
 
@@ -7,8 +7,9 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
+import depends.extractor.python3.PythonFileParser;
 
-public class PythonObjectCreationTest extends PythonParserTest {
+public class PythonObjectCreationTest extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.io.IOException;
 
@@ -7,8 +7,9 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
+import depends.extractor.python3.PythonFileParser;
 
-public class PythonObjectThrowReturn extends PythonParserTest {
+public class PythonObjectThrowReturn extends Python3ParserTest {
     @Before
     public void setUp() {
     	super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -14,7 +14,7 @@ import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 
-public class PythonParameterTypeDedudceTest extends PythonParserTest {
+public class PythonParameterTypeDedudceTest extends Python3ParserTest {
 	@Before
 	public void setUp() {
 		super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import static org.junit.Assert.assertTrue;
 
@@ -12,7 +12,7 @@ import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 
-public class SelfShouldBeThisTypeTest extends PythonParserTest {
+public class SelfShouldBeThisTypeTest extends Python3ParserTest {
 	@Before
 	public void setUp() {
 		super.init();

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.io.IOException;
 
@@ -9,7 +9,7 @@ import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 import depends.extractor.FileParser;
 
-public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
+public class ShouldGetRelationInSamePackageTest extends Python3ParserTest {
 	@Before
 	public void setUp() {
 		super.init();

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -1,28 +1,30 @@
-package depends.extractor.python3;
+package depends.extractor.python;
 
-import static depends.deptypes.DependencyType.*;
+import static depends.deptypes.DependencyType.ANNOTATION;
+import static depends.deptypes.DependencyType.CALL;
+import static depends.deptypes.DependencyType.CONTAIN;
+import static depends.deptypes.DependencyType.CREATE;
+import static depends.deptypes.DependencyType.IMPLLINK;
+import static depends.deptypes.DependencyType.IMPORT;
+import static depends.deptypes.DependencyType.INHERIT;
+import static depends.deptypes.DependencyType.PARAMETER;
+import static depends.deptypes.DependencyType.RETURN;
+import static depends.deptypes.DependencyType.SET;
+import static depends.deptypes.DependencyType.THROW;
+import static depends.deptypes.DependencyType.USE;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
-import depends.extractor.FileParser;
-import depends.extractor.ruby.IncludedFileLocator;
 import depends.relations.ImportLookupStrategy;
 
-public class PythonProcessor extends AbstractLangProcessor {
+public abstract class BasePythonProcessor extends AbstractLangProcessor{
 	private PythonImportLookupStrategy importedLookupStrategy;
 
-	public PythonProcessor() {
-		/* Because Python is dynamic languange, 
-		 * we eagerly resolve expression*/
-		super(true);
-	}
-
-	@Override
-	public String supportedLanguage() {
-		return "python3";
+	public BasePythonProcessor(boolean eagerExpressionResolve) {
+		super(eagerExpressionResolve);
 	}
 
 	@Override
@@ -41,12 +43,6 @@ public class PythonProcessor extends AbstractLangProcessor {
 	public BuiltInType getBuiltInType() {
 		return new PythonBuiltInType();
 	}
-	
-	@Override
-	protected FileParser createFileParser(String fileFullPath) {
-		IncludedFileLocator includeFileLocator = new IncludedFileLocator(super.includePaths());
-		return new PythonFileParser(fileFullPath,entityRepo,includeFileLocator,inferer,this);
-	}
 
 	@Override
 	public List<String> supportedRelations() {
@@ -71,5 +67,4 @@ public class PythonProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(IMPLLINK);
 		return depedencyTypes;
 	}
-
 }

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -1,4 +1,4 @@
-package depends.extractor.python3;
+package depends.extractor.python;
 
 import depends.entity.repo.BuiltInType;
 

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -1,4 +1,4 @@
-package depends.extractor.python3;
+package depends.extractor.python.py3;
 
 import java.util.List;
 
@@ -12,6 +12,7 @@ import depends.entity.GenericName;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
+import depends.extractor.python.PythonHandlerContext;
 import depends.extractor.python.Python3Parser.AtomContext;
 import depends.extractor.python.Python3Parser.Atom_exprContext;
 import depends.extractor.python.Python3Parser.Expr_stmtContext;

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -0,0 +1,15 @@
+package depends.extractor.python.union;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.python.PythonParserBaseListener;
+import depends.extractor.ruby.IncludedFileLocator;
+import depends.relations.Inferer;
+
+public class PythonCodeListener extends PythonParserBaseListener{
+
+	public PythonCodeListener(String fileFullPath, EntityRepo entityRepo, Inferer inferer,
+			IncludedFileLocator includeFileLocator, PythonProcessor processor) {
+		// TODO Auto-generated constructor stub
+	}
+
+}

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -1,4 +1,4 @@
-package depends.extractor.python3;
+package depends.extractor.python.union;
 
 import java.io.IOException;
 
@@ -12,8 +12,8 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
-import depends.extractor.python.Python3Lexer;
-import depends.extractor.python.Python3Parser;
+import depends.extractor.python.PythonLexer;
+import depends.extractor.python.PythonParser;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.relations.Inferer;
 
@@ -42,14 +42,12 @@ public class PythonFileParser implements FileParser {
 			return;
 		}
         CharStream input = CharStreams.fromFileName(fileFullPath);
-        Lexer lexer = new Python3Lexer(input);
+        Lexer lexer = new PythonLexer(input);
         CommonTokenStream tokens = new CommonTokenStream(lexer);
         
-//        Python2Parser parser = new Python2Parser(tokens);
-//        Python2BaseListener bridge = new Python2BaseListener();
         
-        Python3Parser parser = new Python3Parser(tokens);
-        Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
+        PythonParser parser = new PythonParser(tokens);
+        PythonCodeListener bridge = new PythonCodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();
 	    walker.walk(bridge, parser.file_input());
 	    

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -0,0 +1,186 @@
+package depends.extractor.python.union;
+
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.CommonToken;
+import org.antlr.v4.runtime.Lexer;
+import org.antlr.v4.runtime.Token;
+
+import depends.extractor.python.PythonLexer;
+
+import java.util.Stack;
+
+public abstract class PythonLexerBase extends Lexer {
+    public static int TabSize = 8;
+
+    // The amount of opened braces, brackets and parenthesis.
+    private int _opened;
+
+    // The stack that keeps track of the indentation level.
+    private Stack<Integer> _indents = new Stack<>();
+
+    // A circular buffer where extra tokens are pushed on (see the NEWLINE and WS lexer rules).
+    private int _firstTokensInd;
+    private int _lastTokenInd;
+    private Token[] _buffer = new Token[32];
+    private Token _lastToken;
+
+    protected PythonLexerBase(CharStream input) {
+        super(input);
+    }
+
+    @Override
+    public void emit(Token token) {
+        super.setToken(token);
+
+        if (_buffer[_firstTokensInd] != null)
+        {
+            _lastTokenInd = IncTokenInd(_lastTokenInd);
+
+            if (_lastTokenInd == _firstTokensInd)
+            {
+                // Enlarge buffer
+                Token[] newArray = new Token[_buffer.length * 2];
+                int destInd = newArray.length - (_buffer.length - _firstTokensInd);
+
+                System.arraycopy(_buffer, 0, newArray, 0, _firstTokensInd);
+                System.arraycopy(_buffer, _firstTokensInd, newArray, destInd, _buffer.length - _firstTokensInd);
+
+                _firstTokensInd = destInd;
+                _buffer = newArray;
+            }
+        }
+
+        _buffer[_lastTokenInd] = token;
+        _lastToken = token;
+    }
+
+    @Override
+    public Token nextToken() {
+        // Check if the end-of-file is ahead and there are still some DEDENTS expected.
+        if (_input.LA(1) == EOF && _indents.size() > 0)
+        {
+            if (_buffer[_lastTokenInd] == null || _buffer[_lastTokenInd].getType() != PythonLexer.LINE_BREAK)
+            {
+                // First emit an extra line break that serves as the end of the statement.
+                emit(PythonLexer.LINE_BREAK);
+            }
+
+            // Now emit as much DEDENT tokens as needed.
+            while (_indents.size() != 0)
+            {
+                emit(PythonLexer.DEDENT);
+                _indents.pop();
+            }
+        }
+
+        Token next = super.nextToken();
+
+        if (_buffer[_firstTokensInd] == null)
+        {
+            return next;
+        }
+
+        Token result = _buffer[_firstTokensInd];
+        _buffer[_firstTokensInd] = null;
+
+        if (_firstTokensInd != _lastTokenInd)
+        {
+            _firstTokensInd = IncTokenInd(_firstTokensInd);
+        }
+
+        return result;
+    }
+
+    protected void HandleNewLine() {
+        emit(PythonLexer.NEWLINE, HIDDEN, getText());
+
+        char next = (char) _input.LA(1);
+
+        // Process whitespaces in HandleSpaces
+        if (next != ' ' && next != '\t' && IsNotNewLineOrComment(next))
+        {
+            ProcessNewLine(0);
+        }
+    }
+
+    protected void HandleSpaces() {
+        char next = (char) _input.LA(1);
+
+        if ((_lastToken == null || _lastToken.getType() == PythonLexer.NEWLINE) && IsNotNewLineOrComment(next))
+        {
+            // Calculates the indentation of the provided spaces, taking the
+            // following rules into account:
+            //
+            // "Tabs are replaced (from left to right) by one to eight spaces
+            //  such that the total number of characters up to and including
+            //  the replacement is a multiple of eight [...]"
+            //
+            //  -- https://docs.python.org/3.1/reference/lexical_analysis.html#indentation
+
+            int indent = 0;
+            String text = getText();
+
+            for (int i = 0; i < text.length(); i++) {
+                indent += text.charAt(i) == '\t' ? TabSize - indent % TabSize : 1;
+            }
+
+            ProcessNewLine(indent);
+        }
+
+        emit(PythonLexer.WS, HIDDEN, getText());
+    }
+
+    protected void IncIndentLevel() {
+        _opened++;
+    }
+
+    protected void DecIndentLevel() {
+        if (_opened > 0) {
+            --_opened;
+        }
+    }
+
+    private boolean IsNotNewLineOrComment(char next) {
+        return _opened == 0 && next != '\r' && next != '\n' && next != '\f' && next != '#';
+    }
+
+    private void ProcessNewLine(int indent) {
+        emit(PythonLexer.LINE_BREAK);
+
+        int previous = _indents.size() == 0 ? 0 : _indents.peek();
+
+        if (indent > previous)
+        {
+            _indents.push(indent);
+            emit(PythonLexer.INDENT);
+        }
+        else
+        {
+            // Possibly emit more than 1 DEDENT token.
+            while (_indents.size() != 0 && _indents.peek() > indent)
+            {
+                emit(PythonLexer.DEDENT);
+                _indents.pop();
+            }
+        }
+    }
+
+    private int IncTokenInd(int ind) {
+        return (ind + 1) % _buffer.length;
+    }
+
+    private void emit(int tokenType) {
+        emit(tokenType, DEFAULT_TOKEN_CHANNEL, "");
+    }
+
+    private void emit(int tokenType, int channel, String text) {
+        int charIndex = getCharIndex();
+        CommonToken token = new CommonToken(_tokenFactorySourcePair, tokenType, channel, charIndex - text.length(), charIndex);
+        token.setLine(getLine());
+        token.setCharPositionInLine(getCharPositionInLine());
+        token.setText(text);
+
+        emit(token);
+    }
+}
+

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -0,0 +1,26 @@
+package depends.extractor.python.union;
+
+import org.antlr.v4.runtime.Parser;
+import org.antlr.v4.runtime.TokenStream;
+
+public abstract class PythonParserBase extends Parser
+{
+    public PythonVersion Version = PythonVersion.Autodetect;
+
+    protected PythonParserBase(TokenStream input) {
+        super(input);
+    }
+
+    protected boolean CheckVersion(int version) {
+        return Version == PythonVersion.Autodetect || version == Version.getValue();
+    }
+
+    protected void SetVersion(int requiredVersion) {
+        if (requiredVersion == 2) {
+            Version = PythonVersion.Python2;
+        } else if (requiredVersion == 3) {
+            Version = PythonVersion.Python3;
+        }
+    }
+}
+

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -10,7 +10,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.TypeEntity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 
 public class PythonClassTest extends Python3ParserTest {
     @Before
@@ -25,7 +25,7 @@ public class PythonClassTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -39,7 +39,7 @@ public class PythonClassTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -54,7 +54,7 @@ public class PythonClassTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -9,7 +9,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 
 public class PythonDecoratorTest extends Python3ParserTest {
     @Before
@@ -25,7 +25,7 @@ public class PythonDecoratorTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -7,7 +7,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 
 public class PythonFuncCallTest extends Python3ParserTest {
     @Before
@@ -23,7 +23,7 @@ public class PythonFuncCallTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -9,7 +9,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.entity.FunctionEntity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 
 public class PythonFunctionTest extends Python3ParserTest {
     @Before
@@ -24,7 +24,7 @@ public class PythonFunctionTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -38,7 +38,7 @@ public class PythonFunctionTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -10,7 +10,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 
 public class PythonGlobalVarTest extends Python3ParserTest {
     @Before
@@ -26,7 +26,7 @@ public class PythonGlobalVarTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings(true,null);

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -7,7 +7,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 import depends.util.FileUtil;
 
 public class PythonImportTest extends Python3ParserTest {
@@ -24,7 +24,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -41,7 +41,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -58,7 +58,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -75,7 +75,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -93,7 +93,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -111,7 +111,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -130,7 +130,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -146,7 +146,7 @@ public class PythonImportTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -7,7 +7,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 
 public class PythonObjectCreationTest extends Python3ParserTest {
     @Before
@@ -23,7 +23,7 @@ public class PythonObjectCreationTest extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -7,7 +7,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
-import depends.extractor.python3.PythonFileParser;
+import depends.extractor.python.py3.Python3FileParser;
 
 public class PythonObjectThrowReturn extends Python3ParserTest {
     @Before
@@ -23,7 +23,7 @@ public class PythonObjectThrowReturn extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
@@ -39,7 +39,7 @@ public class PythonObjectThrowReturn extends Python3ParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
+		    Python3FileParser parser = createParser(src);
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -118,6 +118,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		expressionList().add(expression);
 	}
 
+	public boolean containsExpression(Object key) {
+		return 	expressions().containsKey(key);
+	}
 	/**
 	 * For all data in the class, infer their types. Should be override in
 	 * sub-classes
@@ -184,6 +187,17 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			}
 			if (expression.getIdentifier() != null) {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
+				String composedName = expression.getIdentifier().toString();
+				Expression theExpr = expression;
+				if (entity.equals(Inferer.externalType)) {
+					while(theExpr.getParent()==null || !theExpr.isDot) {
+						theExpr = theExpr.getParent();
+						composedName = composedName + "." + theExpr.getIdentifier().toString();
+						entity = inferer.resolveName(this, GenericName.build(composedName), true);
+						if (entity!=null && !entity.equals(Inferer.externalType))
+							break;
+					}
+				}
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;
@@ -410,4 +424,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		if (resolvedMixins==null) return new ArrayList<>();
 		return resolvedMixins;
 	}
+
+
 }

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -297,6 +297,10 @@ public class Expression implements Serializable{
 		}
 		this.rawType = GenericName.build(name);
 	}
+
+	public Expression getParent() {
+		return this.parent;
+	}
 	
 	
 }
\ No newline at end of file

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,311 @@
+package depends.extractor.python.union;
+
+import depends.extractor.python.PythonHandlerContext;
+import depends.extractor.python.PythonParser.Assert_stmtContext;
+import depends.extractor.python.PythonParser.AtomContext;
+import depends.extractor.python.PythonParser.Del_stmtContext;
+import depends.extractor.python.PythonParser.ExprContext;
+import depends.extractor.python.PythonParser.Expr_stmtContext;
+import depends.extractor.python.PythonParser.Raise_stmtContext;
+import depends.extractor.python.PythonParser.Return_stmtContext;
+import depends.extractor.python.PythonParser.Testlist_star_exprContext;
+import depends.extractor.python.PythonParser.TrailerContext;
+import depends.extractor.python.PythonParser.Yield_stmtContext;
+import depends.extractor.python.PythonParserBaseVisitor;
+import depends.relations.Inferer;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.antlr.v4.runtime.ParserRuleContext;
+import org.antlr.v4.runtime.RuleContext;
+
+import depends.entity.Entity;
+import depends.entity.Expression;
+import depends.entity.FunctionEntity;
+import depends.entity.GenericName;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.HandlerContext;
+public class ExpressionUsage {
+	HandlerContext context;
+	IdGenerator idGenerator;
+	private boolean exprStarted=false;
+	private Inferer inferer;
+	public ExpressionUsage(PythonHandlerContext context, IdGenerator idGenerator, Inferer inferer) {
+		this.context = context;
+		this.idGenerator = idGenerator;
+		this.inferer = inferer;
+	}
+
+	/**
+	 * Auto deduce variable type from assignment. for example: c = new C() then c is
+	 * type of C
+	 * 
+	 * @param node
+	 */
+	private void deduceVarTypeInCaseOfAssignment(Expr_stmtContext expr, Expression expression) {
+		List<String> names = getName(expr.testlist_star_expr());
+		// TODO: should handle list properly;
+		String varName = null;
+		if (names.size() == 1)
+			varName = names.get(0);
+		if (varName == null)
+			return;
+		VarEntity var = context.lastContainer().lookupVarLocally(varName);
+		if (var != null) {
+			expression.addDeducedTypeVar(var);
+		}
+	}
+
+	private List<String> getName(Testlist_star_exprContext testlist_star_expr) {
+			List<String> names = new ArrayList<>();
+			testlist_star_expr.accept(new NameCollector(names));
+			return names;
+	}
+
+	public void foundExpression(ParserRuleContext ctx) {
+		if (!isStartOfContainerRule(ctx)) {
+			return ;
+		}
+		if (context.lastContainer().containsExpression(ctx)) return;
+		if (ctx.getParent() instanceof TrailerContext) return;
+		System.out.println("expr: "+ctx.getText() + " class:" + ctx.getClass().getSimpleName());
+		
+		Expression parent = findParentInStack(ctx);
+		Expression expression = parent;
+		
+		if (ctx.getParent().getChildCount()==1 && parent!=null) {
+			//如果就是自己，则无需创建新的Expression	
+		}else {
+			/* create expression and link it with parent*/
+			expression = new Expression(idGenerator.generateId());
+			expression.text = ctx.getText();
+			context.lastContainer().addExpression(ctx,expression);
+			expression.setParent(parent);
+		}
+		
+		
+		if (ctx instanceof Expr_stmtContext) {
+			Expr_stmtContext exprAssign = (Expr_stmtContext)ctx;
+			if (exprAssign.assign_part()!=null) {
+				expression.isSet = true;
+				expression.setIdentifier(exprAssign.testlist_star_expr().getText());
+				if (isValidIdentifier(expression.getIdentifier())) {
+					makeSureVarExist(expression.getIdentifier());
+				}
+				deduceVarTypeInCaseOfAssignment((Expr_stmtContext)ctx,expression);
+			}
+		}
+		if (ctx instanceof Raise_stmtContext) {
+			expression.isThrow = true;
+			expression.deriveTypeFromChild = true;
+		}
+		if (ctx instanceof Return_stmtContext) {
+			deduceReturnTypeInCaseOfReturn((Return_stmtContext)ctx,expression);
+		}
+		if (ctx instanceof ExprContext) {
+			processExprContext((ExprContext)ctx, expression);
+		}
+		
+	}
+
+	private void deduceReturnTypeInCaseOfReturn(Return_stmtContext ctx, Expression expression) {
+		FunctionEntity currentFunction = context.currentFunction();
+		if (currentFunction == null)
+			return;
+		expression.addDeducedTypeFunction(currentFunction);
+	}
+
+
+	private void makeSureVarExist(GenericName identifier) {
+		if (context.foundEntityWithName(identifier).equals(Inferer.externalType)) {
+			context.foundVarDefinition(context.lastContainer(), identifier.getName());
+		}
+	}
+
+	private boolean isValidIdentifier(GenericName identifier) {
+		Pattern p = Pattern.compile("[a-z_][a-z0-9_]*");
+		Matcher m = p.matcher(identifier.getName());
+		return m.find();
+	}
+
+
+
+	private void processExprContext(ExprContext exprCtx, Expression expression) {
+		//func_call, member_access, subscript member, and atom
+		Expression lastExpression = null;
+		if (exprCtx.atom()!=null) {
+			//atom
+			Expression atomExpr = new Expression(idGenerator.generateId());
+			atomExpr.setParent(expression);
+			atomExpr.text = exprCtx.atom().getText();
+			atomExpr.setIdentifier(exprCtx.atom().getText());
+			context.lastContainer().addExpression(exprCtx.atom(),atomExpr);
+			processAtom(exprCtx.atom(),atomExpr);
+			lastExpression = atomExpr;
+			if (exprCtx.trailer()==null || exprCtx.trailer().size()==0) {
+				//do nothing; it is just an id;
+			}else {
+				for (TrailerContext trailer:exprCtx.trailer()) {
+					if (trailer.name()!=null) {
+						Expression trailerExpr = new Expression(idGenerator.generateId());
+						trailerExpr.text = trailer.getText();
+						context.lastContainer().addExpression(trailer,trailerExpr);
+						trailerExpr.setParent(expression);
+
+						//doted name = member access or method call
+						trailerExpr.isDot = true;
+						trailerExpr.setIdentifier(trailer.name().getText());
+						if (trailer.arguments()!=null) {
+							if (trailer.arguments().OPEN_PAREN()!=null) {
+								foundCallStyleExpressionWithDot(trailerExpr,lastExpression.getIdentifier());
+							}else {
+								//subscript list, do nothing
+							}
+						}
+						lastExpression.setParent(trailerExpr);
+						lastExpression = trailerExpr;
+					}else {
+						//direct call, or direct data access
+						if (trailer.arguments()!=null) {
+							if (trailer.arguments().OPEN_PAREN()!=null) {
+								foundCallStyleExpressionWithoutDot(lastExpression);
+							}else {
+								//subscript list, do nothing
+							}
+						}
+					}
+				}
+			}
+		}else {
+/**			expr
+		    | <assoc=right> expr op=POWER expr
+		    | op=(ADD | MINUS | NOT_OP) expr
+		    | expr op=(STAR | DIV | MOD | IDIV | AT) expr
+		    | expr op=(ADD | MINUS) expr
+		    | expr op=(LEFT_SHIFT | RIGHT_SHIFT) expr
+		    | expr op=AND_OP expr
+		    | expr op=XOR expr
+		    | expr op=OR_OP expr
+		    ;*/
+
+		}
+	}
+
+
+	private boolean isStartOfContainerRule(ParserRuleContext ctx) {
+		if (this.exprStarted) return true;
+		return ctx instanceof ExprContext ||
+				ctx instanceof Expr_stmtContext ||
+				ctx instanceof Del_stmtContext ||
+				ctx instanceof Return_stmtContext ||
+				ctx instanceof Raise_stmtContext ||
+				ctx instanceof Raise_stmtContext ||
+				ctx instanceof Yield_stmtContext ||
+				ctx instanceof Assert_stmtContext;
+		}
+
+
+
+	private void foundCallStyleExpressionWithDot(Expression theExpression, GenericName varName) {
+		GenericName funcName = theExpression.getIdentifier();
+		Entity prefixEntity = context.foundEntityWithName(varName);
+		if (prefixEntity instanceof VarEntity) {
+			((VarEntity) prefixEntity).addFunctionCall(funcName);
+		}
+		Entity typeEntity = context.foundEntityWithName(funcName);
+		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
+			theExpression.isCreate = true;
+			theExpression.setType(typeEntity.getType(), typeEntity, inferer);
+			theExpression.setRawType(typeEntity.getRawName());
+			return;
+		} 
+		theExpression.setCall(true);
+	}
+
+
+
+	private void foundCallStyleExpressionWithoutDot(Expression theExpression) {
+		GenericName funcName = theExpression.getIdentifier();
+		Entity typeEntity = context.foundEntityWithName(funcName);
+		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
+			theExpression.getParent().isCreate = true;
+			theExpression.setType(typeEntity.getType(), typeEntity, inferer);
+			theExpression.getParent().setRawType(typeEntity.getRawName());
+			return;
+		} 
+		theExpression.setCall(true);
+	}
+
+
+	private void processAtom(AtomContext atom, Expression expression) {
+		if (atom.name()!=null) {
+			expression.setIdentifier(atom.getText());
+			return;
+		}
+		if (atom.STRING()!=null 
+				|| atom.NONE()!=null
+				|| atom.number()!=null) {
+			expression.setRawType("<Built-in>");
+			expression.setIdentifier("<Literal>");
+			return;
+		}
+
+		if (atom.EXEC()!=null
+		|| atom.PRINT()!=null
+		|| atom.ELLIPSIS()!=null) {
+			return;
+		}
+//	    : OPEN_PAREN (yield_expr | testlist_comp)? CLOSE_PAREN
+//	    | OPEN_BRACKET testlist_comp? CLOSE_BRACKET
+//	    | OPEN_BRACE dictorsetmaker? CLOSE_BRACE
+//	    | REVERSE_QUOTE testlist COMMA? REVERSE_QUOTE
+		return;
+	}	
+
+
+
+
+
+	private Expression findParentInStack(RuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.parent==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.parent)) 
+			return context.lastContainer().expressions().get(ctx.parent);
+		return findParentInStack(ctx.parent);
+	}
+
+
+
+	public void startExpr() {
+		this.exprStarted = true;
+	}
+
+
+
+	public void stopExpr() {
+		this.exprStarted = false;
+	}
+	
+	
+}
+
+class NameCollector extends PythonParserBaseVisitor<Void>{
+	private List<String> names;
+	NameCollector(List<String> names){
+		this.names = names;
+	}
+	@Override
+	public Void visitAtom(AtomContext ctx) {
+		if (ctx.name()!=null)
+			names.add(ctx.name().getText());
+		return super.visitAtom(ctx);
+	}
+}
\ No newline at end of file

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -1,15 +1,368 @@
 package depends.extractor.python.union;
 
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.antlr.v4.runtime.ParserRuleContext;
+
+import depends.entity.ContainerEntity;
+import depends.entity.DecoratedEntity;
+import depends.entity.Entity;
+import depends.entity.Expression;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.GenericName;
+import depends.entity.PackageEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
+import depends.extractor.python.NameAliasImport;
+import depends.extractor.python.PythonHandlerContext;
+import depends.extractor.python.PythonParser.ArglistContext;
+import depends.extractor.python.PythonParser.Assert_stmtContext;
+import depends.extractor.python.PythonParser.Class_or_func_def_stmtContext;
+import depends.extractor.python.PythonParser.ClassdefContext;
+import depends.extractor.python.PythonParser.DecoratorContext;
+import depends.extractor.python.PythonParser.Def_parameterContext;
+import depends.extractor.python.PythonParser.Def_parametersContext;
+import depends.extractor.python.PythonParser.Del_stmtContext;
+import depends.extractor.python.PythonParser.Dotted_as_nameContext;
+import depends.extractor.python.PythonParser.Dotted_nameContext;
+import depends.extractor.python.PythonParser.ExprContext;
+import depends.extractor.python.PythonParser.Expr_stmtContext;
+import depends.extractor.python.PythonParser.From_stmtContext;
+import depends.extractor.python.PythonParser.FuncdefContext;
+import depends.extractor.python.PythonParser.Global_stmtContext;
+import depends.extractor.python.PythonParser.Import_as_nameContext;
+import depends.extractor.python.PythonParser.Import_stmtContext;
+import depends.extractor.python.PythonParser.NameContext;
+import depends.extractor.python.PythonParser.Raise_stmtContext;
+import depends.extractor.python.PythonParser.Return_stmtContext;
+import depends.extractor.python.PythonParser.Yield_stmtContext;
 import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.relations.Inferer;
+import depends.util.FileUtil;
 
 public class PythonCodeListener extends PythonParserBaseListener{
-
+	private PythonHandlerContext context;
+	private ExpressionUsage expressionUsage;
+	private EntityRepo entityRepo;
+	private IncludedFileLocator includeFileLocator;
+	private PythonProcessor pythonProcessor;
+	private Inferer inferer;
 	public PythonCodeListener(String fileFullPath, EntityRepo entityRepo, Inferer inferer,
-			IncludedFileLocator includeFileLocator, PythonProcessor processor) {
-		// TODO Auto-generated constructor stub
+			IncludedFileLocator includeFileLocator, PythonProcessor pythonProcessor) {
+		this.context = new PythonHandlerContext(entityRepo, inferer);
+		this.expressionUsage = new ExpressionUsage(context, entityRepo, inferer);
+		FileEntity fileEntity = context.startFile(fileFullPath);
+		this.entityRepo = entityRepo;
+		this.includeFileLocator = includeFileLocator;
+		this.inferer = inferer;
+		this.pythonProcessor = pythonProcessor;
+
+		String dir = FileUtil.uniqFilePath(FileUtil.getLocatedDir(fileFullPath));
+		if (entityRepo.getEntity(dir) == null) {
+			entityRepo.add(new PackageEntity(dir, entityRepo.generateId()));
+		}
+
+		PackageEntity packageEntity = (PackageEntity) entityRepo.getEntity(dir);
+		String moduleName = fileEntity.getRawName().uniqName().substring(packageEntity.getRawName().uniqName().length() + 1);
+		if (moduleName.endsWith(".py"))
+			moduleName = moduleName.substring(0, moduleName.length() - ".py".length());
+		Entity.setParent(fileEntity, packageEntity);
+		packageEntity.addChild(FileUtil.getShortFileName(fileEntity.getRawName().uniqName()).replace(".py", ""), fileEntity);
+	}
+	@Override
+	public void enterImport_stmt(Import_stmtContext ctx) {
+		String moduleName = null;
+		for(Dotted_as_nameContext dotted_as_name:ctx.dotted_as_names().dotted_as_name()){
+			moduleName = getName(dotted_as_name.dotted_name());
+			String aliasName = moduleName;
+			if (dotted_as_name.name()!=null) {
+				aliasName = dotted_as_name.name().getText();
+			}
+			String fullName = foundImportedModuleOrPackage(0,moduleName);
+			if (fullName!=null) {
+				context.foundNewImport(new NameAliasImport(fullName, entityRepo.getEntity(fullName), aliasName));
+			}
+		}
+		super.enterImport_stmt(ctx);
+	}
+	@Override
+	public void enterFrom_stmt(From_stmtContext ctx) {
+		String moduleName = null;
+		if (ctx.dotted_name() != null) {
+			moduleName = ctx.dotted_name().getText();
+		}
+		int prefixDotCount = getDotCounter(ctx);
+
+		String fullName = foundImportedModuleOrPackage(prefixDotCount, moduleName);
+		if (fullName != null) {
+			if (ctx.import_as_names() == null) {// import *
+				ContainerEntity moduleEntity = (ContainerEntity) (entityRepo.getEntity(fullName));
+				if (moduleEntity != null) {
+					for (FunctionEntity func : moduleEntity.getFunctions()) {
+						context.foundNewImport(new NameAliasImport(fullName, func, func.getRawName().uniqName()));
+					}
+					for (VarEntity var : moduleEntity.getVars()) {
+						context.foundNewImport(new NameAliasImport(fullName, var, var.getRawName().uniqName()));
+					}
+					if (moduleEntity instanceof PackageEntity) {
+						for (Entity file : moduleEntity.getChildren()) {
+							String fileName = file.getRawName().uniqName().substring(fullName.length());
+							context.foundNewImport(new NameAliasImport(file.getRawName().uniqName(), file, fileName));
+						}
+					}
+				}
+			} else {
+				for (Import_as_nameContext item : ctx.import_as_names().import_as_name()) {
+					String name = item.name(0).getText();
+					String alias = name;
+					if (item.name().size() > 1)
+						alias = item.name(1).getText();
+					Entity itemEntity = inferer.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
+					if (itemEntity != null)
+						context.foundNewImport(new NameAliasImport(itemEntity.getQualifiedName(), itemEntity, alias));
+				}
+			}
+		}
+		super.enterFrom_stmt(ctx);
+	}
+	
+	
+	private int getDotCounter(From_stmtContext ctx) {
+		int total = 0;
+		if (ctx.DOT()!=null){
+			total = ctx.DOT().size();
+		}
+		if (ctx.ELLIPSIS()!=null) {
+			total += ctx.ELLIPSIS().size()*3;
+		}
+		return total;
+	}
+	private String foundImportedModuleOrPackage(int prefixDotCount, String originalName) {
+		String dir = FileUtil.getLocatedDir(context.currentFile().getRawName().uniqName());
+		String preFix = "";
+		for (int i = 0; i < prefixDotCount - 1; i++) {
+			preFix = preFix + ".." + File.separator;
+		}
+		dir = dir + File.separator + preFix;
+		String fullName = null;
+		if (originalName != null) {
+			String importedName = originalName.replace(".", File.separator);
+			fullName = includeFileLocator.uniqFileName(dir, importedName);
+			if (fullName == null) {
+				fullName = includeFileLocator.uniqFileName(dir, importedName + ".py");
+			}
+		} else {
+			fullName = FileUtil.uniqFilePath(dir);
+		}
+		if (fullName != null) {
+			if (FileUtil.isDirectory(fullName)) {
+				if (!FileUtil.uniqFilePath(fullName).equals(FileUtil.uniqFilePath(dir))) {
+					File d = new File(fullName);
+					File[] files = d.listFiles();
+					for (File file : files) {
+						if (!file.isDirectory()) {
+							if (file.getAbsolutePath().endsWith(".py")) {
+								visitIncludedFile(FileUtil.uniqFilePath(file.getAbsolutePath()));
+							}
+						}
+					}
+				}
+			} else {
+				visitIncludedFile(fullName);
+			}
+		}
+		return fullName;
+	}
+
+	private void visitIncludedFile(String fullName) {
+		PythonFileParser importedParser = new PythonFileParser(fullName, entityRepo, includeFileLocator, inferer,
+				pythonProcessor);
+		try {
+			importedParser.parse();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+	@Override
+	public void enterFuncdef(FuncdefContext ctx) {
+		String functionName ="<empty>";
+		String name = getName(ctx.name());
+		if (name!=null) {
+			functionName = name;
+		}
+		
+		context.foundMethodDeclarator(functionName);
+		if (ctx.typedargslist()!=null) {
+			List<String> parameters = getParameterList(ctx.typedargslist().def_parameters());
+			for (String param : parameters) {
+				VarEntity paramEntity = context.addMethodParameter(param);
+				if (param.equals("self")) {
+					paramEntity.setType(context.currentType());
+				}
+			}
+		}
+		super.enterFuncdef(ctx);
+	}
+
+	@Override
+	public void exitFuncdef(FuncdefContext ctx) {
+		context.exitLastedEntity();
+		super.exitFuncdef(ctx);
+	}
+	
+	
+	@Override
+	public void enterClassdef(ClassdefContext ctx) {
+		String name = getName(ctx.name());
+		TypeEntity type = context.foundNewType(name);
+		List<String> baseClasses = getArgList(ctx.arglist());
+		baseClasses.forEach(base -> type.addExtends(GenericName.build(base)));
+
+		super.enterClassdef(ctx);
+	}
+
+
+	@Override
+	public void exitClassdef(ClassdefContext ctx) {
+		context.exitLastedEntity();
+		super.exitClassdef(ctx);
+	}
+	
+	private List<String> getParameterList(List<Def_parametersContext> def_parameters) {
+		List<String> result = new ArrayList<>();
+		for (Def_parametersContext params:def_parameters) {
+			for (Def_parameterContext param:params.def_parameter()) {
+				String p = getName( param.named_parameter().name());
+				result.add(p);
+			}
+		
+		}
+		return result;
+	}
+	private String getName(NameContext name) {
+		return name.getText();
+	}
+	
+	private String getName(Dotted_nameContext dotted_name) {
+		return dotted_name.getText();
+	}
+	
+	private String getDecoratedName(Class_or_func_def_stmtContext ctx) {
+		if (ctx.classdef()!=null) {
+			return getName(ctx.classdef().name());
+		}else if (ctx.funcdef()!=null) {
+			return getName(ctx.funcdef().name());
+		}
+		return null;
+	}
+	
+	private List<String> getArgList(ArglistContext arglist) {
+		List<String> r = new ArrayList<>();
+		if (arglist==null) return r;
+		if (arglist.argument() == null) return r;
+		if (arglist.argument().isEmpty()) return r;
+		arglist.argument().forEach(arg->r.add(arg.getText()));
+		return r;
+	}
+	
+	
+	/**
+	 * class_or_func_def_stmt: decorator+ (classdef | funcdef);
+	 */
+	@Override
+	public void exitClass_or_func_def_stmt(Class_or_func_def_stmtContext ctx) {
+		String decoratedName = getDecoratedName(ctx);
+		if (decoratedName!=null) {
+			Entity entity = context.foundEntityWithName(GenericName.build(decoratedName));
+			if (entity instanceof DecoratedEntity) {
+				for (DecoratorContext decorator: ctx.decorator()) {
+					String decoratorName = getName(decorator.dotted_name());
+					((DecoratedEntity) entity).addAnnotation(GenericName.build(decoratorName));
+				}
+			}
+		}
+		super.exitClass_or_func_def_stmt(ctx);
+	}
+	
+	
+	@Override
+	public void enterGlobal_stmt(Global_stmtContext ctx) {
+		for (NameContext name:ctx.name()){
+			context.foundGlobalVarDefinition(context.currentFile(),name.getText());
+		}
+		super.enterGlobal_stmt(ctx);
+	}
+	
+	@Override
+	public void enterEveryRule(ParserRuleContext ctx) {
+		expressionUsage.foundExpression(ctx);
+		super.enterEveryRule(ctx);
+	}
+	@Override
+	public void enterExpr_stmt(Expr_stmtContext ctx) {
+		expressionUsage.startExpr();
+		super.enterExpr_stmt(ctx);
+	}
+	@Override
+	public void exitExpr_stmt(Expr_stmtContext ctx) {
+		expressionUsage.stopExpr();
+		super.exitExpr_stmt(ctx);
+	}
+	@Override
+	public void enterDel_stmt(Del_stmtContext ctx) {
+		expressionUsage.startExpr();
+		super.enterDel_stmt(ctx);
+	}
+	@Override
+	public void exitDel_stmt(Del_stmtContext ctx) {
+		expressionUsage.stopExpr();
+		super.exitDel_stmt(ctx);
+	}
+	@Override
+	public void enterReturn_stmt(Return_stmtContext ctx) {
+		expressionUsage.startExpr();
+		super.enterReturn_stmt(ctx);
+	}
+	@Override
+	public void exitReturn_stmt(Return_stmtContext ctx) {
+		expressionUsage.stopExpr();
+		super.exitReturn_stmt(ctx);
+	}
+	@Override
+	public void enterRaise_stmt(Raise_stmtContext ctx) {
+		expressionUsage.startExpr();
+		super.enterRaise_stmt(ctx);
+	}
+	@Override
+	public void exitRaise_stmt(Raise_stmtContext ctx) {
+		expressionUsage.stopExpr();
+		super.exitRaise_stmt(ctx);
+	}
+	@Override
+	public void enterYield_stmt(Yield_stmtContext ctx) {
+		expressionUsage.startExpr();
+		super.enterYield_stmt(ctx);
+	}
+	@Override
+	public void exitYield_stmt(Yield_stmtContext ctx) {
+		expressionUsage.stopExpr();
+		super.exitYield_stmt(ctx);
+	}
+	@Override
+	public void enterAssert_stmt(Assert_stmtContext ctx) {
+		expressionUsage.startExpr();
+		super.enterAssert_stmt(ctx);
+	}
+	@Override
+	public void exitAssert_stmt(Assert_stmtContext ctx) {
+		expressionUsage.stopExpr();
+		super.exitAssert_stmt(ctx);
 	}
 
 }

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,25 @@
+package depends.extractor.java;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.ContainerEntity;
+
+public class JavaCallExpressionTest extends JavaParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test() throws IOException {
+        String src = "./src/test/resources/java-code-examples/SimpleExpressionCallTest.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+	}
+
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,66 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.TypeEntity;
+import depends.extractor.python.union.PythonFileParser;
+
+public class PythonClassTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity(withPackageName(srcs[0],"Foo")));
+	}
+	
+	@Test
+	public void should_parse_method_of_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Foo"));
+        assertEquals(2,type.getFunctions().size());
+	}
+	
+	@Test
+	public void should_parse_baseclass_of_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Bar"));
+	    this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
+	}
+
+
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,37 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.python.union.PythonFileParser;
+
+public class PythonDecoratorTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_decorated() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/decorated.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(func, DependencyType.ANNOTATION	, withPackageName(srcs[0],"our_decorator"));
+	    assertEquals(1,func.getResolvedAnnotations().size());
+	}
+
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,66 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.python.union.PythonFileParser;
+
+public class PythonFuncCallTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_func_call() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func_call.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"bar"));
+	}
+
+	@Test
+	public void could_parse_func_call_of_member() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func_call.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"baz"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"A.foo"));
+	}
+	
+	@Test
+	public void could_parse_func_call_of_multi_dots() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func_call_multi_dots.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"C.test"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"A.fooA"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"B.fooB"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"C.fooC"));
+	}
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,51 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.FunctionEntity;
+import depends.extractor.python.union.PythonFileParser;
+
+public class PythonFunctionTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_methods() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity(withPackageName(srcs[0],"foo")));
+	}
+	
+	@Test
+	public void should_parse_method_parameters() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/func.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+        assertEquals(2,func.getParameters().size());
+	}
+	
+
+
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,36 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.extractor.python.py3.Python3FileParser;
+import depends.extractor.python.union.PythonFileParser;
+
+public class PythonGlobalVarTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_detect_global_reference() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/global_test/file1.py",
+	    		"./src/test/resources/python-code-examples/global_test/file2.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings(true,null);
+        Entity foo = repo.getEntity(withPackageName(srcs[0],"foo"));
+        this.assertContainsRelation(foo, DependencyType.IMPLLINK, "global_var");
+	}
+	
+
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,154 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.extractor.python.union.PythonFileParser;
+import depends.util.FileUtil;
+
+public class PythonImportTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_module_in_same_package() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    		"./src/test/resources/python-code-examples/importing.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[0]));
+	}
+	
+	
+	@Test
+	public void should_parse_module_in_same_package_order_robust() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/importing.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+	}
+	
+	@Test
+	public void should_parse_module_in_same_package_with_alias() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/importing_with_alias.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+	}
+	
+	@Test
+	public void should_parse_module_in_from_importing() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/from_importing.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
+	
+	
+	@Test
+	public void should_parse_module_in_from_importing_star() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/from_importing_star.py",
+	    		"./src/test/resources/python-code-examples/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
+	
+	
+	@Test
+	public void should_parse_import_with_multi_dots() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/from_importing_multidot.py",
+	    		"./src/test/resources/python-code-examples/pkg/imported.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[1],"foo"));
+	}
+	
+	@Test
+	public void should_parse_import_with_prefix_dots() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_with_dir/importing.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/imported_a.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing2.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[3])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
+	
+	@Test
+	public void should_parse_import_with_prefix_dots2() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing2.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	}
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,35 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.python.py3.Python3FileParser;
+import depends.extractor.python.union.PythonFileParser;
+
+public class PythonObjectCreationTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_object_creation() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/object_creation.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    this.assertContainsRelation(func, DependencyType.CREATE, withPackageName(srcs[0],"Bar"));
+	}
+
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,52 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.python.py3.Python3FileParser;
+import depends.extractor.python.union.PythonFileParser;
+
+public class PythonObjectThrowReturn extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+
+	
+	@Test
+	public void could_parse_throws() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/throw_return.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t1"));
+	    this.assertContainsRelation(func, DependencyType.THROW, withPackageName(srcs[0],"Bar"));
+	}
+	
+	
+	@Test
+	public void could_parse_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/throw_return.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t2"));
+	    this.assertContainsRelation(func, DependencyType.RETURN, withPackageName(srcs[0],"Bar"));
+	}
+
+
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,44 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.CandidateTypes;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+
+public class PythonParameterTypeDedudceTest extends PythonParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_deduce_type_of_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/deducetype_parameter.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    String name = withPackageName(srcs[0],"test");
+	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    VarEntity var = function.lookupVarLocally("t1");
+	    TypeEntity type = var.getType();
+	    assertTrue(type instanceof CandidateTypes);
+	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
+	}
+
+
+}
+

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,48 @@
+package depends.extractor.python;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.extractor.ParserCreator;
+import depends.extractor.ParserTest;
+import depends.extractor.python.py3.Python3FileParser;
+import depends.extractor.python.py3.Python3Processor;
+import depends.extractor.python.union.PythonFileParser;
+import depends.extractor.python.union.PythonProcessor;
+import depends.relations.Inferer;
+import depends.util.FileUtil;
+import depends.util.TemporaryFile;
+
+public abstract class PythonParserTest extends ParserTest implements ParserCreator {
+
+	protected EntityRepo repo;
+	private PythonProcessor p;
+	protected Inferer inferer;
+
+	public void init() {
+		List<String> includeDir = new ArrayList<>();
+		includeDir.add("./src/test/resources/python-code-examples/");
+		this.p = new PythonProcessor();
+		p.includeDirs = includeDir.toArray(new String[] {});
+		
+		this.repo = p.getEntityRepo();
+		this.inferer = p.inferer;
+    	TemporaryFile.reset();
+		
+    }
+	
+	public PythonFileParser createParser(String src) {
+		return (PythonFileParser)createFileParser(src);
+	}
+	
+	@Override
+	public FileParser createFileParser(String src) {
+		return  p.createFileParser(FileUtil.uniqFilePath(src));
+	}
+	
+	protected String withPackageName(String theFile,String entityName) {
+		return FileUtil.uniqFilePath(FileUtil.getLocatedDir(theFile))+"."+entityName;
+	}
+}

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,38 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.entity.VarEntity;
+import depends.extractor.FileParser;
+
+public class SelfShouldBeThisTypeTest extends PythonParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_deduce_type_of_return() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/self_should_be_this_type.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"A.foo")));
+	    VarEntity var = function.lookupVarLocally("self");
+	    TypeEntity type = var.getType();
+	    assertTrue(type.getQualifiedName().equals(withPackageName(srcs[0],"A")));
+	}
+}
+

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,34 @@
+package depends.extractor.python;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
+import depends.extractor.FileParser;
+
+public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	
+	@Test
+	public void test_relations_of_sampe_package() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/a.py",
+	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/b.py"
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"bar")));
+	    this.assertContainsRelation(function, DependencyType.CALL, withPackageName(srcs[0],"foo"));
+	}
+}
+

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -0,0 +1,11 @@
+public class SimpleExpressionCallTest {
+    public SimpleExpressionCallTest foo(){
+        return this;
+    }
+    
+    public SimpleExpressionCallTest bar(){
+        _this = this;
+        _this[0].foo().bar().foo();
+        return this;
+    }
+}

94e17e471f95be840d54f9a2afcca564bcb8e45c
@@ -189,12 +189,12 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
-				if (entity.equals(Inferer.externalType)) {
-					while(theExpr.getParent()==null || !theExpr.isDot) {
+				if (Inferer.externalType.equals(entity)) {
+					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
 						theExpr = theExpr.getParent();
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
 						entity = inferer.resolveName(this, GenericName.build(composedName), true);
-						if (entity!=null && !entity.equals(Inferer.externalType))
+						if (entity!=null && !Inferer.externalType.equals(entity))
 							break;
 					}
 				}

ce4dfcf89ec34b0d1e60ca9965a7721f56f5260d
@@ -73,7 +73,6 @@ public class ExpressionUsage {
 		}
 		if (context.lastContainer().containsExpression(ctx)) return;
 		if (ctx.getParent() instanceof TrailerContext) return;
-		System.out.println("expr: "+ctx.getText() + " class:" + ctx.getClass().getSimpleName());
 		
 		Expression parent = findParentInStack(ctx);
 		Expression expression = parent;
@@ -122,7 +121,7 @@ public class ExpressionUsage {
 
 
 	private void makeSureVarExist(GenericName identifier) {
-		if (context.foundEntityWithName(identifier).equals(Inferer.externalType)) {
+		if (Inferer.externalType.equals(context.foundEntityWithName(identifier))) {
 			context.foundVarDefinition(context.lastContainer(), identifier.getName());
 		}
 	}

e504d18f1cb1d41e6f1f45efe88ea2c7a2fe56c9
@@ -10,7 +10,6 @@ import org.antlr.v4.runtime.ParserRuleContext;
 import depends.entity.ContainerEntity;
 import depends.entity.DecoratedEntity;
 import depends.entity.Entity;
-import depends.entity.Expression;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.GenericName;
@@ -30,7 +29,6 @@ import depends.extractor.python.PythonParser.Def_parametersContext;
 import depends.extractor.python.PythonParser.Del_stmtContext;
 import depends.extractor.python.PythonParser.Dotted_as_nameContext;
 import depends.extractor.python.PythonParser.Dotted_nameContext;
-import depends.extractor.python.PythonParser.ExprContext;
 import depends.extractor.python.PythonParser.Expr_stmtContext;
 import depends.extractor.python.PythonParser.From_stmtContext;
 import depends.extractor.python.PythonParser.FuncdefContext;

c24f6b17802322567780d18437f5472833600077
@@ -1,190 +0,0 @@
-package depends.extractor.python.py3;
-
-import java.util.List;
-
-import org.antlr.v4.runtime.ParserRuleContext;
-
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Expression;
-import depends.entity.FunctionEntity;
-import depends.entity.GenericName;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
-import depends.entity.repo.IdGenerator;
-import depends.extractor.python.PythonHandlerContext;
-import depends.extractor.python.Python3Parser.AtomContext;
-import depends.extractor.python.Python3Parser.Atom_exprContext;
-import depends.extractor.python.Python3Parser.Expr_stmtContext;
-import depends.extractor.python.Python3Parser.Raise_stmtContext;
-import depends.extractor.python.Python3Parser.Return_stmtContext;
-import depends.extractor.python.Python3Parser.SuiteContext;
-import depends.extractor.python.Python3Parser.TestContext;
-import depends.relations.Inferer;
-
-public class ExpressionUsage {
-	IdGenerator idGenerator;
-	Inferer inferer;
-	private PythonHandlerContext context;
-	private PythonParserHelper helper;
-
-	public ExpressionUsage(PythonHandlerContext context, IdGenerator idGenerator, PythonParserHelper helper,
-			Inferer inferer) {
-		this.context = context;
-		this.idGenerator = idGenerator;
-		this.inferer = inferer;
-		this.helper = helper;
-	}
-
-	public Expression foundExpression(ParserRuleContext ctx) {
-		if (!context.lastContainer().containsExpression()) {
-			if (!isStartOfContainerRule(ctx)) {
-				return null;
-			}
-		}
-		Expression expression = findExpression(ctx);
-		if (expression != null)
-			return expression;
-		Expression parent = findParentInStack(ctx);
-		/* create expression and link it with parent */
-		expression = new Expression(idGenerator.generateId());
-		expression.text = ctx.getText();
-		expression.setParent(parent);
-
-		context.lastContainer().addExpression(ctx, expression);
-		if (ctx instanceof AtomContext) {
-			AtomContext atom = (AtomContext) ctx;
-			if (atom.NUMBER() != null || atom.STRING() != null && atom.STRING().size() > 0) {
-				expression.setIdentifier("<literal>");
-				expression.setRawType(Inferer.buildInType.getQualifiedName());
-			} else if (atom.getText().equals("True") || atom.getText().equals("False")) {
-				expression.setIdentifier("<boolean>");
-				expression.setRawType(Inferer.buildInType.getQualifiedName());
-			} else if (atom.getText().equals("None")) {
-				expression.setIdentifier("<null>");
-				expression.setRawType(Inferer.buildInType.getQualifiedName());
-			} else if (atom.NAME() != null) {
-				expression.setIdentifier(atom.NAME().getText());
-			}
-		}
-
-		if (ctx instanceof Expr_stmtContext) {
-			Expr_stmtContext expr = ((Expr_stmtContext) ctx);
-			if ((expr.expr_stmt_rhs() != null) || (expr.augassign() != null) || (expr.annassign() != null)) {
-				expression.isSet = true;
-			}
-		} else if (ctx instanceof Atom_exprContext) {
-			Atom_exprContext expr = ((Atom_exprContext) ctx);
-			if (expr.func_call() != null) {
-				// TODO: should be refined later. Currently only a.b.c could be solved.
-				expression.setIdentifier(expr.atom_expr().getText());
-				String callPrefix = expr.atom_expr().getText();
-				// call with variables
-				if (callPrefix.contains(".")) {
-					int pos = callPrefix.lastIndexOf('.');
-					GenericName functionName = GenericName.build(callPrefix.substring(pos + 1));
-					GenericName preFix = GenericName.build(callPrefix.substring(0, pos));
-					Entity prefixEntity = context.foundEntityWithName(preFix);
-					if (prefixEntity instanceof VarEntity) {
-						((VarEntity) prefixEntity).addFunctionCall(functionName);
-						expression.setCall(true);
-					}
-				}
-				if (!expression.isCall()) {
-					Entity typeEntity = context.foundEntityWithName(expression.getIdentifier());
-					if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
-						expression.isCreate = true;
-					} else {
-						expression.setCall(true);
-					}
-				}
-			} else if (expr.member_access() != null) {
-				expression.isDot = true;
-				expression.setIdentifier(expr.member_access().NAME().getText());
-			}
-			// TODO: member access in python should be handled seperately. they could be
-			// different types;
-		} else if (ctx instanceof Return_stmtContext) {
-			deduceReturnTypeInCaseOfReturn(ctx, expression);
-		} else if (ctx instanceof Raise_stmtContext) {
-			expression.isThrow = true;
-			expression.deriveTypeFromChild = true;
-		}
-		deduceVarTypeInCaseOfAssignment(ctx, expression);
-		return expression;
-	}
-
-	/**
-	 * To judge whether is an 'real' expression
-	 * 
-	 * @param ctx
-	 * @return
-	 */
-	private boolean isStartOfContainerRule(ParserRuleContext ctx) {
-		return ctx instanceof SuiteContext || ctx instanceof TestContext || ctx instanceof Expr_stmtContext;
-	}
-
-	/**
-	 * Auto deduce variable type from assignment. for example: c = C.new then c is
-	 * type of C
-	 * 
-	 * @param node
-	 * @param expression
-	 */
-	private void deduceVarTypeInCaseOfAssignment(ParserRuleContext node, Expression expression) {
-		ParserRuleContext parentNode = node.getParent();
-		if (parentNode instanceof Expr_stmtContext) {
-			Expr_stmtContext expr = (Expr_stmtContext) parentNode;
-			if (expr.expr_stmt_rhs() != null) {
-				ContainerEntity scope = helper.getScopeOfVar(expr, this.context);
-				if (scope == null)
-					return;
-				String varName = null;
-				// TODO: should handle list properly;
-				List<String> names = helper.getName(expr.testlist_star_expr());
-				if (names.size() == 1)
-					varName = names.get(0);
-				if (varName == null)
-					return;
-				VarEntity var = scope.lookupVarLocally(varName);
-				if (var != null) {
-					expression.addDeducedTypeVar(var);
-				}
-			}
-		}
-	}
-
-	private void deduceReturnTypeInCaseOfReturn(ParserRuleContext ctx, Expression expression) {
-		FunctionEntity currentFunction = context.currentFunction();
-		if (currentFunction == null)
-			return;
-		if (ctx instanceof Return_stmtContext) {
-			expression.addDeducedTypeFunction(currentFunction);
-		}
-	}
-
-	private Expression findParentInStack(ParserRuleContext ctx) {
-		if (ctx == null)
-			return null;
-		if (ctx.getParent() == null)
-			return null;
-		if (context.lastContainer() == null) {
-			return null;
-		}
-		if (context.lastContainer().expressions().containsKey(ctx.getParent()))
-			return context.lastContainer().expressions().get(ctx.getParent());
-		return findParentInStack(ctx.getParent());
-	}
-
-	private Expression findExpression(ParserRuleContext ctx) {
-		if (ctx == null)
-			return null;
-		if (ctx.getParent() == null)
-			return null;
-		if (context.lastContainer() == null) {
-			return null;
-		}
-		return context.lastContainer().expressions().get(ctx);
-	}
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,66 +0,0 @@
-package depends.extractor.python3;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.TypeEntity;
-import depends.extractor.python.py3.Python3FileParser;
-
-public class PythonClassTest extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-	
-	@Test
-	public void should_parse_class() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/class.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity(withPackageName(srcs[0],"Foo")));
-	}
-	
-	@Test
-	public void should_parse_method_of_class() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/class.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Foo"));
-        assertEquals(2,type.getFunctions().size());
-	}
-	
-	@Test
-	public void should_parse_baseclass_of_class() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/class.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Bar"));
-	    this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
-	}
-
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,37 +0,0 @@
-package depends.extractor.python3;
-
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.FunctionEntity;
-import depends.extractor.python.py3.Python3FileParser;
-
-public class PythonDecoratorTest extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-
-	
-	@Test
-	public void could_parse_decorated() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/decorated.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
-		this.assertContainsRelation(func, DependencyType.ANNOTATION	, withPackageName(srcs[0],"our_decorator"));
-	    assertEquals(1,func.getResolvedAnnotations().size());
-	}
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,34 +0,0 @@
-package depends.extractor.python3;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.FunctionEntity;
-import depends.extractor.python.py3.Python3FileParser;
-
-public class PythonFuncCallTest extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-
-	
-	@Test
-	public void could_parse_func_call() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/func_call.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"bar"));
-	}
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,51 +0,0 @@
-package depends.extractor.python3;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.entity.FunctionEntity;
-import depends.extractor.python.py3.Python3FileParser;
-
-public class PythonFunctionTest extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-	
-	@Test
-	public void should_parse_methods() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/func.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity(withPackageName(srcs[0],"foo")));
-	}
-	
-	@Test
-	public void should_parse_method_parameters() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/func.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
-        assertEquals(2,func.getParameters().size());
-	}
-	
-
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,38 +0,0 @@
-package depends.extractor.python3;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.Entity;
-import depends.extractor.python.py3.Python3FileParser;
-
-public class PythonGlobalVarTest extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-	
-	@Test
-	public void should_detect_global_reference() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/global_test/file1.py",
-	    		"./src/test/resources/python-code-examples/global_test/file2.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings(true,null);
-        Entity foo = repo.getEntity(withPackageName(srcs[0],"foo"));
-        this.assertContainsRelation(foo, DependencyType.IMPLLINK, "global_var");
-	}
-	
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,154 +0,0 @@
-package depends.extractor.python3;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.Entity;
-import depends.extractor.python.py3.Python3FileParser;
-import depends.util.FileUtil;
-
-public class PythonImportTest extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-	
-	@Test
-	public void should_parse_module_in_same_package() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/imported_a.py",
-	    		"./src/test/resources/python-code-examples/importing.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[0]));
-	}
-	
-	
-	@Test
-	public void should_parse_module_in_same_package_order_robust() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/importing.py",
-	    		"./src/test/resources/python-code-examples/imported_a.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
-	}
-	
-	@Test
-	public void should_parse_module_in_same_package_with_alias() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/importing_with_alias.py",
-	    		"./src/test/resources/python-code-examples/imported_a.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
-	}
-	
-	@Test
-	public void should_parse_module_in_from_importing() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/from_importing.py",
-	    		"./src/test/resources/python-code-examples/imported_a.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-	}
-	
-	
-	@Test
-	public void should_parse_module_in_from_importing_star() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/from_importing_star.py",
-	    		"./src/test/resources/python-code-examples/imported_a.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-	}
-	
-	
-	@Test
-	public void should_parse_import_with_multi_dots() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/from_importing_multidot.py",
-	    		"./src/test/resources/python-code-examples/pkg/imported.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[1],"foo"));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-	}
-	
-	@Test
-	public void should_parse_import_with_prefix_dots() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/import_with_dir/importing.py",
-	    		"./src/test/resources/python-code-examples/import_with_dir/imported_a.py",
-	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing.py",
-	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing2.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[3])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-	}
-	
-	@Test
-	public void should_parse_import_with_prefix_dots2() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing2.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	}
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,34 +0,0 @@
-package depends.extractor.python3;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.FunctionEntity;
-import depends.extractor.python.py3.Python3FileParser;
-
-public class PythonObjectCreationTest extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-
-	
-	@Test
-	public void could_parse_object_creation() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/object_creation.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
-	    this.assertContainsRelation(func, DependencyType.CREATE, withPackageName(srcs[0],"Bar"));
-	}
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,51 +0,0 @@
-package depends.extractor.python3;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.FunctionEntity;
-import depends.extractor.python.py3.Python3FileParser;
-
-public class PythonObjectThrowReturn extends Python3ParserTest {
-    @Before
-    public void setUp() {
-    	super.init();
-    }
-
-	
-	@Test
-	public void could_parse_throws() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/throw_return.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t1"));
-	    this.assertContainsRelation(func, DependencyType.THROW, withPackageName(srcs[0],"Bar"));
-	}
-	
-	
-	@Test
-	public void could_parse_return() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/throw_return.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    Python3FileParser parser = createParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t2"));
-	    this.assertContainsRelation(func, DependencyType.RETURN, withPackageName(srcs[0],"Bar"));
-	}
-
-
-}

c24f6b17802322567780d18437f5472833600077
@@ -1,44 +0,0 @@
-package depends.extractor.python3;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.entity.CandidateTypes;
-import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
-import depends.extractor.FileParser;
-
-public class PythonParameterTypeDedudceTest extends Python3ParserTest {
-	@Before
-	public void setUp() {
-		super.init();
-	}
-	
-	@Test
-	public void test_deduce_type_of_return() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/deducetype_parameter.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    String name = withPackageName(srcs[0],"test");
-	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
-	    VarEntity var = function.lookupVarLocally("t1");
-	    TypeEntity type = var.getType();
-	    assertTrue(type instanceof CandidateTypes);
-	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
-	}
-
-
-}
-

c24f6b17802322567780d18437f5472833600077
@@ -1,38 +0,0 @@
-package depends.extractor.python3;
-
-import static org.junit.Assert.assertTrue;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
-import depends.extractor.FileParser;
-
-public class SelfShouldBeThisTypeTest extends Python3ParserTest {
-	@Before
-	public void setUp() {
-		super.init();
-	}
-	
-	@Test
-	public void test_deduce_type_of_return() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/self_should_be_this_type.py",
-	    	    };
-	    
-	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"A.foo")));
-	    VarEntity var = function.lookupVarLocally("self");
-	    TypeEntity type = var.getType();
-	    assertTrue(type.getQualifiedName().equals(withPackageName(srcs[0],"A")));
-	}
-}
-

c24f6b17802322567780d18437f5472833600077
@@ -1,34 +0,0 @@
-package depends.extractor.python3;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
-import depends.entity.FunctionEntity;
-import depends.extractor.FileParser;
-
-public class ShouldGetRelationInSamePackageTest extends Python3ParserTest {
-	@Before
-	public void setUp() {
-		super.init();
-	}
-	
-	@Test
-	public void test_relations_of_sampe_package() throws IOException {
-		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/a.py",
-	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/b.py"
-	    	    };
-	    
-	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
-	    }
-	    inferer.resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"bar")));
-	    this.assertContainsRelation(function, DependencyType.CALL, withPackageName(srcs[0],"foo"));
-	}
-}
-

25621c7d3bae58acff680df84e531342298af290
@@ -7,7 +7,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
-import depends.extractor.python.py3.Python3FileParser;
 import depends.extractor.python.union.PythonFileParser;
 
 public class PythonGlobalVarTest extends PythonParserTest {

25621c7d3bae58acff680df84e531342298af290
@@ -7,7 +7,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
-import depends.extractor.python.py3.Python3FileParser;
 import depends.extractor.python.union.PythonFileParser;
 
 public class PythonObjectCreationTest extends PythonParserTest {

25621c7d3bae58acff680df84e531342298af290
@@ -7,7 +7,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
-import depends.extractor.python.py3.Python3FileParser;
 import depends.extractor.python.union.PythonFileParser;
 
 public class PythonObjectThrowReturn extends PythonParserTest {

25621c7d3bae58acff680df84e531342298af290
@@ -7,8 +7,6 @@ import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
-import depends.extractor.python.py3.Python3FileParser;
-import depends.extractor.python.py3.Python3Processor;
 import depends.extractor.python.union.PythonFileParser;
 import depends.extractor.python.union.PythonProcessor;
 import depends.relations.Inferer;

f7bf745c444f56faa5c735f25e4dfa35e6f454c6
@@ -192,6 +192,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				if (Inferer.externalType.equals(entity)) {
 					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
 						theExpr = theExpr.getParent();
+						if (theExpr.getIdentifier()==null) break;
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
 						entity = inferer.resolveName(this, GenericName.build(composedName), true);
 						if (entity!=null && !Inferer.externalType.equals(entity))

aa5645c0ccabb49690ceefd560a28febf0f39879
@@ -1,9 +1,90 @@
 package depends.extractor.python;
 
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import depends.entity.FileEntity;
+import depends.entity.FunctionCall;
+import depends.entity.FunctionEntity;
+import depends.entity.GenericName;
+import depends.entity.TypeEntity;
 import depends.entity.repo.BuiltInType;
+import depends.relations.FunctionMatcher;
 
 public class PythonBuiltInType extends BuiltInType {
 
+	public static String[] BUILT_IN_FUNCTIONS = { "abs", "delattr", "hash", "memoryview", "set", "all", "dict", "help",
+			"min", "setattr", "any", "dir", "hex", "next", "slice", "exit", "ascii", "divmod", "id", "object", "sorted",
+			"bin", "enumerate", "input", "oct", "staticmethod", "bool", "eval", "int", "open", "str", "breakpoint",
+			"exec", "isinstance", "ord", "sum", "bytearray", "filter", "issubclass", "pow", "super", "bytes", "float",
+			"iter", "print", "tuple", "callable", "format", "len", "property", "type", "chr", "frozenset", "list",
+			"range", "vars", "classmethod", "getattr", "locals", "repr", "zip", "compile", "globals", "map", "reversed",
+			"__import__", "complex", "hasattr", "max", "round" };
+
+	/**
+	 * methods of built-in String
+	 */
+	public static String[] BUILT_IN_STRING_METHODS = { "capitalize", "center", "casefold", "count", "endswith",
+			"expandtabs", "encode", "find", "format", "index", "isalnum", "isalpha", "isdecimal", "isdigit",
+			"isidentifier", "islower", "isnumeric", "isprintable", "isspace", "istitle", "isupper", "join", "ljust",
+			"rjust", "lower", "upper", "swapcase", "lstrip", "rstrip", "strip", "partition", "maketrans", "rpartition",
+			"translate", "replace", "rfind", "rindex", "split", "rsplit", "splitlines", "startswith", "title", "zfill",
+			"format_map" };
+
+	/**
+	 * methods of built-in List
+	 */
+	public static String[] BUILT_IN_LIST_METHODS = { "index", "append", "extend", "insert", "remove", "count", "pop",
+			"reverse", "sort", "copy", "clear" };
+
+	/**
+	 * methods of built-in Tuple
+	 */
+	public static String[] BUILT_IN_TUPLE_METHODS = { "index", "count" };
+
+	/**
+	 * methods of built-in Dict
+	 */
+	public static String[] BUILT_IN_DICT_METHODS = { "clear", "copy", "fromkeys", "get", "items", "keys", "popitem",
+			"setdefault", "pop", "values", "update", };
+
+	/**
+	 * methods of built-in Set
+	 */
+	public static String[] BUILT_IN_SET_METHODS = { "remove", "add", "copy", "clear", "difference", "difference_update",
+			"discard", "intersection", "intersection_update", "isdisjoint", "issubset", "pop", "symmetric_difference",
+			"symmetric_difference_update", "union", "update" };
+
+	/**
+	 * methods of built-in File
+	 */
+	public static String[] BUILT_IN_FILE_METHOD = { "close", "flush", "fileno", "isatty", "next", "read", "readline",
+			"readlines", "seek", "tell", "truncate", "write", "writelines" };
+	
+	List<TypeEntity> buildInTypes = new ArrayList<>();
+	
+
+	
+	public PythonBuiltInType() {
+		addBuildInType(BUILT_IN_FILE_METHOD);
+		addBuildInType(BUILT_IN_SET_METHODS);
+		addBuildInType(BUILT_IN_DICT_METHODS);
+		addBuildInType(BUILT_IN_TUPLE_METHODS);
+		addBuildInType(BUILT_IN_LIST_METHODS);
+		addBuildInType(BUILT_IN_STRING_METHODS);
+	}
+	
+	private void addBuildInType(String[] methods) {
+		TypeEntity type  = new TypeEntity();
+		for (String method:methods) {
+			FunctionEntity func = new FunctionEntity(GenericName.build(method),type,-1,GenericName.build(""));
+			type.addFunction(func);
+		}
+		buildInTypes.add(type);
+	}
+
 	@Override
 	public String[] getBuiltInMethods() {
 		// TODO Auto-generated method stub
@@ -21,5 +102,17 @@ public class PythonBuiltInType extends BuiltInType {
 		// TODO Auto-generated method stub
 		return null;
 	}
+	
+	
+	@Override
+	public  boolean isBuildInTypeMethods(List<FunctionCall> functionCalls) {
+		for (TypeEntity type:buildInTypes) {
+			FunctionMatcher functionMatcher = new FunctionMatcher(type.getFunctions());
+			if (functionMatcher.containsAll(functionCalls)) {
+				return true;
+			}
+		}
+		return false;
+	}
 
 }

aa5645c0ccabb49690ceefd560a28febf0f39879
@@ -6,6 +6,7 @@ import static org.junit.Assert.assertTrue;
 import java.io.IOException;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import depends.entity.CandidateTypes;
@@ -21,7 +22,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	}
 	
 	@Test
-	public void test_deduce_type_of_return() throws IOException {
+	public void test_deduce_type_of_parameter() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/python-code-examples/deducetype_parameter.py",
 	    	    };
@@ -38,6 +39,66 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    assertTrue(type instanceof CandidateTypes);
 	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
 	}
+	
+	
+	@Test
+	public void test_deduce_type_of_builtIn() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/deducetype_builtin.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    String name = withPackageName(srcs[0],"test");
+	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    VarEntity var = function.lookupVarLocally("t1");
+	    TypeEntity type = var.getType();
+	    assertTrue(type instanceof CandidateTypes);
+	    assertEquals(0,((CandidateTypes)type).getCandidateTypes().size());
+	}
+
+	
+	@Test
+	public void test_deduce_type_of_builtIn_cannot_override() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/deducetype_builtin.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    String name = withPackageName(srcs[0],"test2");
+	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    VarEntity var = function.lookupVarLocally("t1");
+	    TypeEntity type = var.getType();
+	    assertTrue(type instanceof CandidateTypes);
+	    assertEquals(1,((CandidateTypes)type).getCandidateTypes().size());
+	}
+	
+	
+	@Ignore
+	public void test_deduce_type_of_non_param_var() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/deducetype_nonparam.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    FileParser parser = createFileParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    String name = withPackageName(srcs[0],"test");
+	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    VarEntity var = function.lookupVarLocally("t2");
+	    TypeEntity type = var.getType();
+	    assertTrue(type instanceof CandidateTypes);
+	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
+	}
 
 
 }

d6a63dd737fca5ed5dc9b981ae1b48572726cf76
@@ -171,6 +171,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 						}
 					}
 				}
+				if (FileUtil.existFile(fullName+File.separator + "__init__.py")) {
+					fullName = fullName+File.separator +"__init__.py";
+				}
 			} else {
 				visitIncludedFile(fullName);
 			}

d6a63dd737fca5ed5dc9b981ae1b48572726cf76
@@ -151,4 +151,21 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	}
+	
+	
+	@Test
+	public void should_import_from_package__init__file() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_from_init/importing.py",
+	    		"./src/test/resources/python-code-examples/import_from_init/pkg/__init__.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
+	
 }

111602a07eff0a56d928a74b606a5742d5a9af18
@@ -127,7 +127,7 @@ public class ExpressionUsage {
 	}
 
 	private boolean isValidIdentifier(GenericName identifier) {
-		Pattern p = Pattern.compile("[a-z_][a-z0-9_]*");
+		Pattern p = Pattern.compile("[a-zA-Z_][a-zA-Z0-9_]*");
 		Matcher m = p.matcher(identifier.getName());
 		return m.find();
 	}

6db3940df1f48a50892d659696d613a7d3763ea0
@@ -82,8 +82,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 			if (dotted_as_name.name()!=null) {
 				aliasName = dotted_as_name.name().getText();
 			}
-			String fullName = foundImportedModuleOrPackage(0,moduleName);
-			if (fullName!=null) {
+			List<String> fullNames = foundImportedModuleOrPackage(0,moduleName);
+			 
+			for (String fullName:fullNames) {
 				context.foundNewImport(new NameAliasImport(fullName, entityRepo.getEntity(fullName), aliasName));
 			}
 		}
@@ -97,16 +98,13 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		int prefixDotCount = getDotCounter(ctx);
 
-		String fullName = foundImportedModuleOrPackage(prefixDotCount, moduleName);
-		if (fullName != null) {
+		 List<String> fullNames = foundImportedModuleOrPackage(prefixDotCount, moduleName);
+		for (String fullName:fullNames) {
 			if (ctx.import_as_names() == null) {// import *
 				ContainerEntity moduleEntity = (ContainerEntity) (entityRepo.getEntity(fullName));
 				if (moduleEntity != null) {
-					for (FunctionEntity func : moduleEntity.getFunctions()) {
-						context.foundNewImport(new NameAliasImport(fullName, func, func.getRawName().uniqName()));
-					}
-					for (VarEntity var : moduleEntity.getVars()) {
-						context.foundNewImport(new NameAliasImport(fullName, var, var.getRawName().uniqName()));
+					for (Entity child:moduleEntity.getChildren()) {
+						context.foundNewImport(new NameAliasImport(fullName, child, child.getRawName().uniqName()));
 					}
 					if (moduleEntity instanceof PackageEntity) {
 						for (Entity file : moduleEntity.getChildren()) {
@@ -114,6 +112,10 @@ public class PythonCodeListener extends PythonParserBaseListener{
 							context.foundNewImport(new NameAliasImport(file.getRawName().uniqName(), file, fileName));
 						}
 					}
+					if (moduleEntity instanceof FileEntity) {
+						String fileName = moduleEntity.getRawName().uniqName().substring(fullName.length());
+						context.foundNewImport(new NameAliasImport(moduleEntity.getRawName().uniqName(), moduleEntity, fileName));
+					}
 				}
 			} else {
 				for (Import_as_nameContext item : ctx.import_as_names().import_as_name()) {
@@ -141,7 +143,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		return total;
 	}
-	private String foundImportedModuleOrPackage(int prefixDotCount, String originalName) {
+	private List<String> foundImportedModuleOrPackage(int prefixDotCount, String originalName) {
 		String dir = FileUtil.getLocatedDir(context.currentFile().getRawName().uniqName());
 		String preFix = "";
 		for (int i = 0; i < prefixDotCount - 1; i++) {
@@ -171,14 +173,17 @@ public class PythonCodeListener extends PythonParserBaseListener{
 						}
 					}
 				}
-				if (FileUtil.existFile(fullName+File.separator + "__init__.py")) {
-					fullName = fullName+File.separator +"__init__.py";
-				}
 			} else {
 				visitIncludedFile(fullName);
 			}
 		}
-		return fullName;
+		ArrayList<String> r = new ArrayList<>();
+		if (fullName==null) return r;
+		r.add(fullName);
+		if (FileUtil.existFile(fullName+File.separator + "__init__.py")) {
+			r.add( fullName+File.separator +"__init__.py");
+		}
+		return r;
 	}
 
 	private void visitIncludedFile(String fullName) {

bd85ee5b8f053acc98d47772a628169e2826dcf2
@@ -41,6 +41,7 @@ import depends.extractor.python.PythonParser.Return_stmtContext;
 import depends.extractor.python.PythonParser.Yield_stmtContext;
 import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.ruby.IncludedFileLocator;
+import depends.importtypes.FileImport;
 import depends.relations.Inferer;
 import depends.util.FileUtil;
 
@@ -85,6 +86,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 			List<String> fullNames = foundImportedModuleOrPackage(0,moduleName);
 			 
 			for (String fullName:fullNames) {
+				if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
+					context.foundNewImport(new FileImport(fullName));
+				}
 				context.foundNewImport(new NameAliasImport(fullName, entityRepo.getEntity(fullName), aliasName));
 			}
 		}
@@ -100,6 +104,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 
 		 List<String> fullNames = foundImportedModuleOrPackage(prefixDotCount, moduleName);
 		for (String fullName:fullNames) {
+
 			if (ctx.import_as_names() == null) {// import *
 				ContainerEntity moduleEntity = (ContainerEntity) (entityRepo.getEntity(fullName));
 				if (moduleEntity != null) {
@@ -123,6 +128,15 @@ public class PythonCodeListener extends PythonParserBaseListener{
 					String alias = name;
 					if (item.name().size() > 1)
 						alias = item.name(1).getText();
+					if (FileUtil.isDirectory(fullName)) {
+						String fileName = fullName + File.separator + name + ".py";
+						if (FileUtil.existFile(fileName) && !(FileUtil.isDirectory(fileName))) {
+							context.foundNewImport(new FileImport(fileName));
+						}
+					}
+					if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
+						context.foundNewImport(new FileImport(fullName));
+					}
 					Entity itemEntity = inferer.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
 					if (itemEntity != null)
 						context.foundNewImport(new NameAliasImport(itemEntity.getQualifiedName(), itemEntity, alias));

bd85ee5b8f053acc98d47772a628169e2826dcf2
@@ -168,4 +168,20 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
+	
+	@Test
+	public void should_not_bypass_import_in_same_dir() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_of_same_dir/pkg/importing.py",
+	    		"./src/test/resources/python-code-examples/import_of_same_dir/pkg/a.py",
+	    	    };
+	   
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
+	
 }

d8ce71ac612c191c9873616f114bde4e6eb65676
@@ -90,7 +90,7 @@ public class VarEntity extends ContainerEntity {
 	}
 
 	public void fillCandidateTypes(Inferer inferer) {
-		if (type!=null) return ; //it is a strong type lang, do not need deduce candidate types
+		if (type!=null && !(type instanceof CandidateTypes)) return ; //it is a strong type lang, do not need deduce candidate types
 		if (functionCalls==null) return;
 		if (functionCalls.size()==0) return; //no information avaliable for type deduction
 		if (this.rawType==null) {

d8ce71ac612c191c9873616f114bde4e6eb65676
@@ -7,6 +7,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
+import depends.entity.FunctionEntity;
 import depends.extractor.python.union.PythonFileParser;
 import depends.util.FileUtil;
 
@@ -184,4 +185,61 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
+	
+	@Test
+	public void should_resolve_symbols_of_imported_in_same_dir() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_of_same_dir/pkg/importing.py",
+	    		"./src/test/resources/python-code-examples/import_of_same_dir/pkg/a.py",
+	    	    };
+	   
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"test"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"foo"));
+	}
+	
+	
+	
+	@Test
+	public void should_resolve_symbols_of_ducktyping() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/duck_typing/forest.py",
+	    		"./src/test/resources/python-code-examples/duck_typing/animals.py",
+	    		"./src/test/resources/python-code-examples/duck_typing/controller.py",
+	    	    };
+	   
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"in_the_forest"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Duck.quack"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Bird.quack"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Doge.quack"));
+	}
+
+	@Test
+	public void should_resolve_symbols_of_ducktyping2() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/duck_typing/animals.py",
+	    		"./src/test/resources/python-code-examples/duck_typing/forest.py",
+	    		"./src/test/resources/python-code-examples/duck_typing/controller.py",
+	    	    };
+	   
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Duck.quack"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Bird.quack"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Doge.quack"));
+	}
+
 }

49853810888a31a9875c3468cbb8349a9acd7b43
@@ -189,16 +189,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
-				if (Inferer.externalType.equals(entity)) {
-					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
-						theExpr = theExpr.getParent();
-						if (theExpr.getIdentifier()==null) break;
-						composedName = composedName + "." + theExpr.getIdentifier().toString();
-						entity = inferer.resolveName(this, GenericName.build(composedName), true);
-						if (entity!=null && !Inferer.externalType.equals(entity))
-							break;
-					}
-				}
+
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;

49853810888a31a9875c3468cbb8349a9acd7b43
@@ -148,9 +148,6 @@ public class Expression implements Serializable{
 		if (this.type.equals(Inferer.buildInType)) {
 			parent.setType(Inferer.buildInType,Inferer.buildInType,inferer);
 			return;
-		}else if (this.type.equals(Inferer.externalType)){
-			parent.setType(Inferer.externalType,Inferer.externalType,inferer);
-			return;
 		}
 		
 		/* if it is a logic expression, the return type/type is boolean. */

49853810888a31a9875c3468cbb8349a9acd7b43
@@ -121,7 +121,7 @@ public class ExpressionUsage {
 
 
 	private void makeSureVarExist(GenericName identifier) {
-		if (Inferer.externalType.equals(context.foundEntityWithName(identifier))) {
+		if (null==context.foundEntityWithName(identifier)) {
 			context.foundVarDefinition(context.lastContainer(), identifier.getName());
 		}
 	}

e662d5c286f501528291567d30409219a749b38c
@@ -189,7 +189,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
-
+				if (entity==null) {
+					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
+						theExpr = theExpr.getParent();
+						if (theExpr.getIdentifier()==null) break;
+						composedName = composedName + "." + theExpr.getIdentifier().toString();
+						entity = inferer.resolveName(this, GenericName.build(composedName), true);
+						if (entity!=null && !Inferer.externalType.equals(entity))
+							break;
+					}
+				}
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;

6617b2a77d05c8b9d48b723b3fe825e5deb56562
@@ -195,7 +195,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 						if (theExpr.getIdentifier()==null) break;
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
 						entity = inferer.resolveName(this, GenericName.build(composedName), true);
-						if (entity!=null && !Inferer.externalType.equals(entity))
+						if (entity!=null)
 							break;
 					}
 				}

e3de22671c616d9a860d4d68414fc9a15b9e0906
@@ -6,6 +6,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 
 public class ContainRelationTest extends CppParserTest{
@@ -55,7 +56,7 @@ public class ContainRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
+	    this.assertContainsRelation(repo.getEntity("UnderTest"), DependencyType.CONTAIN, "Member");
 	}
 	
 	

e3de22671c616d9a860d4d68414fc9a15b9e0906
@@ -18,7 +18,7 @@ public class CppParameterParserTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(5,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

e3de22671c616d9a860d4d68414fc9a15b9e0906
@@ -7,6 +7,9 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+
 public class DuplicateDeclarationTest extends CppParserTest {
 	 @Before
 	    public void setUp() {
@@ -17,7 +20,7 @@ public class DuplicateDeclarationTest extends CppParserTest {
 		public void duplication_declaration_should_be_resolved() throws IOException {
 			
 			 String[] srcs = new String[] {
-			    		"./src/test/resources/cpp-code-examples/DuplicationDeclarationCouldBeResolved.cpp",
+			    		"	",
 			    	    };
 			    
 			    for (String src:srcs) {
@@ -25,7 +28,13 @@ public class DuplicateDeclarationTest extends CppParserTest {
 				    parser.parse();
 			    }
 			    inferer.resolveAllBindings();
-		        assertEquals(8,repo.getEntity("X.invoke").getRelations().size());
+			    Entity e = repo.getEntity("X.invoke");
+			    this.assertContainsRelation(e, DependencyType.CONTAIN,"DupClass");
+			    this.assertContainsRelation(e, DependencyType.CALL,"DupClass");
+			    this.assertContainsRelation(e, DependencyType.CREATE,"DupClass");
+			    this.assertContainsRelation(e, DependencyType.USE,"DupClass");
+			    this.assertContainsRelation(e, DependencyType.USE,"X.invoke.c");
+			    			    
 		}
 
 

e3de22671c616d9a860d4d68414fc9a15b9e0906
@@ -6,6 +6,10 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.relations.Inferer;
+
 public class MacroRelationTest extends CppParserTest{
     @Before
     public void setUp() {
@@ -24,7 +28,10 @@ public class MacroRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(4,repo.getEntity("foo").getRelations().size());
+	    Entity e = repo.getEntity("foo");
+	    this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
+	    this.assertContainsRelation(e, DependencyType.CONTAIN, Inferer.buildInType.getQualifiedName());
+	    this.assertContainsRelation(e, DependencyType.USE, Inferer.buildInType.getQualifiedName());
 	}
 	
 	

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -167,11 +167,6 @@ public class CandidateTypes extends TypeEntity {
 		super.resolveExpressions(inferer);
 	}
 
-	@Override
-	public TypeEntity getLastExpressionType() {
-		System.err.println("error: getLastExpressionType should not been invoked");
-		return super.getLastExpressionType();
-	}
 
 	@Override
 	public void addMixin(GenericName moduleName) {

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -116,6 +116,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public void addExpression(Object key, Expression expression) {
 		expressions().put(key, expression);
 		expressionList().add(expression);
+		expressionCount = expressionList.size();
 	}
 
 	public boolean containsExpression(Object key) {
@@ -133,10 +134,12 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		for (FunctionEntity func : this.getFunctions()) {
 			func.inferLocalLevelEntities(inferer);
 		}
-		resolvedMixins = identiferToContainerEntity(inferer, getMixins());
 		if (inferer.isEagerExpressionResolve()) {
-			this.resolveExpressions(inferer);
+			reloadExpression(inferer.getRepo());
+			resolveExpressions(inferer);
+			cacheExpressions();
 		}
+		resolvedMixins = identiferToContainerEntity(inferer, getMixins());
 	}
 
 	private Collection<GenericName> getMixins() {
@@ -165,13 +168,18 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
+		
+		if (this instanceof FunctionEntity) {
+			((FunctionEntity)this).linkReturnToLastExpression();
+		}
+		
 		if (expressionList==null) return;
 		if(expressionList.size()>10000) return;
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
 			if (expression.getType() != null)
 				continue;
-			if (expression.isDot) { // wait for previous
+			if (expression.isDot()) { // wait for previous
 				continue;
 			}
 			if (expression.getRawType() == null && expression.getIdentifier() == null)
@@ -190,7 +198,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
 				if (entity==null) {
-					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
+					while(theExpr.getParent()!=null && theExpr.getParent().isDot()) {
 						theExpr = theExpr.getParent();
 						if (theExpr.getIdentifier()==null) break;
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
@@ -251,7 +259,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	private void cacheExpressionListToFile() {
-		expressionCount = this.expressionList.size();
 		if (expressionCount ==0) return;
 		try {
 			FileOutputStream fileOut = new FileOutputStream(TemporaryFile.getInstance().exprPath(this.id));
@@ -284,15 +291,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	      }
 	}
 	
-	public TypeEntity getLastExpressionType() {
-		if (expressionList==null) return null;
-		for (int i = this.expressionList.size() - 1; i >= 0; i--) {
-			Expression expr = this.expressionList.get(i);
-			if (expr.isStatement)
-				return expr.getType();
-		}
-		return null;
-	}
 
 	public List<Expression> expressionList() {
 		if (expressionList==null) 
@@ -303,17 +301,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public boolean containsExpression() {
 		return expressions().size() > 0;
 	}
-
-	public String dumpExpressions() {
-		if (expressionList==null) return "";
-		StringBuilder sb = new StringBuilder();
-		for (Expression exp : expressionList) {
-			sb.append(exp.toString()).append("\n");
-		}
-		return sb.toString();
-	}
-
-
 	
 	/**
 	 * The entry point of lookup functions. It will treat multi-declare entities and

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -110,6 +110,7 @@ public abstract class Entity {
     public void addRelation(Relation relation) {
     	if (relations==null)
     		relations = new ArrayList<>();
+    	if (relation.getEntity()==null) return;
         relations.add(relation);
     }
 

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -28,59 +28,104 @@ import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
-
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
 
+/**
+ * Expression 
+ */
 public class Expression implements Serializable{
 	private static final long serialVersionUID = 1L;
-	public Integer id;
-	public String text; // for debug purpose
-	private GenericName rawType; //the raw type name
-	private GenericName identifier; // the varName, or method name, etc.
-	public boolean isSet = false; // is a set relation from right to leftHand
-	public boolean isDot = false; // is a dot expression, will decuce variable tfype left to right
-	public boolean isCall() {
-		return isCall;
-	}
-
-	public void setCall(boolean isCall) {
-		this.isCall = isCall;
-	}
 
+	public Integer id;
+	private String text;                // for debug purpose
+	private GenericName rawType;        // the raw type name
+	private GenericName identifier;     // the varName, or method name, etc.
+	private boolean isSet = false;       // is a set relation from right to leftHand
+	private boolean isDot = false;       // is a dot expression, will decuce variable tfype left to right
 	private boolean isCall = false;
-	public boolean isLogic = false;
-	public boolean isCreate = false;
-	public boolean isCast = false;
-	public boolean isThrow = false;
-	public boolean isStatement = false; //statement is only used for return type calcuation in some langs such as ruby
-	                                    //they will not be treat as real expressions in case of relation calculation
-	public boolean deriveTypeFromChild = true;
-	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
-	
+	private boolean isLogic = false;
+	private boolean isCreate = false;
+	private boolean isCast = false;
+	private boolean isThrow = false;
+	private boolean isStatement = false; //statement is only used for return type calcuation in some langs such as ruby
+    									//they will not be treat as real expressions in case of relation calculation
+	private boolean deriveTypeFromChild = true;
+	private Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
+
 	private Integer parentId = -1; 
+	private transient Expression parent;
+	
+	private transient List<VarEntity> deducedTypeVars = new ArrayList<>();
 	private List<Integer> deducedTypeVarsId = new ArrayList<>();
+
+	private transient List<FunctionEntity> deducedTypeFunctions= new ArrayList<>();
 	private List<Integer> deducedTypeFunctionsId = new ArrayList<>();
 	
-	private transient Expression parent;
-	private transient TypeEntity type; // the type we care - for relation calculation. 
-	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
+	private Integer referredEntityId;
 	private transient Entity referredEntity;
 	
-	private transient List<VarEntity> deducedTypeVars = new ArrayList<>();
-	private transient List<FunctionEntity> deducedTypeFunctions= new ArrayList<>();
-	public TypeEntity getType() {
-		return type;
+	private transient TypeEntity type; // the type we care - for relation calculation. 
+    //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
+	
+	/*
+	 * */
+	
+	public Expression() {
+		deducedTypeVars = new ArrayList<>();
+		deducedTypeFunctions = new ArrayList<>();
+	}
+	
+	public Expression(Integer id) {
+		this.id = id;
+		deducedTypeVars = new ArrayList<>();
+		deducedTypeFunctions = new ArrayList<>();
 	}
 
-	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
-		if (this.referredEntity==null && referredEntity!=null) {
-			this.referredEntity  = referredEntity;
+	public void reload(EntityRepo repo, ArrayList<Expression> expressionList) {
+		this.deducedTypeFunctions = new ArrayList<>();
+		this.deducedTypeVars = new ArrayList<>();
+		
+		//recover parent relation
+		if (parentId!=-1) {
+			for (Expression expr:expressionList) {
+				if (expr.id==parentId) {
+					parent = expr;
+					break;
+				}
+			}
+		}
+		
+		//recover deducedTypeFunctionsId
+		if (deducedTypeFunctionsId!=null) {
+			for (Integer funcId:this.deducedTypeFunctionsId) {
+				this.deducedTypeFunctions.add((FunctionEntity) repo.getEntity(funcId));
+			}
 		}
 		
-		if (type instanceof CandidateTypes) {
-			return ;
+		//recover deducedTypeVars
+		if (deducedTypeVarsId!=null) {
+			for (Integer varId:this.deducedTypeVarsId) {
+				this.deducedTypeVars.add((VarEntity) repo.getEntity(varId));
+			}
 		}
+		
+		//referer referredEntity -- TODO:maybe not require
+		if (this.referredEntityId!=null && this.referredEntity==null)
+			this.referredEntity = repo.getEntity(this.referredEntityId);
+	}
+	
+	/**
+	 * Set type of the expression
+	 * @param type
+	 * @param referredEntity
+	 * @param inferer
+	 */
+	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
+		if (this.getReferredEntity()==null && referredEntity!=null) {
+			this.setReferredEntity(referredEntity);
+		}
+
 		boolean changedType = false;
 		if (this.type==null && type!=null) {
 			this.type = type;
@@ -97,38 +142,12 @@ public class Expression implements Serializable{
 			changedType = true;
 		}
 		if (this.referredEntity==null)
-			this.referredEntity = this.type;
+			this.setReferredEntity(this.type);
 
 		if (changedType)
 			deduceTheParentType(inferer);
 	}
 	
-	public Expression() {
-		deducedTypeVars = new ArrayList<>();
-		deducedTypeFunctions = new ArrayList<>();
-	}
-	public Expression(Integer id) {
-		this.id = id;
-		deducedTypeVars = new ArrayList<>();
-		deducedTypeFunctions = new ArrayList<>();
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder s = new StringBuilder();
-		s.append("[").append(text).append("]").append("|")
-			.append("rawType:").append(rawType).append("|")
-			.append("identifier:").append(identifier).append("|")
-		    .append("prop:").append(isDot?"[dot]":"")
-		                      .append(isSet?"[set]":"")
-		                      .append(isLogic?"[bool]":"")
-		                      .append(isCall?"[call]":"").append("|")
-		                      .append(isCreate?"[new]":"").append("|")
-		                      .append(isThrow?"[throw]":"").append("|")
-		    .append("parent:").append(parent==null?"nil":parent.text).append("|")
-			.append("type:").append(type).append("|");
-		return s.toString();
-	}
 
 	/**
 	 * deduce type of parent based on child's type
@@ -183,19 +202,16 @@ public class Expression implements Serializable{
 		else {
 			parent.setType(type, null, inferer);
 		}
-		if (parent.referredEntity==null)
-			parent.referredEntity = parent.type;
+		if (parent.getReferredEntity()==null)
+			parent.setReferredEntity(parent.type);
 	}
 
 	private void setReferredEntity(Entity referredEntity) {
 		this.referredEntity = referredEntity;
+		if (this.referredEntity!=null)
+			this.referredEntityId = referredEntity.getId();
 	}
 
-	public Entity getReferredEntity() {
-		return referredEntity;
-	}
-
-
 	public void addDeducedTypeVar(VarEntity var) {
 		this.deducedTypeVars.add(var);
 		this.deducedTypeVarsId.add(var.getId());
@@ -219,30 +235,6 @@ public class Expression implements Serializable{
 		}
 	}
 
-	public void reload(EntityRepo repo, ArrayList<Expression> expressionList) {
-		this.deducedTypeFunctions = new ArrayList<>();
-		this.deducedTypeVars = new ArrayList<>();
-		if (parentId!=-1) {
-			for (Expression expr:expressionList) {
-				if (expr.id==parentId) {
-					parent = expr;
-					break;
-				}
-			}
-		}
-		
-		if (deducedTypeFunctionsId!=null) {
-			for (Integer funcId:this.deducedTypeFunctionsId) {
-				this.deducedTypeFunctions.add((FunctionEntity) repo.getEntity(funcId));
-			}
-		}
-		
-		if (deducedTypeVarsId!=null) {
-			for (Integer varId:this.deducedTypeVarsId) {
-				this.deducedTypeVars.add((VarEntity) repo.getEntity(varId));
-			}
-		}
-	}
 
 	public GenericName getIdentifier() {
 		return this.identifier;
@@ -259,17 +251,6 @@ public class Expression implements Serializable{
 		this.identifier = GenericName.build(name);
 	}
 
-	private boolean validName(String name) {
-		if (name==null) return false;
-		if (name.toLowerCase().equals("<literal>")) return true;
-		if (name.toLowerCase().equals("<built-in>")) return true;
-		boolean result = name.matches("([a-zA-Z0-9_]|(\\.)|(\\-))*");
-//		if (result==false) {
-//			System.err.println("expression name " + name);
-//		}
-		return true;
-	}
-
 	public void setIdentifier(GenericName name) {
 		if (name==null) return;
 		if (!validName(name.getName())){
@@ -298,6 +279,110 @@ public class Expression implements Serializable{
 	public Expression getParent() {
 		return this.parent;
 	}
+
+	public void setText(String text) {
+		this.text = text;
+	}
 	
+
+	public boolean isCall() {
+		return isCall;
+	}
+
+	public boolean isSet() {
+		return isSet;
+	}
+
+	public void setSet(boolean isSet) {
+		this.isSet = isSet;
+	}
+
+	public boolean isDot() {
+		return isDot;
+	}
+
+	public void setDot(boolean isDot) {
+		this.isDot = isDot;
+	}
+
+	public boolean isLogic() {
+		return isLogic;
+	}
+
+	public void setLogic(boolean isLogic) {
+		this.isLogic = isLogic;
+	}
+
+	public boolean isCreate() {
+		return isCreate;
+	}
+
+	public void setCreate(boolean isCreate) {
+		this.isCreate = isCreate;
+	}
+
+	public boolean isCast() {
+		return isCast;
+	}
+
+	public void setCast(boolean isCast) {
+		this.isCast = isCast;
+	}
+
+	public boolean isThrow() {
+		return isThrow;
+	}
+
+	public void setThrow(boolean isThrow) {
+		this.isThrow = isThrow;
+	}
+
+	public boolean isStatement() {
+		return isStatement;
+	}
+
+	public void setStatement(boolean isStatement) {
+		this.isStatement = isStatement;
+	}
+
+	public void setCall(boolean isCall) {
+		this.isCall = isCall;
+	}
+
+	public void disableDriveTypeFromChild() {
+		deriveTypeFromChild = false	;	
+	}
 	
+	public Entity getReferredEntity() {
+		return referredEntity;
+	}
+
+	public TypeEntity getType() {
+		return type;
+	}
+
+
+	private boolean validName(String name) {
+		if (name==null) return false;
+		if (name.toLowerCase().equals("<literal>")) return true;
+		if (name.toLowerCase().equals("<built-in>")) return true;
+		return true;
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder s = new StringBuilder();
+		s.append("[").append(text).append("]").append("|")
+			.append("rawType:").append(rawType).append("|")
+			.append("identifier:").append(identifier).append("|")
+		    .append("prop:").append(isDot?"[dot]":"")
+		                      .append(isSet?"[set]":"")
+		                      .append(isLogic?"[bool]":"")
+		                      .append(isCall?"[call]":"")
+		                      .append(isCreate?"[new]":"")
+		                      .append(isThrow?"[throw]":"").append("|")
+		    .append("parent:").append(parent==null?"nil":parent.text).append("|")
+			.append("type:").append(type).append("|");
+		return s.toString();
+	}
 }
\ No newline at end of file

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -94,9 +94,6 @@ public class FunctionEntity extends ContainerEntity{
 		if (throwTypes.size()<throwTypesIdentifiers.size())
 			throwTypes = identiferToEntities(inferer,this.throwTypesIdentifiers);
 		super.inferLocalLevelEntities(inferer);
-		if (this.returnTypes.size()==0 && this.getLastExpressionType()!=null) {
-			this.returnTypes.add(this.getLastExpressionType());
-		}
 	}
 	
 
@@ -140,6 +137,13 @@ public class FunctionEntity extends ContainerEntity{
 		}
 		return super.lookupVarLocally(varName);
 	}
-
-
+	
+	public void linkReturnToLastExpression() {
+		if (expressionList()==null) return;
+		for (int i = expressionList().size() - 1; i >= 0; i--) {
+			Expression expr = expressionList().get(i);
+			if (expr.isStatement())
+				expr.addDeducedTypeFunction(this);
+		}
+	}
 }

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -62,11 +62,12 @@ public abstract class HandlerContext {
 		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
 		pushToStack(currentFileEntity);
 		entityRepo.add(currentFileEntity);
-		entityRepo.addFile(currentFileEntity);
 		return currentFileEntity;
 	}
 
-	
+	public void done() {
+		entityRepo.addFile(this.currentFile());
+	}
 
 	public TypeEntity foundNewType(GenericName name) {
 		TypeEntity currentTypeEntity = new TypeEntity(name, this.latestValidContainer(),

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -60,13 +60,13 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		//If parent already a call 
 		if (parent!=null ) {
-			if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast)) {
+			if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast())) {
 				return;
 			}
 		}
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());
-		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
+		expression.setText( ctx.getRawSignature());
 		context.lastContainer().addExpression(ctx,expression);
 		expression.setParent(parent);
 	
@@ -76,13 +76,13 @@ public class ExpressionUsage {
 			return;
 		}
 		
-		expression.isSet = isSet(ctx);
+		expression.setSet(isSet(ctx));
 		expression.setCall((ctx instanceof IASTFunctionCallExpression)?true:false);
-		expression.isLogic = isLogic(ctx);
+		expression.setLogic(isLogic(ctx));
 		if (ctx instanceof ICPPASTNewExpression){
-			expression.isCreate = true;
+			expression.setCreate(true);;
 		}		
-		expression.isDot = isDot(ctx);
+		expression.setDot(isDot(ctx));
 
 		/**
  *    | expression bop='.'
@@ -99,16 +99,16 @@ public class ExpressionUsage {
 		if (ctx instanceof ICPPASTNewExpression) {
 			expression.setRawType(GenericName.build(ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId())));
 			expression.setCall(true);
-			expression.deriveTypeFromChild = false;
+			expression.disableDriveTypeFromChild();
 		}
 
 		if (ctx instanceof IASTCastExpression) {
-			expression.isCast=true;
+			expression.setCast(true);
 			expression.setRawType(GenericName.build(ASTStringUtilExt.getTypeIdString(((IASTCastExpression)ctx).getTypeId())));
-			expression.deriveTypeFromChild = false;
+			expression.disableDriveTypeFromChild();
 
 		}
-		if (expression.isDot) {
+		if (expression.isDot()) {
 			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
 			if (op2 instanceof IASTIdExpression)
 				expression.setIdentifier(ASTStringUtilExt.getName(((IASTIdExpression)op2).getName()));

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -361,6 +361,9 @@ public class JavaListener extends JavaParserBaseListener {
 			context.currentType().addTypeParameter(GenericName.build(typeParam.IDENTIFIER().getText()));
 		}
 	}
-	
+
+	public void done() {
+		context.done();
+	}
 
 }

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -56,12 +56,12 @@ public class ExpressionUsage {
 			return;
 		}
 		
-		expression.isSet = isSet(ctx);
+		expression.setSet (isSet(ctx));
 		expression.setCall(ctx.methodCall()==null?false:true);
-		expression.isLogic = isLogic(ctx);
-		expression.isDot = isDot(ctx);
+		expression.setLogic (isLogic(ctx));
+		expression.setDot(isDot(ctx));
 		if (ctx.creator()!=null ||ctx.innerCreator()!=null){
-			expression.isCreate = true;
+			expression.setCreate( true);
 		}		
 /**
  *    | expression bop='.'
@@ -82,26 +82,26 @@ public class ExpressionUsage {
 		if (ctx.NEW()!=null && ctx.creator()!=null) {
 			expression.setRawType(CreatorContextHelper.getCreatorType(ctx.creator()));
 			expression.setCall(true);
-			expression.deriveTypeFromChild = false;
+			expression.disableDriveTypeFromChild();
 		}
 		
 		if (ctx.typeCast()!=null) {
-			expression.isCast=true;
+			expression.setCast(true);
 			expression.setRawType(ctx.typeCast().typeType().getText());
-			expression.deriveTypeFromChild = false;
+			expression.disableDriveTypeFromChild();
 		}
 		
 		if (ctx.bop!=null && ctx.bop.getText().equals("instanceof")) {
-			expression.isCast=true;
+			expression.setCast(true);
 			expression.setRawType(ctx.typeType().getText());
-			expression.deriveTypeFromChild = false;
+			expression.disableDriveTypeFromChild();
 		}
 		
 		if (ctx.creator()!=null) {
-			expression.deriveTypeFromChild = false;
+			expression.disableDriveTypeFromChild();
 		}
 		
-		if (expression.isDot) {
+		if (expression.isDot()) {
 			if (ctx.IDENTIFIER()!=null)
 				expression.setIdentifier(ctx.IDENTIFIER().getText());
 			else if (ctx.methodCall()!=null)

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -82,7 +82,7 @@ public class ExpressionUsage {
 		}else {
 			/* create expression and link it with parent*/
 			expression = new Expression(idGenerator.generateId());
-			expression.text = ctx.getText();
+			expression.setText(ctx.getText());
 			context.lastContainer().addExpression(ctx,expression);
 			expression.setParent(parent);
 		}
@@ -91,7 +91,7 @@ public class ExpressionUsage {
 		if (ctx instanceof Expr_stmtContext) {
 			Expr_stmtContext exprAssign = (Expr_stmtContext)ctx;
 			if (exprAssign.assign_part()!=null) {
-				expression.isSet = true;
+				expression.setSet(true);
 				expression.setIdentifier(exprAssign.testlist_star_expr().getText());
 				if (isValidIdentifier(expression.getIdentifier())) {
 					makeSureVarExist(expression.getIdentifier());
@@ -100,8 +100,7 @@ public class ExpressionUsage {
 			}
 		}
 		if (ctx instanceof Raise_stmtContext) {
-			expression.isThrow = true;
-			expression.deriveTypeFromChild = true;
+			expression.setThrow (true);
 		}
 		if (ctx instanceof Return_stmtContext) {
 			deduceReturnTypeInCaseOfReturn((Return_stmtContext)ctx,expression);
@@ -141,7 +140,7 @@ public class ExpressionUsage {
 			//atom
 			Expression atomExpr = new Expression(idGenerator.generateId());
 			atomExpr.setParent(expression);
-			atomExpr.text = exprCtx.atom().getText();
+			atomExpr.setText(exprCtx.atom().getText());
 			atomExpr.setIdentifier(exprCtx.atom().getText());
 			context.lastContainer().addExpression(exprCtx.atom(),atomExpr);
 			processAtom(exprCtx.atom(),atomExpr);
@@ -152,12 +151,12 @@ public class ExpressionUsage {
 				for (TrailerContext trailer:exprCtx.trailer()) {
 					if (trailer.name()!=null) {
 						Expression trailerExpr = new Expression(idGenerator.generateId());
-						trailerExpr.text = trailer.getText();
+						trailerExpr.setText(trailer.getText());
 						context.lastContainer().addExpression(trailer,trailerExpr);
 						trailerExpr.setParent(expression);
 
 						//doted name = member access or method call
-						trailerExpr.isDot = true;
+						trailerExpr.setDot(true);;
 						trailerExpr.setIdentifier(trailer.name().getText());
 						if (trailer.arguments()!=null) {
 							if (trailer.arguments().OPEN_PAREN()!=null) {
@@ -218,7 +217,7 @@ public class ExpressionUsage {
 		}
 		Entity typeEntity = context.foundEntityWithName(funcName);
 		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
-			theExpression.isCreate = true;
+			theExpression.setCreate(true);
 			theExpression.setType(typeEntity.getType(), typeEntity, inferer);
 			theExpression.setRawType(typeEntity.getRawName());
 			return;
@@ -232,7 +231,7 @@ public class ExpressionUsage {
 		GenericName funcName = theExpression.getIdentifier();
 		Entity typeEntity = context.foundEntityWithName(funcName);
 		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
-			theExpression.getParent().isCreate = true;
+			theExpression.getParent().setCreate(true);
 			theExpression.setType(typeEntity.getType(), typeEntity, inferer);
 			theExpression.getParent().setRawType(typeEntity.getRawName());
 			return;

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -384,5 +384,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		expressionUsage.stopExpr();
 		super.exitAssert_stmt(ctx);
 	}
-
+	public void done() {
+		context.done();
+	}
 }

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -50,10 +50,9 @@ public class PythonFileParser implements FileParser {
         PythonCodeListener bridge = new PythonCodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();
 	    walker.walk(bridge, parser.file_input());
-	    
 		fileEntity = entityRepo.getEntity(fileFullPath);
-		fileEntity.inferEntities(inferer);
 		((FileEntity)fileEntity).cacheAllExpressions();
+		bridge.done();
 	}
 
 }

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -81,10 +81,10 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent */
 		expression = new Expression(idGenerator.generateId());
-		expression.text = ctx.toString();
+		expression.setText(ctx.toString());
 		expression.setParent(parent);
 		if (ctx instanceof NewlineNode) {
-			expression.isStatement = true;
+			expression.setStatement(true);
 		}
 
 		context.lastContainer().addExpression(ctx, expression);
@@ -105,12 +105,12 @@ public class ExpressionUsage {
 			expression.setIdentifier(helper.getName(ctx));
 		}
 		if (ctx instanceof AssignableNode) {
-			expression.isSet = true;
+			expression.setSet(true);
 		} else if (helper.isFunctionCall(ctx)) {
 			String name = helper.getName(ctx);
 			expression.setCall(true);
 			if (name.equals("new")) {
-				expression.isCreate = true;
+				expression.setCreate(true);
 				List<Node> childNodes = ctx.childNodes();
 				if (childNodes.size() > 0) {
 					expression.setIdentifier(helper.getName(ctx.childNodes().get(0)));
@@ -118,10 +118,9 @@ public class ExpressionUsage {
 					expression.setIdentifier(context.currentType().getRawName());
 				}
 				expression.setRawType(expression.getIdentifier());
-				expression.deriveTypeFromChild = false;
+				expression.disableDriveTypeFromChild();
 			} else if (name.equals("raise")) {
-				expression.isThrow = true;
-				expression.deriveTypeFromChild = true;
+				expression.setThrow (true);
 			} else if (helper.isArithMeticOperator(name)) {
 				expression.setIdentifier("<operator>");
 				expression.setRawType(Inferer.buildInType.getQualifiedName());
@@ -129,11 +128,11 @@ public class ExpressionUsage {
 				expression.setIdentifier(name);
 				expression.setRawType(helper.getReciever(ctx));
 				if (expression.getRawType() != null) {
-					expression.isDot = true;
+					expression.setDot(true);
 				}
 
 				if (ctx instanceof VCallNode || ctx instanceof FCallNode) {
-					expression.deriveTypeFromChild = false;
+					expression.disableDriveTypeFromChild();
 				}
 			}
 		}

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -31,6 +31,7 @@ import java.util.concurrent.ExecutorService;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;
 import org.jrubyparser.CompatVersion;
+import org.jrubyparser.NodeVisitor;
 import org.jrubyparser.Parser;
 import org.jrubyparser.ast.Node;
 import org.jrubyparser.parser.ParserConfiguration;
@@ -79,10 +80,11 @@ public class JRubyFileParser implements FileParser {
 		ParserConfiguration config = new ParserConfiguration(0, version);
 		try {
 			Node node = rubyParser.parse("<code>", in, config);
-			node.accept(new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator));
+			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator);
+			node.accept(parser);
 			fileEntity = entityRepo.getEntity(fileFullPath);
-			fileEntity.inferEntities(inferer);
 			((FileEntity)fileEntity).cacheAllExpressions();
+			parser.done();
 		}catch(Exception e) {
 			System.err.println("parsing error in "+fileFullPath);
 		}

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -307,4 +307,8 @@ public class JRubyVisitor extends NoopVisitor {
 		expressionUsage.foundExpression(node);
 		return super.visit(node);
 	}
+
+	public void done() {
+		context.done();
+	}
 }

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -86,8 +86,6 @@ public class RelationCounter {
 	
 
 	private void computeContainerRelations(ContainerEntity entity) {
-		entity.reloadExpression(repo);
-		entity.resolveExpressions(inferer);
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
 				entity.addRelation(buildRelation(DependencyType.CONTAIN,var.getType()));
@@ -105,15 +103,18 @@ public class RelationCounter {
 			entity.addRelation(buildRelation(DependencyType.MIXIN,mixin));
 		}
 		
+		entity.reloadExpression(repo);
+		if (!inferer.isEagerExpressionResolve())
+		{
+			entity.resolveExpressions(inferer);
+		}
 		for (Expression expression:entity.expressionList()){
-			if (expression.isStatement) {
+			if (expression.isStatement()) {
 				continue;
 			}
 			Entity referredEntity = expression.getReferredEntity();
 			addRelationFromExpression(entity, expression, referredEntity);
 		}
-		
-
 		entity.clearExpressions();
 	}
 
@@ -148,15 +149,15 @@ public class RelationCounter {
 			matched = true;
 
 		}
-		if (expression.isCreate) {
+		if (expression.isCreate()) {
 			entity.addRelation(buildRelation(DependencyType.CREATE,referredEntity));
 			matched = true;
 		}
-		if (expression.isThrow) {
+		if (expression.isThrow()) {
 			entity.addRelation(buildRelation(DependencyType.THROW,referredEntity));
 			matched = true;
 		}
-		if (expression.isCast) { 
+		if (expression.isCast()) { 
 			entity.addRelation(buildRelation(DependencyType.CAST,referredEntity));
 			matched = true;
 		}

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -27,6 +27,7 @@ public abstract class ParserTest {
 		for (Relation r:inEntity.getRelations()) {
 			if (r.getType().equals(dependencyType)) {
 				relation = r;
+				if (r.getEntity()==null) continue;
 				if (r.getEntity().getQualifiedName().equals(dependedEntityFullName))
 					return;
 			}

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -20,7 +20,7 @@ public class DuplicateDeclarationTest extends CppParserTest {
 		public void duplication_declaration_should_be_resolved() throws IOException {
 			
 			 String[] srcs = new String[] {
-			    		"	",
+			    		"./src/test/resources/cpp-code-examples/DuplicationDeclarationCouldBeResolved.cpp",
 			    	    };
 			    
 			    for (String src:srcs) {

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -6,7 +6,9 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.entity.Entity;
+import depends.relations.Inferer;
 
 public class UsingTest extends CppParserTest{
     @Before
@@ -26,7 +28,10 @@ public class UsingTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         Entity e = repo.getEntity("foo");
-        assertEquals(4,e.getRelations().size());
+        this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
+        this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");
+        this.assertContainsRelation(e, DependencyType.CONTAIN, "B.X");
+        
 	}
 	
 	@Test
@@ -41,6 +46,8 @@ public class UsingTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         Entity e = repo.getEntity("bar");
-        assertEquals(4,e.getRelations().size());
+        this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
+        this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");
+        this.assertContainsRelation(e, DependencyType.CONTAIN, "B.X");
 	}
 }

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -86,7 +86,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(16,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
+        assertEquals(13,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
 	@Test

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -218,9 +218,9 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"in_the_forest"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Duck.quack"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Bird.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Doge.quack"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Bird.quack"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Duck.quack"));
 	}
 
 	@Test

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -30,9 +30,6 @@ public class RubyReturnTypeDedudceTest extends RubyParserTest {
 
 	    function = (FunctionEntity)(entityRepo.getEntity("Class.implicitReturn"));
 	    this.assertContainReturnType(function,"Class1");
-
 	}
-
-
 }
 

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -78,6 +78,8 @@ public class DependsCommand {
     private String[] typeFilter=new String[]{};
 	@Option(names = {"--external-deps"}, description = "Output external dependencies")
 	private boolean outputExternalDependencies = false;	
+	@Option(names = {"--duck-typing-deduce"}, description = "Deduce implicit variable types")
+	private boolean duckTypingDeduce = true;	
 	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
@@ -152,4 +154,8 @@ public class DependsCommand {
 	public boolean isOutputExternalDependencies() {
 		return outputExternalDependencies;
 	}
+	
+	public boolean isDuckTypingDeduce() {
+		return this.duckTypingDeduce;
+	}
 }

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -43,6 +43,7 @@ public class AliasEntity extends Entity {
 	}
 
 	public void inferLocalLevelEntities(Inferer inferer) {
+		if (!(referToEntity instanceof EmptyTypeEntity)) return;
 		Entity entity = inferer.resolveName(this, originName, true);
 		while(entity instanceof AliasEntity) {
 			AliasEntity aliasEntity = (AliasEntity)entity;
@@ -97,14 +98,14 @@ public class AliasEntity extends Entity {
 		return origin.lookupFunctionLocally(functionName);
 	}
 
-	public FunctionEntity lookupFunctionInVisibleScope(GenericName functionName) {
+	public List<Entity> lookupFunctionInVisibleScope(GenericName functionName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
 		return origin.lookupFunctionInVisibleScope(functionName);
 	}
 
-	public VarEntity lookupVarsInVisibleScope(GenericName varName) {
+	public Entity lookupVarsInVisibleScope(GenericName varName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
@@ -164,6 +165,12 @@ public class AliasEntity extends Entity {
 	public Entity getOriginType() {
 		return referToEntity;
 	}
+	public Entity getReferToEntity() {
+		return referToEntity;
+	}
+	public void setReferToEntity(Entity referToEntity) {
+		this.referToEntity = referToEntity;
+	}
 	
 
 }

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -39,8 +39,8 @@ public class CandidateTypes extends TypeEntity {
 	public CandidateTypes() {
 		candidateTypes = new ArrayList<>();
 	}
-	public CandidateTypes(List<TypeEntity> candidateTypes) {
-		super(GenericName.build("candidateTypes"), null, -1);
+	public CandidateTypes(List<TypeEntity> candidateTypes, Integer id) {
+		super(GenericName.build("candidateTypes"), null, id);
 		this.candidateTypes = candidateTypes;
 	}
 
@@ -80,18 +80,23 @@ public class CandidateTypes extends TypeEntity {
 		return inheritedType;
 	}
  	@Override
- 	public FunctionEntity lookupFunctionInVisibleScope(GenericName functionName) {
+ 	public List<Entity> lookupFunctionInVisibleScope(GenericName functionName) {
+ 		List<Entity> functions = new ArrayList<>();
  		for (TypeEntity type:candidateTypes) {
-			FunctionEntity f = type.lookupFunctionInVisibleScope(functionName);
-			if (f!=null) return f;
+ 			List<Entity> f = type.lookupFunctionInVisibleScope(functionName);
+			if (f!=null) {
+				functions.addAll(f);
+			}
 		}
- 		return null;
+ 		if (functions.size()==0)
+ 			return null;
+ 		return functions;
 	}
  	
 	@Override
-	public VarEntity lookupVarInVisibleScope(GenericName varName) {
+	public Entity lookupVarInVisibleScope(GenericName varName) {
 		for (TypeEntity type:candidateTypes) {
-			VarEntity v = type.lookupVarInVisibleScope(varName);
+			Entity v = type.lookupVarInVisibleScope(varName);
 			if (v!=null) return v;
 		}
  		return null;	
@@ -213,13 +218,11 @@ public class CandidateTypes extends TypeEntity {
 
 	@Override
 	public GenericName getRawName() {
-		System.err.println("error: getRawName should not been invoked");
 		return super.getRawName();
 	}
 
 	@Override
 	public Integer getId() {
-		System.err.println("error: getId should not been invoked");
 		return super.getId();
 	}
 
@@ -243,8 +246,7 @@ public class CandidateTypes extends TypeEntity {
 
 	@Override
 	public Entity getParent() {
-		System.err.println("error: getParent should not been invoked");
-		return super.getParent();
+		return null;
 	}
 
 	@Override
@@ -283,8 +285,7 @@ public class CandidateTypes extends TypeEntity {
 	
 	@Override
 	public Entity getAncestorOfType(@SuppressWarnings("rawtypes") Class classType) {
-		System.err.println("error: getAncestorOfType should not been invoked");
-		return super.getAncestorOfType(classType);
+		return null;
 	}
 
 	@Override

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -129,10 +129,14 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public void inferLocalLevelEntities(Inferer inferer) {
 		super.inferLocalLevelEntities(inferer);
 		for (VarEntity var : this.vars()) {
-			var.inferLocalLevelEntities(inferer);
+			if (var.getParent()!=this) {
+				var.inferLocalLevelEntities(inferer);
+			}
 		}
 		for (FunctionEntity func : this.getFunctions()) {
-			func.inferLocalLevelEntities(inferer);
+			if (func.getParent()!=this) {
+				func.inferLocalLevelEntities(inferer);
+			}
 		}
 		if (inferer.isEagerExpressionResolve()) {
 			reloadExpression(inferer.getRepo());
@@ -212,13 +216,15 @@ public abstract class ContainerEntity extends DecoratedEntity {
 					continue;
 				}
 				if (expression.isCall()) {
-					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.getIdentifier());
-					if (func != null) {
-						expression.setType(func.getType(), func, inferer);
+					List<Entity> funcs = this.lookupFunctionInVisibleScope(expression.getIdentifier());
+					if (funcs != null) {
+						for (Entity func:funcs) {
+							expression.setType(func.getType(), func, inferer);
+						}
 					}
 				} else {
 
-					VarEntity varEntity = this.lookupVarInVisibleScope(expression.getIdentifier());
+					Entity varEntity = this.lookupVarInVisibleScope(expression.getIdentifier());
 					if (varEntity != null) {
 						expression.setType(varEntity.getType(), varEntity, inferer);
 					}
@@ -311,16 +317,23 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param functionName
 	 * @return
 	 */
-	public FunctionEntity lookupFunctionInVisibleScope(GenericName functionName) {
+	public List<Entity> lookupFunctionInVisibleScope(GenericName functionName) {
+		List<Entity> functions = new ArrayList<>();
 		if (this.getMutliDeclare() != null) {
-			for (ContainerEntity fromEntity : this.getMutliDeclare().getEntities()) {
-				FunctionEntity f = lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
-				if (f != null)
-					return f;
+			for (Entity fromEntity : this.getMutliDeclare().getEntities()) {
+				Entity f = lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
+				if (f != null) {
+					functions.add(f);
+					return functions;
+				}
 			}
 		} else {
 			ContainerEntity fromEntity = this;
-			return lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
+			Entity f = lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
+			if (f != null) {
+				functions.add(f);
+				return functions;
+			}
 		}
 		return null;
 	}
@@ -332,13 +345,19 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param fromEntity
 	 * @return
 	 */
-	private FunctionEntity lookupFunctionBottomUpTillTopContainer(GenericName functionName, ContainerEntity fromEntity) {
+	private Entity lookupFunctionBottomUpTillTopContainer(GenericName functionName, Entity fromEntity) {
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {
 				FunctionEntity func = ((ContainerEntity) fromEntity).lookupFunctionLocally(functionName);
 				if (func != null)
 					return func;
 			}
+			for (Entity child:this.getChildren()) {
+				if (child instanceof AliasEntity) {
+					if (child.getRawName().equals(functionName))
+						return child;
+				}
+			}
 			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
 		}
 		return null;
@@ -368,7 +387,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param varName
 	 * @return
 	 */
-	public VarEntity lookupVarInVisibleScope(GenericName varName) {
+	public Entity lookupVarInVisibleScope(GenericName varName) {
 		ContainerEntity fromEntity = this;
 		return lookupVarBottomUpTillTopContainer(varName, fromEntity);
 	}
@@ -380,13 +399,19 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param varName
 	 * @return
 	 */
-	private VarEntity lookupVarBottomUpTillTopContainer(GenericName varName, ContainerEntity fromEntity) {
+	private Entity lookupVarBottomUpTillTopContainer(GenericName varName, ContainerEntity fromEntity) {
 		while (fromEntity != null) {
 			if (fromEntity instanceof ContainerEntity) {
 				VarEntity var = ((ContainerEntity) fromEntity).lookupVarLocally(varName);
 				if (var != null)
 					return var;
 			}
+			for (Entity child:this.getChildren()) {
+				if (child instanceof AliasEntity) {
+					if (child.getRawName().equals(varName))
+						return child;
+				}
+			}
 			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
 		}
 		return null;

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -176,21 +176,45 @@ public class Expression implements Serializable{
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {
 			if (parent.isCall()) {
-				FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-				if (func!=null) {
-					parent.setType(func.getType(), func,inferer);
-					parent.setReferredEntity(func);
+				if (parent.getIdentifier().getName().equals("C")) {
+					System.out.println("hh");
+				}
+				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
+				if (funcs!=null) {
+					Entity func = funcs.get(0);
+					if (funcs.size()>1) {
+						MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
+						inferer.getRepo().add(m);
+						for (int i=1;i<funcs.size();i++) {
+							m.add(funcs.get(i));
+						}
+						parent.setType(func.getType(), m,inferer);
+						parent.setReferredEntity(m);
+					}else {
+						parent.setType(func.getType(), func,inferer);
+						parent.setReferredEntity(func);
+					}
 				}
 			}else {
-				VarEntity var = this.getType().lookupVarInVisibleScope(parent.identifier);
+				Entity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
 					parent.setType(var.getType(),var, inferer);
 					parent.setReferredEntity(var);
 				}else {
-					FunctionEntity func = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-					if (func!=null) {
-						parent.setType(func.getType(), func,inferer);
-						parent.setReferredEntity(func);
+					List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
+					if (funcs!=null) {
+						Entity func = funcs.get(0);
+						if (funcs.size()>1) {
+							MultiDeclareEntities m = new MultiDeclareEntities(func, -1);
+							for (int i=1;i<funcs.size();i++) {
+								m.add(funcs.get(i));
+							}
+							parent.setType(func.getType(), m,inferer);
+							parent.setReferredEntity(m);
+						}else {
+							parent.setType(func.getType(), func,inferer);
+							parent.setReferredEntity(func);
+						}
 					}
 				}
 			}

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -113,7 +113,7 @@ public class FunctionEntity extends ContainerEntity{
 		return throwTypes;
 	}
 	@Override
-	public VarEntity lookupVarInVisibleScope(GenericName varName) {
+	public Entity lookupVarInVisibleScope(GenericName varName) {
 		for (VarEntity param:parameters) {
 			if (varName.equals(param.getRawName())) {
 				return param;

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -37,7 +37,7 @@ import depends.relations.Inferer;
  * in C++, a function could be declared in different place with the same signature.
  */
 public class MultiDeclareEntities extends ContainerEntity {
-	List<ContainerEntity> entities = new ArrayList<>();
+	List<Entity> entities = new ArrayList<>();
 	private boolean containsTypeEntity = false;
 	public MultiDeclareEntities(Entity entity, int id ) {
 		setQualifiedName(entity.getQualifiedName());
@@ -54,12 +54,13 @@ public class MultiDeclareEntities extends ContainerEntity {
 
 	public void add(Entity entity) {
 		entity.setMutliDeclare(this);
-		if (entity instanceof TypeEntity) this.containsTypeEntity = true;
-		if (entity instanceof ContainerEntity)
-			entities.add((ContainerEntity)entity);
+		if (entity instanceof TypeEntity) 
+			this.containsTypeEntity = true;
+		
+		entities.add(entity);
 	}
 
-	public List<ContainerEntity> getEntities() {
+	public List<Entity> getEntities() {
 		return entities;
 	}
 

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -62,12 +62,13 @@ public class VarEntity extends ContainerEntity {
 	public void inferLocalLevelEntities(Inferer inferer) {
 		super.inferLocalLevelEntities(inferer);
 		Entity entity = inferer.resolveName(this, rawType, true);
-		if (entity==null) return;
-		this.setActualReferTo(entity);
-		type = entity.getType();
-		if (type==null) {
-			if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
-				type = Inferer.genericParameterType;
+		if (entity!=null) {
+			this.setActualReferTo(entity);
+			type = entity.getType();
+			if (type==null) {
+				if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
+					type = Inferer.genericParameterType;
+				}
 			}
 		}
 		if (type==null) {
@@ -90,11 +91,16 @@ public class VarEntity extends ContainerEntity {
 	}
 
 	public void fillCandidateTypes(Inferer inferer) {
+		if (!inferer.isEagerExpressionResolve()) return;
 		if (type!=null && !(type instanceof CandidateTypes)) return ; //it is a strong type lang, do not need deduce candidate types
 		if (functionCalls==null) return;
 		if (functionCalls.size()==0) return; //no information avaliable for type deduction
 		if (this.rawType==null) {
-			this.type = new CandidateTypes(inferer.calculateCandidateTypes(this,this.functionCalls));
+			List<TypeEntity> candidateTypes = inferer.calculateCandidateTypes(this,this.functionCalls);
+			if (candidateTypes.size()>0) {
+				this.type = new CandidateTypes(candidateTypes,inferer.getRepo().generateId());
+				inferer.getRepo().add(this.type);
+			}
 		}
 	}
 }

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -110,12 +110,14 @@ abstract public class AbstractLangProcessor {
 	 * @param includeDir
 	 * @param inputDir
 	 * @param b 
+	 * @param b 
 	 */
-	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl, boolean isCollectUnsolvedBindings) {
+	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl, boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
 		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
+		this.inferer.setDuckTypingDeduce(isDuckTypingDeduce);
 		logger.info("Start parsing files...");
 		parseAllFiles();
 		markAllEntitiesScope();

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -87,7 +87,7 @@ public abstract class HandlerContext {
 		return foundNewType(GenericName.build(name));
 	}
 
-	public void foundNewTypeAlias(String aliasName, String originalName) {
+	public void foundNewAlias(String aliasName, String originalName) {
 		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
 		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
 		AliasEntity currentTypeEntity = new AliasEntity(GenericName.build(aliasName), this.latestValidContainer(),
@@ -96,6 +96,13 @@ public abstract class HandlerContext {
 		return ;		
 	}
 	
+	public void foundNewAlias(GenericName aliasName, Entity referToEntity) {
+		AliasEntity currentTypeEntity = new AliasEntity(aliasName, this.latestValidContainer(),
+				idGenerator.generateId(),aliasName);
+		currentTypeEntity.setReferToEntity(referToEntity);
+	 	entityRepo.add(currentTypeEntity);
+	}
+	
 	/**
 	 * Tell the context that a new method was found.
 	 * Do not forget to tell the context leave the method when you finish

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -64,7 +64,11 @@ public class PythonCodeListener extends PythonParserBaseListener{
 
 		String dir = FileUtil.uniqFilePath(FileUtil.getLocatedDir(fileFullPath));
 		if (entityRepo.getEntity(dir) == null) {
-			entityRepo.add(new PackageEntity(dir, entityRepo.generateId()));
+			PackageEntity pacakgeEntity = new PackageEntity(dir, entityRepo.generateId());
+			entityRepo.add(pacakgeEntity);
+			if (FileUtil.existFile(dir + File.separator+"__init__.py")) {
+				pacakgeEntity.setFilePath(FileUtil.uniqFilePath(dir + File.separator+"__init__.py"));
+			}
 		}
 
 		PackageEntity packageEntity = (PackageEntity) entityRepo.getEntity(dir);
@@ -110,11 +114,18 @@ public class PythonCodeListener extends PythonParserBaseListener{
 				if (moduleEntity != null) {
 					for (Entity child:moduleEntity.getChildren()) {
 						context.foundNewImport(new NameAliasImport(fullName, child, child.getRawName().uniqName()));
+						context.foundNewAlias(child.getRawName(), child);
 					}
 					if (moduleEntity instanceof PackageEntity) {
 						for (Entity file : moduleEntity.getChildren()) {
-							String fileName = file.getRawName().uniqName().substring(fullName.length());
-							context.foundNewImport(new NameAliasImport(file.getRawName().uniqName(), file, fileName));
+							if (file instanceof FileEntity) {
+								String fileName = file.getRawName().uniqName().substring(fullName.length());
+								context.foundNewImport(new NameAliasImport(file.getRawName().uniqName(), file, fileName));
+								context.foundNewAlias(GenericName.build(FileUtil.getShortFileName(fileName).replace(".py", "")), file);
+							}else {
+								context.foundNewImport(new NameAliasImport(file.getRawName().uniqName(), file, file.getRawName().uniqName()));
+								context.foundNewAlias(GenericName.build(FileUtil.getShortFileName(file.getRawName().uniqName())), file);
+							}
 						}
 					}
 					if (moduleEntity instanceof FileEntity) {
@@ -138,8 +149,10 @@ public class PythonCodeListener extends PythonParserBaseListener{
 						context.foundNewImport(new FileImport(fullName));
 					}
 					Entity itemEntity = inferer.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
-					if (itemEntity != null)
+					if (itemEntity != null) {
+						context.foundNewAlias(GenericName.build(alias), itemEntity);
 						context.foundNewImport(new NameAliasImport(itemEntity.getQualifiedName(), itemEntity, alias));
+					}
 				}
 			}
 		}

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -88,7 +88,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitAliasNode(AliasNode node) {
-		context.foundNewTypeAlias(node.getNewNameString(), node.getOldNameString());
+		context.foundNewAlias(node.getNewNameString(), node.getOldNameString());
 		return super.visitAliasNode(node);
 	}
 

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -30,6 +30,7 @@ import java.util.List;
 import depends.entity.CandidateTypes;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
+import depends.entity.PackageEntity;
 import depends.entity.TypeEntity;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.core.DependencyMatrix;
@@ -86,8 +87,13 @@ public class FileDependencyGenerator extends DependencyGenerator{
 
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
-		if (ancestor==null)
-			return -1;
+		if (ancestor==null) {
+			PackageEntity packageEntity = (PackageEntity)( entity.getAncestorOfType(PackageEntity.class));
+			if (packageEntity==null) return -1;
+			if (packageEntity.getFilePath()==null) return -1;
+			if (entityRepo.getEntity(packageEntity.getFilePath())==null) return -1;
+			return entityRepo.getEntity(packageEntity.getFilePath()).getId();
+		}
 		if (!ancestor.inScope()) return -1;
 		return ancestor.getId();
 	}

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -125,7 +125,7 @@ public class RelationCounter {
 		}
 
 		if (referredEntity instanceof MultiDeclareEntities) {
-			for (ContainerEntity e:((MultiDeclareEntities)referredEntity).getEntities()) {
+			for (Entity e:((MultiDeclareEntities)referredEntity).getEntities()) {
 				addRelationFromExpression(entity,expression,e);
 			}
 			return;
@@ -137,7 +137,7 @@ public class RelationCounter {
 				Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
 				if (multiDeclare instanceof MultiDeclareEntities) {
 					MultiDeclareEntities m = (MultiDeclareEntities)multiDeclare;
-					List<ContainerEntity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
+					List<Entity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
 					.collect(Collectors.toList());
 					for (Entity e:entities) {
 						entity.addRelation(buildRelation(DependencyType.IMPLLINK,e));

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -8,6 +8,7 @@ import org.junit.Test;
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
+import depends.entity.MultiDeclareEntities;
 import depends.extractor.python.union.PythonFileParser;
 import depends.util.FileUtil;
 
@@ -217,10 +218,13 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"in_the_forest"));
+	    
+	    MultiDeclareEntities funcs = (MultiDeclareEntities)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
+	    Entity func = funcs.getEntities().get(0);
+
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Duck.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Doge.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Bird.quack"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Duck.quack"));
 	}
 
 	@Test
@@ -236,10 +240,29 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
+	    
+	    MultiDeclareEntities funcs = (MultiDeclareEntities)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
+	    Entity func = funcs.getEntities().get(0);
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Duck.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Bird.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Doge.quack"));
 	}
+	
+	@Test
+	public void should_resolve_imported_symbols() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_from_init/use_imported.py",
+	    		"./src/test/resources/python-code-examples/import_from_init/pkg/__init__.py",
+	    		"./src/test/resources/python-code-examples/import_from_init/pkg/core.py",
+	    	    };
+	   
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"bar"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[2],"C"));
+	}
 
 }

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -56,8 +56,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
 	    TypeEntity type = var.getType();
-	    assertTrue(type instanceof CandidateTypes);
-	    assertEquals(0,((CandidateTypes)type).getCandidateTypes().size());
+	    assertTrue(type == null);
 	}
 
 	

e58135b89f09d83d669d0926c80eca84d027fbc0
@@ -176,9 +176,6 @@ public class Expression implements Serializable{
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {
 			if (parent.isCall()) {
-				if (parent.getIdentifier().getName().equals("C")) {
-					System.out.println("hh");
-				}
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 				if (funcs!=null) {
 					Entity func = funcs.get(0);

5b800185d7d2460da094640c66198cb100ceba46
@@ -27,6 +27,7 @@ package depends.entity;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.stream.Collectors;
 
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
@@ -178,18 +179,21 @@ public class Expression implements Serializable{
 			if (parent.isCall()) {
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 				if (funcs!=null) {
-					Entity func = funcs.get(0);
-					if (funcs.size()>1) {
-						MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
-						inferer.getRepo().add(m);
-						for (int i=1;i<funcs.size();i++) {
-							m.add(funcs.get(i));
+					//funcs = funcs.stream().filter(item->!(item instanceof MultiDeclareEntities)).collect(Collectors.toList());
+					if (funcs.size()>0) {
+						Entity func = funcs.get(0);
+						if (funcs.size()>1) {
+							MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
+							inferer.getRepo().add(m);
+							for (int i=1;i<funcs.size();i++) {
+								m.add(funcs.get(i));
+							}
+							parent.setType(func.getType(), m,inferer);
+							parent.setReferredEntity(m);
+						}else {
+							parent.setType(func.getType(), func,inferer);
+							parent.setReferredEntity(func);
 						}
-						parent.setType(func.getType(), m,inferer);
-						parent.setReferredEntity(m);
-					}else {
-						parent.setType(func.getType(), func,inferer);
-						parent.setReferredEntity(func);
 					}
 				}
 			}else {
@@ -202,7 +206,9 @@ public class Expression implements Serializable{
 					if (funcs!=null) {
 						Entity func = funcs.get(0);
 						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, -1);
+							MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
+							inferer.getRepo().add(m);
+
 							for (int i=1;i<funcs.size();i++) {
 								m.add(funcs.get(i));
 							}
@@ -229,8 +235,9 @@ public class Expression implements Serializable{
 
 	private void setReferredEntity(Entity referredEntity) {
 		this.referredEntity = referredEntity;
-		if (this.referredEntity!=null)
+		if (this.referredEntity!=null) {
 			this.referredEntityId = referredEntity.getId();
+		}
 	}
 
 	public void addDeducedTypeVar(VarEntity var) {

5b800185d7d2460da094640c66198cb100ceba46
@@ -40,6 +40,7 @@ public class MultiDeclareEntities extends ContainerEntity {
 	List<Entity> entities = new ArrayList<>();
 	private boolean containsTypeEntity = false;
 	public MultiDeclareEntities(Entity entity, int id ) {
+		this.id = id;
 		setQualifiedName(entity.getQualifiedName());
 		setRawName(entity.getRawName());
 		add(entity);

5b800185d7d2460da094640c66198cb100ceba46
@@ -61,7 +61,7 @@ public abstract class HandlerContext {
 	public FileEntity startFile(String fileName) {
 		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
 		pushToStack(currentFileEntity);
-		entityRepo.add(currentFileEntity);
+		addToRepo(currentFileEntity);
 		return currentFileEntity;
 	}
 
@@ -73,7 +73,7 @@ public abstract class HandlerContext {
 		TypeEntity currentTypeEntity = new TypeEntity(name, this.latestValidContainer(),
 				idGenerator.generateId());
 			pushToStack(currentTypeEntity);
-		 	entityRepo.add(currentTypeEntity);
+			addToRepo(currentTypeEntity);
 		 	currentFileEntity.addType(currentTypeEntity);
 			return currentTypeEntity;		
 	}
@@ -92,7 +92,7 @@ public abstract class HandlerContext {
 		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
 		AliasEntity currentTypeEntity = new AliasEntity(GenericName.build(aliasName), this.latestValidContainer(),
 				idGenerator.generateId(),GenericName.build(originalName) );
-	 	entityRepo.add(currentTypeEntity);
+	 	addToRepo(currentTypeEntity);
 		return ;		
 	}
 	
@@ -100,7 +100,7 @@ public abstract class HandlerContext {
 		AliasEntity currentTypeEntity = new AliasEntity(aliasName, this.latestValidContainer(),
 				idGenerator.generateId(),aliasName);
 		currentTypeEntity.setReferToEntity(referToEntity);
-	 	entityRepo.add(currentTypeEntity);
+	 	addToRepo(currentTypeEntity);
 	}
 	
 	/**
@@ -115,7 +115,7 @@ public abstract class HandlerContext {
 	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
 				idGenerator.generateId(),GenericName.build(returnType));
-		entityRepo.add(functionEntity);
+		addToRepo(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
 		functionEntity.addThrowTypes(throwedType.stream().map(item->GenericName.build(item)).collect(Collectors.toList()));
@@ -125,7 +125,7 @@ public abstract class HandlerContext {
 	public FunctionEntity foundMethodDeclarator(String methodName, GenericName returnType, List<String> throwedType) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
 				idGenerator.generateId(),returnType);
-		entityRepo.add(functionEntity);
+		addToRepo(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
 		functionEntity.addThrowTypes(throwedType.stream().map(item->GenericName.build(item)).collect(Collectors.toList()));
@@ -135,7 +135,7 @@ public abstract class HandlerContext {
 	public FunctionEntity foundMethodDeclarator(String methodName) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
 				idGenerator.generateId(),null);
-		entityRepo.add(functionEntity);
+		addToRepo(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
 		return functionEntity;		
@@ -145,7 +145,7 @@ public abstract class HandlerContext {
 	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), containerEntity,
 				idGenerator.generateId(),null);
-		entityRepo.add(functionEntity);
+		addToRepo(functionEntity);
 		containerEntity.addFunction(functionEntity);
 		pushToStack(functionEntity);
 		functionEntity.addThrowTypes(new ArrayList<>());
@@ -195,7 +195,7 @@ public abstract class HandlerContext {
 		Entity global = entityRepo.getEntity(EntityRepo.GLOBAL_SCOPE_NAME);
 		if (global==null) {
 			global = new PackageEntity(EntityRepo.GLOBAL_SCOPE_NAME,idGenerator.generateId());
-			entityRepo.add(global);
+			addToRepo(global);
 		}
 		return (ContainerEntity)global;
 	}
@@ -271,7 +271,7 @@ public abstract class HandlerContext {
 		if (var!=null) return var;
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
 		container.addVar(var);
-		entityRepo.add(var);
+		addToRepo(var);
 
 		return var;
 	}
@@ -287,7 +287,7 @@ public abstract class HandlerContext {
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
 		container.addVar(var);
 		var.setQualifiedName(var.getRawName().toString());
-		entityRepo.add(var);
+		addToRepo(var);
 		return var;
 	}
 
@@ -295,7 +295,7 @@ public abstract class HandlerContext {
 		VarEntity var = new VarEntity(GenericName.build(varName), type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);	
-		entityRepo.add(var);
+		addToRepo(var);
 		return var;
 	}
 	
@@ -335,4 +335,8 @@ public abstract class HandlerContext {
 	public Entity foundEntityWithName(GenericName rawName) {
 		return inferer.resolveName(lastContainer(), rawName, true);
 	}
+	
+	public void addToRepo(Entity entity) {
+		entityRepo.add(entity);
+	}
 }
\ No newline at end of file

5b800185d7d2460da094640c66198cb100ceba46
@@ -11,7 +11,6 @@ import depends.entity.ContainerEntity;
 import depends.entity.DecoratedEntity;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
-import depends.entity.FunctionEntity;
 import depends.entity.GenericName;
 import depends.entity.PackageEntity;
 import depends.entity.TypeEntity;
@@ -66,9 +65,6 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		if (entityRepo.getEntity(dir) == null) {
 			PackageEntity pacakgeEntity = new PackageEntity(dir, entityRepo.generateId());
 			entityRepo.add(pacakgeEntity);
-			if (FileUtil.existFile(dir + File.separator+"__init__.py")) {
-				pacakgeEntity.setFilePath(FileUtil.uniqFilePath(dir + File.separator+"__init__.py"));
-			}
 		}
 
 		PackageEntity packageEntity = (PackageEntity) entityRepo.getEntity(dir);

5b800185d7d2460da094640c66198cb100ceba46
@@ -88,11 +88,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null) {
-			PackageEntity packageEntity = (PackageEntity)( entity.getAncestorOfType(PackageEntity.class));
-			if (packageEntity==null) return -1;
-			if (packageEntity.getFilePath()==null) return -1;
-			if (entityRepo.getEntity(packageEntity.getFilePath())==null) return -1;
-			return entityRepo.getEntity(packageEntity.getFilePath()).getId();
+			return -1;
 		}
 		if (!ancestor.inScope()) return -1;
 		return ancestor.getId();

a00a168fc7c1852dd729c9869bdf8e60e6259234
@@ -26,7 +26,9 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import depends.relations.Inferer;
 
@@ -171,6 +173,20 @@ public class AliasEntity extends Entity {
 	public void setReferToEntity(Entity referToEntity) {
 		this.referToEntity = referToEntity;
 	}
+	public Entity getReferToEntityTillNoAlias() {
+		Set<Entity> searched = new HashSet<>();
+		int i=0;
+		Entity current = this;
+		while(i<100) { //maximum 100 levels
+			if (searched.contains(current)) return current; //with a loop
+			if (!(current instanceof AliasEntity)) return current;
+			searched.add(current);
+			current = ((AliasEntity)current).getReferToEntity();
+			if (current ==null) return this;
+			i++;
+		}
+		return current;
+	}
 	
 
 }

a00a168fc7c1852dd729c9869bdf8e60e6259234
@@ -31,6 +31,7 @@ import java.util.List;
 import java.util.stream.Collectors;
 
 import depends.deptypes.DependencyType;
+import depends.entity.AliasEntity;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.Expression;
@@ -130,6 +131,7 @@ public class RelationCounter {
 			}
 			return;
 		}
+		
 		boolean matched = false;
 		if (expression.isCall()) {
 			/* if it is a FunctionEntityProto, add Relation to all Impl Entities*/
@@ -181,6 +183,12 @@ public class RelationCounter {
 	}
 
 	private Relation buildRelation(String type, Entity referredEntity) {
+		if (referredEntity instanceof AliasEntity) {
+			AliasEntity alias = ((AliasEntity) referredEntity);
+			if (alias.getReferToEntityTillNoAlias()!=null) {
+				referredEntity = alias.getReferToEntityTillNoAlias();
+			}
+		}
 		if (this.langProcessor==null)
 			return new Relation(type,referredEntity);
 		return new Relation(langProcessor.getRelationMapping(type),referredEntity);

a00a168fc7c1852dd729c9869bdf8e60e6259234
@@ -7,6 +7,7 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
+import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.MultiDeclareEntities;
 import depends.extractor.python.union.PythonFileParser;
@@ -265,4 +266,20 @@ public class PythonImportTest extends PythonParserTest {
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[2],"C"));
 	}
 
+	@Test
+	public void should_resolve_imported_vars() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_from_var/use_imported.py",
+	    		"./src/test/resources/python-code-examples/import_from_var/pkg/core.py",
+	    	    };
+	   
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    FileEntity f = (FileEntity)repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    this.assertContainsRelation(f, DependencyType.CALL, withPackageName(srcs[1],"Core.foo"));
+	}
+
 }

ca8e0b048569fadcb8e4d3aed08b5922f1e1c7f2
@@ -36,6 +36,7 @@ public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
 	private GenericName originName;
 	private List<Entity> referPath = new ArrayList<>();
+	private boolean deepResolve = false;
 	public AliasEntity() {
 		
 	}
@@ -173,20 +174,34 @@ public class AliasEntity extends Entity {
 	public void setReferToEntity(Entity referToEntity) {
 		this.referToEntity = referToEntity;
 	}
-	public Entity getReferToEntityTillNoAlias() {
+	public Entity deepResolve() {
+		if (!deepResolve) return this;
 		Set<Entity> searched = new HashSet<>();
 		int i=0;
 		Entity current = this;
 		while(i<100) { //maximum 100 levels
-			if (searched.contains(current)) return current; //with a loop
+			if (searched.contains(current)) return current; //avoid a loop
 			if (!(current instanceof AliasEntity)) return current;
+			
 			searched.add(current);
+			Entity originalFile = current.getAncestorOfType(FileEntity.class);
 			current = ((AliasEntity)current).getReferToEntity();
+			
 			if (current ==null) return this;
+			//if already out of current file, return current
+			if (!current.getAncestorOfType(FileEntity.class).equals(originalFile)) {
+				return current;
+			}
 			i++;
 		}
 		return current;
 	}
+	public boolean isDeepResolve() {
+		return deepResolve;
+	}
+	public void setDeepResolve(boolean deepResolve) {
+		this.deepResolve = deepResolve;
+	}
 	
 
 }

ca8e0b048569fadcb8e4d3aed08b5922f1e1c7f2
@@ -87,20 +87,21 @@ public abstract class HandlerContext {
 		return foundNewType(GenericName.build(name));
 	}
 
-	public void foundNewAlias(String aliasName, String originalName) {
-		if (aliasName.equals(originalName)) return; //it is a tricky, we treat same name no different. 
+	public AliasEntity foundNewAlias(String aliasName, String originalName) {
+		if (aliasName.equals(originalName)) return null; //it is a tricky, we treat same name no different. 
 		//indeed it is not perfect -> the right match should depends on no-bare format like "struct a" instead of "a"
 		AliasEntity currentTypeEntity = new AliasEntity(GenericName.build(aliasName), this.latestValidContainer(),
 				idGenerator.generateId(),GenericName.build(originalName) );
 	 	addToRepo(currentTypeEntity);
-		return ;		
+		return currentTypeEntity;		
 	}
 	
-	public void foundNewAlias(GenericName aliasName, Entity referToEntity) {
+	public AliasEntity foundNewAlias(GenericName aliasName, Entity referToEntity) {
 		AliasEntity currentTypeEntity = new AliasEntity(aliasName, this.latestValidContainer(),
 				idGenerator.generateId(),aliasName);
 		currentTypeEntity.setReferToEntity(referToEntity);
 	 	addToRepo(currentTypeEntity);
+		return currentTypeEntity;		
 	}
 	
 	/**

ca8e0b048569fadcb8e4d3aed08b5922f1e1c7f2
@@ -7,6 +7,7 @@ import java.util.List;
 
 import org.antlr.v4.runtime.ParserRuleContext;
 
+import depends.entity.AliasEntity;
 import depends.entity.ContainerEntity;
 import depends.entity.DecoratedEntity;
 import depends.entity.Entity;

ca8e0b048569fadcb8e4d3aed08b5922f1e1c7f2
@@ -185,8 +185,8 @@ public class RelationCounter {
 	private Relation buildRelation(String type, Entity referredEntity) {
 		if (referredEntity instanceof AliasEntity) {
 			AliasEntity alias = ((AliasEntity) referredEntity);
-			if (alias.getReferToEntityTillNoAlias()!=null) {
-				referredEntity = alias.getReferToEntityTillNoAlias();
+			if (alias.deepResolve()!=null) {
+				referredEntity = alias.deepResolve();
 			}
 		}
 		if (this.langProcessor==null)

2ca9e1d9c9f0319ab864d166753bdb913e847cd8
@@ -179,6 +179,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		
 		if (expressionList==null) return;
 		if(expressionList.size()>10000) return;
+		
+		
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
 			if (expression.getType() != null)
@@ -198,6 +200,13 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				}
 			}
 			if (expression.getIdentifier() != null) {
+
+//				if (this.getAncestorOfType(FileEntity.class).getRawName().contains("/examples/usersession/server.py") &&
+//						expression.getIdentifier().contains("config")) {
+//					System.out.print("dd");
+//				}
+				
+				
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;

2ca9e1d9c9f0319ab864d166753bdb913e847cd8
@@ -121,6 +121,9 @@ public class ExpressionUsage {
 
 	private void makeSureVarExist(GenericName identifier) {
 		if (null==context.foundEntityWithName(identifier)) {
+			if (identifier.getName().contains("Pyro4.config.SERVERTYPE")) {
+				System.out.println(identifier);
+			}
 			context.foundVarDefinition(context.lastContainer(), identifier.getName());
 		}
 	}
@@ -128,7 +131,7 @@ public class ExpressionUsage {
 	private boolean isValidIdentifier(GenericName identifier) {
 		Pattern p = Pattern.compile("[a-zA-Z_][a-zA-Z0-9_]*");
 		Matcher m = p.matcher(identifier.getName());
-		return m.find();
+		return m.matches();
 	}
 
 

2ca9e1d9c9f0319ab864d166753bdb913e847cd8
@@ -89,19 +89,19 @@ public class RelationCounter {
 	private void computeContainerRelations(ContainerEntity entity) {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
-				entity.addRelation(buildRelation(DependencyType.CONTAIN,var.getType()));
+				entity.addRelation(buildRelation(entity,DependencyType.CONTAIN,var.getType()));
 			for (Entity type:var.getResolvedTypeParameters()) {
-				var.addRelation(buildRelation(DependencyType.PARAMETER,type));
+				var.addRelation(buildRelation(var, DependencyType.PARAMETER,type));
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {
-			entity.addRelation(buildRelation(DependencyType.ANNOTATION,type));
+			entity.addRelation(buildRelation(entity,DependencyType.ANNOTATION,type));
 		}
 		for (Entity type:entity.getResolvedTypeParameters()) {
-			entity.addRelation(buildRelation(DependencyType.USE,type));
+			entity.addRelation(buildRelation(entity,DependencyType.USE,type));
 		}
 		for (ContainerEntity mixin:entity.getResolvedMixins()) {
-			entity.addRelation(buildRelation(DependencyType.MIXIN,mixin));
+			entity.addRelation(buildRelation(entity,DependencyType.MIXIN,mixin));
 		}
 		
 		entity.reloadExpression(repo);
@@ -142,25 +142,25 @@ public class RelationCounter {
 					List<Entity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
 					.collect(Collectors.toList());
 					for (Entity e:entities) {
-						entity.addRelation(buildRelation(DependencyType.IMPLLINK,e));
+						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e));
 						matched = true;
 					}
 				}
 			}
-			entity.addRelation(buildRelation(DependencyType.CALL,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity));
 			matched = true;
 
 		}
 		if (expression.isCreate()) {
-			entity.addRelation(buildRelation(DependencyType.CREATE,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.CREATE,referredEntity));
 			matched = true;
 		}
 		if (expression.isThrow()) {
-			entity.addRelation(buildRelation(DependencyType.THROW,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.THROW,referredEntity));
 			matched = true;
 		}
 		if (expression.isCast()) { 
-			entity.addRelation(buildRelation(DependencyType.CAST,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.CAST,referredEntity));
 			matched = true;
 		}
 		if (!matched)  {
@@ -169,24 +169,26 @@ public class RelationCounter {
 				MultiDeclareEntities m =  (MultiDeclareEntities)(repo.getEntity(referredEntity.getQualifiedName()));
 				for (Entity e:m.getEntities()) {
 					if (e==referredEntity) {
-						entity.addRelation(buildRelation(DependencyType.USE,e));
+						entity.addRelation(buildRelation(entity,DependencyType.USE,e));
 					}else {
-						entity.addRelation(buildRelation(DependencyType.IMPLLINK,e));
+						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e));
 					}
 					matched = true;
 				}
 			}
 			else {
-				entity.addRelation(buildRelation(DependencyType.USE,referredEntity));
+				entity.addRelation(buildRelation(entity,DependencyType.USE,referredEntity));
 			}
 		}
 	}
 
-	private Relation buildRelation(String type, Entity referredEntity) {
+	private Relation buildRelation(Entity from, String type, Entity referredEntity) {
 		if (referredEntity instanceof AliasEntity) {
-			AliasEntity alias = ((AliasEntity) referredEntity);
-			if (alias.deepResolve()!=null) {
-				referredEntity = alias.deepResolve();
+			if (from.getAncestorOfType(FileEntity.class).equals(referredEntity.getAncestorOfType(FileEntity.class))) {
+				AliasEntity alias = ((AliasEntity) referredEntity);
+				if (alias.deepResolve()!=null) {
+					referredEntity = alias.deepResolve();
+				}
 			}
 		}
 		if (this.langProcessor==null)
@@ -196,31 +198,31 @@ public class RelationCounter {
 
 	private void computeTypeRelations(TypeEntity type) {
 		for (TypeEntity superType:type.getInheritedTypes()) {
-			type.addRelation(buildRelation(DependencyType.INHERIT,superType));
+			type.addRelation(buildRelation(type,DependencyType.INHERIT,superType));
 		}
 		for (TypeEntity interfaceType:type.getImplementedTypes()) {
-			type.addRelation(buildRelation(DependencyType.IMPLEMENT,interfaceType));
+			type.addRelation(buildRelation(type,DependencyType.IMPLEMENT,interfaceType));
 		}
 	}
 
 	private void computeFunctionRelations(FunctionEntity func) {
 		for (Entity returnType:func.getReturnTypes()) {
-			func.addRelation(buildRelation(DependencyType.RETURN,returnType.getActualReferTo()));
+			func.addRelation(buildRelation(func,DependencyType.RETURN,returnType.getActualReferTo()));
 		}
 		for (VarEntity parameter:func.getParameters()) {
 			if (parameter.getType()!=null) 
-				func.addRelation(buildRelation(DependencyType.PARAMETER,parameter.getActualReferTo()));
+				func.addRelation(buildRelation(func,DependencyType.PARAMETER,parameter.getActualReferTo()));
 		}
 		for (Entity throwType:func.getThrowTypes()) {
-			func.addRelation(buildRelation(DependencyType.THROW,throwType));
+			func.addRelation(buildRelation(func,DependencyType.THROW,throwType));
 		}
 		for (Entity type:func.getResolvedTypeParameters()) {
-			func.addRelation(buildRelation(DependencyType.PARAMETER,type));
+			func.addRelation(buildRelation(func,DependencyType.PARAMETER,type));
 		}
 		if (func instanceof FunctionEntityImpl) {
 			FunctionEntityImpl funcImpl = (FunctionEntityImpl)func;
 			if(funcImpl.getImplemented()!=null) {
-				func.addRelation(buildRelation(DependencyType.IMPLEMENT,funcImpl.getImplemented()));
+				func.addRelation(buildRelation(func,DependencyType.IMPLEMENT,funcImpl.getImplemented()));
 			}
 		}
 	}
@@ -232,9 +234,9 @@ public class RelationCounter {
 			if (imported instanceof FileEntity)
 			{
 				if (((FileEntity)imported).isInProjectScope())
-					file.addRelation(buildRelation(DependencyType.IMPORT,imported));
+					file.addRelation(buildRelation(file,DependencyType.IMPORT,imported));
 			}else {
-				file.addRelation(buildRelation(DependencyType.IMPORT,imported));
+				file.addRelation(buildRelation(file,DependencyType.IMPORT,imported));
 			}
 		}
 	}

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -40,7 +40,7 @@ import org.slf4j.LoggerFactory;
 
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.TemporaryFile;
 
 /**
  * ContainerEntity for example file, class, method, etc. they could contain

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -46,8 +46,8 @@ import depends.matrix.core.DependencyMatrix;
 import depends.matrix.transform.OrderedMatrixGenerator;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
-import depends.util.FileTraversal;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileTraversal;
+import multilang.depends.util.file.FileUtil;
 
 abstract public class AbstractLangProcessor {
 	/**

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -11,7 +11,7 @@ import java.util.Map;
 import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
 
 import depends.entity.repo.EntityRepo;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.TemporaryFile;
 
 public class MacroFileRepo extends MacroRepo{
 	private EntityRepo entityRepo;

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -1,19 +1,9 @@
 package depends.extractor.cpp;
 
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
-import org.eclipse.cdt.core.dom.ast.IMacroBinding;
-import org.eclipse.cdt.core.parser.IScanner;
-import org.eclipse.cdt.core.parser.NullLogService;
-import org.eclipse.cdt.core.parser.ParserMode;
-import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
-import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
-
-import depends.extractor.cpp.cdt.GPPParserExtensionConfigurationExtension;
-import depends.util.FileUtil;
 
 public class MacroMemoryRepo extends MacroRepo{
 

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -28,7 +28,7 @@ import java.io.File;
 import java.util.List;
 
 import depends.entity.GenericName;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 
 public class PomCoords  {
 	public PomCoords() {

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -27,7 +27,7 @@ package depends.extractor.pom;
 import java.io.File;
 import java.util.List;
 
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 
 public class PomLocator {
 

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -7,7 +7,6 @@ import java.util.List;
 
 import org.antlr.v4.runtime.ParserRuleContext;
 
-import depends.entity.AliasEntity;
 import depends.entity.ContainerEntity;
 import depends.entity.DecoratedEntity;
 import depends.entity.Entity;
@@ -43,7 +42,7 @@ import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.importtypes.FileImport;
 import depends.relations.Inferer;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 
 public class PythonCodeListener extends PythonParserBaseListener{
 	private PythonHandlerContext context;

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -31,7 +31,6 @@ import java.util.concurrent.ExecutorService;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;
 import org.jrubyparser.CompatVersion;
-import org.jrubyparser.NodeVisitor;
 import org.jrubyparser.Parser;
 import org.jrubyparser.ast.Node;
 import org.jrubyparser.parser.ParserConfiguration;
@@ -43,7 +42,7 @@ import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.relations.Inferer;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 public class JRubyFileParser implements FileParser {
 	private String fileFullPath;
 	private EntityRepo entityRepo;

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -9,7 +9,7 @@ import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
 import depends.relations.Inferer;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.TemporaryFile;
 
 public abstract class CppParserTest extends ParserTest{
 	protected EntityRepo repo;

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -6,14 +6,12 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.commons.io.FileUtils;
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.AliasEntity;
-import depends.extractor.cpp.CppFileParser;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 
 public class IncludeRelationTest extends CppParserTest{
     @Before

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -3,11 +3,8 @@ package depends.extractor.java;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
 import depends.extractor.ParserTest;
-import depends.extractor.java.JavaBuiltInType;
-import depends.extractor.java.JavaFileParser;
-import depends.extractor.java.JavaImportLookupStrategy;
 import depends.relations.Inferer;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.TemporaryFile;
 
 public abstract class JavaParserTest  extends ParserTest{
 	protected  EntityRepo entityRepo ;

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -6,7 +6,7 @@ import java.util.List;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserTest;
 import depends.relations.Inferer;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.TemporaryFile;
 
 public abstract class MavenParserTest extends ParserTest{
 

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -11,7 +11,7 @@ import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.MultiDeclareEntities;
 import depends.extractor.python.union.PythonFileParser;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 
 public class PythonImportTest extends PythonParserTest {
     @Before

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -10,8 +10,8 @@ import depends.extractor.ParserTest;
 import depends.extractor.python.union.PythonFileParser;
 import depends.extractor.python.union.PythonProcessor;
 import depends.relations.Inferer;
-import depends.util.FileUtil;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.FileUtil;
+import multilang.depends.util.file.TemporaryFile;
 
 public abstract class PythonParserTest extends ParserTest implements ParserCreator {
 

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -12,7 +12,7 @@ import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.TemporaryFile;
 public abstract class RubyParserTest extends ParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -10,7 +10,7 @@ import org.junit.Test;
 import depends.entity.ContainerEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 
 public class RubySingletonMethodTest extends RubyParserTest {
 	@Before

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -10,7 +10,7 @@ import org.junit.Test;
 import depends.entity.ContainerEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
-import depends.util.FileUtil;
+import multilang.depends.util.file.FileUtil;
 
 public class RubyVarInvocationRecordTest extends RubyParserTest {
 	@Before

5dd681fdea3e82cbb649ad6e4762ab71e73a2053
@@ -23,16 +23,7 @@ SOFTWARE.
 */
 
 package depends.extractor.cpp.cdt;
-import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
-import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
-import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
-import org.eclipse.cdt.core.dom.ast.IASTExpression;
-import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
-import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
-import org.eclipse.cdt.core.dom.ast.IASTNode;
-import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
+import org.eclipse.cdt.core.dom.ast.*;
 import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 
 import depends.entity.Expression;
@@ -75,7 +66,6 @@ public class ExpressionUsage {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);
 			return;
 		}
-		
 		expression.setSet(isSet(ctx));
 		expression.setCall((ctx instanceof IASTFunctionCallExpression)?true:false);
 		expression.setLogic(isLogic(ctx));
@@ -108,15 +98,16 @@ public class ExpressionUsage {
 			expression.disableDriveTypeFromChild();
 
 		}
-		if (expression.isDot()) {
-			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
-			if (op2 instanceof IASTIdExpression)
-				expression.setIdentifier(ASTStringUtilExt.getName(((IASTIdExpression)op2).getName()));
-			else if (op2 instanceof IASTLiteralExpression)
-				expression.setIdentifier(ASTStringUtilExt.getName((IASTLiteralExpression)op2));
-			else if (op2 instanceof IASTFunctionCallExpression)
-				expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression)op2));
-			return;
+		if (expression.isDot() ) {
+			if (ctx instanceof  IASTBinaryExpression) {
+				IASTExpression op2 = ((IASTBinaryExpression) ctx).getOperand2();
+				if (op2 instanceof IASTIdExpression)
+					expression.setIdentifier(ASTStringUtilExt.getName(((IASTIdExpression) op2).getName()));
+				else if (op2 instanceof IASTLiteralExpression)
+					expression.setIdentifier(ASTStringUtilExt.getName((IASTLiteralExpression) op2));
+				else if (op2 instanceof IASTFunctionCallExpression)
+					expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression) op2));
+			}
 		}		
 	}
 
@@ -149,6 +140,10 @@ public class ExpressionUsage {
 		if (f instanceof IASTIdExpression) {
 			return GenericName.build(ASTStringUtilExt.getName(((IASTIdExpression)f).getName()));
 		}
+		if (f instanceof  IASTFieldReference){
+			IASTFieldReference func = (IASTFieldReference) f;
+			return GenericName.build(ASTStringUtilExt.getName(func.getFieldName()));
+		}
 		return null;
 	}
 
@@ -158,6 +153,12 @@ public class ExpressionUsage {
 			if (op==IASTBinaryExpression.op_pmdot ||
 					op==IASTBinaryExpression.op_pmarrow	) return true;
 		}
+		if (ctx instanceof  IASTFunctionCallExpression){
+			if (ctx.getChildren().length>0){
+				if (ctx.getChildren()[0] instanceof IASTFieldReference)
+					return true;
+			}
+		}
 		return false;
 	}
 	

5dd681fdea3e82cbb649ad6e4762ab71e73a2053
@@ -121,9 +121,6 @@ public class ExpressionUsage {
 
 	private void makeSureVarExist(GenericName identifier) {
 		if (null==context.foundEntityWithName(identifier)) {
-			if (identifier.getName().contains("Pyro4.config.SERVERTYPE")) {
-				System.out.println(identifier);
-			}
 			context.foundVarDefinition(context.lastContainer(), identifier.getName());
 		}
 	}

97edd75c00417bc6f661d7b91fd9a4032295cf4a
@@ -49,30 +49,28 @@ public class ExpressionUsage {
 	
 	public void foundExpression(IASTExpression ctx) {
 		Expression parent = findParentInStack(ctx);
-		//If parent already a call 
-		if (parent!=null ) {
-			if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast())) {
-				return;
-			}
+		Expression expression = null;
+		if (parent!=null && ctx.getParent()!=null && (ctx.getParent().getChildren().length==1)){
+			expression = parent;
+		}else {
+			/* create expression and link it with parent*/
+			expression = new Expression(idGenerator.generateId());
+			expression.setText(ctx.getRawSignature());
+			context.lastContainer().addExpression(ctx, expression);
+			expression.setParent(parent);
 		}
-		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId());
-		expression.setText( ctx.getRawSignature());
-		context.lastContainer().addExpression(ctx,expression);
-		expression.setParent(parent);
-	
 		
 		if (isTerminalExpression(ctx)) {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);
 			return;
 		}
-		expression.setSet(isSet(ctx));
-		expression.setCall((ctx instanceof IASTFunctionCallExpression)?true:false);
-		expression.setLogic(isLogic(ctx));
+		expression.setSet(expression.isSet() || isSet(ctx));
+		expression.setCall(expression.isCall() || (ctx instanceof IASTFunctionCallExpression)?true:false);
+		expression.setLogic(expression.isLogic() || isLogic(ctx));
 		if (ctx instanceof ICPPASTNewExpression){
 			expression.setCreate(true);;
 		}		
-		expression.setDot(isDot(ctx));
+		expression.setDot(expression.isDot() || isDot(ctx));
 
 		/**
  *    | expression bop='.'

97edd75c00417bc6f661d7b91fd9a4032295cf4a
@@ -1,14 +1,11 @@
 package depends.extractor.cpp;
 
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
-import depends.entity.Entity;
+import java.io.IOException;
 
 public class DuplicateDeclarationTest extends CppParserTest {
 	 @Before
@@ -32,9 +29,8 @@ public class DuplicateDeclarationTest extends CppParserTest {
 			    this.assertContainsRelation(e, DependencyType.CONTAIN,"DupClass");
 			    this.assertContainsRelation(e, DependencyType.CALL,"DupClass");
 			    this.assertContainsRelation(e, DependencyType.CREATE,"DupClass");
-			    this.assertContainsRelation(e, DependencyType.USE,"DupClass");
-			    this.assertContainsRelation(e, DependencyType.USE,"X.invoke.c");
-			    			    
+			    this.assertContainsRelation(e, DependencyType.CALL,"DupClass.foo");
+
 		}
 
 

98bf537cced18c2409a2a807d30470997be2a523
@@ -0,0 +1,47 @@
+package depends.extractor.cpp;
+
+import depends.entity.Entity;
+import depends.entity.FunctionEntityImpl;
+import depends.entity.FunctionEntityProto;
+import depends.relations.Relation;
+import multilang.depends.util.file.FileUtil;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+
+public class RelationInSameFileTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_convert_call_relation_to_impl() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relation_in_samefile/A.c",
+				"./src/test/resources/cpp-code-examples/relation_in_samefile/B.c"
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings(true,null);
+	    Entity bar = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    int matchCount = 0;
+	    for (Relation relation:bar.getRelations()) {
+	    	if (relation.getEntity() instanceof FunctionEntityProto) {
+	    		matchCount++;
+	    	}
+	    	if (relation.getEntity() instanceof FunctionEntityImpl) {
+	    		matchCount++;
+	    	}
+	    }
+	    assertEquals(2, matchCount);
+	}
+	
+
+}

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -24,16 +24,11 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Set;
-
-
 import depends.relations.Inferer;
 import depends.relations.Relation;
 
+import java.util.*;
+
 /**
  * Entity is the root of all entities, including file, package, module, 
  * class, method/function etc.
@@ -52,6 +47,7 @@ public abstract class Entity {
 	private Entity actualReferTo = null;
 	private boolean inScope = true;
 	protected HashMap<String, Entity> visibleNames = new HashMap<>();
+	private Location location = new Location();
 	public Entity() {};
     public Entity(GenericName rawName, Entity parent, Integer id) {
 		this.qualifiedName = null;
@@ -263,5 +259,16 @@ public abstract class Entity {
 		searched.add(this);
 		return visibleNames.get(name);
 	}
-	
+
+	public Integer getLine() {
+		return location.getLine();
+	}
+
+	public void setLine(int lineNumber) {
+		this.location.setLine(lineNumber);
+	}
+
+	public Location getLocation() {
+		return this.location;
+	}
 }

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -24,13 +24,12 @@ SOFTWARE.
 
 package depends.entity;
 
+import depends.entity.repo.EntityRepo;
+import depends.relations.Inferer;
+
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
-
-import depends.entity.repo.EntityRepo;
-import depends.relations.Inferer;
 
 /**
  * Expression 
@@ -67,7 +66,8 @@ public class Expression implements Serializable{
 	private transient Entity referredEntity;
 	
 	private transient TypeEntity type; // the type we care - for relation calculation. 
-    //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
+	private Location location = new Location();
+	//for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
 	
 	/*
 	 * */
@@ -413,4 +413,12 @@ public class Expression implements Serializable{
 			.append("type:").append(type).append("|");
 		return s.toString();
 	}
+
+	public void setLine(int lineNumber) {
+		this.location.setLine(lineNumber);
+	}
+
+	public Location getLocation() {
+		return location;
+	}
 }
\ No newline at end of file

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -47,7 +47,7 @@ public class ExpressionUsage {
 		expression.setIdentifier(functionName);
 	}
 	
-	public void foundExpression(IASTExpression ctx) {
+	public Expression foundExpression(IASTExpression ctx) {
 		Expression parent = findParentInStack(ctx);
 		Expression expression = null;
 		if (parent!=null && ctx.getParent()!=null && (ctx.getParent().getChildren().length==1)){
@@ -62,7 +62,7 @@ public class ExpressionUsage {
 		
 		if (isTerminalExpression(ctx)) {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);
-			return;
+			return expression;
 		}
 		expression.setSet(expression.isSet() || isSet(ctx));
 		expression.setCall(expression.isCall() || (ctx instanceof IASTFunctionCallExpression)?true:false);
@@ -106,7 +106,8 @@ public class ExpressionUsage {
 				else if (op2 instanceof IASTFunctionCallExpression)
 					expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression) op2));
 			}
-		}		
+		}
+		return expression;
 	}
 
 	private boolean isTerminalExpression(IASTExpression ctx) {

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -24,18 +24,17 @@ SOFTWARE.
 
 package depends.generator;
 
-import java.util.Iterator;
-import java.util.List;
-
 import depends.entity.CandidateTypes;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
-import depends.entity.PackageEntity;
 import depends.entity.TypeEntity;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class FileDependencyGenerator extends DependencyGenerator{
 	/**
 	 * Build the dependency matrix (without re-mapping file id)
@@ -66,7 +65,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
     	        		if (candidateType.getId()>=0) {
     	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,candidateType);
     	        			if (fileEntityTo!=-1) {
-    	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,candidateType));
+    	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,candidateType,relation.getFromLine()));
     	        			}
     	        		}
         			}
@@ -74,7 +73,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	        		if (relatedEntity.getId()>=0) {
 	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relatedEntity);
 	        			if (fileEntityTo!=-1) {
-	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,relatedEntity));
+	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,relatedEntity,relation.getFromLine()));
 	        			}
 	        		}
         		}

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -24,9 +24,6 @@ SOFTWARE.
 
 package depends.generator;
 
-import java.util.Iterator;
-import java.util.List;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
@@ -35,6 +32,9 @@ import depends.entity.repo.EntityRepo;
 import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class FunctionDependencyGenerator extends DependencyGenerator {
 	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
 		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
@@ -57,7 +57,7 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 					if (entityTo == -1)
 						continue;
 					dependencyMatrix.addDependency(relation.getType(), entityFrom, entityTo, 1,buildDescription(entity,
-							relation.getEntity()));
+							relation.getEntity(),relation.getFromLine()));
 				}
 			}
 		}

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -25,17 +25,21 @@ SOFTWARE.
 package depends.relations;
 
 import depends.entity.Entity;
+import depends.entity.Location;
 
 /**
  * Dependency relation object
  */
 public class Relation {
+	/*Where the relation happen in src*/
+	private Location location;
 	private String type;
 	private Entity toEntity;
 	
-	public Relation(String type, Entity toEntity) {
+	public Relation(String type, Entity toEntity,Location location) {
 		this.toEntity = toEntity;
 		this.type = type;
+		this.location = location;
 	}
 	public String getType() {
 		return type;
@@ -48,5 +52,9 @@ public class Relation {
 	public Entity getEntity() {
 		return toEntity;
 	}
-	
+
+	public Integer getFromLine() {
+		if (location==null) return null;
+		return location.getLine();
+	}
 }

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -24,27 +24,15 @@ SOFTWARE.
 
 package depends.relations;
 
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.stream.Collectors;
-
 import depends.deptypes.DependencyType;
-import depends.entity.AliasEntity;
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Expression;
-import depends.entity.FileEntity;
-import depends.entity.FunctionEntity;
-import depends.entity.FunctionEntityImpl;
-import depends.entity.FunctionEntityProto;
-import depends.entity.MultiDeclareEntities;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
+import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.AbstractLangProcessor;
 
+import java.util.Collection;
+import java.util.List;
+import java.util.stream.Collectors;
+
 public class RelationCounter {
 
 	private Collection<Entity> entities;
@@ -89,9 +77,9 @@ public class RelationCounter {
 	private void computeContainerRelations(ContainerEntity entity) {
 		for (VarEntity var:entity.getVars()) {
 			if (var.getType()!=null)
-				entity.addRelation(buildRelation(entity,DependencyType.CONTAIN,var.getType()));
+				entity.addRelation(buildRelation(entity,DependencyType.CONTAIN,var.getType(),var.getLocation()));
 			for (Entity type:var.getResolvedTypeParameters()) {
-				var.addRelation(buildRelation(var, DependencyType.PARAMETER,type));
+				var.addRelation(buildRelation(var, DependencyType.PARAMETER,type,type.getLocation()));
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {
@@ -142,25 +130,25 @@ public class RelationCounter {
 					List<Entity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
 					.collect(Collectors.toList());
 					for (Entity e:entities) {
-						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e));
+						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e,expression.getLocation()));
 						matched = true;
 					}
 				}
 			}
-			entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity,expression.getLocation()));
 			matched = true;
 
 		}
 		if (expression.isCreate()) {
-			entity.addRelation(buildRelation(entity,DependencyType.CREATE,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.CREATE,referredEntity,expression.getLocation()));
 			matched = true;
 		}
 		if (expression.isThrow()) {
-			entity.addRelation(buildRelation(entity,DependencyType.THROW,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.THROW,referredEntity,expression.getLocation()));
 			matched = true;
 		}
 		if (expression.isCast()) { 
-			entity.addRelation(buildRelation(entity,DependencyType.CAST,referredEntity));
+			entity.addRelation(buildRelation(entity,DependencyType.CAST,referredEntity,expression.getLocation()));
 			matched = true;
 		}
 		if (!matched)  {
@@ -169,20 +157,24 @@ public class RelationCounter {
 				MultiDeclareEntities m =  (MultiDeclareEntities)(repo.getEntity(referredEntity.getQualifiedName()));
 				for (Entity e:m.getEntities()) {
 					if (e==referredEntity) {
-						entity.addRelation(buildRelation(entity,DependencyType.USE,e));
+						entity.addRelation(buildRelation(entity,DependencyType.USE,e,expression.getLocation()));
 					}else {
-						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e));
+						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e,expression.getLocation()));
 					}
 					matched = true;
 				}
 			}
 			else {
-				entity.addRelation(buildRelation(entity,DependencyType.USE,referredEntity));
+				entity.addRelation(buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation()));
 			}
 		}
 	}
 
 	private Relation buildRelation(Entity from, String type, Entity referredEntity) {
+		return buildRelation(from,type,referredEntity,from.getLocation());
+	}
+
+	private Relation buildRelation(Entity from, String type, Entity referredEntity,Location location) {
 		if (referredEntity instanceof AliasEntity) {
 			if (from.getAncestorOfType(FileEntity.class).equals(referredEntity.getAncestorOfType(FileEntity.class))) {
 				AliasEntity alias = ((AliasEntity) referredEntity);
@@ -192,8 +184,8 @@ public class RelationCounter {
 			}
 		}
 		if (this.langProcessor==null)
-			return new Relation(type,referredEntity);
-		return new Relation(langProcessor.getRelationMapping(type),referredEntity);
+			return new Relation(type,referredEntity,location);
+		return new Relation(langProcessor.getRelationMapping(type),referredEntity,location);
 	}
 
 	private void computeTypeRelations(TypeEntity type) {

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -24,23 +24,16 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
+import depends.relations.Relation;
 import multilang.depends.util.file.TemporaryFile;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.lang.ref.WeakReference;
+import java.util.*;
 
 /**
  * ContainerEntity for example file, class, method, etc. they could contain
@@ -271,6 +264,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		this.expressionList.clear();
 		this.expressionList=null;
 		this.expressionList = new ArrayList<>();
+		this.expressionUseList = null;
 	}
 	
 	private void cacheExpressionListToFile() {
@@ -447,5 +441,35 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return resolvedMixins;
 	}
 
+	HashMap<String,Set<Expression>> expressionUseList = null;
+	public void addRelation(Expression expression, Relation relation) {
+		String key = relation.getEntity().qualifiedName+relation.getType();
+		if (this.expressionUseList==null)
+			expressionUseList = new HashMap<>();
+		if (expressionUseList.containsKey(key)){
+			Set<Expression> expressions = expressionUseList.get(key);
+			for (Expression expr:expressions){
+				if (linkedExpr(expr,expression)) return;
+			}
+		}else{
+			expressionUseList.put(key,new HashSet<>());
+		}
+
+		expressionUseList.get(key).add(expression);
+		super.addRelation(relation);
+	}
 
+	private boolean linkedExpr(Expression a, Expression b) {
+		Expression parent = a.getParent();
+		while(parent!=null){
+			if (parent==b) return true;
+			parent = parent.getParent();
+		}
+		parent = b.getParent();
+		while(parent!=null){
+			if (parent==a) return true;
+			parent = parent.getParent();
+		}
+		return  false;
+	}
 }

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -271,4 +271,5 @@ public abstract class Entity {
 	public Location getLocation() {
 		return this.location;
 	}
+
 }

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -51,6 +51,7 @@ public class Expression implements Serializable{
 	private boolean isStatement = false; //statement is only used for return type calcuation in some langs such as ruby
     									//they will not be treat as real expressions in case of relation calculation
 	private boolean deriveTypeFromChild = true;
+
 	private Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 
 	private Integer parentId = -1; 

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -1,35 +1,19 @@
 package depends.extractor.python.union;
 
+import depends.entity.*;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.HandlerContext;
 import depends.extractor.python.PythonHandlerContext;
-import depends.extractor.python.PythonParser.Assert_stmtContext;
-import depends.extractor.python.PythonParser.AtomContext;
-import depends.extractor.python.PythonParser.Del_stmtContext;
-import depends.extractor.python.PythonParser.ExprContext;
-import depends.extractor.python.PythonParser.Expr_stmtContext;
-import depends.extractor.python.PythonParser.Raise_stmtContext;
-import depends.extractor.python.PythonParser.Return_stmtContext;
-import depends.extractor.python.PythonParser.Testlist_star_exprContext;
-import depends.extractor.python.PythonParser.TrailerContext;
-import depends.extractor.python.PythonParser.Yield_stmtContext;
+import depends.extractor.python.PythonParser.*;
 import depends.extractor.python.PythonParserBaseVisitor;
 import depends.relations.Inferer;
+import org.antlr.v4.runtime.ParserRuleContext;
+import org.antlr.v4.runtime.RuleContext;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-
-import org.antlr.v4.runtime.ParserRuleContext;
-import org.antlr.v4.runtime.RuleContext;
-
-import depends.entity.Entity;
-import depends.entity.Expression;
-import depends.entity.FunctionEntity;
-import depends.entity.GenericName;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
-import depends.entity.repo.IdGenerator;
-import depends.extractor.HandlerContext;
 public class ExpressionUsage {
 	HandlerContext context;
 	IdGenerator idGenerator;
@@ -82,6 +66,7 @@ public class ExpressionUsage {
 		}else {
 			/* create expression and link it with parent*/
 			expression = new Expression(idGenerator.generateId());
+
 			expression.setText(ctx.getText());
 			context.lastContainer().addExpression(ctx,expression);
 			expression.setParent(parent);

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -24,37 +24,16 @@ SOFTWARE.
 
 package depends.extractor.ruby.jruby;
 
-import java.util.List;
-
-import org.jrubyparser.ast.AndNode;
-import org.jrubyparser.ast.AssignableNode;
-import org.jrubyparser.ast.BlockNode;
-import org.jrubyparser.ast.ClassVarNode;
-import org.jrubyparser.ast.Colon3Node;
-import org.jrubyparser.ast.ConstNode;
-import org.jrubyparser.ast.FCallNode;
-import org.jrubyparser.ast.FalseNode;
-import org.jrubyparser.ast.GlobalVarNode;
-import org.jrubyparser.ast.ILiteralNode;
-import org.jrubyparser.ast.InstVarNode;
-import org.jrubyparser.ast.ListNode;
-import org.jrubyparser.ast.LocalVarNode;
-import org.jrubyparser.ast.NewlineNode;
-import org.jrubyparser.ast.Node;
-import org.jrubyparser.ast.OrNode;
-import org.jrubyparser.ast.ReturnNode;
-import org.jrubyparser.ast.RootNode;
-import org.jrubyparser.ast.TrueNode;
-import org.jrubyparser.ast.VCallNode;
-
 import depends.entity.ContainerEntity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
-import depends.entity.GenericName;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.ruby.RubyHandlerContext;
 import depends.relations.Inferer;
+import org.jrubyparser.ast.*;
+
+import java.util.List;
 
 public class ExpressionUsage {
 	RubyHandlerContext context;

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -112,7 +112,9 @@ public class RelationCounter {
 		if (referredEntity==null) {
 			return;
 		}
-
+		if (referredEntity.getId()<0){
+			return;
+		}
 		if (referredEntity instanceof MultiDeclareEntities) {
 			for (Entity e:((MultiDeclareEntities)referredEntity).getEntities()) {
 				addRelationFromExpression(entity,expression,e);
@@ -124,14 +126,18 @@ public class RelationCounter {
 		if (expression.isCall()) {
 			/* if it is a FunctionEntityProto, add Relation to all Impl Entities*/
 			if (callAsImpl && referredEntity instanceof FunctionEntityProto) {
-				Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
-				if (multiDeclare instanceof MultiDeclareEntities) {
-					MultiDeclareEntities m = (MultiDeclareEntities)multiDeclare;
-					List<Entity> entities = m.getEntities().stream().filter(item->(item instanceof FunctionEntityImpl))
-					.collect(Collectors.toList());
-					for (Entity e:entities) {
-						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e,expression.getLocation()));
-						matched = true;
+				if (entity.getAncestorOfType(FileEntity.class).getId().equals(referredEntity.getAncestorOfType(FileEntity.class).getId())){
+					entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity,expression.getLocation()));
+				}else {
+					Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
+					if (multiDeclare instanceof MultiDeclareEntities) {
+						MultiDeclareEntities m = (MultiDeclareEntities) multiDeclare;
+						List<Entity> entities = m.getEntities().stream().filter(item -> (item instanceof FunctionEntityImpl))
+								.collect(Collectors.toList());
+						for (Entity e : entities) {
+							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation()));
+							matched = true;
+						}
 					}
 				}
 			}
@@ -154,18 +160,22 @@ public class RelationCounter {
 		if (!matched)  {
 			if (callAsImpl && repo.getEntity(referredEntity.getQualifiedName()) instanceof MultiDeclareEntities &&
 					(referredEntity instanceof VarEntity ||referredEntity instanceof FunctionEntity)) {
-				MultiDeclareEntities m =  (MultiDeclareEntities)(repo.getEntity(referredEntity.getQualifiedName()));
-				for (Entity e:m.getEntities()) {
-					if (e==referredEntity) {
-						entity.addRelation(buildRelation(entity,DependencyType.USE,e,expression.getLocation()));
-					}else {
-						entity.addRelation(buildRelation(entity,DependencyType.IMPLLINK,e,expression.getLocation()));
+				if (entity.getAncestorOfType(FileEntity.class).getId().equals(referredEntity.getAncestorOfType(FileEntity.class).getId())){
+					entity.addRelation(buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation()));
+				}else {
+					MultiDeclareEntities m = (MultiDeclareEntities) (repo.getEntity(referredEntity.getQualifiedName()));
+					for (Entity e : m.getEntities()) {
+						if (e == referredEntity) {
+							entity.addRelation(expression, buildRelation(entity, DependencyType.USE, e, expression.getLocation()));
+						} else {
+							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation()));
+						}
+						matched = true;
 					}
-					matched = true;
 				}
 			}
 			else {
-				entity.addRelation(buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation()));
+				entity.addRelation(expression,buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation()));
 			}
 		}
 	}

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -1,11 +1,12 @@
 package depends.extractor.cpp;
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
-import depends.entity.Entity;
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
 
 public class CppExpressionTest extends CppParserTest{
     @Before
@@ -31,4 +32,13 @@ public class CppExpressionTest extends CppParserTest{
         this.assertContainsRelation(e, DependencyType.CONTAIN,"ClassA");
 	}
 
+	@Test
+    public void test_should_not_count_expr_duplicated() throws IOException {
+        String src = "./src/test/resources/cpp-code-examples/DupExpressions.cpp";
+        CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        Entity e = repo.getEntity("foo");
+        assertEquals(4,e.getRelations().size());
+    }
 }

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -1,14 +1,11 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.relations.Inferer;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
 
 public class MacroRelationTest extends CppParserTest{
     @Before
@@ -31,7 +28,6 @@ public class MacroRelationTest extends CppParserTest{
 	    Entity e = repo.getEntity("foo");
 	    this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
 	    this.assertContainsRelation(e, DependencyType.CONTAIN, Inferer.buildInType.getQualifiedName());
-	    this.assertContainsRelation(e, DependencyType.USE, Inferer.buildInType.getQualifiedName());
 	}
 	
 	

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -40,7 +40,7 @@ public class RelationInSameFileTest extends CppParserTest{
 	    		matchCount++;
 	    	}
 	    }
-	    assertEquals(2, matchCount);
+	    assertEquals(1, matchCount);
 	}
 	
 

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -1,19 +1,15 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.entity.FunctionEntityImpl;
 import depends.entity.FunctionEntityProto;
 import depends.entity.VarEntity;
 import depends.relations.Relation;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
 
 public class RelationToImplementationTest extends CppParserTest{
     @Before

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -1,17 +1,16 @@
 package depends.extractor.java;
 
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
 
 public class JavaVarResolveTest extends JavaParserTest{
 	@Before
@@ -86,7 +85,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(13,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
+        assertEquals(10,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
 	@Test

1e1fd70dfc0a05b97d5a41ea1dc407868397d722
@@ -1,14 +1,14 @@
 package depends.extractor.cpp;
 
-import java.util.HashMap;
-import java.util.Map;
-
-import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
-
 import depends.entity.repo.EntityRepo;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Element;
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
+import org.eclipse.cdt.core.dom.ast.IMacroBinding;
+
+import java.util.HashMap;
+import java.util.Map;
 
 public class MacroEhcacheRepo extends MacroRepo {
 	private EntityRepo entityRepo;
@@ -44,7 +44,7 @@ public class MacroEhcacheRepo extends MacroRepo {
 		Map<String, String> macros = get(fileFullPath);
 		macros.putAll(macroMap);
 		for (IASTPreprocessorMacroDefinition def : macroDefinitions) {
-			macros.put(def.getName().toString(), new String(def.getExpansion()));
+			macros.put(((IMacroBinding)def.getName().resolveBinding()).toString(), new String(def.getExpansion()));
 		}
 		Element cacheElement = new Element(buildKey(fileId), macros);
 		cache.put(cacheElement);

1e1fd70dfc0a05b97d5a41ea1dc407868397d722
@@ -1,17 +1,13 @@
 package depends.extractor.cpp;
 
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
-
 import depends.entity.repo.EntityRepo;
 import multilang.depends.util.file.TemporaryFile;
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
+import org.eclipse.cdt.core.dom.ast.IMacroBinding;
+
+import java.io.*;
+import java.util.HashMap;
+import java.util.Map;
 
 public class MacroFileRepo extends MacroRepo{
 	private EntityRepo entityRepo;
@@ -49,7 +45,7 @@ public class MacroFileRepo extends MacroRepo{
 		Map<String, String> macros = get(fileFullPath);
 		macros.putAll(macroMap);
 		for (IASTPreprocessorMacroDefinition def:macroDefinitions) {
-			macros.put(def.getName().toString(), new String(def.getExpansion()));
+			macros.put(((IMacroBinding)def.getName().resolveBinding()).toString(), new String(def.getExpansion()));
 		}
 		
 		try {

1e1fd70dfc0a05b97d5a41ea1dc407868397d722
@@ -1,10 +1,11 @@
 package depends.extractor.cpp;
 
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
+import org.eclipse.cdt.core.dom.ast.IMacroBinding;
+
 import java.util.HashMap;
 import java.util.Map;
 
-import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
-
 public class MacroMemoryRepo extends MacroRepo{
 
 	private Map<String, Map<String, String>> fileMacroDefinition = new HashMap<>();
@@ -19,7 +20,7 @@ public class MacroMemoryRepo extends MacroRepo{
 	private void put(String file, IASTPreprocessorMacroDefinition[] macroDefinitions) {
 		Map<String, String> macros = new HashMap<>();
 		for (IASTPreprocessorMacroDefinition def:macroDefinitions) {
-			macros.put(def.getName().toString().intern(), new String(def.getExpansion()).intern());
+			macros.put(((IMacroBinding)def.getName().resolveBinding()).toString(), new String(def.getExpansion()).intern());
 		}
 		Map<String, String>  existingMacros = fileMacroDefinition.get(file);
 		if (existingMacros==null)

1e1fd70dfc0a05b97d5a41ea1dc407868397d722
@@ -1,12 +1,11 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
+import depends.extractor.cpp.cdt.CdtCppFileParser;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.entity.Entity;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
 
 public class ParseErrorTest extends CppParserTest{
     @Before
@@ -26,5 +25,21 @@ public class ParseErrorTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
 	}
+
+	@Test
+	public void macro_definition() throws IOException {
+		String[] srcs = new String[] {
+				"./src/test/resources/cpp-code-examples/parseError/macro.c",
+		};
+
+		for (String src:srcs) {
+			CdtCppFileParser parser = (CdtCppFileParser)createParser(src);
+
+			Map<String, String> macroMap = new HashMap<>();
+			macroMap.put("AP_DECLARE(x)","x");
+			parser.parse(true,macroMap);
+		}
+		inferer.resolveAllBindings();
+	}
 	
 }

02e3a87f3d519ae49a7eceaa2c102040028a4905
@@ -0,0 +1,132 @@
+package depends.extractor.golang;
+
+import org.antlr.v4.runtime.*;
+
+import java.util.List;
+
+/**
+ * All parser methods that used in grammar (p, prev, notLineTerminator, etc.)
+ * should start with lower case char similar to parser rules.
+ */
+public abstract class GoParserBase extends Parser
+{
+    protected GoParserBase(TokenStream input) {
+        super(input);
+    }
+
+    /**
+     * Returns {@code true} iff on the current index of the parser's
+     * token stream a token exists on the {@code HIDDEN} channel which
+     * either is a line terminator, or is a multi line comment that
+     * contains a line terminator.
+     *
+     * @return {@code true} iff on the current index of the parser's
+     * token stream a token exists on the {@code HIDDEN} channel which
+     * either is a line terminator, or is a multi line comment that
+     * contains a line terminator.
+     */
+    protected boolean lineTerminatorAhead() {
+        // Get the token ahead of the current index.
+        int possibleIndexEosToken = this.getCurrentToken().getTokenIndex() - 1;
+
+        if (possibleIndexEosToken == -1)
+        {
+            return true;
+        }
+
+        Token ahead = _input.get(possibleIndexEosToken);
+        if (ahead.getChannel() != Lexer.HIDDEN) {
+            // We're only interested in tokens on the HIDDEN channel.
+            return false;
+        }
+
+        if (ahead.getType() == GoLexer.TERMINATOR) {
+            // There is definitely a line terminator ahead.
+            return true;
+        }
+
+        if (ahead.getType() == GoLexer.WS) {
+            // Get the token ahead of the current whitespaces.
+            possibleIndexEosToken = this.getCurrentToken().getTokenIndex() - 2;
+            ahead = _input.get(possibleIndexEosToken);
+        }
+
+        // Get the token's text and type.
+        String text = ahead.getText();
+        int type = ahead.getType();
+
+        // Check if the token is, or contains a line terminator.
+        return (type == GoLexer.COMMENT && (text.contains("\r") || text.contains("\n"))) ||
+                (type == GoLexer.TERMINATOR);
+    }
+
+     /**
+     * Returns {@code true} if no line terminator exists between the specified
+     * token offset and the prior one on the {@code HIDDEN} channel.
+     *
+     * @return {@code true} if no line terminator exists between the specified
+     * token offset and the prior one on the {@code HIDDEN} channel.
+     */
+    protected boolean noTerminatorBetween(int tokenOffset) {
+        BufferedTokenStream stream = (BufferedTokenStream)_input;
+        List<Token> tokens = stream.getHiddenTokensToLeft(stream.LT(tokenOffset).getTokenIndex());
+        
+        if (tokens == null) {
+            return true;
+        }
+
+        for (Token token : tokens) {
+            if (token.getText().contains("\n"))
+                return false;
+        }
+
+        return true;
+    }
+
+     /**
+     * Returns {@code true} if no line terminator exists after any encounterd
+     * parameters beyond the specified token offset and the next on the
+     * {@code HIDDEN} channel.
+     *
+     * @return {@code true} if no line terminator exists after any encounterd
+     * parameters beyond the specified token offset and the next on the
+     * {@code HIDDEN} channel.
+     */
+    protected boolean noTerminatorAfterParams(int tokenOffset) {
+        BufferedTokenStream stream = (BufferedTokenStream)_input;
+        int leftParams = 1;
+        int rightParams = 0;
+        int valueType;
+
+        if (stream.LT(tokenOffset).getType() == GoLexer.L_PAREN) {
+            // Scan past parameters
+            while (leftParams != rightParams) {
+                tokenOffset++;
+                valueType = stream.LT(tokenOffset).getType();
+
+                if (valueType == GoLexer.L_PAREN){
+                    leftParams++;
+                }
+                else if (valueType == GoLexer.R_PAREN) {
+                    rightParams++;
+                }
+            }
+
+            tokenOffset++;
+            return noTerminatorBetween(tokenOffset);
+        }
+
+        return true;
+    }
+
+    protected boolean checkPreviousTokenText(String text)
+    {
+        BufferedTokenStream stream = (BufferedTokenStream)_input;
+        String prevTokenText = stream.LT(1).getText();
+        
+        if (prevTokenText == null)
+            return false;
+        
+        return prevTokenText.equals(text);
+    }
+}

02e3a87f3d519ae49a7eceaa2c102040028a4905
@@ -1,13 +1,12 @@
 package depends.extractor.python;
 
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.extractor.python.union.PythonFileParser;
+import org.junit.Before;
+import org.junit.Ignore;
+
+import java.io.IOException;
 
 public class PythonGlobalVarTest extends PythonParserTest {
     @Before
@@ -15,7 +14,7 @@ public class PythonGlobalVarTest extends PythonParserTest {
     	super.init();
     }
 	
-	@Test
+	@Ignore
 	public void should_detect_global_reference() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/python-code-examples/global_test/file1.py",

9188affd5288882270795e341e9ef9a4979f03f3
@@ -24,25 +24,17 @@ SOFTWARE.
 
 package depends.extractor;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Stack;
-import java.util.stream.Collectors;
-
-import depends.entity.AliasEntity;
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.FunctionEntity;
-import depends.entity.PackageEntity;
-import depends.entity.GenericName;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
+import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.IdGenerator;
 import depends.importtypes.Import;
 import depends.relations.Inferer;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Stack;
+import java.util.stream.Collectors;
+
 public abstract class HandlerContext {
 	protected EntityRepo entityRepo;
 	protected IdGenerator idGenerator;
@@ -307,9 +299,9 @@ public abstract class HandlerContext {
 		return varEntity;
 	}
 
-	public void foundEnumConstDefinition(String varName) {
+	public VarEntity foundEnumConstDefinition(String varName) {
 		GenericName type = lastContainer().getRawName();
-		foundVarDefinition(varName,type,new ArrayList<>());
+		return foundVarDefinition(varName,type,new ArrayList<>());
 	}
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();

9188affd5288882270795e341e9ef9a4979f03f3
@@ -24,53 +24,22 @@ SOFTWARE.
 
 package depends.extractor.java;
 
-import java.util.ArrayList;
-import java.util.List;
-
-import depends.entity.FunctionEntity;
-import depends.entity.GenericName;
-import depends.entity.VarEntity;
+import depends.entity.*;
 import depends.entity.repo.EntityRepo;
-import depends.extractor.java.JavaParser.AnnotationConstantRestContext;
-import depends.extractor.java.JavaParser.AnnotationMethodRestContext;
-import depends.extractor.java.JavaParser.AnnotationTypeDeclarationContext;
-import depends.extractor.java.JavaParser.BlockContext;
-import depends.extractor.java.JavaParser.ClassBodyDeclarationContext;
-import depends.extractor.java.JavaParser.ClassDeclarationContext;
-import depends.extractor.java.JavaParser.ConstDeclarationContext;
-import depends.extractor.java.JavaParser.ConstructorDeclarationContext;
-import depends.extractor.java.JavaParser.EnhancedForControlContext;
-import depends.extractor.java.JavaParser.EnumConstantContext;
-import depends.extractor.java.JavaParser.EnumDeclarationContext;
-import depends.extractor.java.JavaParser.ExpressionContext;
-import depends.extractor.java.JavaParser.FieldDeclarationContext;
-import depends.extractor.java.JavaParser.ImportDeclarationContext;
-import depends.extractor.java.JavaParser.InterfaceBodyDeclarationContext;
-import depends.extractor.java.JavaParser.InterfaceDeclarationContext;
-import depends.extractor.java.JavaParser.InterfaceMethodDeclarationContext;
-import depends.extractor.java.JavaParser.LocalVariableDeclarationContext;
-import depends.extractor.java.JavaParser.MethodDeclarationContext;
-import depends.extractor.java.JavaParser.PackageDeclarationContext;
-import depends.extractor.java.JavaParser.ResourceContext;
-import depends.extractor.java.JavaParser.TypeDeclarationContext;
-import depends.extractor.java.JavaParser.TypeParameterContext;
-import depends.extractor.java.JavaParser.TypeParametersContext;
-import depends.extractor.java.context.AnnotationProcessor;
-import depends.extractor.java.context.ClassTypeContextHelper;
-import depends.extractor.java.context.ExpressionUsage;
-import depends.extractor.java.context.FormalParameterListContextHelper;
-import depends.extractor.java.context.IdentifierContextHelper;
-import depends.extractor.java.context.QualitiedNameContextHelper;
-import depends.extractor.java.context.TypeParameterContextHelper;
-import depends.extractor.java.context.VariableDeclaratorsContextHelper;
+import depends.extractor.java.JavaParser.*;
+import depends.extractor.java.context.*;
 import depends.importtypes.ExactMatchImport;
 import depends.relations.Inferer;
+import org.antlr.v4.runtime.ParserRuleContext;
+
+import java.util.ArrayList;
+import java.util.List;
 
 public class JavaListener extends JavaParserBaseListener {
-	private JavaHandlerContext context;
-	private AnnotationProcessor annotationProcessor;
-	private ExpressionUsage expressionUsage;
-	private EntityRepo entityRepo;
+	private final JavaHandlerContext context;
+	private final AnnotationProcessor annotationProcessor;
+	private final ExpressionUsage expressionUsage;
+	private final EntityRepo entityRepo;
 
 	public JavaListener(String fileFullPath, EntityRepo entityRepo,Inferer inferer) {
 		this.context = new JavaHandlerContext(entityRepo,inferer);
@@ -88,6 +57,10 @@ public class JavaListener extends JavaParserBaseListener {
 		super.enterPackageDeclaration(ctx);
 	}
 
+	private void setLine(Entity entity, ParserRuleContext ctx) {
+		entity.setLine(ctx.getStart().getLine());
+	}
+
 	////////////////////////
 	// Import
 	@Override
@@ -103,7 +76,8 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterClassDeclaration(ClassDeclarationContext ctx) {
 		if (ctx.IDENTIFIER()==null) return;
-		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		setLine(entity,ctx);
 		// implements
 		if (ctx.typeList() != null) {
 			for (int i = 0; i < ctx.typeList().typeType().size(); i++) {
@@ -130,14 +104,16 @@ public class JavaListener extends JavaParserBaseListener {
 
 	@Override
 	public void enterEnumDeclaration(EnumDeclarationContext ctx) {
-		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		setLine(entity,ctx);
 		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterEnumDeclaration(ctx);
 	}
 
 	@Override
 	public void enterAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
-		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		setLine(entity,ctx);
 		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterAnnotationTypeDeclaration(ctx);
 	}
@@ -154,7 +130,8 @@ public class JavaListener extends JavaParserBaseListener {
 	 */
 	@Override
 	public void enterInterfaceDeclaration(InterfaceDeclarationContext ctx) {
-		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
+		setLine(entity,ctx);
 		// type parameters
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
@@ -191,6 +168,7 @@ public class JavaListener extends JavaParserBaseListener {
 		String methodName = ctx.IDENTIFIER().getText();
 		String returnedType = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
 		FunctionEntity method = context.foundMethodDeclarator(methodName, returnedType, throwedType);
+		setLine(method,ctx);
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		if (ctx.typeParameters() != null) {
 			List<GenericName> parameters = TypeParameterContextHelper.getTypeParameters(ctx.typeParameters());
@@ -219,6 +197,7 @@ public class JavaListener extends JavaParserBaseListener {
 		List<String> throwedType = QualitiedNameContextHelper.getNames(ctx.qualifiedNameList());
 		FunctionEntity method = context.foundMethodDeclarator(ctx.IDENTIFIER().getText(),
 				ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid()), throwedType);
+		setLine(method,ctx);
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
@@ -238,6 +217,7 @@ public class JavaListener extends JavaParserBaseListener {
 		List<String> throwedType = QualitiedNameContextHelper.getNames(ctx.qualifiedNameList());
 		FunctionEntity method = context.foundMethodDeclarator(ctx.IDENTIFIER().getText(), ctx.IDENTIFIER().getText(),
 				throwedType);
+		setLine(method,ctx);
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		method.addReturnType(context.currentType());
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",context.lastContainer());
@@ -258,6 +238,7 @@ public class JavaListener extends JavaParserBaseListener {
 		String type = ClassTypeContextHelper.getClassName(ctx.typeType());
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		List<VarEntity> vars = context.foundVarDefinitions(varNames, type,typeArguments);
+		vars.forEach(var->setLine(var,ctx));
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterFieldDeclaration(ctx);
 	}
@@ -269,21 +250,26 @@ public class JavaListener extends JavaParserBaseListener {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
 				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
+		vars.forEach(var->setLine(var,ctx));
+
 		annotationProcessor.processAnnotationModifier(ctx, InterfaceBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterConstDeclaration(ctx);
 	}
 
 	@Override
 	public void enterEnumConstant(EnumConstantContext ctx) {
-		if (ctx.IDENTIFIER() != null)
-			context.foundEnumConstDefinition(ctx.IDENTIFIER().getText());
+		if (ctx.IDENTIFIER() != null) {
+			VarEntity var = context.foundEnumConstDefinition(ctx.IDENTIFIER().getText());
+			setLine(var,ctx);
+		}
 		super.enterEnumConstant(ctx);
 	}
 
 	@Override
 	public void enterAnnotationMethodRest(AnnotationMethodRestContext ctx) {
-		context.foundMethodDeclarator(ctx.IDENTIFIER().getText(), ClassTypeContextHelper.getClassName(ctx.typeType()),
+		FunctionEntity func = context.foundMethodDeclarator(ctx.IDENTIFIER().getText(), ClassTypeContextHelper.getClassName(ctx.typeType()),
 				new ArrayList<>());
+		setLine(func,ctx);
 		super.enterAnnotationMethodRest(ctx);
 	}
 
@@ -296,7 +282,8 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterAnnotationConstantRest(AnnotationConstantRestContext ctx) {
 		// TODO: no variable type defined in annotation const？
-		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators()), "",new ArrayList<>());
+		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators()), "", new ArrayList<>());
+		vars.forEach(var->setLine(var,ctx));
 		super.enterAnnotationConstantRest(ctx);
 	}
 
@@ -306,15 +293,19 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterLocalVariableDeclaration(LocalVariableDeclarationContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
-				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
+		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
+				ClassTypeContextHelper.getClassName(ctx.typeType()), typeArguments);
+		vars.forEach(var->setLine(var,ctx));
+
 		super.enterLocalVariableDeclaration(ctx);
 	}
 
 	public void enterEnhancedForControl(EnhancedForControlContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
-				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
+		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
+				ClassTypeContextHelper.getClassName(ctx.typeType()), typeArguments);
+		vars.forEach(var->setLine(var,ctx));
+
 		super.enterEnhancedForControl(ctx);
 	}
 
@@ -324,14 +315,16 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterResource(ResourceContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
-		context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
-				GenericName.build(IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER())),typeArguments);
+		VarEntity var = context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
+				GenericName.build(IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER())), typeArguments);
+		setLine(var,ctx);
 		super.enterResource(ctx);
 	}
 
 	@Override
 	public void enterExpression(ExpressionContext ctx) {
-		expressionUsage.foundExpression(ctx);
+		Expression expr = expressionUsage.foundExpression(ctx);
+		expr.setLine(ctx.getStart().getLine());
 		super.enterExpression(ctx);
 	}
 

9188affd5288882270795e341e9ef9a4979f03f3
@@ -42,7 +42,7 @@ public class ExpressionUsage {
 		this.idGenerator = idGenerator;
 	}
 
-	public void foundExpression(ExpressionContext ctx) {
+	public Expression foundExpression(ExpressionContext ctx) {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());
@@ -53,7 +53,7 @@ public class ExpressionUsage {
 		
 		if (ctx.primary()!=null) {
 			tryFillExpressionTypeAndIdentifier(ctx.primary(),expression);
-			return;
+			return expression;
 		}
 		
 		expression.setSet (isSet(ctx));
@@ -112,8 +112,9 @@ public class ExpressionUsage {
 				expression.setIdentifier(ctx.innerCreator().IDENTIFIER().getText());
 			else if (ctx.SUPER()!=null)
 				expression.setIdentifier("super");
-			return;
+			return expression;
 		}
+		return expression;
 	}
 
 	private GenericName getMethodCallIdentifier(MethodCallContext methodCall) {

190b575301a535680fb631f4af6d01dc47ce94a9
@@ -29,7 +29,6 @@ public class ExpressionUsage {
 	 * Auto deduce variable type from assignment. for example: c = new C() then c is
 	 * type of C
 	 * 
-	 * @param node
 	 */
 	private void deduceVarTypeInCaseOfAssignment(Expr_stmtContext expr, Expression expression) {
 		List<String> names = getName(expr.testlist_star_expr());
@@ -66,6 +65,7 @@ public class ExpressionUsage {
 		}else {
 			/* create expression and link it with parent*/
 			expression = new Expression(idGenerator.generateId());
+			expression.setLine(ctx.getStart().getLine());
 
 			expression.setText(ctx.getText());
 			context.lastContainer().addExpression(ctx,expression);
@@ -79,7 +79,7 @@ public class ExpressionUsage {
 				expression.setSet(true);
 				expression.setIdentifier(exprAssign.testlist_star_expr().getText());
 				if (isValidIdentifier(expression.getIdentifier())) {
-					makeSureVarExist(expression.getIdentifier());
+					makeSureVarExist(expression.getIdentifier(), ctx);
 				}
 				deduceVarTypeInCaseOfAssignment((Expr_stmtContext)ctx,expression);
 			}
@@ -104,9 +104,11 @@ public class ExpressionUsage {
 	}
 
 
-	private void makeSureVarExist(GenericName identifier) {
+	private void makeSureVarExist(GenericName identifier, ParserRuleContext ctx) {
 		if (null==context.foundEntityWithName(identifier)) {
-			context.foundVarDefinition(context.lastContainer(), identifier.getName());
+			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName());
+			var.setLine(ctx.getStart().getLine());
+
 		}
 	}
 
@@ -124,6 +126,7 @@ public class ExpressionUsage {
 		if (exprCtx.atom()!=null) {
 			//atom
 			Expression atomExpr = new Expression(idGenerator.generateId());
+			atomExpr.setLine(exprCtx.atom().getStart().getLine());
 			atomExpr.setParent(expression);
 			atomExpr.setText(exprCtx.atom().getText());
 			atomExpr.setIdentifier(exprCtx.atom().getText());
@@ -136,6 +139,7 @@ public class ExpressionUsage {
 				for (TrailerContext trailer:exprCtx.trailer()) {
 					if (trailer.name()!=null) {
 						Expression trailerExpr = new Expression(idGenerator.generateId());
+						trailerExpr.setLine(trailer.getStart().getLine());
 						trailerExpr.setText(trailer.getText());
 						context.lastContainer().addExpression(trailer,trailerExpr);
 						trailerExpr.setParent(expression);
@@ -145,7 +149,7 @@ public class ExpressionUsage {
 						trailerExpr.setIdentifier(trailer.name().getText());
 						if (trailer.arguments()!=null) {
 							if (trailer.arguments().OPEN_PAREN()!=null) {
-								foundCallStyleExpressionWithDot(trailerExpr,lastExpression.getIdentifier());
+								foundCallStyleExpressionWithDot(trailerExpr,lastExpression.getIdentifier(), trailer);
 							}else {
 								//subscript list, do nothing
 							}
@@ -156,7 +160,7 @@ public class ExpressionUsage {
 						//direct call, or direct data access
 						if (trailer.arguments()!=null) {
 							if (trailer.arguments().OPEN_PAREN()!=null) {
-								foundCallStyleExpressionWithoutDot(lastExpression);
+								foundCallStyleExpressionWithoutDot(lastExpression, trailer.arguments());
 							}else {
 								//subscript list, do nothing
 							}
@@ -194,7 +198,7 @@ public class ExpressionUsage {
 
 
 
-	private void foundCallStyleExpressionWithDot(Expression theExpression, GenericName varName) {
+	private void foundCallStyleExpressionWithDot(Expression theExpression, GenericName varName, ParserRuleContext ctx) {
 		GenericName funcName = theExpression.getIdentifier();
 		Entity prefixEntity = context.foundEntityWithName(varName);
 		if (prefixEntity instanceof VarEntity) {
@@ -212,7 +216,7 @@ public class ExpressionUsage {
 
 
 
-	private void foundCallStyleExpressionWithoutDot(Expression theExpression) {
+	private void foundCallStyleExpressionWithoutDot(Expression theExpression, ParserRuleContext ctx) {
 		GenericName funcName = theExpression.getIdentifier();
 		Entity typeEntity = context.foundEntityWithName(funcName);
 		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {

190b575301a535680fb631f4af6d01dc47ce94a9
@@ -1,48 +1,21 @@
 package depends.extractor.python.union;
 
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.antlr.v4.runtime.ParserRuleContext;
-
-import depends.entity.ContainerEntity;
-import depends.entity.DecoratedEntity;
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.GenericName;
-import depends.entity.PackageEntity;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
+import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.python.NameAliasImport;
 import depends.extractor.python.PythonHandlerContext;
-import depends.extractor.python.PythonParser.ArglistContext;
-import depends.extractor.python.PythonParser.Assert_stmtContext;
-import depends.extractor.python.PythonParser.Class_or_func_def_stmtContext;
-import depends.extractor.python.PythonParser.ClassdefContext;
-import depends.extractor.python.PythonParser.DecoratorContext;
-import depends.extractor.python.PythonParser.Def_parameterContext;
-import depends.extractor.python.PythonParser.Def_parametersContext;
-import depends.extractor.python.PythonParser.Del_stmtContext;
-import depends.extractor.python.PythonParser.Dotted_as_nameContext;
-import depends.extractor.python.PythonParser.Dotted_nameContext;
-import depends.extractor.python.PythonParser.Expr_stmtContext;
-import depends.extractor.python.PythonParser.From_stmtContext;
-import depends.extractor.python.PythonParser.FuncdefContext;
-import depends.extractor.python.PythonParser.Global_stmtContext;
-import depends.extractor.python.PythonParser.Import_as_nameContext;
-import depends.extractor.python.PythonParser.Import_stmtContext;
-import depends.extractor.python.PythonParser.NameContext;
-import depends.extractor.python.PythonParser.Raise_stmtContext;
-import depends.extractor.python.PythonParser.Return_stmtContext;
-import depends.extractor.python.PythonParser.Yield_stmtContext;
+import depends.extractor.python.PythonParser.*;
 import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.importtypes.FileImport;
 import depends.relations.Inferer;
 import multilang.depends.util.file.FileUtil;
+import org.antlr.v4.runtime.ParserRuleContext;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 public class PythonCodeListener extends PythonParserBaseListener{
 	private PythonHandlerContext context;
@@ -225,8 +198,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		if (name!=null) {
 			functionName = name;
 		}
-		
-		context.foundMethodDeclarator(functionName);
+
+		FunctionEntity method = context.foundMethodDeclarator(functionName);
+		method.setLine(ctx.getStart().getLine());
 		if (ctx.typedargslist()!=null) {
 			List<String> parameters = getParameterList(ctx.typedargslist().def_parameters());
 			for (String param : parameters) {
@@ -250,6 +224,8 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	public void enterClassdef(ClassdefContext ctx) {
 		String name = getName(ctx.name());
 		TypeEntity type = context.foundNewType(name);
+		type.setLine(ctx.getStart().getLine());
+
 		List<String> baseClasses = getArgList(ctx.arglist());
 		baseClasses.forEach(base -> type.addExtends(GenericName.build(base)));
 
@@ -309,6 +285,8 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		String decoratedName = getDecoratedName(ctx);
 		if (decoratedName!=null) {
 			Entity entity = context.foundEntityWithName(GenericName.build(decoratedName));
+			entity.setLine(ctx.getStart().getLine());
+
 			if (entity instanceof DecoratedEntity) {
 				for (DecoratorContext decorator: ctx.decorator()) {
 					String decoratorName = getName(decorator.dotted_name());
@@ -323,7 +301,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	@Override
 	public void enterGlobal_stmt(Global_stmtContext ctx) {
 		for (NameContext name:ctx.name()){
-			context.foundGlobalVarDefinition(context.currentFile(),name.getText());
+			VarEntity var = context.foundGlobalVarDefinition(context.currentFile(), name.getText());
+			var.setLine(ctx.getStart().getLine());
+
 		}
 		super.enterGlobal_stmt(ctx);
 	}

3daeed23bc01306f5ec1ad860d0c1d564c2d949d
@@ -1,13 +1,12 @@
 package depends.extractor.python;
 
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.extractor.python.union.PythonFileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
 
 public class PythonGlobalVarTest extends PythonParserTest {
     @Before
@@ -28,7 +27,7 @@ public class PythonGlobalVarTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings(true,null);
         Entity foo = repo.getEntity(withPackageName(srcs[0],"foo"));
-        this.assertContainsRelation(foo, DependencyType.IMPLLINK, "global_var");
+        this.assertContainsRelation(foo, DependencyType.USE, "global_var");
 	}
 	
 

36174edb716bdf9b12181f883ed8dbdf80aba4ae
@@ -61,22 +61,24 @@ public abstract class HandlerContext {
 		entityRepo.addFile(this.currentFile());
 	}
 
-	public TypeEntity foundNewType(GenericName name) {
+	public TypeEntity foundNewType(GenericName name, Integer startLine) {
 		TypeEntity currentTypeEntity = new TypeEntity(name, this.latestValidContainer(),
 				idGenerator.generateId());
-			pushToStack(currentTypeEntity);
-			addToRepo(currentTypeEntity);
-		 	currentFileEntity.addType(currentTypeEntity);
-			return currentTypeEntity;		
+		currentTypeEntity.setLine(startLine);
+		pushToStack(currentTypeEntity);
+		addToRepo(currentTypeEntity);
+		currentFileEntity.addType(currentTypeEntity);
+		return currentTypeEntity;
 	}
 	
 	/**
 	 * Tell the context object that a new type founded.
 	 * @param name
+	 * @param startLine
 	 * @return
 	 */
-	public TypeEntity foundNewType(String name) {
-		return foundNewType(GenericName.build(name));
+	public TypeEntity foundNewType(String name, Integer startLine) {
+		return foundNewType(GenericName.build(name),startLine);
 	}
 
 	public AliasEntity foundNewAlias(String aliasName, String originalName) {
@@ -105,9 +107,10 @@ public abstract class HandlerContext {
 	 * @param throwedType - if no throwed type information avaliable, keep it as empty list;  
 	 * @return the new function enity
 	 */
-	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
+	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType, Integer startLine) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
 				idGenerator.generateId(),GenericName.build(returnType));
+		functionEntity.setLine(startLine);
 		addToRepo(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
@@ -115,19 +118,10 @@ public abstract class HandlerContext {
 		return functionEntity;
 	}
 	
-	public FunctionEntity foundMethodDeclarator(String methodName, GenericName returnType, List<String> throwedType) {
-		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
-				idGenerator.generateId(),returnType);
-		addToRepo(functionEntity);
-		this.typeOrFileContainer().addFunction(functionEntity);
-		pushToStack(functionEntity);
-		functionEntity.addThrowTypes(throwedType.stream().map(item->GenericName.build(item)).collect(Collectors.toList()));
-		return functionEntity;
-	}
-	
-	public FunctionEntity foundMethodDeclarator(String methodName) {
+	public FunctionEntity foundMethodDeclarator(String methodName, Integer startLine) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
 				idGenerator.generateId(),null);
+		functionEntity.setLine(startLine);
 		addToRepo(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
@@ -135,9 +129,10 @@ public abstract class HandlerContext {
 	}
 
 	
-	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName) {
+	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName, Integer startLine) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), containerEntity,
 				idGenerator.generateId(),null);
+		functionEntity.setLine(startLine);
 		addToRepo(functionEntity);
 		containerEntity.addFunction(functionEntity);
 		pushToStack(functionEntity);
@@ -215,10 +210,6 @@ public abstract class HandlerContext {
 		return null;
 	}
 
-	public void foundAnnotation(String name) {
-		lastContainer().addAnnotation(GenericName.build(name));
-	}
-
 	public void foundImplements(GenericName typeName) {
 		currentType().addImplements(typeName);
 	}
@@ -250,11 +241,11 @@ public abstract class HandlerContext {
 	}
 
 
-	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericName> typeArguments) {
-		return varNames.stream().map(item->foundVarDefinition(item,GenericName.build(type),typeArguments)).collect(Collectors.toList());
+	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericName> typeArguments, Integer line) {
+		return varNames.stream().map(item->foundVarDefinition(item,GenericName.build(type),typeArguments,line)).collect(Collectors.toList());
 	}
 	
-	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
+	public VarEntity foundVarDefinition(ContainerEntity container,String varName,Integer line) {
 		if (container==null) {
 			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
 			container = currentFile();
@@ -263,13 +254,14 @@ public abstract class HandlerContext {
 		VarEntity var = getVarInLocalFile(container,GenericName.build(varName));
 		if (var!=null) return var;
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
+		var.setLine(line);
 		container.addVar(var);
 		addToRepo(var);
 
 		return var;
 	}
 	
-	public VarEntity foundGlobalVarDefinition(ContainerEntity container,String varName) {
+	public VarEntity foundGlobalVarDefinition(ContainerEntity container,String varName,Integer line) {
 		if (container==null) {
 			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
 			container = currentFile();
@@ -279,13 +271,15 @@ public abstract class HandlerContext {
 		if (var!=null) return var;
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
 		container.addVar(var);
+		var.setLine(line);
 		var.setQualifiedName(var.getRawName().toString());
 		addToRepo(var);
 		return var;
 	}
 
-	public VarEntity foundVarDefinition(String varName, GenericName type, List<GenericName> typeArguments) {
+	public VarEntity foundVarDefinition(String varName, GenericName type, List<GenericName> typeArguments,Integer line) {
 		VarEntity var = new VarEntity(GenericName.build(varName), type, lastContainer(), idGenerator.generateId());
+		var.setLine(line);
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);	
 		addToRepo(var);
@@ -299,9 +293,9 @@ public abstract class HandlerContext {
 		return varEntity;
 	}
 
-	public VarEntity foundEnumConstDefinition(String varName) {
+	public VarEntity foundEnumConstDefinition(String varName,Integer line) {
 		GenericName type = lastContainer().getRawName();
-		return foundVarDefinition(varName,type,new ArrayList<>());
+		return foundVarDefinition(varName,type,new ArrayList<>(),line);
 	}
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();

36174edb716bdf9b12181f883ed8dbdf80aba4ae
@@ -30,7 +30,6 @@ import depends.extractor.java.JavaParser.*;
 import depends.extractor.java.context.*;
 import depends.importtypes.ExactMatchImport;
 import depends.relations.Inferer;
-import org.antlr.v4.runtime.ParserRuleContext;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -57,9 +56,6 @@ public class JavaListener extends JavaParserBaseListener {
 		super.enterPackageDeclaration(ctx);
 	}
 
-	private void setLine(Entity entity, ParserRuleContext ctx) {
-		entity.setLine(ctx.getStart().getLine());
-	}
 
 	////////////////////////
 	// Import
@@ -76,8 +72,7 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterClassDeclaration(ClassDeclarationContext ctx) {
 		if (ctx.IDENTIFIER()==null) return;
-		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
-		setLine(entity,ctx);
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()), ctx.getStart().getLine());
 		// implements
 		if (ctx.typeList() != null) {
 			for (int i = 0; i < ctx.typeList().typeType().size(); i++) {
@@ -104,16 +99,14 @@ public class JavaListener extends JavaParserBaseListener {
 
 	@Override
 	public void enterEnumDeclaration(EnumDeclarationContext ctx) {
-		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
-		setLine(entity,ctx);
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()), ctx.getStart().getLine());
 		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterEnumDeclaration(ctx);
 	}
 
 	@Override
 	public void enterAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
-		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
-		setLine(entity,ctx);
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()), ctx.getStart().getLine());
 		annotationProcessor.processAnnotationModifier(ctx, TypeDeclarationContext.class ,"classOrInterfaceModifier.annotation",context.lastContainer());
 		super.enterAnnotationTypeDeclaration(ctx);
 	}
@@ -130,8 +123,7 @@ public class JavaListener extends JavaParserBaseListener {
 	 */
 	@Override
 	public void enterInterfaceDeclaration(InterfaceDeclarationContext ctx) {
-		TypeEntity entity = context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()));
-		setLine(entity,ctx);
+		context.foundNewType(GenericName.build(ctx.IDENTIFIER().getText()), ctx.getStart().getLine());
 		// type parameters
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
@@ -167,8 +159,7 @@ public class JavaListener extends JavaParserBaseListener {
 		List<String> throwedType = QualitiedNameContextHelper.getNames(ctx.qualifiedNameList());
 		String methodName = ctx.IDENTIFIER().getText();
 		String returnedType = ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid());
-		FunctionEntity method = context.foundMethodDeclarator(methodName, returnedType, throwedType);
-		setLine(method,ctx);
+		FunctionEntity method = context.foundMethodDeclarator(methodName, returnedType, throwedType,ctx.getStart().getLine());
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		if (ctx.typeParameters() != null) {
 			List<GenericName> parameters = TypeParameterContextHelper.getTypeParameters(ctx.typeParameters());
@@ -196,8 +187,7 @@ public class JavaListener extends JavaParserBaseListener {
 	public void enterInterfaceMethodDeclaration(InterfaceMethodDeclarationContext ctx) {
 		List<String> throwedType = QualitiedNameContextHelper.getNames(ctx.qualifiedNameList());
 		FunctionEntity method = context.foundMethodDeclarator(ctx.IDENTIFIER().getText(),
-				ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid()), throwedType);
-		setLine(method,ctx);
+				ClassTypeContextHelper.getClassName(ctx.typeTypeOrVoid()), throwedType,ctx.getStart().getLine());
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		if (ctx.typeParameters() != null) {
 			foundTypeParametersUse(ctx.typeParameters());
@@ -216,8 +206,7 @@ public class JavaListener extends JavaParserBaseListener {
 	public void enterConstructorDeclaration(ConstructorDeclarationContext ctx) {
 		List<String> throwedType = QualitiedNameContextHelper.getNames(ctx.qualifiedNameList());
 		FunctionEntity method = context.foundMethodDeclarator(ctx.IDENTIFIER().getText(), ctx.IDENTIFIER().getText(),
-				throwedType);
-		setLine(method,ctx);
+				throwedType,ctx.getStart().getLine());
 		new FormalParameterListContextHelper(ctx.formalParameters(), method, entityRepo);
 		method.addReturnType(context.currentType());
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",context.lastContainer());
@@ -237,8 +226,7 @@ public class JavaListener extends JavaParserBaseListener {
 		List<String> varNames = VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators());
 		String type = ClassTypeContextHelper.getClassName(ctx.typeType());
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		List<VarEntity> vars = context.foundVarDefinitions(varNames, type,typeArguments);
-		vars.forEach(var->setLine(var,ctx));
+		List<VarEntity> vars = context.foundVarDefinitions(varNames, type,typeArguments,ctx.getStart().getLine());
 		annotationProcessor.processAnnotationModifier(ctx, ClassBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterFieldDeclaration(ctx);
 	}
@@ -249,8 +237,7 @@ public class JavaListener extends JavaParserBaseListener {
 	public void enterConstDeclaration(ConstDeclarationContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
 		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.constantDeclarator()),
-				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments);
-		vars.forEach(var->setLine(var,ctx));
+				ClassTypeContextHelper.getClassName(ctx.typeType()),typeArguments, ctx.getStart().getLine());
 
 		annotationProcessor.processAnnotationModifier(ctx, InterfaceBodyDeclarationContext.class,"modifier.classOrInterfaceModifier.annotation",vars);
 		super.enterConstDeclaration(ctx);
@@ -259,17 +246,15 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterEnumConstant(EnumConstantContext ctx) {
 		if (ctx.IDENTIFIER() != null) {
-			VarEntity var = context.foundEnumConstDefinition(ctx.IDENTIFIER().getText());
-			setLine(var,ctx);
+			context.foundEnumConstDefinition(ctx.IDENTIFIER().getText(),ctx.getStart().getLine());
 		}
 		super.enterEnumConstant(ctx);
 	}
 
 	@Override
 	public void enterAnnotationMethodRest(AnnotationMethodRestContext ctx) {
-		FunctionEntity func = context.foundMethodDeclarator(ctx.IDENTIFIER().getText(), ClassTypeContextHelper.getClassName(ctx.typeType()),
-				new ArrayList<>());
-		setLine(func,ctx);
+		context.foundMethodDeclarator(ctx.IDENTIFIER().getText(), ClassTypeContextHelper.getClassName(ctx.typeType()),
+				new ArrayList<>(),ctx.getStart().getLine());
 		super.enterAnnotationMethodRest(ctx);
 	}
 
@@ -282,8 +267,7 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterAnnotationConstantRest(AnnotationConstantRestContext ctx) {
 		// TODO: no variable type defined in annotation const？
-		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators()), "", new ArrayList<>());
-		vars.forEach(var->setLine(var,ctx));
+		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables(ctx.variableDeclarators()), "", new ArrayList<>(), ctx.getStart().getLine());
 		super.enterAnnotationConstantRest(ctx);
 	}
 
@@ -293,19 +277,16 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterLocalVariableDeclaration(LocalVariableDeclarationContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
-				ClassTypeContextHelper.getClassName(ctx.typeType()), typeArguments);
-		vars.forEach(var->setLine(var,ctx));
+		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariables((ctx.variableDeclarators())),
+				ClassTypeContextHelper.getClassName(ctx.typeType()), typeArguments, ctx.getStart().getLine());
 
 		super.enterLocalVariableDeclaration(ctx);
 	}
 
 	public void enterEnhancedForControl(EnhancedForControlContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.typeType());
-		List<VarEntity> vars = context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
-				ClassTypeContextHelper.getClassName(ctx.typeType()), typeArguments);
-		vars.forEach(var->setLine(var,ctx));
-
+		context.foundVarDefinitions(VariableDeclaratorsContextHelper.getVariable((ctx.variableDeclaratorId())),
+				ClassTypeContextHelper.getClassName(ctx.typeType()), typeArguments, ctx.getStart().getLine());
 		super.enterEnhancedForControl(ctx);
 	}
 
@@ -315,9 +296,8 @@ public class JavaListener extends JavaParserBaseListener {
 	@Override
 	public void enterResource(ResourceContext ctx) {
 		List<GenericName> typeArguments = ClassTypeContextHelper.getTypeArguments(ctx.classOrInterfaceType());
-		VarEntity var = context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
-				GenericName.build(IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER())), typeArguments);
-		setLine(var,ctx);
+		context.foundVarDefinition(ctx.variableDeclaratorId().IDENTIFIER().getText(),
+				GenericName.build(IdentifierContextHelper.getName(ctx.classOrInterfaceType().IDENTIFIER())), typeArguments,ctx.getStart().getLine());
 		super.enterResource(ctx);
 	}
 

36174edb716bdf9b12181f883ed8dbdf80aba4ae
@@ -106,7 +106,7 @@ public class ExpressionUsage {
 
 	private void makeSureVarExist(GenericName identifier, ParserRuleContext ctx) {
 		if (null==context.foundEntityWithName(identifier)) {
-			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName());
+			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName(),ctx.getStart().getLine());
 			var.setLine(ctx.getStart().getLine());
 
 		}

36174edb716bdf9b12181f883ed8dbdf80aba4ae
@@ -18,12 +18,12 @@ import java.util.ArrayList;
 import java.util.List;
 
 public class PythonCodeListener extends PythonParserBaseListener{
-	private PythonHandlerContext context;
-	private ExpressionUsage expressionUsage;
-	private EntityRepo entityRepo;
-	private IncludedFileLocator includeFileLocator;
-	private PythonProcessor pythonProcessor;
-	private Inferer inferer;
+	private final PythonHandlerContext context;
+	private final ExpressionUsage expressionUsage;
+	private final EntityRepo entityRepo;
+	private final IncludedFileLocator  includeFileLocator;
+	private final PythonProcessor pythonProcessor;
+	private final Inferer inferer;
 	public PythonCodeListener(String fileFullPath, EntityRepo entityRepo, Inferer inferer,
 			IncludedFileLocator includeFileLocator, PythonProcessor pythonProcessor) {
 		this.context = new PythonHandlerContext(entityRepo, inferer);
@@ -43,7 +43,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		PackageEntity packageEntity = (PackageEntity) entityRepo.getEntity(dir);
 		String moduleName = fileEntity.getRawName().uniqName().substring(packageEntity.getRawName().uniqName().length() + 1);
 		if (moduleName.endsWith(".py"))
-			moduleName = moduleName.substring(0, moduleName.length() - ".py".length());
+			moduleName.substring(0, moduleName.length() - ".py".length());
 		Entity.setParent(fileEntity, packageEntity);
 		packageEntity.addChild(FileUtil.getShortFileName(fileEntity.getRawName().uniqName()).replace(".py", ""), fileEntity);
 	}
@@ -199,8 +199,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 			functionName = name;
 		}
 
-		FunctionEntity method = context.foundMethodDeclarator(functionName);
-		method.setLine(ctx.getStart().getLine());
+		FunctionEntity method = context.foundMethodDeclarator(functionName,ctx.getStart().getLine());
 		if (ctx.typedargslist()!=null) {
 			List<String> parameters = getParameterList(ctx.typedargslist().def_parameters());
 			for (String param : parameters) {
@@ -223,9 +222,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	@Override
 	public void enterClassdef(ClassdefContext ctx) {
 		String name = getName(ctx.name());
-		TypeEntity type = context.foundNewType(name);
-		type.setLine(ctx.getStart().getLine());
-
+		TypeEntity type = context.foundNewType(name, ctx.getStart().getLine());
 		List<String> baseClasses = getArgList(ctx.arglist());
 		baseClasses.forEach(base -> type.addExtends(GenericName.build(base)));
 
@@ -301,9 +298,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	@Override
 	public void enterGlobal_stmt(Global_stmtContext ctx) {
 		for (NameContext name:ctx.name()){
-			VarEntity var = context.foundGlobalVarDefinition(context.currentFile(), name.getText());
-			var.setLine(ctx.getStart().getLine());
-
+			VarEntity var = context.foundGlobalVarDefinition(context.currentFile(), name.getText(),ctx.getStart().getLine());
 		}
 		super.enterGlobal_stmt(ctx);
 	}

36174edb716bdf9b12181f883ed8dbdf80aba4ae
@@ -60,6 +60,7 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent */
 		expression = new Expression(idGenerator.generateId());
+		expression.setLine(ctx.getPosition().getStartLine());
 		expression.setText(ctx.toString());
 		expression.setParent(parent);
 		if (ctx instanceof NewlineNode) {

36174edb716bdf9b12181f883ed8dbdf80aba4ae
@@ -24,53 +24,18 @@ SOFTWARE.
 
 package depends.extractor.ruby.jruby;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.concurrent.ExecutorService;
-
-import org.jrubyparser.ast.AliasNode;
-import org.jrubyparser.ast.ArgumentNode;
-import org.jrubyparser.ast.ArrayNode;
-import org.jrubyparser.ast.CallNode;
-import org.jrubyparser.ast.ClassNode;
-import org.jrubyparser.ast.ClassVarAsgnNode;
-import org.jrubyparser.ast.ClassVarDeclNode;
-import org.jrubyparser.ast.ClassVarNode;
-import org.jrubyparser.ast.Colon2ConstNode;
-import org.jrubyparser.ast.Colon3Node;
-import org.jrubyparser.ast.ConstNode;
-import org.jrubyparser.ast.DAsgnNode;
-import org.jrubyparser.ast.DVarNode;
-import org.jrubyparser.ast.DefnNode;
-import org.jrubyparser.ast.DefsNode;
-import org.jrubyparser.ast.FCallNode;
-import org.jrubyparser.ast.GlobalAsgnNode;
-import org.jrubyparser.ast.GlobalVarNode;
-import org.jrubyparser.ast.IArgumentNode;
-import org.jrubyparser.ast.INameNode;
-import org.jrubyparser.ast.InstAsgnNode;
-import org.jrubyparser.ast.InstVarNode;
-import org.jrubyparser.ast.LocalAsgnNode;
-import org.jrubyparser.ast.LocalVarNode;
-import org.jrubyparser.ast.ModuleNode;
-import org.jrubyparser.ast.Node;
-import org.jrubyparser.ast.RootNode;
-import org.jrubyparser.ast.SelfNode;
-import org.jrubyparser.ast.StrNode;
-import org.jrubyparser.ast.SymbolNode;
-import org.jrubyparser.ast.UnaryCallNode;
-import org.jrubyparser.ast.VCallNode;
-import org.jrubyparser.util.NoopVisitor;
-
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.GenericName;
-import depends.entity.VarEntity;
+import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.extractor.ruby.RubyHandlerContext;
 import depends.relations.Inferer;
+import org.jrubyparser.ast.*;
+import org.jrubyparser.util.NoopVisitor;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.ExecutorService;
 
 public class JRubyVisitor extends NoopVisitor {
 
@@ -95,7 +60,7 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitModuleNode(ModuleNode node) {
 		String name = helper.getName(node.getCPath());
-		context.foundNamespace(name);
+		context.foundNamespace(name,node.getPosition().getStartLine());
 		super.visitModuleNode(node);
 		context.exitLastedEntity();
 		return null;
@@ -103,7 +68,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitClassNode(ClassNode node) {
-		context.foundNewType(helper.getName(node.getCPath()));
+		TypeEntity type = context.foundNewType(helper.getName(node.getCPath()),node.getPosition().getStartLine());
 		Node superNode = node.getSuper();
 		
 		if (superNode instanceof ConstNode ||
@@ -132,7 +97,7 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitFCallNode(FCallNode node) {
 		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
-		context.processSpecialFuncCall(fname, params);
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
 		return super.visitFCallNode(node);
 	}
 
@@ -157,7 +122,7 @@ public class JRubyVisitor extends NoopVisitor {
 		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
 		addCallToReceiverVar(node, fname);
-		context.processSpecialFuncCall(fname, params);
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
 		return super.visitCallNode(node);
 	}
 
@@ -178,7 +143,7 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitUnaryCallNode(UnaryCallNode node) {
 		String fname = helper.getName(node);
 		Collection<String> params = new ArrayList<>();
-		context.processSpecialFuncCall(fname, params);
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
 		return super.visitUnaryCallNode(node);
 	}
 
@@ -192,7 +157,9 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDefnNode(DefnNode node) {
-		context.foundMethodDeclarator(node.getName());
+		FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine());
+		method.setLine(node.getPosition().getStartLine());
+
 		super.visitDefnNode(node);
 		context.exitLastedEntity();
 		return null;
@@ -208,7 +175,8 @@ public class JRubyVisitor extends NoopVisitor {
 			String className = ((INameNode) varNode).getName();
 			Entity entity = context.foundEntityWithName(GenericName.build(className));
 			if (entity != null && entity instanceof ContainerEntity) {
-				context.foundMethodDeclarator(((ContainerEntity) entity), node.getName());
+				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) entity), node.getName(),node.getPosition().getStartLine());
+				method.setLine(node.getPosition().getStartLine());
 				handled = true;
 			}
 
@@ -216,14 +184,16 @@ public class JRubyVisitor extends NoopVisitor {
 			String varName = ((INameNode) varNode).getName();
 			Entity var = context.foundEntityWithName(GenericName.build(varName));
 			if (var != null && var instanceof ContainerEntity) {
-				context.foundMethodDeclarator(((ContainerEntity) var), node.getName());
+				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) var), node.getName(),node.getPosition().getStartLine());
+				method.setLine(node.getPosition().getStartLine());
 				handled = true;
 			}
 		} 
 
 		if (!handled) {
 			// fallback to add it to last container
-			context.foundMethodDeclarator(node.getName());
+			FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine());
+			method.setLine(node.getPosition().getStartLine());
 		}
 		super.visitDefsNode(node);
 		context.exitLastedEntity();
@@ -232,31 +202,31 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitGlobalVarNode(GlobalVarNode node) {
-		context.foundVarDefinition(context.globalScope(), node.getName());
+		context.foundVarDefinition(context.globalScope(), node.getName(),node.getPosition().getStartLine());
 		return super.visitGlobalVarNode(node);
 	}
 
 	@Override
 	public Object visitInstVarNode(InstVarNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
 		return super.visitInstVarNode(node);
 	}
 
 	@Override
 	public Object visitClassVarAsgnNode(ClassVarAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
 		return super.visitClassVarAsgnNode(node);
 	}
 
 	@Override
 	public Object visitClassVarDeclNode(ClassVarDeclNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
 		return super.visitClassVarDeclNode(node);
 	}
 
 	@Override
 	public Object visitClassVarNode(ClassVarNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
 		return super.visitClassVarNode(node);
 	}
 
@@ -267,25 +237,25 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDVarNode(DVarNode node) {
-		context.foundVarDefinition(context.lastContainer(), node.getName());
+		context.foundVarDefinition(context.lastContainer(), node.getName(),node.getPosition().getStartLine());
 		return super.visitDVarNode(node);
 	}
 
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
 		return super.visitDAsgnNode(node);
 	}
 
 	@Override
 	public Object visitGlobalAsgnNode(GlobalAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
 		return super.visitGlobalAsgnNode(node);
 	}
 
 	@Override
 	public Object visitInstAsgnNode(InstAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
 		return super.visitInstAsgnNode(node);
 	}
 
@@ -298,7 +268,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitLocalAsgnNode(LocalAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
 		return super.visitLocalAsgnNode(node);
 	}
 

a41d0bc65bcb34a4b37983e789d2c0f4b4b5df99
@@ -0,0 +1,50 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.extractor.golang;
+
+import depends.entity.repo.BuiltInType;
+
+public class GoBuiltInType extends BuiltInType{
+
+	public GoBuiltInType() {
+        super.createBuiltInTypes();
+	}
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[]{
+				"<Built-in>"
+		};
+	}
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[]{
+		};
+	}
+	@Override
+	public String[] getBuiltInMethods() {
+		return new String[]{};
+	}
+	
+}

a41d0bc65bcb34a4b37983e789d2c0f4b4b5df99
@@ -0,0 +1,101 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.extractor.golang;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.PackageEntity;
+import depends.entity.repo.EntityRepo;
+import depends.extractor.UnsolvedBindings;
+import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+public class GoImportLookupStrategy implements ImportLookupStrategy{
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+		//Java Strategy
+		String importedString = fileEntity.importedSuffixMatch(name);
+		if (importedString==null) return null;	
+		return repo.getEntity(importedString);
+	}
+
+
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) continue;
+			if (imported instanceof PackageEntity) { 
+				//ignore wildcard import relation
+			}else {
+				result.add(imported);
+			}
+		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) {
+				unsolvedBindings.add(new UnsolvedBindings(importedItem.getContent(),null));
+				continue;
+			}
+			if (imported instanceof PackageEntity) { 
+				//expand import of package to all classes under the package due to we dis-courage the behavior
+				for (Entity child:imported.getChildren()) {
+					if (child instanceof FileEntity) {
+						child.getChildren().forEach(item->result.add(item));
+					}else {
+						result.add(child);
+					}
+				}
+			}else {
+				result.add(imported);
+			}
+		}
+		return result;
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+		return new ArrayList<Entity>();
+	}
+
+
+	@Override
+	public boolean supportGlobalNameLookup() {
+		return true;
+	}
+
+}

a41d0bc65bcb34a4b37983e789d2c0f4b4b5df99
@@ -0,0 +1,88 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.extractor.golang;
+
+import depends.entity.repo.BuiltInType;
+import depends.extractor.AbstractLangProcessor;
+import depends.extractor.FileParser;
+import depends.relations.ImportLookupStrategy;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static depends.deptypes.DependencyType.*;
+
+public class GoProcessor extends AbstractLangProcessor {
+	private static final String LANG = "go";
+	private static final String[] SUFFIX = new String[] { ".go" };
+	public GoProcessor() {
+		super(false);
+	}
+
+	@Override
+	public String supportedLanguage() {
+		return LANG;
+	}
+
+	@Override
+	public String[] fileSuffixes() {
+		return SUFFIX;
+	}
+
+	@Override
+	protected FileParser createFileParser(String fileFullPath) {
+		return new GoFileParser(fileFullPath, entityRepo, inferer);
+	}
+
+	@Override
+	public ImportLookupStrategy getImportLookupStrategy() {
+		return new GoImportLookupStrategy();
+	}
+
+	@Override
+	public BuiltInType getBuiltInType() {
+		return new GoBuiltInType();
+	}
+
+	@Override
+	public List<String> supportedRelations() {
+		ArrayList<String> depedencyTypes = new ArrayList<>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(CONTAIN);
+		depedencyTypes.add(IMPLEMENT);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		depedencyTypes.add(IMPLLINK);
+		return depedencyTypes;
+	}
+
+}

a41d0bc65bcb34a4b37983e789d2c0f4b4b5df99
@@ -0,0 +1,22 @@
+package depends.extractor.golang;
+
+import depends.entity.repo.EntityRepo;
+import depends.entity.repo.InMemoryEntityRepo;
+import depends.extractor.ParserTest;
+import depends.relations.Inferer;
+import multilang.depends.util.file.TemporaryFile;
+
+public abstract class GolangParserTest extends ParserTest{
+	protected  EntityRepo entityRepo ;
+	protected Inferer inferer ;
+
+	public void init() {
+		entityRepo = new InMemoryEntityRepo();
+		inferer = new Inferer(entityRepo,new GoImportLookupStrategy(),new GoBuiltInType(),false);
+    	TemporaryFile.reset();
+	}
+	
+	public GoFileParser createParser(String src) {
+		return new GoFileParser(src,entityRepo, inferer);
+	}
+}

adf1da4360a6e7455af8519c6aa6e7a7bb181740
@@ -26,25 +26,39 @@ package depends.extractor.golang;
 
 import depends.entity.repo.BuiltInType;
 
-public class GoBuiltInType extends BuiltInType{
+public class GoBuiltInType extends BuiltInType {
 
-	public GoBuiltInType() {
+    public GoBuiltInType() {
         super.createBuiltInTypes();
-	}
-	@Override
-	public String[] getBuiltInTypeStr() {
-		return new String[]{
-				"<Built-in>"
-		};
-	}
-	@Override
-	public String[] getBuiltInPrefixStr() {
-		return new String[]{
-		};
-	}
-	@Override
-	public String[] getBuiltInMethods() {
-		return new String[]{};
-	}
-	
+    }
+
+    @Override
+    public String[] getBuiltInTypeStr() {
+        return new String[]{
+                "<Built-in>",
+                "break", "default", "func", "interface",
+				"select", "case", "defer", "go", "map", "struct", "chan",
+				"else", "goto", "package", "switch", "const", "fallthrough",
+				"if", "range", "type", "continue", "for", "import", "return",
+				"var", "append", "bool", "byte", "cap", "close", "complex",
+				"complex64", "complex128", "uint16", "copy", "false", "float32",
+				"float64", "imag", "int", "int8", "int16", "uint32", "int32",
+				"int64", "iota", "len", "make", "new", "nil", "panic", "uint64",
+				"print", "println", "real", "recover", "string", "true", "uint",
+				"uint8", "uintptr",
+				"_"
+        };
+    }
+
+    @Override
+    public String[] getBuiltInPrefixStr() {
+        return new String[]{
+        };
+    }
+
+    @Override
+    public String[] getBuiltInMethods() {
+        return new String[]{};
+    }
+
 }

adf1da4360a6e7455af8519c6aa6e7a7bb181740
@@ -0,0 +1,45 @@
+package depends.extractor.golang;
+
+import depends.entity.TypeEntity;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+public class GoFunctionsTest extends GolangParserTest {
+	@Before
+	public void setUp() {
+		super.init();
+	}
+	@Test
+	public void test_could_parse_function() throws IOException {
+        String src = "./src/test/resources/go-code-examples/func.go";
+        GoFileParser parser =createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertNotNull(entityRepo.getEntity("main"));
+	}
+
+	@Test
+	public void test_could_parse_struct_type() throws IOException {
+		String src = "./src/test/resources/go-code-examples/struct.go";
+		GoFileParser parser =createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		assertNotNull(entityRepo.getEntity("Books"));
+	}
+
+	@Test
+	public void test_could_parse_struct_members() throws IOException {
+		String src = "./src/test/resources/go-code-examples/struct.go";
+		GoFileParser parser =createParser(src);
+		parser.parse();
+		inferer.resolveAllBindings();
+		assertNotNull(entityRepo.getEntity("Books"));
+		TypeEntity book = (TypeEntity)entityRepo.getEntity("Books");
+		assertEquals(4,book.getChildren().size());
+	}
+}

8c054fdbe92f063713b04ce0954d26b316f0c7d5
@@ -326,4 +326,6 @@ public abstract class HandlerContext {
 	public void addToRepo(Entity entity) {
 		entityRepo.add(entity);
 	}
+
+
 }
\ No newline at end of file

8c054fdbe92f063713b04ce0954d26b316f0c7d5
@@ -1,22 +1,24 @@
 package depends.format.json;
 
+import depends.matrix.core.LocationInfo;
+
 public class DetailItem {
 
-	private String src;
-	private String dest;
+	private LocationInfo src;
+	private LocationInfo dest;
 	private String type;
 
-	public DetailItem(String src, String dest, String type) {
+	public DetailItem(LocationInfo src, LocationInfo dest, String type) {
 		this.src = src;
 		this.dest = dest;
 		this.type = type;
 	}
 
-	public String getSrc() {
+	public LocationInfo getSrc() {
 		return src;
 	}
 
-	public String getDest() {
+	public LocationInfo getDest() {
 		return dest;
 	}
 

8c054fdbe92f063713b04ce0954d26b316f0c7d5
@@ -29,7 +29,9 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.TypeEntity;
 import depends.entity.repo.EntityRepo;
+import depends.matrix.core.DependencyDetail;
 import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.LocationInfo;
 import depends.relations.Relation;
 
 import java.util.Iterator;
@@ -65,7 +67,9 @@ public class FileDependencyGenerator extends DependencyGenerator{
     	        		if (candidateType.getId()>=0) {
     	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,candidateType);
     	        			if (fileEntityTo!=-1) {
-    	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,candidateType,relation.getFromLine()));
+								DependencyDetail detail = buildDescription(entity,candidateType,relation.getFromLine());
+								detail = rewriteDetail(detail);
+								dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
     	        			}
     	        		}
         			}
@@ -73,7 +77,9 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	        		if (relatedEntity.getId()>=0) {
 	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relatedEntity);
 	        			if (fileEntityTo!=-1) {
-	        				dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,buildDescription(entity,relatedEntity,relation.getFromLine()));
+							DependencyDetail detail = buildDescription(entity, relatedEntity, relation.getFromLine());
+							detail = rewriteDetail(detail);
+							dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
 	        			}
 	        		}
         		}
@@ -84,6 +90,17 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		return dependencyMatrix;
 	}
 
+	private DependencyDetail rewriteDetail(DependencyDetail detail) {
+		String srcFile = filenameWritter.reWrite(detail.getSrc().getFile());
+		String dstFile = filenameWritter.reWrite(detail.getDest().getFile());
+		return new DependencyDetail(
+				new LocationInfo(detail.getSrc().getObject(),
+						srcFile, detail.getSrc().getLineNumber())
+		,
+				new LocationInfo(detail.getDest().getObject(),
+						dstFile, detail.getDest().getLineNumber()));
+	}
+
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null) {

8c054fdbe92f063713b04ce0954d26b316f0c7d5
@@ -27,7 +27,7 @@ package depends.generator;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
-import depends.entity.PackageNamePrefixRemover;
+import depends.entity.EntityNameBuilder;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.core.DependencyMatrix;
 import depends.relations.Relation;
@@ -69,7 +69,7 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 		FileEntity file = (FileEntity) entity.getAncestorOfType(FileEntity.class);
 		String name = stripper.stripFilename(file.getRawName().uniqName());
 		name = filenameWritter.reWrite(name);
-		String functionName = PackageNamePrefixRemover.remove(entity);
+		String functionName = EntityNameBuilder.build(entity);
 		name = name + "("+functionName+")";
 		return name;
 	}

78158583dd7d0c06ea2e285667406038ea11f662
@@ -91,6 +91,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	}
 
 	private DependencyDetail rewriteDetail(DependencyDetail detail) {
+		if (detail==null) return null;
 		String srcFile = filenameWritter.reWrite(detail.getSrc().getFile());
 		String dstFile = filenameWritter.reWrite(detail.getDest().getFile());
 		return new DependencyDetail(

78158583dd7d0c06ea2e285667406038ea11f662
@@ -2,6 +2,7 @@ package depends.extractor.golang;
 
 import depends.entity.TypeEntity;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -23,7 +24,7 @@ public class GoFunctionsTest extends GolangParserTest {
         assertNotNull(entityRepo.getEntity("main"));
 	}
 
-	@Test
+	@Ignore
 	public void test_could_parse_struct_type() throws IOException {
 		String src = "./src/test/resources/go-code-examples/struct.go";
 		GoFileParser parser =createParser(src);
@@ -32,7 +33,7 @@ public class GoFunctionsTest extends GolangParserTest {
 		assertNotNull(entityRepo.getEntity("Books"));
 	}
 
-	@Test
+	@Ignore
 	public void test_could_parse_struct_members() throws IOException {
 		String src = "./src/test/resources/go-code-examples/struct.go";
 		GoFileParser parser =createParser(src);

b80c11205bc98f5370756dc346842a09d509eb32
@@ -92,8 +92,11 @@ public class FileDependencyGenerator extends DependencyGenerator{
 
 	private DependencyDetail rewriteDetail(DependencyDetail detail) {
 		if (detail==null) return null;
-		String srcFile = filenameWritter.reWrite(detail.getSrc().getFile());
-		String dstFile = filenameWritter.reWrite(detail.getDest().getFile());
+		String srcFile = filenameWritter.reWrite(
+				stripper.stripFilename(detail.getSrc().getFile())
+				);
+		String dstFile = filenameWritter.reWrite(
+				stripper.stripFilename(detail.getDest().getFile()));
 		return new DependencyDetail(
 				new LocationInfo(detail.getSrc().getObject(),
 						srcFile, detail.getSrc().getLineNumber())

e5cb76afa0a102a92fa6b5b0bccd1805a556b7fb
@@ -62,7 +62,7 @@ public class DependsCommand {
 	@Option(names = {"--strip-paths"}, split=",", description =  "The path(s) to be stripped. if -s enabled, the path(s) start after <src>. "
 			+ "Otherwise, the path(s) should be valid.")
 	private String[] strippedPaths = new String[]{};
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,structure,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
     private String namePathPattern="";

e5cb76afa0a102a92fa6b5b0bccd1805a556b7fb
@@ -0,0 +1,116 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.generator;
+
+import depends.entity.*;
+import depends.entity.repo.EntityRepo;
+import depends.matrix.core.DependencyDetail;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.LocationInfo;
+import depends.relations.Relation;
+
+import java.util.Iterator;
+import java.util.List;
+
+public class StructureDependencyGenerator extends DependencyGenerator{
+	/**
+	 * Build the dependency matrix (without re-mapping file id)
+	 * @param entityRepo which contains entities and relations
+	 * @return the generated dependency matrix
+	 */
+	@Override
+	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
+		Iterator<Entity> iterator = entityRepo.entityIterator();
+		System.out.println("Start create dependencies matrix....");
+		while(iterator.hasNext()) {
+			Entity entity = iterator.next();
+			if (!entity.inScope()) continue;
+			if (isStructureEntityType(entity)){
+				String name = entity.getQualifiedName() + "|" + entity.getClass().getSimpleName().replace("Entity","");
+        		dependencyMatrix.addNode(name,entity.getId());
+        	}
+			
+        	int fileEntityFrom = getStructureEntityIdNoException(entity);
+        	if (fileEntityFrom==-1) continue;
+        	for (Relation relation:entity.getRelations()) {
+        		Entity relatedEntity = relation.getEntity();
+        		if (relatedEntity==null) continue;
+        		if (relatedEntity instanceof CandidateTypes) {
+        			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
+        			for (TypeEntity candidateType:candidateTypes) {
+    	        		if (candidateType.getId()>=0) {
+    	        			int fileEntityTo = getStructureEntityIdNoException(candidateType);
+    	        			if (fileEntityTo!=-1) {
+								DependencyDetail detail = buildDescription(entity,candidateType,relation.getFromLine());
+								dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
+    	        			}
+    	        		}
+        			}
+        		}else {
+	        		if (relatedEntity.getId()>=0) {
+	        			int fileEntityTo = getStructureEntityIdNoException(relatedEntity);
+	        			if (fileEntityTo!=-1) {
+							DependencyDetail detail = buildDescription(entity, relatedEntity, relation.getFromLine());
+							dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
+	        			}
+	        		}
+        		}
+        	}
+        }
+		System.out.println("Finish create dependencies matrix....");
+
+		return dependencyMatrix;
+	}
+
+
+
+	private boolean isStructureEntityType(Entity entity) {
+		if (entity instanceof FileEntity) return false;
+		if (entity instanceof TypeEntity) return true; //package included
+		if (entity instanceof VarEntity && entity.getParent() instanceof TypeEntity) return true;
+		if (entity instanceof FunctionEntity) return true;
+		return false;
+	}
+
+	private int getStructureEntityIdNoException(Entity entity) {
+		Entity ancestor = getAncestorOfType(entity);
+		if (ancestor==null) {
+			return -1;
+		}
+		if (!ancestor.inScope()) return -1;
+		return ancestor.getId();
+	}
+
+	public Entity getAncestorOfType(Entity fromEntity) {
+		while(fromEntity!=null) {
+			if (isStructureEntityType(fromEntity))
+				return fromEntity;
+			if (fromEntity.getParent()==null) return null;
+			fromEntity = fromEntity.getParent();
+		}
+		return null;
+	}
+}

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,18 +24,6 @@ SOFTWARE.
 
 package depends.extractor;
 
-import java.io.File;
-import java.io.IOException;
-import java.lang.management.ManagementFactory;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.codehaus.plexus.util.FileUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.BuiltInType;
@@ -48,8 +36,20 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import multilang.depends.util.file.FileTraversal;
 import multilang.depends.util.file.FileUtil;
+import org.codehaus.plexus.util.FileUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 
 abstract public class AbstractLangProcessor {
+
 	/**
 	 * The name of the lang
 	 * 
@@ -99,7 +99,7 @@ abstract public class AbstractLangProcessor {
 	
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo, getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
+		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
 	}
 
 	/**
@@ -109,8 +109,6 @@ abstract public class AbstractLangProcessor {
 	 * 
 	 * @param includeDir
 	 * @param inputDir
-	 * @param b 
-	 * @param b 
 	 */
 	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl, boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
 		this.inputSrcPath = inputDir;

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,14 +24,6 @@ SOFTWARE.
 
 package depends.extractor.cpp;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.GenericName;
@@ -40,11 +32,17 @@ import depends.extractor.UnsolvedBindings;
 import depends.importtypes.FileImport;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
 
-public class CppImportLookupStrategy implements ImportLookupStrategy {
+import java.util.*;
+
+public class CppImportLookupStrategy extends ImportLookupStrategy {
+
+
+	public CppImportLookupStrategy(EntityRepo repo){
+		super(repo);
+	}
 	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+	public Entity lookupImportedType(String name, FileEntity fileEntity) {
 		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString!=null) {
 			Entity r = repo.getEntity(importedString);
@@ -95,7 +93,7 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 	
 	
 	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedRelationEntities(List<Import> importedList) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			if (importedItem instanceof FileImport) {
@@ -108,7 +106,7 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 	}
 
 	@Override
-	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
+	public List<Entity> getImportedTypes(List<Import> importedList,  Set<UnsolvedBindings> unsolvedBindings) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			if (!(importedItem instanceof FileImport)) {
@@ -124,8 +122,8 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 	}
 
 	@Override
-	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
-		return getImportedRelationEntities(importedList,repo);
+	public List<Entity> getImportedFiles(List<Import> importedList) {
+		return getImportedRelationEntities(importedList);
 	}
 	
 	@Override

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,10 +24,6 @@ SOFTWARE.
 
 package depends.extractor.cpp;
 
-import static depends.deptypes.DependencyType.*;
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
@@ -35,6 +31,11 @@ import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
 import depends.relations.ImportLookupStrategy;
 
+import java.util.ArrayList;
+import java.util.List;
+
+import static depends.deptypes.DependencyType.*;
+
 public class CppProcessor extends AbstractLangProcessor {
 	private static final String LANG = "cpp";
 	private static final String[] SUFFIX = new String[] { ".cpp", ".cc", ".c", ".c++", ".h", ".hpp", ".hh", ".cxx", ".hxx" };
@@ -71,7 +72,7 @@ public class CppProcessor extends AbstractLangProcessor {
 
 	@Override
 	public ImportLookupStrategy getImportLookupStrategy() {
-		return new CppImportLookupStrategy();
+		return new CppImportLookupStrategy(entityRepo);
 	}
 
 	@Override

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,40 +24,43 @@ SOFTWARE.
 
 package depends.extractor.empty;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.UnsolvedBindings;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
 
-public class EmptyImportLookupStategy implements ImportLookupStrategy {
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+public class EmptyImportLookupStategy extends ImportLookupStrategy {
+
+	public EmptyImportLookupStategy(EntityRepo repo) {
+		super(repo);
+	}
 
 	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+	public Entity lookupImportedType(String name, FileEntity fileEntity) {
 		return null;
 	}
 
 	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedNames, EntityRepo repo) {
+	public List<Entity> getImportedRelationEntities(List<Import> importedNames) {
 		return new ArrayList<Entity>();
 	}
 
 	@Override
-	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
+	public List<Entity> getImportedTypes(List<Import> importedNames,Set<UnsolvedBindings> unsolvedBindings) {
 		return new ArrayList<Entity>();
 	}
 
 	@Override
-	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
+	public List<Entity> getImportedFiles(List<Import> importedNames) {
 		return new ArrayList<Entity>();
 	}
-	@Override
+
 	public boolean supportGlobalNameLookup() {
 		return false;
 	}

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -31,15 +31,17 @@ import depends.entity.repo.EntityRepo;
 import depends.extractor.UnsolvedBindings;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
-public class GoImportLookupStrategy implements ImportLookupStrategy{
-	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+public class GoImportLookupStrategy extends ImportLookupStrategy{
+	public GoImportLookupStrategy(EntityRepo repo) {
+		super(repo);
+	}
+
+	public Entity lookupImportedType(String name, FileEntity fileEntity) {
 		//Java Strategy
 		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString==null) return null;	
@@ -48,7 +50,7 @@ public class GoImportLookupStrategy implements ImportLookupStrategy{
 
 
 	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedRelationEntities(List<Import> importedList) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			Entity imported = repo.getEntity(importedItem.getContent());
@@ -63,7 +65,7 @@ public class GoImportLookupStrategy implements ImportLookupStrategy{
 	}
 
 	@Override
-	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
+	public List<Entity> getImportedTypes(List<Import> importedList, Set<UnsolvedBindings> unsolvedBindings) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			Entity imported = repo.getEntity(importedItem.getContent());
@@ -88,7 +90,7 @@ public class GoImportLookupStrategy implements ImportLookupStrategy{
 	}
 
 	@Override
-	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedFiles(List<Import> importedList) {
 		return new ArrayList<Entity>();
 	}
 

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -58,7 +58,7 @@ public class GoProcessor extends AbstractLangProcessor {
 
 	@Override
 	public ImportLookupStrategy getImportLookupStrategy() {
-		return new GoImportLookupStrategy();
+		return new GoImportLookupStrategy(entityRepo);
 	}
 
 	@Override

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,10 +24,6 @@ SOFTWARE.
 
 package depends.extractor.java;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.PackageEntity;
@@ -35,11 +31,19 @@ import depends.entity.repo.EntityRepo;
 import depends.extractor.UnsolvedBindings;
 import depends.importtypes.Import;
 import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
 
-public class JavaImportLookupStrategy implements ImportLookupStrategy{
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+public class JavaImportLookupStrategy extends ImportLookupStrategy{
+
+	public JavaImportLookupStrategy(EntityRepo repo) {
+		super(repo);
+	}
+
 	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+	public Entity lookupImportedType(String name, FileEntity fileEntity) {
 		//Java Strategy
 		String importedString = fileEntity.importedSuffixMatch(name);
 		if (importedString==null) return null;	
@@ -48,7 +52,7 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 
 
 	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedRelationEntities(List<Import> importedList) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			Entity imported = repo.getEntity(importedItem.getContent());
@@ -63,7 +67,7 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	}
 
 	@Override
-	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo, Set<UnsolvedBindings> unsolvedBindings) {
+	public List<Entity> getImportedTypes(List<Import> importedList,Set<UnsolvedBindings> unsolvedBindings) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			Entity imported = repo.getEntity(importedItem.getContent());
@@ -88,7 +92,7 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 	}
 
 	@Override
-	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedFiles(List<Import> importedList) {
 		return new ArrayList<Entity>();
 	}
 

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,13 +24,14 @@ SOFTWARE.
 
 package depends.extractor.java;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
 import depends.relations.ImportLookupStrategy;
+
+import java.util.ArrayList;
+import java.util.List;
+
 import static depends.deptypes.DependencyType.*;
 public class JavaProcessor extends AbstractLangProcessor {
     private static final String JAVA_LANG = "java";
@@ -57,7 +58,7 @@ public class JavaProcessor extends AbstractLangProcessor {
 	
 	@Override
 	public ImportLookupStrategy getImportLookupStrategy() {
-		return new JavaImportLookupStrategy();
+		return new JavaImportLookupStrategy(entityRepo);
 	}
 	
 	@Override

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -1,22 +1,5 @@
 package depends.extractor.kotlin;
 
-import static depends.deptypes.DependencyType.ANNOTATION;
-import static depends.deptypes.DependencyType.CALL;
-import static depends.deptypes.DependencyType.CAST;
-import static depends.deptypes.DependencyType.CONTAIN;
-import static depends.deptypes.DependencyType.CREATE;
-import static depends.deptypes.DependencyType.IMPLEMENT;
-import static depends.deptypes.DependencyType.IMPORT;
-import static depends.deptypes.DependencyType.INHERIT;
-import static depends.deptypes.DependencyType.PARAMETER;
-import static depends.deptypes.DependencyType.RETURN;
-import static depends.deptypes.DependencyType.SET;
-import static depends.deptypes.DependencyType.THROW;
-import static depends.deptypes.DependencyType.USE;
-
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
@@ -24,6 +7,11 @@ import depends.extractor.java.JavaBuiltInType;
 import depends.extractor.java.JavaImportLookupStrategy;
 import depends.relations.ImportLookupStrategy;
 
+import java.util.ArrayList;
+import java.util.List;
+
+import static depends.deptypes.DependencyType.*;
+
 public class KotlinProcessor extends AbstractLangProcessor {
 
 	public KotlinProcessor() {
@@ -42,7 +30,7 @@ public class KotlinProcessor extends AbstractLangProcessor {
 
 	@Override
 	public ImportLookupStrategy getImportLookupStrategy() {
-		return new JavaImportLookupStrategy();
+		return new JavaImportLookupStrategy(entityRepo);
 	}
 
 	@Override

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,17 +24,21 @@ SOFTWARE.
 
 package depends.extractor.pom;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.Entity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.empty.EmptyImportLookupStategy;
 import depends.importtypes.Import;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class PomImportLookupStategy extends EmptyImportLookupStategy  {
+	public PomImportLookupStategy(EntityRepo repo) {
+		super(repo);
+	}
+
 	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+	public List<Entity> getImportedRelationEntities(List<Import> importedList) {
 		ArrayList<Entity> result = new ArrayList<>();
 		for (Import importedItem:importedList) {
 			Entity imported = repo.getEntity(importedItem.getContent());

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -1,24 +1,13 @@
 package depends.extractor.python;
 
-import static depends.deptypes.DependencyType.ANNOTATION;
-import static depends.deptypes.DependencyType.CALL;
-import static depends.deptypes.DependencyType.CONTAIN;
-import static depends.deptypes.DependencyType.CREATE;
-import static depends.deptypes.DependencyType.IMPLLINK;
-import static depends.deptypes.DependencyType.IMPORT;
-import static depends.deptypes.DependencyType.INHERIT;
-import static depends.deptypes.DependencyType.PARAMETER;
-import static depends.deptypes.DependencyType.RETURN;
-import static depends.deptypes.DependencyType.SET;
-import static depends.deptypes.DependencyType.THROW;
-import static depends.deptypes.DependencyType.USE;
+import depends.entity.repo.BuiltInType;
+import depends.extractor.AbstractLangProcessor;
+import depends.relations.ImportLookupStrategy;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import depends.entity.repo.BuiltInType;
-import depends.extractor.AbstractLangProcessor;
-import depends.relations.ImportLookupStrategy;
+import static depends.deptypes.DependencyType.*;
 
 public abstract class BasePythonProcessor extends AbstractLangProcessor{
 	private PythonImportLookupStrategy importedLookupStrategy;
@@ -34,7 +23,7 @@ public abstract class BasePythonProcessor extends AbstractLangProcessor{
 
 	@Override
 	public ImportLookupStrategy getImportLookupStrategy() {
-		importedLookupStrategy = new PythonImportLookupStrategy();
+		importedLookupStrategy = new PythonImportLookupStrategy(entityRepo);
 		return this.importedLookupStrategy;
 	}
 

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,9 +24,12 @@ SOFTWARE.
 
 package depends.extractor.ruby;
 
+import depends.entity.repo.EntityRepo;
 import depends.extractor.cpp.CppImportLookupStrategy;
 
 public class RubyImportLookupStrategy extends  CppImportLookupStrategy {
 
-
+    public RubyImportLookupStrategy(EntityRepo repo) {
+        super(repo);
+    }
 }

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,13 +24,6 @@ SOFTWARE.
 
 package depends.extractor.ruby;
 
-import static depends.deptypes.DependencyType.*;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
@@ -38,6 +31,13 @@ import depends.extractor.ParserCreator;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.ImportLookupStrategy;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import static depends.deptypes.DependencyType.*;
+
 public class RubyProcessor extends AbstractLangProcessor implements ParserCreator{
     private static final String LANG = "ruby";
     private static final String[] SUFFIX = new String[] {".rb"};
@@ -72,7 +72,7 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 
 	@Override
 	public ImportLookupStrategy getImportLookupStrategy() {
-		return new RubyImportLookupStrategy();
+		return new RubyImportLookupStrategy(entityRepo);
 	}
 
 

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -1,16 +1,15 @@
 package depends.extractor.cpp;
 
-import java.util.ArrayList;
-
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
-
 import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
 import depends.relations.Inferer;
 import multilang.depends.util.file.TemporaryFile;
 
+import java.util.ArrayList;
+
 public abstract class CppParserTest extends ParserTest{
 	protected EntityRepo repo;
 	protected Inferer inferer;
@@ -19,7 +18,7 @@ public abstract class CppParserTest extends ParserTest{
 
 	public void init() {
     	repo = new InMemoryEntityRepo();
-    	inferer = new Inferer(repo,new CppImportLookupStrategy(),new CppBuiltInType(),false);
+    	inferer = new Inferer(repo,new CppImportLookupStrategy(repo),new CppBuiltInType(),false);
     	preprocessorHandler = new PreprocessorHandler("./src/test/resources/cpp-code-examples/",new ArrayList<>());
     	TemporaryFile.reset();
 //    	macroRepo = new MacroMemoryRepo();

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -12,7 +12,7 @@ public abstract class GolangParserTest extends ParserTest{
 
 	public void init() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new GoImportLookupStrategy(),new GoBuiltInType(),false);
+		inferer = new Inferer(entityRepo,new GoImportLookupStrategy(entityRepo),new GoBuiltInType(),false);
     	TemporaryFile.reset();
 	}
 	

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -12,7 +12,7 @@ public abstract class JavaParserTest  extends ParserTest{
 
 	public void init() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(),new JavaBuiltInType(),false);
+		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(entityRepo),new JavaBuiltInType(),false);
     	TemporaryFile.reset();
 	}
 	

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -1,10 +1,5 @@
 package depends.extractor.ruby;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
 import depends.extractor.FileParser;
@@ -13,13 +8,18 @@ import depends.extractor.ParserTest;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
 import multilang.depends.util.file.TemporaryFile;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 public abstract class RubyParserTest extends ParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
 
 	public void init() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(),new RubyBuiltInType(),true);
+		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(entityRepo),new RubyBuiltInType(),true);
     	TemporaryFile.reset();
 	}
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -97,9 +97,9 @@ abstract public class AbstractLangProcessor {
 	private List<String> includePaths;
 	private static Logger logger = LoggerFactory.getLogger(AbstractLangProcessor.class);
 	
-	public AbstractLangProcessor(boolean eagerExpressionResolve) {
+	public AbstractLangProcessor() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
+		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType());
 	}
 
 	/**
@@ -260,4 +260,7 @@ abstract public class AbstractLangProcessor {
 		return relation;
 	}
 
+	public boolean isEagerExpressionResolve(){
+		return false;
+	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -44,8 +44,7 @@ public class CppProcessor extends AbstractLangProcessor {
 	MacroRepo macroRepo = null;
 
 	public CppProcessor() {
-		super(false);
-
+		super();
 	}
 
 	@Override

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -38,7 +38,7 @@ public class GoProcessor extends AbstractLangProcessor {
 	private static final String LANG = "go";
 	private static final String[] SUFFIX = new String[] { ".go" };
 	public GoProcessor() {
-		super(false);
+		super();
 	}
 
 	@Override

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -38,7 +38,6 @@ public class JavaProcessor extends AbstractLangProcessor {
     private static final String JAVA_SUFFIX = ".java";
     
     public JavaProcessor() {
-    	super(false);
     }
     
 	@Override

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -15,7 +15,7 @@ import static depends.deptypes.DependencyType.*;
 public class KotlinProcessor extends AbstractLangProcessor {
 
 	public KotlinProcessor() {
-    	super(true);
+    	super();
 	}
 
 	@Override
@@ -42,7 +42,12 @@ public class KotlinProcessor extends AbstractLangProcessor {
 	protected FileParser createFileParser(String fileFullPath) {
 		return new KotlinFileParser(fileFullPath,entityRepo, inferer);
 	}
-	
+
+	@Override
+	public boolean isEagerExpressionResolve(){
+		return true;
+	}
+
 	@Override
 	public List<String> supportedRelations() {
 		ArrayList<String> depedencyTypes = new ArrayList<>();

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -12,10 +12,6 @@ import static depends.deptypes.DependencyType.*;
 public abstract class BasePythonProcessor extends AbstractLangProcessor{
 	private PythonImportLookupStrategy importedLookupStrategy;
 
-	public BasePythonProcessor(boolean eagerExpressionResolve) {
-		super(eagerExpressionResolve);
-	}
-
 	@Override
 	public String[] fileSuffixes() {
 		return new String[] {".py"};

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -42,9 +42,6 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
     private static final String LANG = "ruby";
     private static final String[] SUFFIX = new String[] {".rb"};
 	private ExecutorService executor;
-    public RubyProcessor() {
-    	super(true);
-    }
 
 	@Override
 	public String supportedLanguage() {
@@ -97,5 +94,10 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(MIXIN);
 		return depedencyTypes;
-	}		
+	}
+
+	@Override
+	public boolean isEagerExpressionResolve(){
+		return true;
+	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -20,7 +20,7 @@ public class AliasTest extends CppParserTest{
 	    String src = "./src/test/resources/cpp-code-examples/Alias.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "F.foo");
 	}
 	
@@ -29,7 +29,7 @@ public class AliasTest extends CppParserTest{
 	    String src = "./src/test/resources/cpp-code-examples/AliasType.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(repo.getEntity("C"), DependencyType.INHERIT, "A");
 	}
 	
@@ -44,7 +44,7 @@ public class AliasTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "foo");
 	}
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -22,7 +22,7 @@ public class ConstructFunctionReturnValueTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         //assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
 	}
 	
@@ -36,7 +36,7 @@ public class ConstructFunctionReturnValueTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         //assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
 	}
 		

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -25,7 +25,7 @@ public class ContainRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
 	}
 	
@@ -40,7 +40,7 @@ public class ContainRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
 	}
 	
@@ -55,7 +55,7 @@ public class ContainRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    this.assertContainsRelation(repo.getEntity("UnderTest"), DependencyType.CONTAIN, "Member");
 	}
 	
@@ -72,7 +72,7 @@ public class ContainRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	}
 	
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -19,7 +19,7 @@ public class CppExpressionTest extends CppParserTest{
 	    String src = "./src/test/resources/cpp-code-examples/Expressions.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         Entity e = repo.getEntity("foo");
         this.assertContainsRelation(e, DependencyType.PARAMETER,"ClassA");
         this.assertContainsRelation(e, DependencyType.CAST,"ClassA");
@@ -37,7 +37,7 @@ public class CppExpressionTest extends CppParserTest{
         String src = "./src/test/resources/cpp-code-examples/DupExpressions.cpp";
         CppFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         Entity e = repo.getEntity("foo");
         assertEquals(4,e.getRelations().size());
     }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -17,7 +17,7 @@ public class CppParameterParserTest extends CppParserTest{
 	    String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -2,6 +2,7 @@ package depends.extractor.cpp;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
+import depends.extractor.AbstractLangProcessor;
 import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
@@ -15,10 +16,12 @@ public abstract class CppParserTest extends ParserTest{
 	protected Inferer inferer;
     protected PreprocessorHandler preprocessorHandler;
 	private MacroRepo macroRepo;
+	protected AbstractLangProcessor langProcessor;
 
 	public void init() {
+		langProcessor = new CppProcessor();
     	repo = new InMemoryEntityRepo();
-    	inferer = new Inferer(repo,new CppImportLookupStrategy(repo),new CppBuiltInType(),false);
+    	inferer = new Inferer(repo,new CppImportLookupStrategy(repo),new CppBuiltInType());
     	preprocessorHandler = new PreprocessorHandler("./src/test/resources/cpp-code-examples/",new ArrayList<>());
     	TemporaryFile.reset();
 //    	macroRepo = new MacroMemoryRepo();
@@ -30,4 +33,8 @@ public abstract class CppParserTest extends ParserTest{
 	public CppFileParser createParser(String src) {
 		return new  CdtCppFileParser(src,repo, preprocessorHandler,inferer,macroRepo );
 	}
+
+	public void  resolveAllBindings(){
+		inferer.resolveAllBindings(false,langProcessor);
+	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -24,7 +24,7 @@ public class DuplicateDeclarationTest extends CppParserTest {
 				    CppFileParser parser = createParser(src);
 				    parser.parse();
 			    }
-			    inferer.resolveAllBindings();
+			    resolveAllBindings();
 			    Entity e = repo.getEntity("X.invoke");
 			    this.assertContainsRelation(e, DependencyType.CONTAIN,"DupClass");
 			    this.assertContainsRelation(e, DependencyType.CALL,"DupClass");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -24,7 +24,7 @@ public class ForwardDeclareTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         //TODO: to be complete
 	}
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -21,7 +21,7 @@ public class GenericTypeTest extends CppParserTest {
 		String src = "./src/test/resources/cpp-code-examples/template/TempateStructure.cpp";
 		CppFileParser parser = createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		assertNotNull(repo.getEntity("hash"));
 	}
 
@@ -30,7 +30,7 @@ public class GenericTypeTest extends CppParserTest {
 		String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
 		CppFileParser parser = createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		this.assertContainsRelation(repo.getEntity("xStack"), DependencyType.PARAMETER, "X");
 	}
 
@@ -39,7 +39,7 @@ public class GenericTypeTest extends CppParserTest {
 		String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
 		CppFileParser parser = createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
 	}
 
@@ -48,7 +48,7 @@ public class GenericTypeTest extends CppParserTest {
 		String src = "./src/test/resources/cpp-code-examples/template/EmbededTemplates.cpp";
 		CppFileParser parser = createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest"), DependencyType.CONTAIN, "MyHashMap");
 		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyList");
 		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyArray");
@@ -59,7 +59,7 @@ public class GenericTypeTest extends CppParserTest {
 		String src = "./src/test/resources/cpp-code-examples/template/TemplateWithDots.cpp";
 		CppFileParser parser = createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		assertNotNull(repo.getEntity("foo.t2"));
 	}
 
@@ -68,7 +68,7 @@ public class GenericTypeTest extends CppParserTest {
 		String src = "./src/test/resources/cpp-code-examples/template/TemplateInReturnValue.cpp";
 		CppFileParser parser = createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		FunctionEntity func = (FunctionEntity) repo.getEntity("get");
 		this.assertContainsRelation(func, DependencyType.RETURN, "std.tuple_element.type");
 		this.assertContainsRelation(repo.getEntity("get"), DependencyType.PARAMETER, "Index");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -33,7 +33,7 @@ public class ImplementRelationTest extends CppParserTest{
 		    CppFileParser parser =createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    MultiDeclareEntities multiDeclare = (MultiDeclareEntities)( repo.getEntity("foo"));
 	    List<Entity> f = multiDeclare.getEntities().stream().filter(item->item.getClass().equals(FunctionEntityImpl.class)).collect(Collectors.toList());
         this.assertContainsRelation(f.get(0),DependencyType.IMPLEMENT,"foo");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -33,7 +33,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         File f = new File(srcs[0]);
         assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
@@ -52,7 +52,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         File f = new File(srcs[0]);
         assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
@@ -68,7 +68,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertEquals("abc",((AliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName().uniqName());
         
 	}
@@ -85,7 +85,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    this.assertContainsRelation(this.repo.getEntity("foo"), DependencyType.CALL, "bar");
 	    this.assertNotContainsRelation(this.repo.getEntity("foo2"), DependencyType.CALL, "bar");
 	}
@@ -102,7 +102,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[1]));
 	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[2]));
 	} 

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -24,7 +24,7 @@ public class MacroRelationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity e = repo.getEntity("foo");
 	    this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
 	    this.assertContainsRelation(e, DependencyType.CONTAIN, Inferer.buildInType.getQualifiedName());

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -28,7 +28,7 @@ public class MacroTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    
         assertNotNull(this.repo.getEntity("Macro"));
 	}
@@ -44,7 +44,7 @@ public class MacroTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    
         assertFalse(repo.getEntity("foo") instanceof MultiDeclareEntities);
 	}
@@ -60,7 +60,7 @@ public class MacroTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    
         assertNotNull(repo.getEntity("Macro3.bar"));
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -23,7 +23,7 @@ public class ParseErrorTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	}
 
 	@Test
@@ -39,7 +39,7 @@ public class ParseErrorTest extends CppParserTest{
 			macroMap.put("AP_DECLARE(x)","x");
 			parser.parse(true,macroMap);
 		}
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 	}
 	
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -29,7 +29,7 @@ public class RelationInSameFileTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,null);
+	    inferer.resolveAllBindings(true,langProcessor);
 	    Entity bar = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -29,7 +29,7 @@ public class RelationToImplementationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,null);
+	    inferer.resolveAllBindings(true,langProcessor);
 	    Entity bar = repo.getEntity("bar");
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {
@@ -56,7 +56,7 @@ public class RelationToImplementationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,null);
+	    inferer.resolveAllBindings(true,langProcessor);
 	    Entity bar = repo.getEntity("baz");
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {
@@ -80,7 +80,7 @@ public class RelationToImplementationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,null);
+	    inferer.resolveAllBindings(true,langProcessor);
 	    Entity bar = repo.getEntity("qux");
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -23,7 +23,7 @@ public class TypeDefTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         this.assertContainsRelation(repo.getEntity("foo"), DependencyType.PARAMETER, "MyInt");
 	}
 			

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -26,7 +26,7 @@ public class UsingTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         Entity e = repo.getEntity("foo");
         this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
         this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");
@@ -44,7 +44,7 @@ public class UsingTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         Entity e = repo.getEntity("bar");
         this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
         this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -24,7 +24,7 @@ public class extendsTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         Entity e = repo.getEntity("B");
         assertEquals(2,e.getRelations().size());
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -20,16 +20,17 @@ public class GoFunctionsTest extends GolangParserTest {
         String src = "./src/test/resources/go-code-examples/func.go";
         GoFileParser parser =createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertNotNull(entityRepo.getEntity("main"));
 	}
 
+
 	@Ignore
 	public void test_could_parse_struct_type() throws IOException {
 		String src = "./src/test/resources/go-code-examples/struct.go";
 		GoFileParser parser =createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		assertNotNull(entityRepo.getEntity("Books"));
 	}
 
@@ -38,7 +39,7 @@ public class GoFunctionsTest extends GolangParserTest {
 		String src = "./src/test/resources/go-code-examples/struct.go";
 		GoFileParser parser =createParser(src);
 		parser.parse();
-		inferer.resolveAllBindings();
+		resolveAllBindings();
 		assertNotNull(entityRepo.getEntity("Books"));
 		TypeEntity book = (TypeEntity)entityRepo.getEntity("Books");
 		assertEquals(4,book.getChildren().size());

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -2,6 +2,7 @@ package depends.extractor.golang;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
+import depends.extractor.AbstractLangProcessor;
 import depends.extractor.ParserTest;
 import depends.relations.Inferer;
 import multilang.depends.util.file.TemporaryFile;
@@ -9,14 +10,21 @@ import multilang.depends.util.file.TemporaryFile;
 public abstract class GolangParserTest extends ParserTest{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
+	private AbstractLangProcessor langProcessor;
 
 	public void init() {
+		langProcessor = new GoProcessor();
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new GoImportLookupStrategy(entityRepo),new GoBuiltInType(),false);
+		inferer = new Inferer(entityRepo,new GoImportLookupStrategy(entityRepo),new GoBuiltInType());
     	TemporaryFile.reset();
 	}
 	
 	public GoFileParser createParser(String src) {
 		return new GoFileParser(src,entityRepo, inferer);
 	}
+
+	public void resolveAllBindings() {
+		inferer.resolveAllBindings(false,langProcessor);
+	}
+
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -19,7 +19,7 @@ public class InheritTypeTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/InheritTest.java";
         JavaFileParser parser =createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("InheritTest").getRelations().size());
 	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -19,7 +19,7 @@ public class JavaAnnotationParserTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
         JavaFileParser parser =createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("AnnotationTest.value").getRelations().size());
 	}
 	
@@ -28,7 +28,7 @@ public class JavaAnnotationParserTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
         JavaFileParser parser =createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("TheClass"), DependencyType.ANNOTATION, "AnnotationTest");
 	}
 	
@@ -37,7 +37,7 @@ public class JavaAnnotationParserTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
         JavaFileParser parser =createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("TheFunction.foo"), DependencyType.ANNOTATION, "AnnotationTest");
 	}
 	
@@ -46,7 +46,7 @@ public class JavaAnnotationParserTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
         JavaFileParser parser =createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertNotContainsRelation(entityRepo.getEntity("TheFunction.bar"), DependencyType.ANNOTATION, "AnnotationTest");
 	}
 
@@ -55,7 +55,7 @@ public class JavaAnnotationParserTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
         JavaFileParser parser =createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("TheClass.TheClass"), DependencyType.ANNOTATION, "AnnotationTest");
         this.assertContainsRelation(entityRepo.getEntity("TheEnum"), DependencyType.ANNOTATION, "AnnotationTest");
         this.assertContainsRelation(entityRepo.getEntity("TheInterface.foo"), DependencyType.ANNOTATION, "AnnotationTest");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -19,7 +19,7 @@ public class JavaCallExpressionTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/SimpleExpressionCallTest.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
 	}
 
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -19,7 +19,7 @@ public class JavaComplexExpressionTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/ComplexExpressionTest.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         ContainerEntity entity  = (ContainerEntity)(entityRepo.getEntity("ComplexExpressionTest.other"));
         assertEquals(3,entity.getRelations().size());
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -16,7 +16,7 @@ public class JavaCylicInheritTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/CyclicInherit.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
 	}
 	
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -17,7 +17,7 @@ public class JavaEmbededClassTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/EmbededTest.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("x.EmbededTest").getRelations().size());
 	}
 
@@ -26,7 +26,7 @@ public class JavaEmbededClassTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/EmbededTest.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("x.EmbededTest2").getRelations().size());
 	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -26,7 +26,7 @@ public class JavaExpressionCreatorTest extends JavaParserTest{
 		    FileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity entity = (entityRepo.getEntity("A.foo"));
 	    this.assertContainsRelation(entity, DependencyType.CREATE, "b.B");
 	}
@@ -43,7 +43,7 @@ public class JavaExpressionCreatorTest extends JavaParserTest{
 		    FileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity entity = (entityRepo.getEntity("X.foo"));
 	    this.assertContainsRelation(entity, DependencyType.CREATE, "b.B");
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -26,7 +26,7 @@ public class JavaFileImportTest extends JavaParserTest{
 		    FileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    TypeEntity type = (TypeEntity)(entityRepo.getEntity("a.Importing"));
 	    this.assertContainsRelation(type, DependencyType.INHERIT, "b.B");
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -18,7 +18,7 @@ public class JavaGenericTypeTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/GenericTypeTest.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("x.GenericTypeTest.v"),
         		DependencyType.PARAMETER, "x.Parent2.Enum");
 	}
@@ -28,7 +28,7 @@ public class JavaGenericTypeTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/GenericTypeEmbededTest.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest"),
         		DependencyType.CONTAIN, "MyHashMap");
         this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"),

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -18,7 +18,7 @@ public class JavaParameterParserTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/FunctionParameters.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(4,entityRepo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -16,7 +16,7 @@ public class JavaParseErrorFileTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/IncompleteFile.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
 	}
 	
 	@Test
@@ -24,7 +24,7 @@ public class JavaParseErrorFileTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/EclipseTestBase_No_ResponseDuirngTypeResolve.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
 	}
 	
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -2,21 +2,31 @@ package depends.extractor.java;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
+import depends.extractor.AbstractLangProcessor;
 import depends.extractor.ParserTest;
+import depends.extractor.UnsolvedBindings;
 import depends.relations.Inferer;
 import multilang.depends.util.file.TemporaryFile;
 
+import java.util.Set;
+
 public abstract class JavaParserTest  extends ParserTest{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
+	private AbstractLangProcessor langProcessor;
 
 	public void init() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(entityRepo),new JavaBuiltInType(),false);
+		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(entityRepo),new JavaBuiltInType());
     	TemporaryFile.reset();
+		langProcessor = new JavaProcessor();
 	}
 	
 	public JavaFileParser createParser(String src) {
 		return new JavaFileParser(src,entityRepo, inferer);
 	}
+
+	public Set<UnsolvedBindings> resolveAllBindings() {
+		return inferer.resolveAllBindings(false,langProcessor);
+	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -21,7 +21,7 @@ public class JavaTypeInferUnderSamePackageTest extends JavaParserTest{
         src = "./src/test/resources/java-code-examples/TypeInferUnderSamePackageB.java";
         parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("x.TypeInferUnderSamePackageA").getRelations().size());
 	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -23,7 +23,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/FieldVar.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         Entity classEntity = entityRepo.getEntity("FieldVar");
         assertEquals(3,((TypeEntity)classEntity).getVars().size()); 
 	}
@@ -33,7 +33,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/LocalVar.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(1,((TypeEntity)entityRepo.getEntity("LocalVar")).getVars().size());
         assertEquals(1,((FunctionEntity)entityRepo.getEntity("LocalVar.foo")).getVars().size());
 	}
@@ -43,7 +43,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/LocalVarInferExample.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
         this.assertContainsRelation(e, DependencyType.CONTAIN, "MyInteger");
 	}
@@ -53,7 +53,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/ComplexExpressionExample.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         Entity e = entityRepo.getEntity("test.ComplexExpressionExample.setExample");
         this.assertContainsRelation(e, DependencyType.PARAMETER, "test.ClassA");
         this.assertContainsRelation(e, DependencyType.CREATE, "test.ClassA");
@@ -73,7 +73,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/LongExpressionWithAbsolutePath.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(5,entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
 	}
 	
@@ -84,7 +84,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/ExpressionCallTest.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         assertEquals(10,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
 	
@@ -93,7 +93,7 @@ public class JavaVarResolveTest extends JavaParserTest{
         String src = "./src/test/resources/java-code-examples/TypeArgument.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.resolveAllBindings();
+        resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("JDepObject.cells"),DependencyType.PARAMETER, "JCellObject");
 	}
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -21,7 +21,7 @@ public class UnsolvedSymbolsTest extends JavaParserTest {
         JavaFileParser parser = createParser(src);
         parser.parse();
         inferer.setCollectUnsolvedBindings(true);
-        Set<UnsolvedBindings> missing = inferer.resolveAllBindings();
+        Set<UnsolvedBindings> missing = resolveAllBindings();
         assertEquals(1,missing.size());
         assertEquals("a.b",missing.iterator().next().getRawName());
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -1,13 +1,9 @@
 package depends.extractor.pom;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
+import java.io.IOException;
 
 public class DependencyTest extends MavenParserTest{
     @Before
@@ -26,8 +22,8 @@ public class DependencyTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	    resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -41,8 +37,8 @@ public class DependencyTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	    resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -1,13 +1,12 @@
 package depends.extractor.pom;
-import static org.junit.Assert.assertFalse;
-
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
+import depends.entity.MultiDeclareEntities;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
-import depends.entity.MultiDeclareEntities;
+import java.io.IOException;
+
+import static org.junit.Assert.assertFalse;
 
 public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
     @Before
@@ -27,9 +26,9 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    assertFalse(repo.getEntity("parent-group.a-parent_1.0_") instanceof MultiDeclareEntities);
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -44,8 +43,8 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	    resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -1,13 +1,9 @@
 package depends.extractor.pom;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
+import java.io.IOException;
 
 public class DependencyWithPropertiesTest extends MavenParserTest{
     @Before
@@ -26,8 +22,8 @@ public class DependencyWithPropertiesTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	    resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -41,8 +37,8 @@ public class DependencyWithPropertiesTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	    resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -1,10 +1,9 @@
 package depends.extractor.pom;
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
+import java.io.IOException;
 
 public class DependencyWithoutVersionTest extends MavenParserTest{
     @Before
@@ -23,8 +22,8 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	    resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -38,8 +37,8 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	    resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -23,7 +23,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertEquals(0,repo.getEntity("org.log4j-test.log4j_1.2.12_").getRelations().size());
 	}
 	
@@ -38,7 +38,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4_2.12.4_"));
 	}
 	
@@ -52,7 +52,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
     	/*
         <project.version>1.00</project.version>
@@ -74,7 +74,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
     	/*
         <project.version>1.00</project.version>
@@ -94,7 +94,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    PomFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
         assertEquals("13",entity.getProperty("project.version"));
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -1,17 +1,19 @@
 package depends.extractor.pom;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserTest;
+import depends.extractor.UnsolvedBindings;
 import depends.relations.Inferer;
 import multilang.depends.util.file.TemporaryFile;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
 public abstract class MavenParserTest extends ParserTest{
 
 	protected EntityRepo repo;
-	private PomProcessor p;
+	private PomProcessor langProcessor;
 	protected Inferer inferer;
 
 	public void init() {
@@ -20,16 +22,20 @@ public abstract class MavenParserTest extends ParserTest{
 		includeDir.add("./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent");
 		includeDir.add("./src/test/resources/maven-code-examples/dependencyWithoutVersion");
 		
-		this.p = new PomProcessor();
-		p.includeDirs = includeDir.toArray(new String[] {});
+		this.langProcessor = new PomProcessor();
+		langProcessor.includeDirs = includeDir.toArray(new String[] {});
 		
-		this.repo = p.getEntityRepo();
-		this.inferer = p.inferer;
+		this.repo = langProcessor.getEntityRepo();
+		this.inferer = langProcessor.inferer;
     	TemporaryFile.reset();
 
     }
 	
 	public PomFileParser createParser(String src) {
-		return (PomFileParser) p.createFileParser(src);
+		return (PomFileParser) langProcessor.createFileParser(src);
+	}
+
+	public Set<UnsolvedBindings> resolveAllBindings() {
+		return inferer.resolveAllBindings(false, langProcessor);
 	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -28,7 +28,7 @@ public class PythonClassTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertNotNull(repo.getEntity(withPackageName(srcs[0],"Foo")));
 	}
 	
@@ -42,7 +42,7 @@ public class PythonClassTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Foo"));
         assertEquals(2,type.getFunctions().size());
 	}
@@ -57,7 +57,7 @@ public class PythonClassTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Bar"));
 	    this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -28,7 +28,7 @@ public class PythonDecoratorTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(func, DependencyType.ANNOTATION	, withPackageName(srcs[0],"our_decorator"));
 	    assertEquals(1,func.getResolvedAnnotations().size());

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -26,7 +26,7 @@ public class PythonFuncCallTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"bar"));
 	}
@@ -41,7 +41,7 @@ public class PythonFuncCallTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"baz"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"A.foo"));
 	}
@@ -57,7 +57,7 @@ public class PythonFuncCallTest extends PythonParserTest {
 		    parser.parse();
 	    }
 
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"C.test"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"A.fooA"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"B.fooB"));

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -27,7 +27,7 @@ public class PythonFunctionTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertNotNull(repo.getEntity(withPackageName(srcs[0],"foo")));
 	}
 	
@@ -41,7 +41,7 @@ public class PythonFunctionTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
         assertEquals(2,func.getParameters().size());
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -25,7 +25,7 @@ public class PythonGlobalVarTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,null);
+	    inferer.resolveAllBindings(true,langProcessor);
         Entity foo = repo.getEntity(withPackageName(srcs[0],"foo"));
         this.assertContainsRelation(foo, DependencyType.USE, "global_var");
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -30,7 +30,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[0]));
 	}
@@ -47,7 +47,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
@@ -64,7 +64,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
@@ -81,7 +81,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
@@ -99,7 +99,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
@@ -117,7 +117,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[1],"foo"));
@@ -136,7 +136,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[3])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
@@ -152,7 +152,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	}
 	
 	
@@ -167,7 +167,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
@@ -183,7 +183,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
@@ -199,7 +199,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"test"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"foo"));
 	}
@@ -218,7 +218,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    
 	    MultiDeclareEntities funcs = (MultiDeclareEntities)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
 	    Entity func = funcs.getEntities().get(0);
@@ -240,7 +240,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    
 	    MultiDeclareEntities funcs = (MultiDeclareEntities)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
 	    Entity func = funcs.getEntities().get(0);
@@ -261,7 +261,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"bar"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[2],"C"));
 	}
@@ -277,7 +277,7 @@ public class PythonImportTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FileEntity f = (FileEntity)repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 	    this.assertContainsRelation(f, DependencyType.CALL, withPackageName(srcs[1],"Core.foo"));
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -26,7 +26,7 @@ public class PythonObjectCreationTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
 	    this.assertContainsRelation(func, DependencyType.CREATE, withPackageName(srcs[0],"Bar"));
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -26,7 +26,7 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t1"));
 	    this.assertContainsRelation(func, DependencyType.THROW, withPackageName(srcs[0],"Bar"));
 	}
@@ -42,7 +42,7 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t2"));
 	    this.assertContainsRelation(func, DependencyType.RETURN, withPackageName(srcs[0],"Bar"));
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -31,7 +31,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
 	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
@@ -51,7 +51,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
 	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
@@ -70,7 +70,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test2");
 	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
@@ -90,7 +90,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
 	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t2");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -1,32 +1,31 @@
 package depends.extractor.python;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.repo.EntityRepo;
-import depends.extractor.FileParser;
-import depends.extractor.ParserCreator;
-import depends.extractor.ParserTest;
+import depends.extractor.*;
 import depends.extractor.python.union.PythonFileParser;
 import depends.extractor.python.union.PythonProcessor;
 import depends.relations.Inferer;
 import multilang.depends.util.file.FileUtil;
 import multilang.depends.util.file.TemporaryFile;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
 public abstract class PythonParserTest extends ParserTest implements ParserCreator {
 
 	protected EntityRepo repo;
-	private PythonProcessor p;
+	protected PythonProcessor langProcessor;
 	protected Inferer inferer;
 
 	public void init() {
 		List<String> includeDir = new ArrayList<>();
 		includeDir.add("./src/test/resources/python-code-examples/");
-		this.p = new PythonProcessor();
-		p.includeDirs = includeDir.toArray(new String[] {});
+		this.langProcessor = new PythonProcessor();
+		langProcessor.includeDirs = includeDir.toArray(new String[] {});
 		
-		this.repo = p.getEntityRepo();
-		this.inferer = p.inferer;
+		this.repo = langProcessor.getEntityRepo();
+		this.inferer = langProcessor.inferer;
     	TemporaryFile.reset();
 		
     }
@@ -37,10 +36,14 @@ public abstract class PythonParserTest extends ParserTest implements ParserCreat
 	
 	@Override
 	public FileParser createFileParser(String src) {
-		return  p.createFileParser(FileUtil.uniqFilePath(src));
+		return  langProcessor.createFileParser(FileUtil.uniqFilePath(src));
 	}
 	
 	protected String withPackageName(String theFile,String entityName) {
 		return FileUtil.uniqFilePath(FileUtil.getLocatedDir(theFile))+"."+entityName;
 	}
+
+	public Set<UnsolvedBindings> resolveAllBindings() {
+		return inferer.resolveAllBindings(false, langProcessor);
+	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -28,7 +28,7 @@ public class SelfShouldBeThisTypeTest extends PythonParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"A.foo")));
 	    VarEntity var = function.lookupVarLocally("self");
 	    TypeEntity type = var.getType();

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -26,7 +26,7 @@ public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"bar")));
 	    this.assertContainsRelation(function, DependencyType.CALL, withPackageName(srcs[0],"foo"));
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -29,7 +29,7 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
 	    VarEntity var = function.lookupVarLocally("var_int");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
@@ -56,7 +56,7 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.operator_is_call"));
 	    VarEntity var = function.lookupVarLocally("var_compose");
 	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -25,7 +25,7 @@ public class RubyClassMethodcallTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
 	    this.assertContainsRelation(function, DependencyType.CALL, "Foo1.bar");
 	    this.assertContainsRelation(function, DependencyType.CALL, "Foo2.bar");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -27,7 +27,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
 	}
 	
@@ -42,7 +42,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
 	}
 	
@@ -57,7 +57,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    super.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
 	}
 	
@@ -71,7 +71,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    super.assertContainsRelation(entityRepo.getEntity("ZooCat"), DependencyType.INHERIT, "Zoo.Animal");
 	}
 	
@@ -85,7 +85,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("Zoo.Cow"), DependencyType.INHERIT, "Zoo.Animal");
 	}
 	
@@ -99,7 +99,7 @@ public class RubyInheritTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());
         Relation r = entityRepo.getEntity("Cat").getRelations().get(0);
         assertEquals(DependencyType.INHERIT,r.getType());

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -23,7 +23,7 @@ public class RubyMixinTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    assertContainsRelation(entityRepo.getEntity("MixedIn"),DependencyType.MIXIN,"ToBeMixin");
 
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -23,7 +23,7 @@ public class RubyObjectCreationTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    super.assertContainsRelation(entityRepo.getEntity("T.foo"), DependencyType.CREATE, "M");
 	}
 	

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -30,7 +30,7 @@ public class RubyParameterTypeDedudceTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
 	    VarEntity var = function.lookupVarLocally("t1");
 	    TypeEntity type = var.getType();

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -2,25 +2,26 @@ package depends.extractor.ruby;
 
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
-import depends.extractor.FileParser;
-import depends.extractor.ParserCreator;
-import depends.extractor.ParserTest;
+import depends.extractor.*;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.Inferer;
 import multilang.depends.util.file.TemporaryFile;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 public abstract class RubyParserTest extends ParserTest implements ParserCreator{
 	protected  EntityRepo entityRepo ;
 	protected Inferer inferer ;
+	private AbstractLangProcessor langProcessor;
 
 	public void init() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(entityRepo),new RubyBuiltInType(),true);
+		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(entityRepo),new RubyBuiltInType());
     	TemporaryFile.reset();
+		langProcessor = new RubyProcessor();
 	}
 	
 	public FileParser createFileParser(String src) {
@@ -31,6 +32,8 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 	private List<String> includePaths() {
 		return new ArrayList<>();
 	}
-	
 
+	public Set<UnsolvedBindings> resolveAllBindings() {
+		return inferer.resolveAllBindings(false, langProcessor);
+	}
 }

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -25,7 +25,7 @@ public class RubyRaiseTypeDedudceTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
 	    this.assertContainsRelation(function, DependencyType.THROW, "Class1");
 	}

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -25,7 +25,7 @@ public class RubyRequireTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
         File f = new File(srcs[0]);
         File f2 = new File(srcs[1]);
         

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -24,7 +24,7 @@ public class RubyReturnTypeDedudceTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
 	    this.assertContainReturnType(function,"Class");
 

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -25,7 +25,7 @@ public class RubyVCallTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
 	    this.assertContainsRelation(function, DependencyType.CALL, "called");
 	}
@@ -40,7 +40,7 @@ public class RubyVCallTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
 	    this.assertContainsRelation(function, DependencyType.CALL, "foo");
 	    this.assertContainsRelation(function, DependencyType.CALL, "bar");

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -25,7 +25,7 @@ public class RubyVariableCallTest extends RubyParserTest {
 		    FileParser parser = createFileParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings();
+	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));
 	    this.assertContainsRelation(function, DependencyType.CALL, "Class.function");
 	}

2fbd504d61455e28fb36cde50ad689d81ae69b79
@@ -24,13 +24,13 @@ SOFTWARE.
 
 package depends.entity.repo;
 
-import java.util.Collection;
-import java.util.Iterator;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.GenericName;
 
+import java.util.Collection;
+import java.util.Iterator;
+
 public interface EntityRepo extends IdGenerator {
 	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
@@ -52,6 +52,5 @@ public interface EntityRepo extends IdGenerator {
 
 	void addFile(FileEntity currentFileEntity);
 
-
-
+    void clear();
 }

2fbd504d61455e28fb36cde50ad689d81ae69b79
@@ -1,19 +1,13 @@
 package depends.entity.repo;
 
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.TreeMap;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.GenericName;
 import depends.entity.MultiDeclareEntities;
 
+import java.util.*;
+import java.util.Map.Entry;
+
 
 public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo {
 
@@ -109,4 +103,10 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 		allFileEntitiesByOrder.add(fileEntity);
 	}
 
+	@Override
+	public void clear() {
+		allEntieisByName.clear();
+		allEntitiesById.clear();
+		allFileEntitiesByOrder.clear();
+	}
 }

2fbd504d61455e28fb36cde50ad689d81ae69b79
@@ -29,9 +29,6 @@ import depends.entity.FileEntity;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
-import depends.generator.DependencyGenerator;
-import depends.matrix.core.DependencyMatrix;
-import depends.matrix.transform.OrderedMatrixGenerator;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import multilang.depends.util.file.FileTraversal;
@@ -88,12 +85,9 @@ abstract public class AbstractLangProcessor {
 
 	public Inferer inferer;
 	protected EntityRepo entityRepo;
-	DependencyMatrix dependencyMatrix;
 	protected String inputSrcPath;
 	public String[] includeDirs;
-	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> potentialExternalDependencies;
-	private List<String> typeFilter;
 	private List<String> includePaths;
 	private static Logger logger = LoggerFactory.getLogger(AbstractLangProcessor.class);
 	
@@ -106,14 +100,14 @@ abstract public class AbstractLangProcessor {
 	 * The process steps of build dependencies. Step 1: parse all files, add
 	 * entities and expression into repositories Step 2: resolve bindings of files
 	 * (if not resolved yet) Step 3: identify dependencies
-	 * 
-	 * @param includeDir
+	 *
 	 * @param inputDir
+	 * @param includeDir
+	 * @return
 	 */
-	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl, boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
+	public EntityRepo buildDependencies(String inputDir, String[] includeDir, boolean callAsImpl, boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
-		this.typeFilter = typeFilter;
 		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
 		this.inferer.setDuckTypingDeduce(isDuckTypingDeduce);
 		logger.info("Start parsing files...");
@@ -128,8 +122,7 @@ abstract public class AbstractLangProcessor {
 			System.gc();
 			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
 		}
-		identifyDependencies();
-		logger.info("Dependencie data generating done successfully...");
+		return entityRepo;
 	}
 
 	private void markAllEntitiesScope() {
@@ -159,14 +152,7 @@ abstract public class AbstractLangProcessor {
 		System.out.println("types and bindings resolved successfully...");
 	}
 
-	private void identifyDependencies() {
-		System.out.println("dependencie data generating...");
-		dependencyMatrix = dependencyGenerator.build(entityRepo, typeFilter);
-		entityRepo = null;
-		System.out.println("reorder dependency matrix...");
-		dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
-		System.out.println("Dependencie data generating done successfully...");
-	}
+
 
 	private final void parseAllFiles() {
 		System.out.println("Start parsing files...");
@@ -238,17 +224,11 @@ abstract public class AbstractLangProcessor {
 		return includePaths;
 	}
 
-	public DependencyMatrix getDependencies() {
-		return dependencyMatrix;
-	}
 
 	public EntityRepo getEntityRepo() {
 		return this.entityRepo;
 	}
 
-	public void setDependencyGenerator(DependencyGenerator dependencyGenerator) {
-		this.dependencyGenerator = dependencyGenerator;
-	}
 
 	public abstract List<String> supportedRelations();
 

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -81,7 +81,7 @@ abstract public class AbstractLangProcessor {
 	 * @param fileFullPath
 	 * @return
 	 */
-	protected abstract FileParser createFileParser(String fileFullPath);
+	public abstract FileParser createFileParser(String fileFullPath);
 
 	public Inferer inferer;
 	protected EntityRepo entityRepo;
@@ -93,7 +93,6 @@ abstract public class AbstractLangProcessor {
 	
 	public AbstractLangProcessor() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType());
 	}
 
 	/**
@@ -103,13 +102,13 @@ abstract public class AbstractLangProcessor {
 	 *
 	 * @param inputDir
 	 * @param includeDir
+	 * @param inferer
 	 * @return
 	 */
-	public EntityRepo buildDependencies(String inputDir, String[] includeDir, boolean callAsImpl, boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
+	public EntityRepo buildDependencies(String inputDir, String[] includeDir, Inferer inferer) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
-		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
-		this.inferer.setDuckTypingDeduce(isDuckTypingDeduce);
+		this.inferer = inferer;
 		logger.info("Start parsing files...");
 		parseAllFiles();
 		markAllEntitiesScope();
@@ -117,7 +116,7 @@ abstract public class AbstractLangProcessor {
 			logger.info("Resolve types and bindings of variables, methods and expressions.... " + this.inputSrcPath);
 			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
 		}
-		resolveBindings(callAsImpl);
+		resolveBindings();
 		if (logger.isInfoEnabled()) {
 			System.gc();
 			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
@@ -143,9 +142,9 @@ abstract public class AbstractLangProcessor {
 	 * @param callAsImpl
 	 * @return unsolved bindings
 	 */
-	public void resolveBindings(boolean callAsImpl) {
+	public void resolveBindings() {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
+		this.potentialExternalDependencies = inferer.resolveAllBindings(this);
 		if (getExternalDependencies().size() > 0) {
 			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
 		}

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -58,7 +58,7 @@ public class CppProcessor extends AbstractLangProcessor {
 	}
 
 	@Override
-	protected FileParser createFileParser(String fileFullPath) {
+	public FileParser createFileParser(String fileFullPath) {
 		if (macroRepo == null) {
 			macroRepo = new MacroEhcacheRepo(entityRepo);
 			macroRepo.buildDefaultMap(super.includePaths());

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -52,7 +52,7 @@ public class GoProcessor extends AbstractLangProcessor {
 	}
 
 	@Override
-	protected FileParser createFileParser(String fileFullPath) {
+	public FileParser createFileParser(String fileFullPath) {
 		return new GoFileParser(fileFullPath, entityRepo, inferer);
 	}
 

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -51,7 +51,7 @@ public class JavaProcessor extends AbstractLangProcessor {
 	}
 	
 	@Override
-	protected FileParser createFileParser(String fileFullPath) {
+	public FileParser createFileParser(String fileFullPath) {
 		return new JavaFileParser(fileFullPath,entityRepo, inferer);
 	}
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -39,7 +39,7 @@ public class KotlinProcessor extends AbstractLangProcessor {
 	}
 
 	@Override
-	protected FileParser createFileParser(String fileFullPath) {
+	public FileParser createFileParser(String fileFullPath) {
 		return new KotlinFileParser(fileFullPath,entityRepo, inferer);
 	}
 

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -41,8 +41,8 @@ public class RelationCounter {
 	private boolean callAsImpl;
 	private AbstractLangProcessor langProcessor;
 
-	public RelationCounter(Collection<Entity> iterator, Inferer inferer, EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor) {
-		this.entities = iterator;
+	public RelationCounter( EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor,Inferer inferer) {
+		this.entities = repo.getFileEntities();
 		this.inferer = inferer;
 		this.repo = repo;
 		this.callAsImpl = callAsImpl;

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,17 +1,52 @@
 package depends.extractor;
 
-import static org.junit.Assert.fail;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.VarEntity;
+import depends.entity.repo.EntityRepo;
+import depends.relations.Inferer;
 import depends.relations.Relation;
+import depends.relations.RelationCounter;
+import multilang.depends.util.file.TemporaryFile;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Set;
+
+import static org.junit.Assert.fail;
 
 public abstract class ParserTest {
+	protected EntityRepo entityRepo ;
+	protected Inferer inferer ;
+	protected AbstractLangProcessor langProcessor;
+
+	protected  void init(){
+		entityRepo = langProcessor.getEntityRepo();
+		inferer = new Inferer(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),false,false);
+		langProcessor.inferer = inferer;
+		TemporaryFile.reset();
+	}
+
+	protected  void init(boolean duckTypingDeduce){
+		entityRepo = langProcessor.getEntityRepo();
+		inferer = new Inferer(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),false,duckTypingDeduce);
+		langProcessor.inferer = inferer;
+		TemporaryFile.reset();
+	}
+
+	public Set<UnsolvedBindings> resolveAllBindings() {
+		Set<UnsolvedBindings> result = inferer.resolveAllBindings(langProcessor);
+		new RelationCounter(entityRepo,false,langProcessor,inferer).computeRelations();
+		return result;
+	}
+
+	protected Set<UnsolvedBindings>  resolveAllBindings(boolean callAsImpl) {
+		Set<UnsolvedBindings> result = inferer.resolveAllBindings(langProcessor);
+		new RelationCounter(entityRepo,callAsImpl,langProcessor,inferer).computeRelations();
+		return result;
+	}
+
 	protected void assertNotContainsRelation(Entity inEntity, String dependencyType, String dependedEntityFullName) {
 		for (Relation r:inEntity.getRelations()) {
 			if (r.getType().equals(dependencyType)) {
@@ -69,4 +104,5 @@ public abstract class ParserTest {
 	    }
 	    fail("cannot found return type with rawname " + name);			
 	}
+
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,13 +1,12 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.fail;
-
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
+import java.io.IOException;
+
+import static org.junit.Assert.fail;
 
 public class AliasTest extends CppParserTest{
     @Before
@@ -21,7 +20,7 @@ public class AliasTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "F.foo");
+        this.assertContainsRelation(entityRepo.getEntity("bar"), DependencyType.CALL, "F.foo");
 	}
 	
 	@Test
@@ -30,7 +29,7 @@ public class AliasTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("C"), DependencyType.INHERIT, "A");
+        this.assertContainsRelation(entityRepo.getEntity("C"), DependencyType.INHERIT, "A");
 	}
 	
 	@Test
@@ -45,7 +44,7 @@ public class AliasTest extends CppParserTest{
 		    parser.parse();
 	    }
         resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "foo");
+        this.assertContainsRelation(entityRepo.getEntity("bar"), DependencyType.CALL, "foo");
 	}
 	
 	@Ignore

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,13 +1,11 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
+import depends.deptypes.DependencyType;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
-import depends.extractor.cpp.cdt.CdtCppFileParser;
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
 
 public class ContainRelationTest extends CppParserTest{
     @Before
@@ -26,7 +24,7 @@ public class ContainRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
+        assertEquals(1, entityRepo.getEntity("UnderTest").getRelations().size());
 	}
 	
 	@Test
@@ -41,7 +39,7 @@ public class ContainRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
+        assertEquals(2, entityRepo.getEntity("UnderTest").getRelations().size());
 	}
 	
 	@Test
@@ -56,7 +54,7 @@ public class ContainRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("UnderTest"), DependencyType.CONTAIN, "Member");
+	    this.assertContainsRelation(entityRepo.getEntity("UnderTest"), DependencyType.CONTAIN, "Member");
 	}
 	
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -20,7 +20,7 @@ public class CppExpressionTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         resolveAllBindings();
-        Entity e = repo.getEntity("foo");
+        Entity e = entityRepo.getEntity("foo");
         this.assertContainsRelation(e, DependencyType.PARAMETER,"ClassA");
         this.assertContainsRelation(e, DependencyType.CAST,"ClassA");
         this.assertContainsRelation(e, DependencyType.CALL,"ClassA");
@@ -38,7 +38,7 @@ public class CppExpressionTest extends CppParserTest{
         CppFileParser parser = createParser(src);
         parser.parse();
         resolveAllBindings();
-        Entity e = repo.getEntity("foo");
+        Entity e = entityRepo.getEntity("foo");
         assertEquals(4,e.getRelations().size());
     }
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -18,7 +18,7 @@ public class CppParameterParserTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         resolveAllBindings();
-        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        assertEquals(4, entityRepo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,40 +1,23 @@
 package depends.extractor.cpp;
 
-import depends.entity.repo.EntityRepo;
-import depends.entity.repo.InMemoryEntityRepo;
-import depends.extractor.AbstractLangProcessor;
 import depends.extractor.ParserTest;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 import depends.extractor.cpp.cdt.PreprocessorHandler;
-import depends.relations.Inferer;
-import multilang.depends.util.file.TemporaryFile;
 
 import java.util.ArrayList;
 
 public abstract class CppParserTest extends ParserTest{
-	protected EntityRepo repo;
-	protected Inferer inferer;
     protected PreprocessorHandler preprocessorHandler;
 	private MacroRepo macroRepo;
-	protected AbstractLangProcessor langProcessor;
 
 	public void init() {
 		langProcessor = new CppProcessor();
-    	repo = new InMemoryEntityRepo();
-    	inferer = new Inferer(repo,new CppImportLookupStrategy(repo),new CppBuiltInType());
     	preprocessorHandler = new PreprocessorHandler("./src/test/resources/cpp-code-examples/",new ArrayList<>());
-    	TemporaryFile.reset();
-//    	macroRepo = new MacroMemoryRepo();
-//    	macroRepo = new MacroFileRepo(repo);
-    	macroRepo = new MacroEhcacheRepo(repo);
-
+		super.init();
+    	macroRepo = new MacroEhcacheRepo(entityRepo);
     }
 	
 	public CppFileParser createParser(String src) {
-		return new  CdtCppFileParser(src,repo, preprocessorHandler,inferer,macroRepo );
-	}
-
-	public void  resolveAllBindings(){
-		inferer.resolveAllBindings(false,langProcessor);
+		return new  CdtCppFileParser(src, entityRepo, preprocessorHandler,inferer,macroRepo );
 	}
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -25,7 +25,7 @@ public class DuplicateDeclarationTest extends CppParserTest {
 				    parser.parse();
 			    }
 			    resolveAllBindings();
-			    Entity e = repo.getEntity("X.invoke");
+			    Entity e = entityRepo.getEntity("X.invoke");
 			    this.assertContainsRelation(e, DependencyType.CONTAIN,"DupClass");
 			    this.assertContainsRelation(e, DependencyType.CALL,"DupClass");
 			    this.assertContainsRelation(e, DependencyType.CREATE,"DupClass");

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -22,7 +22,7 @@ public class GenericTypeTest extends CppParserTest {
 		CppFileParser parser = createParser(src);
 		parser.parse();
 		resolveAllBindings();
-		assertNotNull(repo.getEntity("hash"));
+		assertNotNull(entityRepo.getEntity("hash"));
 	}
 
 	@Test
@@ -31,7 +31,7 @@ public class GenericTypeTest extends CppParserTest {
 		CppFileParser parser = createParser(src);
 		parser.parse();
 		resolveAllBindings();
-		this.assertContainsRelation(repo.getEntity("xStack"), DependencyType.PARAMETER, "X");
+		this.assertContainsRelation(entityRepo.getEntity("xStack"), DependencyType.PARAMETER, "X");
 	}
 
 	@Test
@@ -40,7 +40,7 @@ public class GenericTypeTest extends CppParserTest {
 		CppFileParser parser = createParser(src);
 		parser.parse();
 		resolveAllBindings();
-		this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
+		this.assertContainsRelation(entityRepo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
 	}
 
 	@Test
@@ -49,9 +49,9 @@ public class GenericTypeTest extends CppParserTest {
 		CppFileParser parser = createParser(src);
 		parser.parse();
 		resolveAllBindings();
-		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest"), DependencyType.CONTAIN, "MyHashMap");
-		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyList");
-		this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyArray");
+		this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest"), DependencyType.CONTAIN, "MyHashMap");
+		this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyList");
+		this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyArray");
 	}
 
 	@Test
@@ -60,7 +60,7 @@ public class GenericTypeTest extends CppParserTest {
 		CppFileParser parser = createParser(src);
 		parser.parse();
 		resolveAllBindings();
-		assertNotNull(repo.getEntity("foo.t2"));
+		assertNotNull(entityRepo.getEntity("foo.t2"));
 	}
 
 	@Test
@@ -69,11 +69,11 @@ public class GenericTypeTest extends CppParserTest {
 		CppFileParser parser = createParser(src);
 		parser.parse();
 		resolveAllBindings();
-		FunctionEntity func = (FunctionEntity) repo.getEntity("get");
+		FunctionEntity func = (FunctionEntity) entityRepo.getEntity("get");
 		this.assertContainsRelation(func, DependencyType.RETURN, "std.tuple_element.type");
-		this.assertContainsRelation(repo.getEntity("get"), DependencyType.PARAMETER, "Index");
-		this.assertContainsRelation(repo.getEntity("get"), DependencyType.PARAMETER, "std.tuple");
-		this.assertContainsRelation(repo.getEntity("get"), DependencyType.PARAMETER, "Domains");
+		this.assertContainsRelation(entityRepo.getEntity("get"), DependencyType.PARAMETER, "Index");
+		this.assertContainsRelation(entityRepo.getEntity("get"), DependencyType.PARAMETER, "std.tuple");
+		this.assertContainsRelation(entityRepo.getEntity("get"), DependencyType.PARAMETER, "Domains");
 	}
 
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,20 +1,14 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
-import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.FunctionEntityImpl;
 import depends.entity.MultiDeclareEntities;
-import depends.extractor.cpp.cdt.CdtCppFileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.stream.Collectors;
 
 public class ImplementRelationTest extends CppParserTest{
     @Before
@@ -34,7 +28,7 @@ public class ImplementRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    MultiDeclareEntities multiDeclare = (MultiDeclareEntities)( repo.getEntity("foo"));
+	    MultiDeclareEntities multiDeclare = (MultiDeclareEntities)( entityRepo.getEntity("foo"));
 	    List<Entity> f = multiDeclare.getEntities().stream().filter(item->item.getClass().equals(FunctionEntityImpl.class)).collect(Collectors.toList());
         this.assertContainsRelation(f.get(0),DependencyType.IMPLEMENT,"foo");
 	}

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -35,7 +35,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+        assertEquals(3, entityRepo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
 	
 	
@@ -54,7 +54,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals(1,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+        assertEquals(1, entityRepo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
 	
 	
@@ -69,7 +69,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        assertEquals("abc",((AliasEntity)repo.getEntity("abc_t")).getOriginType().getRawName().uniqName());
+        assertEquals("abc",((AliasEntity) entityRepo.getEntity("abc_t")).getOriginType().getRawName().uniqName());
         
 	}
 	
@@ -86,8 +86,8 @@ public class IncludeRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(this.repo.getEntity("foo"), DependencyType.CALL, "bar");
-	    this.assertNotContainsRelation(this.repo.getEntity("foo2"), DependencyType.CALL, "bar");
+	    this.assertContainsRelation(this.entityRepo.getEntity("foo"), DependencyType.CALL, "bar");
+	    this.assertNotContainsRelation(this.entityRepo.getEntity("foo2"), DependencyType.CALL, "bar");
 	}
 	
 	@Test
@@ -103,7 +103,7 @@ public class IncludeRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[1]));
-	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[2]));
+	    this.assertContainsRelation(this.entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[1]));
+	    this.assertContainsRelation(this.entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[2]));
 	} 
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -25,7 +25,7 @@ public class MacroRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    Entity e = repo.getEntity("foo");
+	    Entity e = entityRepo.getEntity("foo");
 	    this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
 	    this.assertContainsRelation(e, DependencyType.CONTAIN, Inferer.buildInType.getQualifiedName());
 	}

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -9,7 +9,6 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
 import depends.entity.MultiDeclareEntities;
 
 public class MacroTest extends CppParserTest{
@@ -30,7 +29,7 @@ public class MacroTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
 	    
-        assertNotNull(this.repo.getEntity("Macro"));
+        assertNotNull(this.entityRepo.getEntity("Macro"));
 	}
 
 	@Test
@@ -46,7 +45,7 @@ public class MacroTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
 	    
-        assertFalse(repo.getEntity("foo") instanceof MultiDeclareEntities);
+        assertFalse(entityRepo.getEntity("foo") instanceof MultiDeclareEntities);
 	}
 	
 	
@@ -62,7 +61,7 @@ public class MacroTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
 	    
-        assertNotNull(repo.getEntity("Macro3.bar"));
+        assertNotNull(entityRepo.getEntity("Macro3.bar"));
 	}
 	
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -29,8 +29,8 @@ public class RelationInSameFileTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,langProcessor);
-	    Entity bar = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    resolveAllBindings(true);
+	    Entity bar = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {
 	    	if (relation.getEntity() instanceof FunctionEntityProto) {

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -29,8 +29,8 @@ public class RelationToImplementationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,langProcessor);
-	    Entity bar = repo.getEntity("bar");
+	    resolveAllBindings(true);
+	    Entity bar = entityRepo.getEntity("bar");
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {
 	    	if (relation.getEntity() instanceof FunctionEntityProto) {
@@ -56,8 +56,8 @@ public class RelationToImplementationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,langProcessor);
-	    Entity bar = repo.getEntity("baz");
+	    resolveAllBindings(true);
+	    Entity bar = entityRepo.getEntity("baz");
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {
 	    	if (relation.getEntity() instanceof VarEntity) {
@@ -80,8 +80,8 @@ public class RelationToImplementationTest extends CppParserTest{
 		    CppFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,langProcessor);
-	    Entity bar = repo.getEntity("qux");
+	    resolveAllBindings(true);
+	    Entity bar = entityRepo.getEntity("qux");
 	    int matchCount = 0;
 	    for (Relation relation:bar.getRelations()) {
 	    	if (relation.getEntity() instanceof VarEntity) {

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -5,7 +5,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
-import depends.extractor.cpp.cdt.CdtCppFileParser;
 
 public class TypeDefTest extends CppParserTest{
     @Before
@@ -24,7 +23,7 @@ public class TypeDefTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        this.assertContainsRelation(repo.getEntity("foo"), DependencyType.PARAMETER, "MyInt");
+        this.assertContainsRelation(entityRepo.getEntity("foo"), DependencyType.PARAMETER, "MyInt");
 	}
 			
 }
\ No newline at end of file

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -27,7 +27,7 @@ public class UsingTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        Entity e = repo.getEntity("foo");
+        Entity e = entityRepo.getEntity("foo");
         this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
         this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");
         this.assertContainsRelation(e, DependencyType.CONTAIN, "B.X");
@@ -45,7 +45,7 @@ public class UsingTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        Entity e = repo.getEntity("bar");
+        Entity e = entityRepo.getEntity("bar");
         this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
         this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");
         this.assertContainsRelation(e, DependencyType.CONTAIN, "B.X");

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -25,7 +25,7 @@ public class extendsTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        Entity e = repo.getEntity("B");
+        Entity e = entityRepo.getEntity("B");
         assertEquals(2,e.getRelations().size());
 	}
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,30 +1,16 @@
 package depends.extractor.golang;
 
-import depends.entity.repo.EntityRepo;
-import depends.entity.repo.InMemoryEntityRepo;
-import depends.extractor.AbstractLangProcessor;
 import depends.extractor.ParserTest;
-import depends.relations.Inferer;
-import multilang.depends.util.file.TemporaryFile;
 
 public abstract class GolangParserTest extends ParserTest{
-	protected  EntityRepo entityRepo ;
-	protected Inferer inferer ;
-	private AbstractLangProcessor langProcessor;
 
 	public void init() {
 		langProcessor = new GoProcessor();
-		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new GoImportLookupStrategy(entityRepo),new GoBuiltInType());
-    	TemporaryFile.reset();
+		super.init();
 	}
 	
 	public GoFileParser createParser(String src) {
 		return new GoFileParser(src,entityRepo, inferer);
 	}
 
-	public void resolveAllBindings() {
-		inferer.resolveAllBindings(false,langProcessor);
-	}
-
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,32 +1,14 @@
 package depends.extractor.java;
 
-import depends.entity.repo.EntityRepo;
-import depends.entity.repo.InMemoryEntityRepo;
-import depends.extractor.AbstractLangProcessor;
 import depends.extractor.ParserTest;
-import depends.extractor.UnsolvedBindings;
-import depends.relations.Inferer;
-import multilang.depends.util.file.TemporaryFile;
-
-import java.util.Set;
 
 public abstract class JavaParserTest  extends ParserTest{
-	protected  EntityRepo entityRepo ;
-	protected Inferer inferer ;
-	private AbstractLangProcessor langProcessor;
-
 	public void init() {
-		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new JavaImportLookupStrategy(entityRepo),new JavaBuiltInType());
-    	TemporaryFile.reset();
 		langProcessor = new JavaProcessor();
+		super.init();
 	}
 	
 	public JavaFileParser createParser(String src) {
 		return new JavaFileParser(src,entityRepo, inferer);
 	}
-
-	public Set<UnsolvedBindings> resolveAllBindings() {
-		return inferer.resolveAllBindings(false,langProcessor);
-	}
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -23,7 +23,7 @@ public class DependencyTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -38,7 +38,7 @@ public class DependencyTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -27,8 +27,8 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    assertFalse(repo.getEntity("parent-group.a-parent_1.0_") instanceof MultiDeclareEntities);
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
+	    assertFalse(entityRepo.getEntity("parent-group.a-parent_1.0_") instanceof MultiDeclareEntities);
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -44,7 +44,7 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -23,7 +23,7 @@ public class DependencyWithPropertiesTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -38,7 +38,7 @@ public class DependencyWithPropertiesTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -23,7 +23,7 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
 	}
 	
 	@Test
@@ -38,7 +38,7 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
+	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");
 	}
 	
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,11 +1,11 @@
 package depends.extractor.pom;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.IOException;
 
-import org.junit.Before;
-import org.junit.Test;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 
 public class EntityExtractTest extends MavenParserTest{
     @Before
@@ -24,7 +24,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        assertEquals(0,repo.getEntity("org.log4j-test.log4j_1.2.12_").getRelations().size());
+        assertEquals(0,entityRepo.getEntity("org.log4j-test.log4j_1.2.12_").getRelations().size());
 	}
 	
 	
@@ -39,7 +39,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4_2.12.4_"));
+        assertNotNull(entityRepo.getEntity("org.apache.maven.surefire.surefire-junit4_2.12.4_"));
 	}
 	
 	@Test
@@ -53,7 +53,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
+        PomArtifactEntity entity = (PomArtifactEntity)(entityRepo.getEntity("properties-test.test_1_"));
     	/*
         <project.version>1.00</project.version>
         <activeio-version>3.1.4</activeio-version>
@@ -75,7 +75,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
+        PomArtifactEntity entity = (PomArtifactEntity)(entityRepo.getEntity("properties-test.test_1_"));
     	/*
         <project.version>1.00</project.version>
         <activeio-version>3.1.4</activeio-version>
@@ -95,7 +95,7 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test_1_"));
+        PomArtifactEntity entity = (PomArtifactEntity)(entityRepo.getEntity("properties-test.test_1_"));
         assertEquals("13",entity.getProperty("project.version"));
 	}
 }
\ No newline at end of file

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,41 +1,24 @@
 package depends.extractor.pom;
 
-import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserTest;
-import depends.extractor.UnsolvedBindings;
-import depends.relations.Inferer;
-import multilang.depends.util.file.TemporaryFile;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
 
 public abstract class MavenParserTest extends ParserTest{
 
-	protected EntityRepo repo;
-	private PomProcessor langProcessor;
-	protected Inferer inferer;
-
 	public void init() {
 		List<String> includeDir = new ArrayList<>();
 		includeDir.add("./src/test/resources/maven-code-examples/");
 		includeDir.add("./src/test/resources/maven-code-examples/dependencyWithPropertiesOfParent");
 		includeDir.add("./src/test/resources/maven-code-examples/dependencyWithoutVersion");
-		
 		this.langProcessor = new PomProcessor();
 		langProcessor.includeDirs = includeDir.toArray(new String[] {});
-		
-		this.repo = langProcessor.getEntityRepo();
-		this.inferer = langProcessor.inferer;
-    	TemporaryFile.reset();
-
+		super.init();
     }
 	
 	public PomFileParser createParser(String src) {
 		return (PomFileParser) langProcessor.createFileParser(src);
 	}
 
-	public Set<UnsolvedBindings> resolveAllBindings() {
-		return inferer.resolveAllBindings(false, langProcessor);
-	}
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -29,7 +29,7 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        assertNotNull(repo.getEntity(withPackageName(srcs[0],"Foo")));
+        assertNotNull(entityRepo.getEntity(withPackageName(srcs[0],"Foo")));
 	}
 	
 	@Test
@@ -43,7 +43,7 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Foo"));
+	    TypeEntity type = (TypeEntity) entityRepo.getEntity(withPackageName(srcs[0],"Foo"));
         assertEquals(2,type.getFunctions().size());
 	}
 	
@@ -58,7 +58,7 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Bar"));
+	    TypeEntity type = (TypeEntity) entityRepo.getEntity(withPackageName(srcs[0],"Bar"));
 	    this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
 	}
 

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -29,7 +29,7 @@ public class PythonDecoratorTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(func, DependencyType.ANNOTATION	, withPackageName(srcs[0],"our_decorator"));
 	    assertEquals(1,func.getResolvedAnnotations().size());
 	}

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -27,7 +27,7 @@ public class PythonFuncCallTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"bar"));
 	}
 
@@ -42,7 +42,7 @@ public class PythonFuncCallTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"baz"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"baz"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"A.foo"));
 	}
 	
@@ -58,7 +58,7 @@ public class PythonFuncCallTest extends PythonParserTest {
 	    }
 
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"C.test"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"C.test"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"A.fooA"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"B.fooB"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"C.fooC"));

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -28,7 +28,7 @@ public class PythonFunctionTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-        assertNotNull(repo.getEntity(withPackageName(srcs[0],"foo")));
+        assertNotNull(entityRepo.getEntity(withPackageName(srcs[0],"foo")));
 	}
 	
 	@Test
@@ -42,7 +42,7 @@ public class PythonFunctionTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));
         assertEquals(2,func.getParameters().size());
 	}
 	

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -25,10 +25,11 @@ public class PythonGlobalVarTest extends PythonParserTest {
 		    PythonFileParser parser = createParser(src);
 		    parser.parse();
 	    }
-	    inferer.resolveAllBindings(true,langProcessor);
-        Entity foo = repo.getEntity(withPackageName(srcs[0],"foo"));
+	    resolveAllBindings(true);
+        Entity foo = entityRepo.getEntity(withPackageName(srcs[0],"foo"));
         this.assertContainsRelation(foo, DependencyType.USE, "global_var");
 	}
-	
+
+
 
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,10 +1,5 @@
 package depends.extractor.python;
 
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
@@ -12,6 +7,10 @@ import depends.entity.FunctionEntity;
 import depends.entity.MultiDeclareEntities;
 import depends.extractor.python.union.PythonFileParser;
 import multilang.depends.util.file.FileUtil;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
 
 public class PythonImportTest extends PythonParserTest {
     @Before
@@ -31,7 +30,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[1]));
+	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[0]));
 	}
 	
@@ -48,7 +47,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 	}
@@ -65,7 +64,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 	}
@@ -82,7 +81,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
@@ -100,7 +99,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
@@ -118,7 +117,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[1],"foo"));
 	}
@@ -137,9 +136,9 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[3])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[3])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
 	@Test
@@ -168,7 +167,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
 	
@@ -184,7 +183,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
 	
@@ -200,7 +199,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"test"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"test"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"foo"));
 	}
 	
@@ -220,7 +219,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    
-	    MultiDeclareEntities funcs = (MultiDeclareEntities)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
+	    MultiDeclareEntities funcs = (MultiDeclareEntities) entityRepo.getEntity(withPackageName(srcs[1],"in_the_forest"));
 	    Entity func = funcs.getEntities().get(0);
 
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Duck.quack"));
@@ -242,7 +241,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    
-	    MultiDeclareEntities funcs = (MultiDeclareEntities)repo.getEntity(withPackageName(srcs[1],"in_the_forest"));
+	    MultiDeclareEntities funcs = (MultiDeclareEntities) entityRepo.getEntity(withPackageName(srcs[1],"in_the_forest"));
 	    Entity func = funcs.getEntities().get(0);
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Duck.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Bird.quack"));
@@ -262,7 +261,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"bar"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"bar"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[2],"C"));
 	}
 
@@ -278,7 +277,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FileEntity f = (FileEntity)repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    FileEntity f = (FileEntity) entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 	    this.assertContainsRelation(f, DependencyType.CALL, withPackageName(srcs[1],"Core.foo"));
 	}
 

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -27,7 +27,7 @@ public class PythonObjectCreationTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"foo"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));
 	    this.assertContainsRelation(func, DependencyType.CREATE, withPackageName(srcs[0],"Bar"));
 	}
 

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -27,7 +27,7 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t1"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"t1"));
 	    this.assertContainsRelation(func, DependencyType.THROW, withPackageName(srcs[0],"Bar"));
 	}
 	
@@ -43,7 +43,7 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity)repo.getEntity(withPackageName(srcs[0],"t2"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"t2"));
 	    this.assertContainsRelation(func, DependencyType.RETURN, withPackageName(srcs[0],"Bar"));
 	}
 

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,19 +1,18 @@
 package depends.extractor.python;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-
 import depends.entity.CandidateTypes;
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	@Before
@@ -33,7 +32,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
-	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
 	    TypeEntity type = var.getType();
 	    assertTrue(type instanceof CandidateTypes);
@@ -53,7 +52,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
-	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
 	    TypeEntity type = var.getType();
 	    assertTrue(type == null);
@@ -72,7 +71,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test2");
-	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t1");
 	    TypeEntity type = var.getType();
 	    assertTrue(type instanceof CandidateTypes);
@@ -92,7 +91,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
-	    FunctionEntity function = (FunctionEntity)( repo.getEntity(name));
+	    FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
 	    VarEntity var = function.lookupVarLocally("t2");
 	    TypeEntity type = var.getType();
 	    assertTrue(type instanceof CandidateTypes);

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,33 +1,22 @@
 package depends.extractor.python;
 
-import depends.entity.repo.EntityRepo;
-import depends.extractor.*;
+import depends.extractor.FileParser;
+import depends.extractor.ParserCreator;
+import depends.extractor.ParserTest;
 import depends.extractor.python.union.PythonFileParser;
 import depends.extractor.python.union.PythonProcessor;
-import depends.relations.Inferer;
 import multilang.depends.util.file.FileUtil;
-import multilang.depends.util.file.TemporaryFile;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
 
 public abstract class PythonParserTest extends ParserTest implements ParserCreator {
-
-	protected EntityRepo repo;
-	protected PythonProcessor langProcessor;
-	protected Inferer inferer;
-
 	public void init() {
 		List<String> includeDir = new ArrayList<>();
 		includeDir.add("./src/test/resources/python-code-examples/");
 		this.langProcessor = new PythonProcessor();
 		langProcessor.includeDirs = includeDir.toArray(new String[] {});
-		
-		this.repo = langProcessor.getEntityRepo();
-		this.inferer = langProcessor.inferer;
-    	TemporaryFile.reset();
-		
+		super.init(true);
     }
 	
 	public PythonFileParser createParser(String src) {
@@ -43,7 +32,5 @@ public abstract class PythonParserTest extends ParserTest implements ParserCreat
 		return FileUtil.uniqFilePath(FileUtil.getLocatedDir(theFile))+"."+entityName;
 	}
 
-	public Set<UnsolvedBindings> resolveAllBindings() {
-		return inferer.resolveAllBindings(false, langProcessor);
-	}
+
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,16 +1,15 @@
 package depends.extractor.python;
 
-import static org.junit.Assert.assertTrue;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertTrue;
 
 public class SelfShouldBeThisTypeTest extends PythonParserTest {
 	@Before
@@ -29,7 +28,7 @@ public class SelfShouldBeThisTypeTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"A.foo")));
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity(withPackageName(srcs[0],"A.foo")));
 	    VarEntity var = function.lookupVarLocally("self");
 	    TypeEntity type = var.getType();
 	    assertTrue(type.getQualifiedName().equals(withPackageName(srcs[0],"A")));

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -27,7 +27,7 @@ public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(repo.getEntity(withPackageName(srcs[0],"bar")));
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity(withPackageName(srcs[0],"bar")));
 	    this.assertContainsRelation(function, DependencyType.CALL, withPackageName(srcs[0],"foo"));
 	}
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -1,27 +1,18 @@
 package depends.extractor.ruby;
 
-import depends.entity.repo.EntityRepo;
-import depends.entity.repo.InMemoryEntityRepo;
-import depends.extractor.*;
+import depends.extractor.FileParser;
+import depends.extractor.ParserCreator;
+import depends.extractor.ParserTest;
 import depends.extractor.ruby.jruby.JRubyFileParser;
-import depends.relations.Inferer;
-import multilang.depends.util.file.TemporaryFile;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 public abstract class RubyParserTest extends ParserTest implements ParserCreator{
-	protected  EntityRepo entityRepo ;
-	protected Inferer inferer ;
-	private AbstractLangProcessor langProcessor;
-
 	public void init() {
-		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,new RubyImportLookupStrategy(entityRepo),new RubyBuiltInType());
-    	TemporaryFile.reset();
 		langProcessor = new RubyProcessor();
+		super.init(true);
 	}
 	
 	public FileParser createFileParser(String src) {
@@ -32,8 +23,4 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 	private List<String> includePaths() {
 		return new ArrayList<>();
 	}
-
-	public Set<UnsolvedBindings> resolveAllBindings() {
-		return inferer.resolveAllBindings(false, langProcessor);
-	}
 }

3768f51d89efb4dba59690e7476e379357790554
@@ -166,14 +166,14 @@ public class Expression implements Serializable{
 		if (parent.deduceTypeBasedId!=this.id) return;
 		
 		//if child is a built-in/external type, then parent must also a built-in/external type
-		if (this.type.equals(Inferer.buildInType)) {
-			parent.setType(Inferer.buildInType,Inferer.buildInType,inferer);
+		if (this.type.equals(TypeEntity.buildInType)) {
+			parent.setType(TypeEntity.buildInType,TypeEntity.buildInType,inferer);
 			return;
 		}
 		
 		/* if it is a logic expression, the return type/type is boolean. */
 		if (parent.isLogic) {
-			parent.setType(Inferer.buildInType,null,inferer);
+			parent.setType(TypeEntity.buildInType,null,inferer);
 		}
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {

3768f51d89efb4dba59690e7476e379357790554
@@ -24,13 +24,15 @@ SOFTWARE.
 
 package depends.entity;
 
+import depends.relations.Inferer;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
 
-import depends.relations.Inferer;
-
 public class TypeEntity extends ContainerEntity {
+	static final public TypeEntity buildInType = new TypeEntity(GenericName.build("built-in"), null, -1);
+	static final public TypeEntity genericParameterType = new TypeEntity(GenericName.build("T"), null, -3);
 	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
 	Collection<TypeEntity> implementedTypes = new ArrayList<>();
 	Collection<GenericName> inhertedTypeIdentifiers;

3768f51d89efb4dba59690e7476e379357790554
@@ -67,7 +67,7 @@ public class VarEntity extends ContainerEntity {
 			type = entity.getType();
 			if (type==null) {
 				if (((ContainerEntity)getParent()).isGenericTypeParameter(rawType)) {
-					type = Inferer.genericParameterType;
+					type = TypeEntity.genericParameterType;
 				}
 			}
 		}

3768f51d89efb4dba59690e7476e379357790554
@@ -24,10 +24,7 @@ SOFTWARE.
 
 package depends.extractor.ruby.jruby;
 
-import depends.entity.ContainerEntity;
-import depends.entity.Expression;
-import depends.entity.FunctionEntity;
-import depends.entity.VarEntity;
+import depends.entity.*;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.ruby.RubyHandlerContext;
 import depends.relations.Inferer;
@@ -70,13 +67,13 @@ public class ExpressionUsage {
 		context.lastContainer().addExpression(ctx, expression);
 		if (ctx instanceof ILiteralNode && !(ctx instanceof ListNode)) {
 			expression.setIdentifier("<literal>");
-			expression.setRawType(Inferer.buildInType.getQualifiedName());
+			expression.setRawType(TypeEntity.buildInType.getQualifiedName());
 		} else if (ctx instanceof TrueNode || ctx instanceof FalseNode) {
 			expression.setIdentifier("<boolean>");
-			expression.setRawType(Inferer.buildInType.getQualifiedName());
+			expression.setRawType(TypeEntity.buildInType.getQualifiedName());
 		} else if (ctx instanceof AndNode || ctx instanceof OrNode) {
 			expression.setIdentifier("<logical>");
-			expression.setRawType(Inferer.buildInType.getQualifiedName());
+			expression.setRawType(TypeEntity.buildInType.getQualifiedName());
 		} else if (ctx instanceof ConstNode) {
 			expression.setRawType(helper.getName(ctx));
 			expression.setIdentifier(helper.getName(ctx));
@@ -103,7 +100,7 @@ public class ExpressionUsage {
 				expression.setThrow (true);
 			} else if (helper.isArithMeticOperator(name)) {
 				expression.setIdentifier("<operator>");
-				expression.setRawType(Inferer.buildInType.getQualifiedName());
+				expression.setRawType(TypeEntity.buildInType.getQualifiedName());
 			} else {
 				expression.setIdentifier(name);
 				expression.setRawType(helper.getReciever(ctx));

3768f51d89efb4dba59690e7476e379357790554
@@ -1,7 +1,8 @@
 package depends.extractor.cpp;
+
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
-import depends.relations.Inferer;
+import depends.entity.TypeEntity;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -26,8 +27,8 @@ public class MacroRelationTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
 	    Entity e = entityRepo.getEntity("foo");
-	    this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
-	    this.assertContainsRelation(e, DependencyType.CONTAIN, Inferer.buildInType.getQualifiedName());
+	    this.assertContainsRelation(e, DependencyType.RETURN, TypeEntity.buildInType.getQualifiedName());
+	    this.assertContainsRelation(e, DependencyType.CONTAIN, TypeEntity.buildInType.getQualifiedName());
 	}
 	
 	

3768f51d89efb4dba59690e7476e379357790554
@@ -1,14 +1,12 @@
 package depends.extractor.cpp;
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
 
+import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.entity.TypeEntity;
 import org.junit.Before;
 import org.junit.Test;
 
-import depends.deptypes.DependencyType;
-import depends.entity.Entity;
-import depends.relations.Inferer;
+import java.io.IOException;
 
 public class UsingTest extends CppParserTest{
     @Before
@@ -28,7 +26,7 @@ public class UsingTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
         Entity e = entityRepo.getEntity("foo");
-        this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
+        this.assertContainsRelation(e, DependencyType.RETURN, TypeEntity.buildInType.getQualifiedName());
         this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");
         this.assertContainsRelation(e, DependencyType.CONTAIN, "B.X");
         
@@ -46,7 +44,7 @@ public class UsingTest extends CppParserTest{
 	    }
 	    resolveAllBindings();
         Entity e = entityRepo.getEntity("bar");
-        this.assertContainsRelation(e, DependencyType.RETURN, Inferer.buildInType.getQualifiedName());
+        this.assertContainsRelation(e, DependencyType.RETURN, TypeEntity.buildInType.getQualifiedName());
         this.assertContainsRelation(e, DependencyType.CONTAIN, "A.C");
         this.assertContainsRelation(e, DependencyType.CONTAIN, "B.X");
 	}

3768f51d89efb4dba59690e7476e379357790554
@@ -32,7 +32,7 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
 	    VarEntity var = function.lookupVarLocally("var_int");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 
 	    var = function.lookupVarLocally("var_c");
 	    assertEquals("Class",var.getType().getRawName().uniqName());
@@ -59,25 +59,25 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.operator_is_call"));
 	    VarEntity var = function.lookupVarLocally("var_compose");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 	    
 	    var = function.lookupVarLocally("var_1");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 
 	    var = function.lookupVarLocally("var_2");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 
 	    var = function.lookupVarLocally("var_3");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 
 	    var = function.lookupVarLocally("var_4");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 
 	    var = function.lookupVarLocally("var_5");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 
 	    var = function.lookupVarLocally("var_6");
-	    assertEquals(Inferer.buildInType.getRawName(),var.getType().getRawName());
+	    assertEquals(TypeEntity.buildInType.getRawName(),var.getType().getRawName());
 
 	}
 }

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,13 +24,9 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import depends.relations.IBindingResolver;
 
-import depends.relations.Inferer;
+import java.util.*;
 
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
@@ -45,9 +41,9 @@ public class AliasEntity extends Entity {
 		this.originName = originTypeName;
 	}
 
-	public void inferLocalLevelEntities(Inferer inferer) {
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
 		if (!(referToEntity instanceof EmptyTypeEntity)) return;
-		Entity entity = inferer.resolveName(this, originName, true);
+		Entity entity = bindingResolver.resolveName(this, originName, true);
 		while(entity instanceof AliasEntity) {
 			AliasEntity aliasEntity = (AliasEntity)entity;
 			if (this.referPath.contains(aliasEntity)) {
@@ -55,7 +51,7 @@ public class AliasEntity extends Entity {
 				break;
 			}
 			this.referPath.add(aliasEntity);
-			entity = inferer.resolveName(aliasEntity, aliasEntity.originName,true);
+			entity = bindingResolver.resolveName(aliasEntity, aliasEntity.originName,true);
 			if (entity==null) break;
 			if (entity.equals(this)) {
 				entity = null;

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,15 +24,11 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import depends.relations.Relation;
 
+import java.util.*;
+
 public class CandidateTypes extends TypeEntity {
 	private List<TypeEntity> candidateTypes;
 
@@ -119,9 +115,9 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
 		System.err.println("error: inferLocalLevelEntities should not been invoked");
-		super.inferLocalLevelEntities(inferer);
+		super.inferLocalLevelEntities(bindingResolver);
 	}
 
 	@Override
@@ -166,10 +162,9 @@ public class CandidateTypes extends TypeEntity {
 		super.addExpression(key, expression);
 	}
 
-	@Override
-	public void resolveExpressions(Inferer inferer) {
+	public void resolveExpressions(IBindingResolver bindingResolver) {
 		System.err.println("error: resolveExpressions should not been invoked");
-		super.resolveExpressions(inferer);
+		super.resolveExpressions(bindingResolver);
 	}
 
 
@@ -211,9 +206,9 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	protected Collection<Entity> identiferToEntities(Inferer inferer, Collection<GenericName> identifiers) {
+	protected Collection<Entity> identiferToEntities(IBindingResolver bindingResolver, Collection<GenericName> identifiers) {
 		System.err.println("error: identiferToTypes should not been invoked");
-		return super.identiferToEntities(inferer, identifiers);
+		return super.identiferToEntities(bindingResolver, identifiers);
 	}
 
 	@Override
@@ -289,9 +284,9 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void inferEntities(Inferer inferer) {
+	public void inferEntities(IBindingResolver bindingResolver) {
 		System.err.println("error: inferEntities should not been invoked");
-		super.inferEntities(inferer);
+		super.inferEntities(bindingResolver);
 	}
 
 	@Override

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -25,7 +25,7 @@ SOFTWARE.
 package depends.entity;
 
 import depends.entity.repo.EntityRepo;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import depends.relations.Relation;
 import multilang.depends.util.file.TemporaryFile;
 import org.slf4j.Logger;
@@ -119,24 +119,24 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * For all data in the class, infer their types. Should be override in
 	 * sub-classes
 	 */
-	public void inferLocalLevelEntities(Inferer inferer) {
-		super.inferLocalLevelEntities(inferer);
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
+		super.inferLocalLevelEntities(bindingResolver);
 		for (VarEntity var : this.vars()) {
 			if (var.getParent()!=this) {
-				var.inferLocalLevelEntities(inferer);
+				var.inferLocalLevelEntities(bindingResolver);
 			}
 		}
 		for (FunctionEntity func : this.getFunctions()) {
 			if (func.getParent()!=this) {
-				func.inferLocalLevelEntities(inferer);
+				func.inferLocalLevelEntities(bindingResolver);
 			}
 		}
-		if (inferer.isEagerExpressionResolve()) {
-			reloadExpression(inferer.getRepo());
-			resolveExpressions(inferer);
+		if (bindingResolver.isEagerExpressionResolve()) {
+			reloadExpression(bindingResolver.getRepo());
+			resolveExpressions(bindingResolver);
 			cacheExpressions();
 		}
-		resolvedMixins = identiferToContainerEntity(inferer, getMixins());
+		resolvedMixins = identiferToContainerEntity(bindingResolver, getMixins());
 	}
 
 	private Collection<GenericName> getMixins() {
@@ -145,11 +145,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return mixins;
 	}
 
-	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<GenericName> identifiers) {
+	private Collection<ContainerEntity> identiferToContainerEntity(IBindingResolver bindingResolver, Collection<GenericName> identifiers) {
 		if (identifiers.size()==0) return null;
 		ArrayList<ContainerEntity> r = new ArrayList<>();
 		for (GenericName identifier : identifiers) {
-			Entity entity = inferer.resolveName(this, identifier, true);
+			Entity entity = bindingResolver.resolveName(this, identifier, true);
 			if (entity == null) {
 				continue;
 			}
@@ -162,10 +162,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	/**
 	 * Resolve all expression's type
 	 * 
-	 * @param inferer
+	 * @param bindingResolver
 	 */
-	public void resolveExpressions(Inferer inferer) {
-		
+	public void resolveExpressions(IBindingResolver bindingResolver) {
 		if (this instanceof FunctionEntity) {
 			((FunctionEntity)this).linkReturnToLastExpression();
 		}
@@ -187,20 +186,13 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			// 2. if expression's rawType existed, directly infer type by rawType
 			// if expression's rawType does not existed, infer type based on identifiers
 			if (expression.getRawType() != null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.getRawType()), null, inferer);
+				expression.setType(bindingResolver.inferTypeFromName(this, expression.getRawType()), null, bindingResolver);
 				if (expression.getType() != null) {
 					continue;
 				}
 			}
 			if (expression.getIdentifier() != null) {
-
-//				if (this.getAncestorOfType(FileEntity.class).getRawName().contains("/examples/usersession/server.py") &&
-//						expression.getIdentifier().contains("config")) {
-//					System.out.print("dd");
-//				}
-				
-				
-				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
+				Entity entity = bindingResolver.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
 				if (entity==null) {
@@ -208,27 +200,27 @@ public abstract class ContainerEntity extends DecoratedEntity {
 						theExpr = theExpr.getParent();
 						if (theExpr.getIdentifier()==null) break;
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
-						entity = inferer.resolveName(this, GenericName.build(composedName), true);
+						entity = bindingResolver.resolveName(this, GenericName.build(composedName), true);
 						if (entity!=null)
 							break;
 					}
 				}
 				if (entity != null) {
-					expression.setType(entity.getType(), entity, inferer);
+					expression.setType(entity.getType(), entity, bindingResolver);
 					continue;
 				}
 				if (expression.isCall()) {
 					List<Entity> funcs = this.lookupFunctionInVisibleScope(expression.getIdentifier());
 					if (funcs != null) {
 						for (Entity func:funcs) {
-							expression.setType(func.getType(), func, inferer);
+							expression.setType(func.getType(), func, bindingResolver);
 						}
 					}
 				} else {
 
 					Entity varEntity = this.lookupVarInVisibleScope(expression.getIdentifier());
 					if (varEntity != null) {
-						expression.setType(varEntity.getType(), varEntity, inferer);
+						expression.setType(varEntity.getType(), varEntity, bindingResolver);
 					}
 				}
 			}

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,7 +24,7 @@ SOFTWARE.
 
 package depends.entity;
 
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import depends.relations.Relation;
 
 import java.util.*;
@@ -177,13 +177,13 @@ public abstract class Entity {
 	/**
 	 * Invoke inferer to resolve the entity type etc. 
 	 * */
-	public void inferEntities(Inferer inferer) {
-		inferLocalLevelEntities(inferer);
+	public void inferEntities(IBindingResolver bindingResolver) {
+		inferLocalLevelEntities(bindingResolver);
 		for (Entity child:this.getChildren()) {
-			child.inferEntities(inferer);
+			child.inferEntities(bindingResolver);
 		}
 	}
-	public abstract void inferLocalLevelEntities(Inferer inferer);
+	public abstract void inferLocalLevelEntities(IBindingResolver bindingResolver);
 	
 	public TypeEntity getType() {
 		return null;

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -25,7 +25,7 @@ SOFTWARE.
 package depends.entity;
 
 import depends.entity.repo.EntityRepo;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 
 import java.io.Serializable;
 import java.util.ArrayList;
@@ -121,9 +121,9 @@ public class Expression implements Serializable{
 	 * Set type of the expression
 	 * @param type
 	 * @param referredEntity
-	 * @param inferer
+	 * @param bindingResolver
 	 */
-	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
+	public void setType(TypeEntity type, Entity referredEntity, IBindingResolver bindingResolver) {
 		if (this.getReferredEntity()==null && referredEntity!=null) {
 			this.setReferredEntity(referredEntity);
 		}
@@ -147,16 +147,15 @@ public class Expression implements Serializable{
 			this.setReferredEntity(this.type);
 
 		if (changedType)
-			deduceTheParentType(inferer);
+			deduceTheParentType(bindingResolver);
 	}
 	
 
 	/**
 	 * deduce type of parent based on child's type
-	 * @param expressionList
-	 * @param inferer
+	 * @param bindingResolver
 	 */
-	private void deduceTheParentType(Inferer inferer) {
+	private void deduceTheParentType(IBindingResolver bindingResolver) {
 		if (this.type==null) return;
 		if (this.parent==null) return;
 		Expression parent = this.parent;
@@ -167,13 +166,13 @@ public class Expression implements Serializable{
 		
 		//if child is a built-in/external type, then parent must also a built-in/external type
 		if (this.type.equals(TypeEntity.buildInType)) {
-			parent.setType(TypeEntity.buildInType,TypeEntity.buildInType,inferer);
+			parent.setType(TypeEntity.buildInType,TypeEntity.buildInType, bindingResolver);
 			return;
 		}
 		
 		/* if it is a logic expression, the return type/type is boolean. */
 		if (parent.isLogic) {
-			parent.setType(TypeEntity.buildInType,null,inferer);
+			parent.setType(TypeEntity.buildInType,null, bindingResolver);
 		}
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {
@@ -184,15 +183,15 @@ public class Expression implements Serializable{
 					if (funcs.size()>0) {
 						Entity func = funcs.get(0);
 						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
-							inferer.getRepo().add(m);
+							MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
+							bindingResolver.getRepo().add(m);
 							for (int i=1;i<funcs.size();i++) {
 								m.add(funcs.get(i));
 							}
-							parent.setType(func.getType(), m,inferer);
+							parent.setType(func.getType(), m, bindingResolver);
 							parent.setReferredEntity(m);
 						}else {
-							parent.setType(func.getType(), func,inferer);
+							parent.setType(func.getType(), func, bindingResolver);
 							parent.setReferredEntity(func);
 						}
 					}
@@ -200,35 +199,35 @@ public class Expression implements Serializable{
 			}else {
 				Entity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
-					parent.setType(var.getType(),var, inferer);
+					parent.setType(var.getType(),var, bindingResolver);
 					parent.setReferredEntity(var);
 				}else {
 					List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 					if (funcs!=null) {
 						Entity func = funcs.get(0);
 						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
-							inferer.getRepo().add(m);
+							MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
+							bindingResolver.getRepo().add(m);
 
 							for (int i=1;i<funcs.size();i++) {
 								m.add(funcs.get(i));
 							}
-							parent.setType(func.getType(), m,inferer);
+							parent.setType(func.getType(), m, bindingResolver);
 							parent.setReferredEntity(m);
 						}else {
-							parent.setType(func.getType(), func,inferer);
+							parent.setType(func.getType(), func, bindingResolver);
 							parent.setReferredEntity(func);
 						}
 					}
 				}
 			}
 			if (parent.getType()==null) {
-				parent.setType(inferer.inferTypeFromName(this.getType(), parent.identifier),null,inferer);
+				parent.setType(bindingResolver.inferTypeFromName(this.getType(), parent.identifier),null, bindingResolver);
 			}
 		}
 		/* if other situation, simple make the parent and child type same */
 		else {
-			parent.setType(type, null, inferer);
+			parent.setType(type, null, bindingResolver);
 		}
 		if (parent.getReferredEntity()==null)
 			parent.setReferredEntity(parent.type);

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,14 +24,10 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
 import depends.importtypes.Import;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
+
+import java.util.*;
 
 public class FileEntity extends TypeEntity {
 	private List<Import> importedNames = new ArrayList<>();
@@ -95,12 +91,12 @@ public class FileEntity extends TypeEntity {
 	}
 
 	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
-		this.importedRelationEntities = inferer.getImportedRelationEntities(importedNames);
-		this.importedTypes = inferer.getImportedTypes(importedNames,this);
-		this.importedFiles = inferer.getImportedFiles(importedNames);
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
+		this.importedRelationEntities = bindingResolver.getImportedRelationEntities(importedNames);
+		this.importedTypes = bindingResolver.getImportedTypes(importedNames,this);
+		this.importedFiles = bindingResolver.getImportedFiles(importedNames);
 
-		super.inferLocalLevelEntities(inferer);
+		super.inferLocalLevelEntities(bindingResolver);
 	}
 
 	public boolean isInProjectScope() {

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,12 +24,12 @@ SOFTWARE.
 
 package depends.entity;
 
+import depends.relations.IBindingResolver;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import depends.relations.Inferer;
-
 public class FunctionEntity extends ContainerEntity{
 	private List<GenericName> returnTypeIdentifiers = new ArrayList<>();
 	Collection<VarEntity> parameters;
@@ -79,28 +79,28 @@ public class FunctionEntity extends ContainerEntity{
 	}
 	
 	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
 		for (VarEntity param:parameters) {
-			param.fillCandidateTypes(inferer);
-			param.inferLocalLevelEntities(inferer);
+			param.fillCandidateTypes(bindingResolver);
+			param.inferLocalLevelEntities(bindingResolver);
 		}
 		if (returnTypes.size()<returnTypeIdentifiers.size()) {
-			returnTypes = identiferToEntities(inferer,this.returnTypeIdentifiers);
+			returnTypes = identiferToEntities(bindingResolver,this.returnTypeIdentifiers);
 			for ( GenericName returnTypeName: returnTypeIdentifiers) {
-				Collection<Entity> typeEntities = typeParametersToEntities(inferer, returnTypeName);
+				Collection<Entity> typeEntities = typeParametersToEntities(bindingResolver, returnTypeName);
 				this.appendTypeParameters(typeEntities);
 			}
 		}
 		if (throwTypes.size()<throwTypesIdentifiers.size())
-			throwTypes = identiferToEntities(inferer,this.throwTypesIdentifiers);
-		super.inferLocalLevelEntities(inferer);
+			throwTypes = identiferToEntities(bindingResolver,this.throwTypesIdentifiers);
+		super.inferLocalLevelEntities(bindingResolver);
 	}
 	
 
-	private Collection<Entity> typeParametersToEntities(Inferer inferer,GenericName name) {
+	private Collection<Entity> typeParametersToEntities(IBindingResolver bindingResolver, GenericName name) {
 		ArrayList<Entity> r = new ArrayList<>();
 		for (GenericName typeParameter:name.getArguments()) {
-			toEntityList(inferer, r,typeParameter);
+			toEntityList(bindingResolver, r,typeParameter);
 		}
 		return r;
 	}

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -29,7 +29,7 @@ import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 
 /**
  * MultiDeclareEntity is a special container, which is used as a wrapper
@@ -47,9 +47,9 @@ public class MultiDeclareEntities extends ContainerEntity {
 	}
 
 	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
 		for (Entity entity:entities) {
-			entity.inferLocalLevelEntities(inferer);
+			entity.inferLocalLevelEntities(bindingResolver);
 		}
 	}
 

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,7 +24,7 @@ SOFTWARE.
 
 package depends.entity;
 
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -46,9 +46,9 @@ public class TypeEntity extends ContainerEntity {
 	}
 
 	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
 		inheritedTypes = new ArrayList<>();
-		Collection<Entity> r = identiferToEntities(inferer, this.inhertedTypeIdentifiers);
+		Collection<Entity> r = identiferToEntities(bindingResolver, this.inhertedTypeIdentifiers);
 		if (r!=null) {
 			r.forEach(item -> {
 				Entity typeItem = getTypeEntity(item);
@@ -62,7 +62,7 @@ public class TypeEntity extends ContainerEntity {
 		inheritedTypes.remove(this);
 
 		implementedTypes = new ArrayList<>();
-		r = identiferToEntities(inferer, this.implementedIdentifiers);
+		r = identiferToEntities(bindingResolver, this.implementedIdentifiers);
 		if (r!=null) {
 				r.forEach(item -> {
 					Entity typeItem = getTypeEntity(item);
@@ -76,7 +76,7 @@ public class TypeEntity extends ContainerEntity {
 		implementedTypes.remove(this);
 		if (inheritedTypes.size() > 0)
 			inheritedType = inheritedTypes.iterator().next();
-		super.inferLocalLevelEntities(inferer);
+		super.inferLocalLevelEntities(bindingResolver);
 	}
 
 	private Entity getTypeEntity(Entity item) {

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,11 +24,11 @@ SOFTWARE.
 
 package depends.entity;
 
+import depends.relations.IBindingResolver;
+
 import java.util.ArrayList;
 import java.util.List;
 
-import depends.relations.Inferer;
-
 public class VarEntity extends ContainerEntity {
 	private GenericName rawType;
 	private TypeEntity type;
@@ -59,9 +59,9 @@ public class VarEntity extends ContainerEntity {
 	}
 
 	@Override
-	public void inferLocalLevelEntities(Inferer inferer) {
-		super.inferLocalLevelEntities(inferer);
-		Entity entity = inferer.resolveName(this, rawType, true);
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
+		super.inferLocalLevelEntities(bindingResolver);
+		Entity entity = bindingResolver.resolveName(this, rawType, true);
 		if (entity!=null) {
 			this.setActualReferTo(entity);
 			type = entity.getType();
@@ -72,7 +72,7 @@ public class VarEntity extends ContainerEntity {
 			}
 		}
 		if (type==null) {
-			fillCandidateTypes(inferer);
+			fillCandidateTypes(bindingResolver);
 		}
 	}
 
@@ -90,16 +90,16 @@ public class VarEntity extends ContainerEntity {
 		this.functionCalls.add(new FunctionCall(fname));
 	}
 
-	public void fillCandidateTypes(Inferer inferer) {
-		if (!inferer.isEagerExpressionResolve()) return;
+	public void fillCandidateTypes(IBindingResolver bindingResolver) {
+		if (!bindingResolver.isEagerExpressionResolve()) return;
 		if (type!=null && !(type instanceof CandidateTypes)) return ; //it is a strong type lang, do not need deduce candidate types
 		if (functionCalls==null) return;
 		if (functionCalls.size()==0) return; //no information avaliable for type deduction
 		if (this.rawType==null) {
-			List<TypeEntity> candidateTypes = inferer.calculateCandidateTypes(this,this.functionCalls);
+			List<TypeEntity> candidateTypes = bindingResolver.calculateCandidateTypes(this,this.functionCalls);
 			if (candidateTypes.size()>0) {
-				this.type = new CandidateTypes(candidateTypes,inferer.getRepo().generateId());
-				inferer.getRepo().add(this.type);
+				this.type = new CandidateTypes(candidateTypes, bindingResolver.getRepo().generateId());
+				bindingResolver.getRepo().add(this.type);
 			}
 		}
 	}

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -30,7 +30,7 @@ import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.InMemoryEntityRepo;
 import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileTraversal;
 import multilang.depends.util.file.FileUtil;
 import org.codehaus.plexus.util.FileUtils;
@@ -83,7 +83,7 @@ abstract public class AbstractLangProcessor {
 	 */
 	public abstract FileParser createFileParser(String fileFullPath);
 
-	public Inferer inferer;
+	public IBindingResolver bindingResolver;
 	protected EntityRepo entityRepo;
 	protected String inputSrcPath;
 	public String[] includeDirs;
@@ -102,13 +102,13 @@ abstract public class AbstractLangProcessor {
 	 *
 	 * @param inputDir
 	 * @param includeDir
-	 * @param inferer
+	 * @param bindingResolver
 	 * @return
 	 */
-	public EntityRepo buildDependencies(String inputDir, String[] includeDir, Inferer inferer) {
+	public EntityRepo buildDependencies(String inputDir, String[] includeDir, IBindingResolver bindingResolver) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
-		this.inferer = inferer;
+		this.bindingResolver = bindingResolver;
 		logger.info("Start parsing files...");
 		parseAllFiles();
 		markAllEntitiesScope();
@@ -144,7 +144,7 @@ abstract public class AbstractLangProcessor {
 	 */
 	public void resolveBindings() {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-		this.potentialExternalDependencies = inferer.resolveAllBindings(this);
+		this.potentialExternalDependencies = bindingResolver.resolveAllBindings(this.isEagerExpressionResolve());
 		if (getExternalDependencies().size() > 0) {
 			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
 		}

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -28,7 +28,7 @@ import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.IdGenerator;
 import depends.importtypes.Import;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -40,14 +40,14 @@ public abstract class HandlerContext {
 	protected IdGenerator idGenerator;
 
 	protected FileEntity currentFileEntity;
-	protected Inferer inferer;
+	protected IBindingResolver bindingResolver;
 
 	
-	public HandlerContext(EntityRepo entityRepo, Inferer inferer) {
+	public HandlerContext(EntityRepo entityRepo, IBindingResolver bindingResolver) {
 		this.entityRepo = entityRepo;
 		this.idGenerator = entityRepo;
 		entityStack = new Stack<Entity>();
-		this.inferer = inferer;
+		this.bindingResolver = bindingResolver;
 	}
 
 	public FileEntity startFile(String fileName) {
@@ -312,7 +312,7 @@ public abstract class HandlerContext {
 	}
 	
 	private VarEntity getVarInLocalFile(ContainerEntity container, GenericName varName) {
-		Entity entity = inferer.resolveName(container, varName, false); 
+		Entity entity = bindingResolver.resolveName(container, varName, false);
 		if (entity ==null ) return null;
 		if (!entity.getAncestorOfType(FileEntity.class).equals(currentFileEntity)) return null;
 		if (entity instanceof VarEntity) return (VarEntity)entity;
@@ -320,7 +320,7 @@ public abstract class HandlerContext {
 	}
 
 	public Entity foundEntityWithName(GenericName rawName) {
-		return inferer.resolveName(lastContainer(), rawName, true);
+		return bindingResolver.resolveName(lastContainer(), rawName, true);
 	}
 	
 	public void addToRepo(Entity entity) {

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -56,12 +56,12 @@ public class CppImportLookupStrategy extends ImportLookupStrategy {
 			if (importedItem instanceof FileEntity) {
 				FileEntity importedFile = (FileEntity) repo.getEntity(file);
 				if (importedFile==null) continue;
-				 Entity entity = inferer.resolveName(importedFile,GenericName.build(name), false);
+				 Entity entity = bindingResolver.resolveName(importedFile,GenericName.build(name), false);
 				if (entity!=null) return entity;
 				Collection<Entity> namespaces = fileEntity.getImportedTypes();
 				for (Entity ns:namespaces) {
 					String nameWithPrefix = ns.getQualifiedName() + "." + name;
-					entity = inferer.resolveName(importedFile,GenericName.build(nameWithPrefix), false);
+					entity = bindingResolver.resolveName(importedFile,GenericName.build(nameWithPrefix), false);
 					if (entity!=null) return entity;				
 				}
 			}	

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -66,7 +66,7 @@ public class CppProcessor extends AbstractLangProcessor {
 		if (preprocessorHandler==null) {
 			preprocessorHandler = new PreprocessorHandler(super.inputSrcPath,super.includePaths());
 		}
-		return new CdtCppFileParser(fileFullPath, entityRepo, preprocessorHandler, inferer, macroRepo);
+		return new CdtCppFileParser(fileFullPath, entityRepo, preprocessorHandler, bindingResolver, macroRepo);
 	}
 
 	@Override

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -53,7 +53,7 @@ public class GoProcessor extends AbstractLangProcessor {
 
 	@Override
 	public FileParser createFileParser(String fileFullPath) {
-		return new GoFileParser(fileFullPath, entityRepo, inferer);
+		return new GoFileParser(fileFullPath, entityRepo, bindingResolver);
 	}
 
 	@Override

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -29,7 +29,7 @@ import depends.entity.repo.EntityRepo;
 import depends.extractor.java.JavaParser.*;
 import depends.extractor.java.context.*;
 import depends.importtypes.ExactMatchImport;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -40,8 +40,8 @@ public class JavaListener extends JavaParserBaseListener {
 	private final ExpressionUsage expressionUsage;
 	private final EntityRepo entityRepo;
 
-	public JavaListener(String fileFullPath, EntityRepo entityRepo,Inferer inferer) {
-		this.context = new JavaHandlerContext(entityRepo,inferer);
+	public JavaListener(String fileFullPath, EntityRepo entityRepo, IBindingResolver bindingResolver) {
+		this.context = new JavaHandlerContext(entityRepo, bindingResolver);
 		this.entityRepo = entityRepo;
 		annotationProcessor = new AnnotationProcessor();
 		expressionUsage = new ExpressionUsage(context,entityRepo);

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -52,7 +52,7 @@ public class JavaProcessor extends AbstractLangProcessor {
 	
 	@Override
 	public FileParser createFileParser(String fileFullPath) {
-		return new JavaFileParser(fileFullPath,entityRepo, inferer);
+		return new JavaFileParser(fileFullPath,entityRepo, bindingResolver);
 	}
 	
 	@Override

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -1,16 +1,15 @@
 package depends.extractor.kotlin;
 
-import java.io.IOException;
-
+import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.relations.IBindingResolver;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;
 import org.antlr.v4.runtime.CommonTokenStream;
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
-import depends.entity.repo.EntityRepo;
-import depends.extractor.FileParser;
-import depends.relations.Inferer;
+import java.io.IOException;
 
 public class KotlinFileParser implements FileParser {
 
@@ -20,18 +19,18 @@ public class KotlinFileParser implements FileParser {
 	        Lexer lexer = new KotlinLexer(input);
 	        CommonTokenStream tokens = new CommonTokenStream(lexer);
 	        KotlinParser parser = new KotlinParser(tokens);
-	        KotlinListener bridge = new KotlinListener(fileFullPath, entityRepo,inferer);
+	        KotlinListener bridge = new KotlinListener(fileFullPath, entityRepo, bindingResolver);
 		    ParseTreeWalker walker = new ParseTreeWalker();
 		    walker.walk(bridge, parser.kotlinFile());
 	}
 	
 	private String fileFullPath;
 	private EntityRepo entityRepo;
-	private Inferer inferer;
-	public KotlinFileParser(String fileFullPath,EntityRepo entityRepo, Inferer inferer) {
+	private IBindingResolver bindingResolver;
+	public KotlinFileParser(String fileFullPath,EntityRepo entityRepo, IBindingResolver bindingResolver) {
         this.fileFullPath = fileFullPath;
         this.entityRepo = entityRepo;
-        this.inferer = inferer;
+        this.bindingResolver = bindingResolver;
 	}
 
 

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -40,7 +40,7 @@ public class KotlinProcessor extends AbstractLangProcessor {
 
 	@Override
 	public FileParser createFileParser(String fileFullPath) {
-		return new KotlinFileParser(fileFullPath,entityRepo, inferer);
+		return new KotlinFileParser(fileFullPath,entityRepo, bindingResolver);
 	}
 
 	@Override

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -1,11 +1,8 @@
 package depends.extractor.python;
 
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
-import depends.entity.FileEntity;
 import depends.entity.FunctionCall;
 import depends.entity.FunctionEntity;
 import depends.entity.GenericName;

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -6,7 +6,7 @@ import depends.extractor.HandlerContext;
 import depends.extractor.python.PythonHandlerContext;
 import depends.extractor.python.PythonParser.*;
 import depends.extractor.python.PythonParserBaseVisitor;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.RuleContext;
 
@@ -18,11 +18,11 @@ public class ExpressionUsage {
 	HandlerContext context;
 	IdGenerator idGenerator;
 	private boolean exprStarted=false;
-	private Inferer inferer;
-	public ExpressionUsage(PythonHandlerContext context, IdGenerator idGenerator, Inferer inferer) {
+	private IBindingResolver bindingResolver;
+	public ExpressionUsage(PythonHandlerContext context, IdGenerator idGenerator, IBindingResolver bindingResolver) {
 		this.context = context;
 		this.idGenerator = idGenerator;
-		this.inferer = inferer;
+		this.bindingResolver = bindingResolver;
 	}
 
 	/**
@@ -207,7 +207,7 @@ public class ExpressionUsage {
 		Entity typeEntity = context.foundEntityWithName(funcName);
 		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
 			theExpression.setCreate(true);
-			theExpression.setType(typeEntity.getType(), typeEntity, inferer);
+			theExpression.setType(typeEntity.getType(), typeEntity, bindingResolver);
 			theExpression.setRawType(typeEntity.getRawName());
 			return;
 		} 
@@ -221,7 +221,7 @@ public class ExpressionUsage {
 		Entity typeEntity = context.foundEntityWithName(funcName);
 		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
 			theExpression.getParent().setCreate(true);
-			theExpression.setType(typeEntity.getType(), typeEntity, inferer);
+			theExpression.setType(typeEntity.getType(), typeEntity, bindingResolver);
 			theExpression.getParent().setRawType(typeEntity.getRawName());
 			return;
 		} 

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -8,7 +8,7 @@ import depends.extractor.python.PythonParser.*;
 import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.importtypes.FileImport;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.ParserRuleContext;
 
@@ -23,15 +23,15 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	private final EntityRepo entityRepo;
 	private final IncludedFileLocator  includeFileLocator;
 	private final PythonProcessor pythonProcessor;
-	private final Inferer inferer;
-	public PythonCodeListener(String fileFullPath, EntityRepo entityRepo, Inferer inferer,
+	private final IBindingResolver bindingResolver;
+	public PythonCodeListener(String fileFullPath, EntityRepo entityRepo, IBindingResolver bindingResolver,
 			IncludedFileLocator includeFileLocator, PythonProcessor pythonProcessor) {
-		this.context = new PythonHandlerContext(entityRepo, inferer);
-		this.expressionUsage = new ExpressionUsage(context, entityRepo, inferer);
+		this.context = new PythonHandlerContext(entityRepo, bindingResolver);
+		this.expressionUsage = new ExpressionUsage(context, entityRepo, bindingResolver);
 		FileEntity fileEntity = context.startFile(fileFullPath);
 		this.entityRepo = entityRepo;
 		this.includeFileLocator = includeFileLocator;
-		this.inferer = inferer;
+		this.bindingResolver = bindingResolver;
 		this.pythonProcessor = pythonProcessor;
 
 		String dir = FileUtil.uniqFilePath(FileUtil.getLocatedDir(fileFullPath));
@@ -117,7 +117,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 					if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
 						context.foundNewImport(new FileImport(fullName));
 					}
-					Entity itemEntity = inferer.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
+					Entity itemEntity = bindingResolver.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
 					if (itemEntity != null) {
 						context.foundNewAlias(GenericName.build(alias), itemEntity);
 						context.foundNewImport(new NameAliasImport(itemEntity.getQualifiedName(), itemEntity, alias));
@@ -183,7 +183,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	}
 
 	private void visitIncludedFile(String fullName) {
-		PythonFileParser importedParser = new PythonFileParser(fullName, entityRepo, includeFileLocator, inferer,
+		PythonFileParser importedParser = new PythonFileParser(fullName, entityRepo, includeFileLocator, bindingResolver,
 				pythonProcessor);
 		try {
 			importedParser.parse();

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -1,13 +1,5 @@
 package depends.extractor.python.union;
 
-import java.io.IOException;
-
-import org.antlr.v4.runtime.CharStream;
-import org.antlr.v4.runtime.CharStreams;
-import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.Lexer;
-import org.antlr.v4.runtime.tree.ParseTreeWalker;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
@@ -15,21 +7,28 @@ import depends.extractor.FileParser;
 import depends.extractor.python.PythonLexer;
 import depends.extractor.python.PythonParser;
 import depends.extractor.ruby.IncludedFileLocator;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.CharStreams;
+import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.Lexer;
+import org.antlr.v4.runtime.tree.ParseTreeWalker;
+
+import java.io.IOException;
 
 public class PythonFileParser implements FileParser {
 
 	private String fileFullPath;
 	private EntityRepo entityRepo;
-	private Inferer inferer;
+	private IBindingResolver bindingResolver;
 	private IncludedFileLocator includeFileLocator;
 	private PythonProcessor processor;
 
 	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includeFileLocator,
-			Inferer inferer, PythonProcessor pythonProcessor) {
+							IBindingResolver bindingResolver, PythonProcessor pythonProcessor) {
 		this.fileFullPath = fileFullPath;
 		this.entityRepo = entityRepo;
-		this.inferer = inferer;
+		this.bindingResolver = bindingResolver;
 		this.includeFileLocator = includeFileLocator;
 		this.processor = pythonProcessor;
 	}
@@ -47,7 +46,7 @@ public class PythonFileParser implements FileParser {
         
         
         PythonParser parser = new PythonParser(tokens);
-        PythonCodeListener bridge = new PythonCodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
+        PythonCodeListener bridge = new PythonCodeListener(fileFullPath, entityRepo, bindingResolver, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();
 	    walker.walk(bridge, parser.file_input());
 		fileEntity = entityRepo.getEntity(fileFullPath);

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -57,7 +57,7 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 	@Override
 	public FileParser createFileParser(String fileFullPath) {
 		executor = Executors.newSingleThreadExecutor();
-		return new JRubyFileParser(fileFullPath,entityRepo,executor,new IncludedFileLocator(super.includePaths()),inferer,this);
+		return new JRubyFileParser(fileFullPath,entityRepo,executor,new IncludedFileLocator(super.includePaths()), bindingResolver,this);
 	}
 
 

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -27,7 +27,7 @@ package depends.extractor.ruby.jruby;
 import depends.entity.*;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.ruby.RubyHandlerContext;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import org.jrubyparser.ast.*;
 
 import java.util.List;
@@ -35,14 +35,14 @@ import java.util.List;
 public class ExpressionUsage {
 	RubyHandlerContext context;
 	IdGenerator idGenerator;
-	Inferer inferer;
+	IBindingResolver bindingResolver;
 	private RubyParserHelper helper;
 
 	public ExpressionUsage(RubyHandlerContext context, IdGenerator idGenerator, RubyParserHelper helper,
-			Inferer inferer) {
+			IBindingResolver bindingResolver) {
 		this.context = context;
 		this.idGenerator = idGenerator;
-		this.inferer = inferer;
+		this.bindingResolver = bindingResolver;
 		this.helper = helper;
 	}
 

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,42 +24,41 @@ SOFTWARE.
 
 package depends.extractor.ruby.jruby;
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.concurrent.ExecutorService;
-
-import org.antlr.v4.runtime.CharStream;
-import org.antlr.v4.runtime.CharStreams;
-import org.jrubyparser.CompatVersion;
-import org.jrubyparser.Parser;
-import org.jrubyparser.ast.Node;
-import org.jrubyparser.parser.ParserConfiguration;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileUtil;
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.CharStreams;
+import org.jrubyparser.CompatVersion;
+import org.jrubyparser.Parser;
+import org.jrubyparser.ast.Node;
+import org.jrubyparser.parser.ParserConfiguration;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.concurrent.ExecutorService;
 public class JRubyFileParser implements FileParser {
 	private String fileFullPath;
 	private EntityRepo entityRepo;
 	private ExecutorService executor;
 	private IncludedFileLocator includesFileLocator;
-	private Inferer inferer;
+	private IBindingResolver bindingResolver;
 	private ParserCreator parserCreator;
 
-	public JRubyFileParser(String fileFullPath, EntityRepo entityRepo, 
-			ExecutorService executorService, 
-			IncludedFileLocator includesFileLocator, 
-			Inferer inferer, ParserCreator parserCreator) {
+	public JRubyFileParser(String fileFullPath, EntityRepo entityRepo,
+                           ExecutorService executorService,
+                           IncludedFileLocator includesFileLocator,
+                           IBindingResolver bindingResolver, ParserCreator parserCreator) {
         this.fileFullPath  = FileUtil.uniqFilePath(fileFullPath);
         this.entityRepo = entityRepo;
         this.executor = executorService;
         this.includesFileLocator = includesFileLocator;
-        this.inferer = inferer;
+        this.bindingResolver = bindingResolver;
         this.parserCreator = parserCreator;
     }
 
@@ -79,7 +78,7 @@ public class JRubyFileParser implements FileParser {
 		ParserConfiguration config = new ParserConfiguration(0, version);
 		try {
 			Node node = rubyParser.parse("<code>", in, config);
-			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor,inferer,parserCreator);
+			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor, bindingResolver,parserCreator);
 			node.accept(parser);
 			fileEntity = entityRepo.getEntity(fileFullPath);
 			((FileEntity)fileEntity).cacheAllExpressions();

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -29,7 +29,7 @@ import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.IncludedFileLocator;
 import depends.extractor.ruby.RubyHandlerContext;
-import depends.relations.Inferer;
+import depends.relations.IBindingResolver;
 import org.jrubyparser.ast.*;
 import org.jrubyparser.util.NoopVisitor;
 
@@ -44,9 +44,9 @@ public class JRubyVisitor extends NoopVisitor {
 	private ExpressionUsage expressionUsage;
 
 	public JRubyVisitor(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
-			ExecutorService executorService, Inferer inferer, ParserCreator parserCreator) {
-		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, inferer, parserCreator);
-		expressionUsage = new ExpressionUsage(context, entityRepo, helper, inferer);
+                        ExecutorService executorService, IBindingResolver bindingResolver, ParserCreator parserCreator) {
+		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, bindingResolver, parserCreator);
+		expressionUsage = new ExpressionUsage(context, entityRepo, helper, bindingResolver);
 		context.startFile(fileFullPath);
 
 	}

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -23,12 +23,10 @@ SOFTWARE.
 */
 
 package depends.relations;
-
 import depends.entity.*;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.NullBuiltInType;
-import depends.extractor.AbstractLangProcessor;
 import depends.extractor.UnsolvedBindings;
 import depends.importtypes.Import;
 import org.slf4j.Logger;
@@ -37,7 +35,7 @@ import org.slf4j.LoggerFactory;
 import java.lang.management.ManagementFactory;
 import java.util.*;
 
-public class Inferer {
+public class BindingResolver implements IBindingResolver{
 
 	private BuiltInType buildInTypeManager = new NullBuiltInType();
 	private ImportLookupStrategy importLookupStrategy;
@@ -47,31 +45,26 @@ public class Inferer {
 	private boolean eagerExpressionResolve = false;
 	private boolean isCollectUnsolvedBindings = false;
 	private boolean isDuckTypingDeduce = true;
-	private static Logger logger = LoggerFactory.getLogger(Inferer.class);
+	private static Logger logger = LoggerFactory.getLogger(IBindingResolver.class);
 
-	public Inferer(EntityRepo repo, ImportLookupStrategy importLookupStrategy, BuiltInType buildInTypeManager,
-				   boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
+	public BindingResolver(EntityRepo repo, ImportLookupStrategy importLookupStrategy, BuiltInType buildInTypeManager,
+							boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
 		this.repo = repo;
 		this.importLookupStrategy = importLookupStrategy;
 		this.buildInTypeManager = buildInTypeManager;
 		this.isCollectUnsolvedBindings = isCollectUnsolvedBindings;
 		this.isDuckTypingDeduce = isDuckTypingDeduce;
 		unsolvedSymbols= new HashSet<>();
-		importLookupStrategy.setInferer(this);
+		importLookupStrategy.setBindingResolver(this);
 	}
 
-	/**
-	 * Resolve all bindings
-	 * - Firstly, we resolve all types from there names.
-	 * - Secondly, we resolve all expressions (expression will use type infomation of previous step
-	 * @param langProcessor 
-	 */
-	public  Set<UnsolvedBindings> resolveAllBindings(AbstractLangProcessor langProcessor) {
+	@Override
+	public  Set<UnsolvedBindings> resolveAllBindings(boolean isEagerExpressionResolve) {
 		System.out.println("Resolve type bindings....");
 		if (logger.isInfoEnabled()) {
 			logger.info("Resolve type bindings...");
 		}
-		resolveTypes(langProcessor.isEagerExpressionResolve());
+		resolveTypes(isEagerExpressionResolve);
 		System.out.println("Dependency analaysing....");
 		if (logger.isInfoEnabled()) {
 			logger.info("Dependency analaysing...");
@@ -90,26 +83,13 @@ public class Inferer {
 		}
 	}
 	
-	/**
-	 * For types start with the prefix, it will be treated as built-in type
-	 * For example, java.io.* in Java, or __ in C/C++
-	 * @param prefix
-	 * @return
-	 */
-	public boolean isBuiltInTypePrefix(String prefix) {
-		return buildInTypeManager.isBuiltInTypePrefix(prefix);
-	}
-	
-	/**
-	 * Different languages have different strategy on how to compute the imported types
-	 * and the imported files.
-	 * For example, in C/C++, both imported types (using namespace, using <type>) and imported files exists. 
-	 * while in java, only 'import class/function, or import wildcard class.* package.* exists. 
-	 */
+
+	@Override
 	public Collection<Entity> getImportedRelationEntities(List<Import> importedNames) {
 		return importLookupStrategy.getImportedRelationEntities(importedNames);
 	}
 
+	@Override
 	public Collection<Entity> getImportedTypes(List<Import> importedNames, FileEntity fileEntity) {
 		HashSet<UnsolvedBindings> unsolved = new HashSet<UnsolvedBindings>();
 		Collection<Entity> result = importLookupStrategy.getImportedTypes(importedNames,unsolved);
@@ -124,22 +104,13 @@ public class Inferer {
 		if (!isCollectUnsolvedBindings) return;
 		 	this.unsolvedSymbols.add(item);
 	}
-
+	@Override
 	public Collection<Entity> getImportedFiles(List<Import> importedNames) {
 		return importLookupStrategy.getImportedFiles(importedNames);
 	}
 
-	/**
-	 * By given raw name, to infer the type of the name
-	 * for example
-	 * (It is just a wrapper of resolve name)
-	 *   if it is a class, the class is the type
-	 *   if it is a function, the return type is the type
-	 *   if it is a variable, type of variable is the type 
-	 * @param fromEntity
-	 * @param rawName
-	 * @return
-	 */
+
+	@Override
 	public TypeEntity inferTypeFromName(Entity fromEntity, GenericName rawName) {
 		Entity data = resolveName(fromEntity, rawName, true);
 		if (data == null)
@@ -147,13 +118,8 @@ public class Inferer {
 		return data.getType();
 	}
 
-	/**
-	 * By given raw name, to infer the entity of the name
-	 * @param fromEntity
-	 * @param rawName
-	 * @param searchImport
-	 * @return
-	 */
+
+	@Override
 	public Entity resolveName(Entity fromEntity, GenericName rawName, boolean searchImport) {
 		if (rawName==null) return null;
 		Entity entity = resolveNameInternal(fromEntity,rawName,searchImport);
@@ -262,6 +228,7 @@ public class Inferer {
 		return null;
 	}
 
+	@Override
 	public Entity lookupTypeInImported(FileEntity fileEntity, String name) {
 		if (fileEntity == null)
 			return null;
@@ -290,13 +257,8 @@ public class Inferer {
 		return null;
 	}
 	
-	/**
-	 * Deduce type based on function calls
-	 * If the function call is a subset of a type, then the type could be a candidate of the var's type 
-	 * @param fromEntity
-	 * @param functionCalls
-	 * @return
-	 */
+
+	@Override
 	public List<TypeEntity> calculateCandidateTypes(VarEntity fromEntity, List<FunctionCall> functionCalls) {
 		if (buildInTypeManager.isBuildInTypeMethods(functionCalls)) {
 			return new ArrayList<>();
@@ -323,16 +285,14 @@ public class Inferer {
 		return types;
 	}
 
+	@Override
 	public boolean isEagerExpressionResolve() {
 		return eagerExpressionResolve;
 	}
 
-
+	@Override
 	public EntityRepo getRepo() {
 		return repo;
 	}
 
-	public void setCollectUnsolvedBindings(boolean isCollectUnsolvedBindings) {
-		this.isCollectUnsolvedBindings = isCollectUnsolvedBindings;
-	}
 }

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -36,14 +36,14 @@ import java.util.stream.Collectors;
 public class RelationCounter {
 
 	private Collection<Entity> entities;
-	private Inferer inferer;
+	private IBindingResolver bindingResolver;
 	private EntityRepo repo;
 	private boolean callAsImpl;
 	private AbstractLangProcessor langProcessor;
 
-	public RelationCounter( EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor,Inferer inferer) {
+	public RelationCounter(EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor, IBindingResolver bindingResolver) {
 		this.entities = repo.getFileEntities();
-		this.inferer = inferer;
+		this.bindingResolver = bindingResolver;
 		this.repo = repo;
 		this.callAsImpl = callAsImpl;
 		this.langProcessor = langProcessor;
@@ -93,9 +93,9 @@ public class RelationCounter {
 		}
 		
 		entity.reloadExpression(repo);
-		if (!inferer.isEagerExpressionResolve())
+		if (!bindingResolver.isEagerExpressionResolve())
 		{
-			entity.resolveExpressions(inferer);
+			entity.resolveExpressions(bindingResolver);
 		}
 		for (Expression expression:entity.expressionList()){
 			if (expression.isStatement()) {

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -5,7 +5,8 @@ import depends.entity.Entity;
 import depends.entity.FunctionEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
-import depends.relations.Inferer;
+import depends.relations.BindingResolver;
+import depends.relations.IBindingResolver;
 import depends.relations.Relation;
 import depends.relations.RelationCounter;
 import multilang.depends.util.file.TemporaryFile;
@@ -18,32 +19,32 @@ import static org.junit.Assert.fail;
 
 public abstract class ParserTest {
 	protected EntityRepo entityRepo ;
-	protected Inferer inferer ;
+	protected IBindingResolver bindingResolver;
 	protected AbstractLangProcessor langProcessor;
 
 	protected  void init(){
 		entityRepo = langProcessor.getEntityRepo();
-		inferer = new Inferer(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),false,false);
-		langProcessor.inferer = inferer;
+		bindingResolver = new BindingResolver(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),true,false);
+		langProcessor.bindingResolver = bindingResolver;
 		TemporaryFile.reset();
 	}
 
 	protected  void init(boolean duckTypingDeduce){
 		entityRepo = langProcessor.getEntityRepo();
-		inferer = new Inferer(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),false,duckTypingDeduce);
-		langProcessor.inferer = inferer;
+		bindingResolver = new BindingResolver(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),false,duckTypingDeduce);
+		langProcessor.bindingResolver = bindingResolver;
 		TemporaryFile.reset();
 	}
 
 	public Set<UnsolvedBindings> resolveAllBindings() {
-		Set<UnsolvedBindings> result = inferer.resolveAllBindings(langProcessor);
-		new RelationCounter(entityRepo,false,langProcessor,inferer).computeRelations();
+		Set<UnsolvedBindings> result = bindingResolver.resolveAllBindings(langProcessor.isEagerExpressionResolve());
+		new RelationCounter(entityRepo,false,langProcessor, bindingResolver).computeRelations();
 		return result;
 	}
 
 	protected Set<UnsolvedBindings>  resolveAllBindings(boolean callAsImpl) {
-		Set<UnsolvedBindings> result = inferer.resolveAllBindings(langProcessor);
-		new RelationCounter(entityRepo,callAsImpl,langProcessor,inferer).computeRelations();
+		Set<UnsolvedBindings> result = bindingResolver.resolveAllBindings(langProcessor.isEagerExpressionResolve());
+		new RelationCounter(entityRepo,callAsImpl,langProcessor, bindingResolver).computeRelations();
 		return result;
 	}
 

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -18,6 +18,6 @@ public abstract class CppParserTest extends ParserTest{
     }
 	
 	public CppFileParser createParser(String src) {
-		return new  CdtCppFileParser(src, entityRepo, preprocessorHandler,inferer,macroRepo );
+		return new  CdtCppFileParser(src, entityRepo, preprocessorHandler, bindingResolver,macroRepo );
 	}
 }

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -10,7 +10,7 @@ public abstract class GolangParserTest extends ParserTest{
 	}
 	
 	public GoFileParser createParser(String src) {
-		return new GoFileParser(src,entityRepo, inferer);
+		return new GoFileParser(src,entityRepo, bindingResolver);
 	}
 
 }

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -9,6 +9,6 @@ public abstract class JavaParserTest  extends ParserTest{
 	}
 	
 	public JavaFileParser createParser(String src) {
-		return new JavaFileParser(src,entityRepo, inferer);
+		return new JavaFileParser(src,entityRepo, bindingResolver);
 	}
 }

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -20,7 +20,6 @@ public class UnsolvedSymbolsTest extends JavaParserTest {
         String src = "./src/test/resources/java-code-examples/UnsolvedSymbols/MissingImport.java";
         JavaFileParser parser = createParser(src);
         parser.parse();
-        inferer.setCollectUnsolvedBindings(true);
         Set<UnsolvedBindings> missing = resolveAllBindings();
         assertEquals(1,missing.size());
         assertEquals("a.b",missing.iterator().next().getRawName());

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -11,7 +11,6 @@ import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
-import depends.relations.Inferer;
 
 public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	@Before

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -9,7 +9,7 @@ import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 import depends.extractor.FileParser;
 
-public class RubyNameInfererTest extends RubyParserTest {
+public class RubyNameIBindingResolverTest extends RubyParserTest {
 	@Before
 	public void setUp() {
 		super.init();

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -17,7 +17,7 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 	
 	public FileParser createFileParser(String src) {
 		ExecutorService executor = Executors.newSingleThreadExecutor();
-		return new JRubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()), inferer, this);
+		return new JRubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()), bindingResolver, this);
 	}
 
 	private List<String> includePaths() {

2f0724800b1a1808db7ad18db917480eeea8fe81
@@ -213,7 +213,7 @@ public class BindingResolver implements IBindingResolver{
 			return precendenceEntity;
 		}
 		if (nameIndex == -1) {
-			System.err.println("error");
+			System.err.println("No expected symbols: names"+Arrays.toString(names) +", index=" + nameIndex);
 			return null;
 		}
 		//If it is not an entity with types (not a type, var, function), fall back to itself

1016ff9298216859922a8e055c425d0b789d9ef3
@@ -33,15 +33,12 @@ import depends.relations.ImportLookupStrategy;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 
 import static depends.deptypes.DependencyType.*;
 
 public class RubyProcessor extends AbstractLangProcessor implements ParserCreator{
     private static final String LANG = "ruby";
     private static final String[] SUFFIX = new String[] {".rb"};
-	private ExecutorService executor;
 
 	@Override
 	public String supportedLanguage() {
@@ -56,15 +53,7 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 
 	@Override
 	public FileParser createFileParser(String fileFullPath) {
-		executor = Executors.newSingleThreadExecutor();
-		return new JRubyFileParser(fileFullPath,entityRepo,executor,new IncludedFileLocator(super.includePaths()), bindingResolver,this);
-	}
-
-
-	@Override
-	protected void finalize() throws Throwable {
-		this.executor.shutdown();
-		super.finalize();
+		return new JRubyFileParser(fileFullPath,entityRepo,new IncludedFileLocator(super.includePaths()), bindingResolver,this);
 	}
 
 	@Override

1016ff9298216859922a8e055c425d0b789d9ef3
@@ -41,22 +41,18 @@ import org.jrubyparser.parser.ParserConfiguration;
 
 import java.io.IOException;
 import java.io.StringReader;
-import java.util.concurrent.ExecutorService;
 public class JRubyFileParser implements FileParser {
 	private String fileFullPath;
 	private EntityRepo entityRepo;
-	private ExecutorService executor;
 	private IncludedFileLocator includesFileLocator;
 	private IBindingResolver bindingResolver;
 	private ParserCreator parserCreator;
 
 	public JRubyFileParser(String fileFullPath, EntityRepo entityRepo,
-                           ExecutorService executorService,
                            IncludedFileLocator includesFileLocator,
                            IBindingResolver bindingResolver, ParserCreator parserCreator) {
         this.fileFullPath  = FileUtil.uniqFilePath(fileFullPath);
         this.entityRepo = entityRepo;
-        this.executor = executorService;
         this.includesFileLocator = includesFileLocator;
         this.bindingResolver = bindingResolver;
         this.parserCreator = parserCreator;
@@ -78,7 +74,7 @@ public class JRubyFileParser implements FileParser {
 		ParserConfiguration config = new ParserConfiguration(0, version);
 		try {
 			Node node = rubyParser.parse("<code>", in, config);
-			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator,executor, bindingResolver,parserCreator);
+			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator, bindingResolver,parserCreator);
 			node.accept(parser);
 			fileEntity = entityRepo.getEntity(fileFullPath);
 			((FileEntity)fileEntity).cacheAllExpressions();

1016ff9298216859922a8e055c425d0b789d9ef3
@@ -35,7 +35,6 @@ import org.jrubyparser.util.NoopVisitor;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.concurrent.ExecutorService;
 
 public class JRubyVisitor extends NoopVisitor {
 
@@ -44,8 +43,8 @@ public class JRubyVisitor extends NoopVisitor {
 	private ExpressionUsage expressionUsage;
 
 	public JRubyVisitor(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
-                        ExecutorService executorService, IBindingResolver bindingResolver, ParserCreator parserCreator) {
-		this.context = new RubyHandlerContext(entityRepo, includedFileLocator, executorService, bindingResolver, parserCreator);
+                        IBindingResolver bindingResolver, ParserCreator parserCreator) {
+		this.context = new RubyHandlerContext(entityRepo, includedFileLocator,  bindingResolver, parserCreator);
 		expressionUsage = new ExpressionUsage(context, entityRepo, helper, bindingResolver);
 		context.startFile(fileFullPath);
 

1016ff9298216859922a8e055c425d0b789d9ef3
@@ -1,10 +1,10 @@
 package depends.extractor.java;
 
-import java.io.IOException;
-
 import org.junit.Before;
 import org.junit.Test;
 
+import java.io.IOException;
+
 public class JavaCylicInheritTest extends JavaParserTest{
 	@Before
 	public void setUp() {
@@ -18,6 +18,4 @@ public class JavaCylicInheritTest extends JavaParserTest{
         parser.parse();
         resolveAllBindings();
 	}
-	
-	
 }

1016ff9298216859922a8e055c425d0b789d9ef3
@@ -7,8 +7,6 @@ import depends.extractor.ruby.jruby.JRubyFileParser;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 public abstract class RubyParserTest extends ParserTest implements ParserCreator{
 	public void init() {
 		langProcessor = new RubyProcessor();
@@ -16,8 +14,7 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 	}
 	
 	public FileParser createFileParser(String src) {
-		ExecutorService executor = Executors.newSingleThreadExecutor();
-		return new JRubyFileParser(src,entityRepo, executor,new IncludedFileLocator(includePaths()), bindingResolver, this);
+		return new JRubyFileParser(src,entityRepo, new IncludedFileLocator(includePaths()), bindingResolver, this);
 	}
 
 	private List<String> includePaths() {

b6feb8187235f09f1e9347e55de613ec5ba5c52a
@@ -28,12 +28,8 @@ import depends.entity.repo.BuiltInType;
 
 public class CppBuiltInType extends BuiltInType {
 
-	public CppBuiltInType() {
-		super.createBuiltInTypes();
-	}
-
 	@Override
-	public String[] getBuiltInTypeStr() {
+	protected String[] getBuiltInTypeName() {
 		return new String[] { "alignas", "alignof", "asm", "auto", "bool", "break", "case", "catch", "char",
 				"char16_t", "char32_t", "class", "const", "constexpr", "const_cast", "continue", "decltype",
 				"default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
@@ -64,12 +60,7 @@ public class CppBuiltInType extends BuiltInType {
 	}
 
 	@Override
-	public String[] getBuiltInPrefixStr() {
+	protected String[] getBuiltInTypePrefix() {
 		return new String[] {"__"};
 	}
-	@Override
-	public String[] getBuiltInMethods() {
-		return new String[]{};
-	}
-
 }
\ No newline at end of file

b6feb8187235f09f1e9347e55de613ec5ba5c52a
@@ -27,19 +27,4 @@ package depends.extractor.empty;
 import depends.entity.repo.BuiltInType;
 
 public class EmptyBuiltInType extends BuiltInType {
-
-	@Override
-	public String[] getBuiltInMethods() {
-		return new String[] {};
-	}
-
-	@Override
-	public String[] getBuiltInTypeStr() {
-		return new String[] {};
-	}
-
-	@Override
-	public String[] getBuiltInPrefixStr() {
-		return new String[] {};
-	}
 }

b6feb8187235f09f1e9347e55de613ec5ba5c52a
@@ -28,12 +28,8 @@ import depends.entity.repo.BuiltInType;
 
 public class GoBuiltInType extends BuiltInType {
 
-    public GoBuiltInType() {
-        super.createBuiltInTypes();
-    }
-
     @Override
-    public String[] getBuiltInTypeStr() {
+    protected String[] getBuiltInTypeName() {
         return new String[]{
                 "<Built-in>",
                 "break", "default", "func", "interface",
@@ -49,16 +45,4 @@ public class GoBuiltInType extends BuiltInType {
 				"_"
         };
     }
-
-    @Override
-    public String[] getBuiltInPrefixStr() {
-        return new String[]{
-        };
-    }
-
-    @Override
-    public String[] getBuiltInMethods() {
-        return new String[]{};
-    }
-
 }

b6feb8187235f09f1e9347e55de613ec5ba5c52a
@@ -28,11 +28,8 @@ import depends.entity.repo.BuiltInType;
 
 public class JavaBuiltInType extends BuiltInType{
 	
-	public JavaBuiltInType() {
-        super.createBuiltInTypes();
-	}
 	@Override
-	public String[] getBuiltInTypeStr() {
+	protected String[] getBuiltInTypeName() {
 		return new String[]{
 				"void","int","double","char","byte","boolean","long","short","float",
 				"BigDecimal","Integer","Double","Char","Byte","Boolean","Long","Short","Float",
@@ -79,14 +76,9 @@ public class JavaBuiltInType extends BuiltInType{
 		};
 	}
 	@Override
-	public String[] getBuiltInPrefixStr() {
+	protected String[] getBuiltInTypePrefix() {
 		return new String[]{
 				"java.","javax.","com.sun."
 		};
 	}
-	@Override
-	public String[] getBuiltInMethods() {
-		return new String[]{};
-	}
-	
 }

b6feb8187235f09f1e9347e55de613ec5ba5c52a
@@ -1,8 +1,5 @@
 package depends.extractor.python;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.FunctionCall;
 import depends.entity.FunctionEntity;
 import depends.entity.GenericName;
@@ -10,6 +7,9 @@ import depends.entity.TypeEntity;
 import depends.entity.repo.BuiltInType;
 import depends.relations.FunctionMatcher;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class PythonBuiltInType extends BuiltInType {
 
 	public static String[] BUILT_IN_FUNCTIONS = { "abs", "delattr", "hash", "memoryview", "set", "all", "dict", "help",
@@ -82,25 +82,6 @@ public class PythonBuiltInType extends BuiltInType {
 		buildInTypes.add(type);
 	}
 
-	@Override
-	public String[] getBuiltInMethods() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public String[] getBuiltInTypeStr() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public String[] getBuiltInPrefixStr() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-	
-	
 	@Override
 	public  boolean isBuildInTypeMethods(List<FunctionCall> functionCalls) {
 		for (TypeEntity type:buildInTypes) {

b6feb8187235f09f1e9347e55de613ec5ba5c52a
@@ -26,8 +26,8 @@ package depends.relations;
 import depends.entity.*;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
-import depends.entity.repo.NullBuiltInType;
 import depends.extractor.UnsolvedBindings;
+import depends.extractor.empty.EmptyBuiltInType;
 import depends.importtypes.Import;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -37,7 +37,7 @@ import java.util.*;
 
 public class BindingResolver implements IBindingResolver{
 
-	private BuiltInType buildInTypeManager = new NullBuiltInType();
+	private BuiltInType buildInTypeManager = new EmptyBuiltInType();
 	private ImportLookupStrategy importLookupStrategy;
 	private Set<UnsolvedBindings> unsolvedSymbols = new HashSet<>();
 	private EntityRepo repo;
@@ -137,9 +137,6 @@ public class BindingResolver implements IBindingResolver{
 		if (buildInTypeManager.isBuiltInType(rawName.getName())) {
 			return TypeEntity.buildInType;
 		}
-		if (buildInTypeManager.isBuiltInTypePrefix(rawName.getName())) {
-			return TypeEntity.buildInType;
-		}
 		// qualified name will first try global name directly
 		if (rawName.startsWith(".")) {
 			rawName = rawName.substring(1);

aaa26dab1acc77b60ee66459259a230fb59b79eb
@@ -6,7 +6,7 @@ import depends.extractor.python.NameAliasImport;
 import depends.extractor.python.PythonHandlerContext;
 import depends.extractor.python.PythonParser.*;
 import depends.extractor.python.PythonParserBaseListener;
-import depends.extractor.ruby.IncludedFileLocator;
+import depends.extractor.IncludedFileLocator;
 import depends.importtypes.FileImport;
 import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileUtil;

aaa26dab1acc77b60ee66459259a230fb59b79eb
@@ -6,7 +6,7 @@ import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.python.PythonLexer;
 import depends.extractor.python.PythonParser;
-import depends.extractor.ruby.IncludedFileLocator;
+import depends.extractor.IncludedFileLocator;
 import depends.relations.IBindingResolver;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;

aaa26dab1acc77b60ee66459259a230fb59b79eb
@@ -27,6 +27,7 @@ package depends.extractor.ruby;
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
 import depends.extractor.FileParser;
+import depends.extractor.IncludedFileLocator;
 import depends.extractor.ParserCreator;
 import depends.extractor.ruby.jruby.JRubyFileParser;
 import depends.relations.ImportLookupStrategy;

aaa26dab1acc77b60ee66459259a230fb59b79eb
@@ -29,7 +29,7 @@ import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ParserCreator;
-import depends.extractor.ruby.IncludedFileLocator;
+import depends.extractor.IncludedFileLocator;
 import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.CharStream;

aaa26dab1acc77b60ee66459259a230fb59b79eb
@@ -27,7 +27,7 @@ package depends.extractor.ruby.jruby;
 import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.ParserCreator;
-import depends.extractor.ruby.IncludedFileLocator;
+import depends.extractor.IncludedFileLocator;
 import depends.extractor.ruby.RubyHandlerContext;
 import depends.relations.IBindingResolver;
 import org.jrubyparser.ast.*;

aaa26dab1acc77b60ee66459259a230fb59b79eb
@@ -1,6 +1,7 @@
 package depends.extractor.ruby;
 
 import depends.extractor.FileParser;
+import depends.extractor.IncludedFileLocator;
 import depends.extractor.ParserCreator;
 import depends.extractor.ParserTest;
 import depends.extractor.ruby.jruby.JRubyFileParser;

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -81,7 +81,7 @@ abstract public class AbstractLangProcessor {
 	 * @param fileFullPath
 	 * @return
 	 */
-	public abstract FileParser createFileParser(String fileFullPath);
+	public abstract FileParser createFileParser();
 
 	public IBindingResolver bindingResolver;
 	protected EntityRepo entityRepo;
@@ -182,10 +182,10 @@ abstract public class AbstractLangProcessor {
 	}
 
 	protected void parseFile(String fileFullPath) {
-		FileParser fileParser = createFileParser(fileFullPath);
+		FileParser fileParser = createFileParser();
 		try {
 			System.out.println("parsing " + fileFullPath + "...");
-			fileParser.parse();
+			fileParser.parse(FileUtil.uniqFilePath(fileFullPath));
 		} catch (IOException e) {
 			e.printStackTrace();
 		} catch (Exception e) {

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -58,7 +58,7 @@ public class CppProcessor extends AbstractLangProcessor {
 	}
 
 	@Override
-	public FileParser createFileParser(String fileFullPath) {
+	public FileParser createFileParser() {
 		if (macroRepo == null) {
 			macroRepo = new MacroEhcacheRepo(entityRepo);
 			macroRepo.buildDefaultMap(super.includePaths());
@@ -66,7 +66,7 @@ public class CppProcessor extends AbstractLangProcessor {
 		if (preprocessorHandler==null) {
 			preprocessorHandler = new PreprocessorHandler(super.inputSrcPath,super.includePaths());
 		}
-		return new CdtCppFileParser(fileFullPath, entityRepo, preprocessorHandler, bindingResolver, macroRepo);
+		return new CdtCppFileParser(entityRepo, preprocessorHandler, bindingResolver, macroRepo);
 	}
 
 	@Override

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -52,8 +52,8 @@ public class GoProcessor extends AbstractLangProcessor {
 	}
 
 	@Override
-	public FileParser createFileParser(String fileFullPath) {
-		return new GoFileParser(fileFullPath, entityRepo, bindingResolver);
+	public FileParser createFileParser() {
+		return new GoFileParser( entityRepo, bindingResolver);
 	}
 
 	@Override

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -51,8 +51,8 @@ public class JavaProcessor extends AbstractLangProcessor {
 	}
 	
 	@Override
-	public FileParser createFileParser(String fileFullPath) {
-		return new JavaFileParser(fileFullPath,entityRepo, bindingResolver);
+	public FileParser createFileParser() {
+		return new JavaFileParser(entityRepo, bindingResolver);
 	}
 	
 	@Override

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -3,6 +3,7 @@ package depends.extractor.kotlin;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.relations.IBindingResolver;
+import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;
 import org.antlr.v4.runtime.CommonTokenStream;
@@ -14,21 +15,20 @@ import java.io.IOException;
 public class KotlinFileParser implements FileParser {
 
 	@Override
-	public void parse() throws IOException {
-	       CharStream input = CharStreams.fromFileName(fileFullPath);
-	        Lexer lexer = new KotlinLexer(input);
-	        CommonTokenStream tokens = new CommonTokenStream(lexer);
-	        KotlinParser parser = new KotlinParser(tokens);
-	        KotlinListener bridge = new KotlinListener(fileFullPath, entityRepo, bindingResolver);
-		    ParseTreeWalker walker = new ParseTreeWalker();
-		    walker.walk(bridge, parser.kotlinFile());
+	public void parse(String fileFullPath) throws IOException {
+		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
+		CharStream input = CharStreams.fromFileName(fileFullPath);
+		Lexer lexer = new KotlinLexer(input);
+		CommonTokenStream tokens = new CommonTokenStream(lexer);
+		KotlinParser parser = new KotlinParser(tokens);
+		KotlinListener bridge = new KotlinListener(fileFullPath, entityRepo, bindingResolver);
+		ParseTreeWalker walker = new ParseTreeWalker();
+		walker.walk(bridge, parser.kotlinFile());
 	}
 	
-	private String fileFullPath;
 	private EntityRepo entityRepo;
 	private IBindingResolver bindingResolver;
-	public KotlinFileParser(String fileFullPath,EntityRepo entityRepo, IBindingResolver bindingResolver) {
-        this.fileFullPath = fileFullPath;
+	public KotlinFileParser(EntityRepo entityRepo, IBindingResolver bindingResolver) {
         this.entityRepo = entityRepo;
         this.bindingResolver = bindingResolver;
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -39,8 +39,8 @@ public class KotlinProcessor extends AbstractLangProcessor {
 	}
 
 	@Override
-	public FileParser createFileParser(String fileFullPath) {
-		return new KotlinFileParser(fileFullPath,entityRepo, bindingResolver);
+	public FileParser createFileParser() {
+		return new KotlinFileParser(entityRepo, bindingResolver);
 	}
 
 	@Override

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -183,10 +183,10 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	}
 
 	private void visitIncludedFile(String fullName) {
-		PythonFileParser importedParser = new PythonFileParser(fullName, entityRepo, includeFileLocator, bindingResolver,
+		PythonFileParser importedParser = new PythonFileParser(entityRepo, includeFileLocator, bindingResolver,
 				pythonProcessor);
 		try {
-			importedParser.parse();
+			importedParser.parse(fullName);
 		} catch (IOException e) {
 			e.printStackTrace();
 		}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -8,6 +8,7 @@ import depends.extractor.python.PythonLexer;
 import depends.extractor.python.PythonParser;
 import depends.extractor.IncludedFileLocator;
 import depends.relations.IBindingResolver;
+import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;
 import org.antlr.v4.runtime.CommonTokenStream;
@@ -17,16 +18,13 @@ import org.antlr.v4.runtime.tree.ParseTreeWalker;
 import java.io.IOException;
 
 public class PythonFileParser implements FileParser {
-
-	private String fileFullPath;
 	private EntityRepo entityRepo;
 	private IBindingResolver bindingResolver;
 	private IncludedFileLocator includeFileLocator;
 	private PythonProcessor processor;
 
-	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includeFileLocator,
+	public PythonFileParser(EntityRepo entityRepo, IncludedFileLocator includeFileLocator,
 							IBindingResolver bindingResolver, PythonProcessor pythonProcessor) {
-		this.fileFullPath = fileFullPath;
 		this.entityRepo = entityRepo;
 		this.bindingResolver = bindingResolver;
 		this.includeFileLocator = includeFileLocator;
@@ -34,7 +32,8 @@ public class PythonFileParser implements FileParser {
 	}
 
 	@Override
-	public void parse() throws IOException {
+	public void parse(String fileFullPath) throws IOException {
+		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
 		/** If file already exist, skip it */
 		Entity fileEntity = entityRepo.getEntity(fileFullPath);
 		if (fileEntity!=null && fileEntity instanceof FileEntity) {

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -53,8 +53,8 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 
 
 	@Override
-	public FileParser createFileParser(String fileFullPath) {
-		return new JRubyFileParser(fileFullPath,entityRepo,new IncludedFileLocator(super.includePaths()), bindingResolver,this);
+	public FileParser createFileParser() {
+		return new JRubyFileParser(entityRepo,new IncludedFileLocator(super.includePaths()), bindingResolver,this);
 	}
 
 	@Override

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -28,8 +28,8 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
-import depends.extractor.ParserCreator;
 import depends.extractor.IncludedFileLocator;
+import depends.extractor.ParserCreator;
 import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.CharStream;
@@ -42,16 +42,14 @@ import org.jrubyparser.parser.ParserConfiguration;
 import java.io.IOException;
 import java.io.StringReader;
 public class JRubyFileParser implements FileParser {
-	private String fileFullPath;
 	private EntityRepo entityRepo;
 	private IncludedFileLocator includesFileLocator;
 	private IBindingResolver bindingResolver;
 	private ParserCreator parserCreator;
 
-	public JRubyFileParser(String fileFullPath, EntityRepo entityRepo,
+	public JRubyFileParser( EntityRepo entityRepo,
                            IncludedFileLocator includesFileLocator,
                            IBindingResolver bindingResolver, ParserCreator parserCreator) {
-        this.fileFullPath  = FileUtil.uniqFilePath(fileFullPath);
         this.entityRepo = entityRepo;
         this.includesFileLocator = includesFileLocator;
         this.bindingResolver = bindingResolver;
@@ -60,7 +58,8 @@ public class JRubyFileParser implements FileParser {
 
 	@SuppressWarnings("unchecked")
 	@Override
-	public void parse() throws IOException {
+	public void parse(String fileFullPath) throws IOException {
+		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
 		/** If file already exist, skip it */
 		Entity fileEntity = entityRepo.getEntity(fileFullPath);
 		if (fileEntity!=null && fileEntity instanceof FileEntity) {

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,8 +17,8 @@ public class AliasTest extends CppParserTest{
 	@Test
 	public void test_genericTypes() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/Alias.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
+	    CppFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("bar"), DependencyType.CALL, "F.foo");
 	}
@@ -26,8 +26,8 @@ public class AliasTest extends CppParserTest{
 	@Test
 	public void test_refer_to_alias_type_should_work() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/AliasType.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
+	    CppFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("C"), DependencyType.INHERIT, "A");
 	}
@@ -40,8 +40,8 @@ public class AliasTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("bar"), DependencyType.CALL, "foo");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -19,8 +19,8 @@ public class ConstructFunctionReturnValueTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         //assertEquals(1,repo.getEntity("UnderTest").getRelations().size());
@@ -33,8 +33,8 @@ public class ConstructFunctionReturnValueTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         //assertEquals(1,repo.getEntity("UnderTest").getRelations().size());

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -1,5 +1,6 @@
 package depends.extractor.cpp;
 import depends.deptypes.DependencyType;
+import multilang.depends.util.file.FileUtil;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -20,8 +21,8 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         assertEquals(1, entityRepo.getEntity("UnderTest").getRelations().size());
@@ -35,8 +36,8 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(FileUtil.uniqFilePath(src));
 	    }
 	    resolveAllBindings();
         assertEquals(2, entityRepo.getEntity("UnderTest").getRelations().size());
@@ -50,8 +51,8 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("UnderTest"), DependencyType.CONTAIN, "Member");
@@ -67,8 +68,8 @@ public class ContainRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,8 +17,8 @@ public class CppExpressionTest extends CppParserTest{
 	@Test
 	public void test_expressions() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/Expressions.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
+	    CppFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         Entity e = entityRepo.getEntity("foo");
         this.assertContainsRelation(e, DependencyType.PARAMETER,"ClassA");
@@ -35,8 +35,8 @@ public class CppExpressionTest extends CppParserTest{
 	@Test
     public void test_should_not_count_expr_duplicated() throws IOException {
         String src = "./src/test/resources/cpp-code-examples/DupExpressions.cpp";
-        CppFileParser parser = createParser(src);
-        parser.parse();
+        CppFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         Entity e = entityRepo.getEntity("foo");
         assertEquals(4,e.getRelations().size());

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -15,8 +15,8 @@ public class CppParameterParserTest extends CppParserTest{
 	@Test
 	public void test_parameter() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
-	    CppFileParser parser = createParser(src);
-        parser.parse();
+	    CppFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(4, entityRepo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,7 +17,7 @@ public abstract class CppParserTest extends ParserTest{
     	macroRepo = new MacroEhcacheRepo(entityRepo);
     }
 	
-	public CppFileParser createParser(String src) {
-		return new  CdtCppFileParser(src, entityRepo, preprocessorHandler, bindingResolver,macroRepo );
+	public CppFileParser createParser() {
+		return new  CdtCppFileParser(entityRepo, preprocessorHandler, bindingResolver,macroRepo );
 	}
 }

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -21,8 +21,8 @@ public class DuplicateDeclarationTest extends CppParserTest {
 			    	    };
 			    
 			    for (String src:srcs) {
-				    CppFileParser parser = createParser(src);
-				    parser.parse();
+				    CppFileParser parser = createParser();
+				    parser.parse(src);
 			    }
 			    resolveAllBindings();
 			    Entity e = entityRepo.getEntity("X.invoke");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -21,8 +21,8 @@ public class ForwardDeclareTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         //TODO: to be complete

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -19,8 +19,8 @@ public class GenericTypeTest extends CppParserTest {
 	@Test
 	public void test_templateSpecializationOfStruct() throws IOException {
 		String src = "./src/test/resources/cpp-code-examples/template/TempateStructure.cpp";
-		CppFileParser parser = createParser(src);
-		parser.parse();
+		CppFileParser parser = createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		assertNotNull(entityRepo.getEntity("hash"));
 	}
@@ -28,8 +28,8 @@ public class GenericTypeTest extends CppParserTest {
 	@Test
 	public void test_genericTypesVarParameterReference() throws IOException {
 		String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
-		CppFileParser parser = createParser(src);
-		parser.parse();
+		CppFileParser parser = createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		this.assertContainsRelation(entityRepo.getEntity("xStack"), DependencyType.PARAMETER, "X");
 	}
@@ -37,8 +37,8 @@ public class GenericTypeTest extends CppParserTest {
 	@Test
 	public void test_genericTypesExtends() throws IOException {
 		String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
-		CppFileParser parser = createParser(src);
-		parser.parse();
+		CppFileParser parser = createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		this.assertContainsRelation(entityRepo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
 	}
@@ -46,8 +46,8 @@ public class GenericTypeTest extends CppParserTest {
 	@Test
 	public void test_GenericTypeEmbededShouldBeIdentified() throws IOException {
 		String src = "./src/test/resources/cpp-code-examples/template/EmbededTemplates.cpp";
-		CppFileParser parser = createParser(src);
-		parser.parse();
+		CppFileParser parser = createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest"), DependencyType.CONTAIN, "MyHashMap");
 		this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"), DependencyType.PARAMETER, "MyList");
@@ -57,8 +57,8 @@ public class GenericTypeTest extends CppParserTest {
 	@Test
 	public void test_TemplateWithDots() throws IOException {
 		String src = "./src/test/resources/cpp-code-examples/template/TemplateWithDots.cpp";
-		CppFileParser parser = createParser(src);
-		parser.parse();
+		CppFileParser parser = createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		assertNotNull(entityRepo.getEntity("foo.t2"));
 	}
@@ -66,8 +66,8 @@ public class GenericTypeTest extends CppParserTest {
 	@Test
 	public void test_TemplateInReturn() throws IOException {
 		String src = "./src/test/resources/cpp-code-examples/template/TemplateInReturnValue.cpp";
-		CppFileParser parser = createParser(src);
-		parser.parse();
+		CppFileParser parser = createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		FunctionEntity func = (FunctionEntity) entityRepo.getEntity("get");
 		this.assertContainsRelation(func, DependencyType.RETURN, "std.tuple_element.type");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -24,8 +24,8 @@ public class ImplementRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser =createParser(src);
-		    parser.parse();
+		    CppFileParser parser =createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    MultiDeclareEntities multiDeclare = (MultiDeclareEntities)( entityRepo.getEntity("foo"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -30,8 +30,8 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         File f = new File(srcs[0]);
@@ -49,8 +49,8 @@ public class IncludeRelationTest extends CppParserTest{
 	    List<String> includePaths = new ArrayList<>();
 	    includePaths.add("./src/test/resources/cpp-code-examples/includesTest/path/");
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         File f = new File(srcs[0]);
@@ -65,8 +65,8 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         assertEquals("abc",((AliasEntity) entityRepo.getEntity("abc_t")).getOriginType().getRawName().uniqName());
@@ -82,8 +82,8 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(this.entityRepo.getEntity("foo"), DependencyType.CALL, "bar");
@@ -99,8 +99,8 @@ public class IncludeRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(this.entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[1]));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -22,8 +22,8 @@ public class MacroRelationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity e = entityRepo.getEntity("foo");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -24,8 +24,8 @@ public class MacroTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    
@@ -40,8 +40,8 @@ public class MacroTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    
@@ -56,8 +56,8 @@ public class MacroTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -20,8 +20,8 @@ public class ParseErrorTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	}
@@ -33,11 +33,11 @@ public class ParseErrorTest extends CppParserTest{
 		};
 
 		for (String src:srcs) {
-			CdtCppFileParser parser = (CdtCppFileParser)createParser(src);
+			CdtCppFileParser parser = (CdtCppFileParser)createParser();
 
 			Map<String, String> macroMap = new HashMap<>();
 			macroMap.put("AP_DECLARE(x)","x");
-			parser.parse(true,macroMap);
+			parser.parse(src,true,macroMap);
 		}
 		resolveAllBindings();
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -26,8 +26,8 @@ public class RelationInSameFileTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings(true);
 	    Entity bar = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -26,8 +26,8 @@ public class RelationToImplementationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings(true);
 	    Entity bar = entityRepo.getEntity("bar");
@@ -53,8 +53,8 @@ public class RelationToImplementationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings(true);
 	    Entity bar = entityRepo.getEntity("baz");
@@ -77,8 +77,8 @@ public class RelationToImplementationTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings(true);
 	    Entity bar = entityRepo.getEntity("qux");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -19,8 +19,8 @@ public class TypeDefTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("foo"), DependencyType.PARAMETER, "MyInt");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -21,8 +21,8 @@ public class UsingTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         Entity e = entityRepo.getEntity("foo");
@@ -39,8 +39,8 @@ public class UsingTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         Entity e = entityRepo.getEntity("bar");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -21,8 +21,8 @@ public class extendsTest extends CppParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    CppFileParser parser = createParser(src);
-		    parser.parse();
+		    CppFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         Entity e = entityRepo.getEntity("B");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -18,8 +18,8 @@ public class GoFunctionsTest extends GolangParserTest {
 	@Test
 	public void test_could_parse_function() throws IOException {
         String src = "./src/test/resources/go-code-examples/func.go";
-        GoFileParser parser =createParser(src);
-        parser.parse();
+        GoFileParser parser =createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertNotNull(entityRepo.getEntity("main"));
 	}
@@ -28,8 +28,8 @@ public class GoFunctionsTest extends GolangParserTest {
 	@Ignore
 	public void test_could_parse_struct_type() throws IOException {
 		String src = "./src/test/resources/go-code-examples/struct.go";
-		GoFileParser parser =createParser(src);
-		parser.parse();
+		GoFileParser parser =createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		assertNotNull(entityRepo.getEntity("Books"));
 	}
@@ -37,8 +37,8 @@ public class GoFunctionsTest extends GolangParserTest {
 	@Ignore
 	public void test_could_parse_struct_members() throws IOException {
 		String src = "./src/test/resources/go-code-examples/struct.go";
-		GoFileParser parser =createParser(src);
-		parser.parse();
+		GoFileParser parser =createParser();
+		parser.parse(src);
 		resolveAllBindings();
 		assertNotNull(entityRepo.getEntity("Books"));
 		TypeEntity book = (TypeEntity)entityRepo.getEntity("Books");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -9,8 +9,8 @@ public abstract class GolangParserTest extends ParserTest{
 		super.init();
 	}
 	
-	public GoFileParser createParser(String src) {
-		return new GoFileParser(src,entityRepo, bindingResolver);
+	public GoFileParser createParser() {
+		return new GoFileParser(entityRepo, bindingResolver);
 	}
 
 }

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,8 +17,8 @@ public class InheritTypeTest extends JavaParserTest {
 	@Test
 	public void should_handle_inherited_type_correctly() throws IOException {
         String src = "./src/test/resources/java-code-examples/InheritTest.java";
-        JavaFileParser parser =createParser(src);
-        parser.parse();
+        JavaFileParser parser =createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("InheritTest").getRelations().size());
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,8 +17,8 @@ public class JavaAnnotationParserTest extends JavaParserTest {
 	@Test
 	public void test_could_parse_annotationType() throws IOException {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
-        JavaFileParser parser =createParser(src);
-        parser.parse();
+        JavaFileParser parser =createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("AnnotationTest.value").getRelations().size());
 	}
@@ -26,8 +26,8 @@ public class JavaAnnotationParserTest extends JavaParserTest {
 	@Test
 	public void test_could_detect_annotation_in_class_level() throws IOException {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
-        JavaFileParser parser =createParser(src);
-        parser.parse();
+        JavaFileParser parser =createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("TheClass"), DependencyType.ANNOTATION, "AnnotationTest");
 	}
@@ -35,8 +35,8 @@ public class JavaAnnotationParserTest extends JavaParserTest {
 	@Test
 	public void test_could_detect_annotation_in_function_level() throws IOException {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
-        JavaFileParser parser =createParser(src);
-        parser.parse();
+        JavaFileParser parser =createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("TheFunction.foo"), DependencyType.ANNOTATION, "AnnotationTest");
 	}
@@ -44,8 +44,8 @@ public class JavaAnnotationParserTest extends JavaParserTest {
 	@Test
 	public void test_could_detect_no_annotation_in_function_level() throws IOException {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
-        JavaFileParser parser =createParser(src);
-        parser.parse();
+        JavaFileParser parser =createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertNotContainsRelation(entityRepo.getEntity("TheFunction.bar"), DependencyType.ANNOTATION, "AnnotationTest");
 	}
@@ -53,8 +53,8 @@ public class JavaAnnotationParserTest extends JavaParserTest {
 	@Test
 	public void test_could_detect_annotation_in_miscs() throws IOException {
         String src = "./src/test/resources/java-code-examples/AnnotationTest.java";
-        JavaFileParser parser =createParser(src);
-        parser.parse();
+        JavaFileParser parser =createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("TheClass.TheClass"), DependencyType.ANNOTATION, "AnnotationTest");
         this.assertContainsRelation(entityRepo.getEntity("TheEnum"), DependencyType.ANNOTATION, "AnnotationTest");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,8 +17,8 @@ public class JavaCallExpressionTest extends JavaParserTest {
 	@Test
 	public void test() throws IOException {
         String src = "./src/test/resources/java-code-examples/SimpleExpressionCallTest.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
 	}
 

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,8 +17,8 @@ public class JavaComplexExpressionTest extends JavaParserTest {
 	@Test
 	public void test_complexExpression() throws IOException {
         String src = "./src/test/resources/java-code-examples/ComplexExpressionTest.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         ContainerEntity entity  = (ContainerEntity)(entityRepo.getEntity("ComplexExpressionTest.other"));
         assertEquals(3,entity.getRelations().size());

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -14,8 +14,8 @@ public class JavaCylicInheritTest extends JavaParserTest{
 	@Test(timeout=3000L)
 	public void test_cyclic_should_not_occur_inifinite_test() throws IOException {
         String src = "./src/test/resources/java-code-examples/CyclicInherit.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
 	}
 }

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -15,8 +15,8 @@ public class JavaEmbededClassTest extends JavaParserTest{
 	@Test
 	public void test_EmbededTypeWithImport() throws IOException {
         String src = "./src/test/resources/java-code-examples/EmbededTest.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("x.EmbededTest").getRelations().size());
 	}
@@ -24,8 +24,8 @@ public class JavaEmbededClassTest extends JavaParserTest{
 	@Test
 	public void test_EmbededTypeWithoutImport() throws IOException {
         String src = "./src/test/resources/java-code-examples/EmbededTest.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("x.EmbededTest2").getRelations().size());
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class JavaExpressionCreatorTest extends JavaParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createParser(src);
-		    parser.parse();
+		    FileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity entity = (entityRepo.getEntity("A.foo"));
@@ -40,8 +40,8 @@ public class JavaExpressionCreatorTest extends JavaParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createParser(src);
-		    parser.parse();
+		    FileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity entity = (entityRepo.getEntity("X.foo"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class JavaFileImportTest extends JavaParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createParser(src);
-		    parser.parse();
+		    FileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    TypeEntity type = (TypeEntity)(entityRepo.getEntity("a.Importing"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -16,8 +16,8 @@ public class JavaGenericTypeTest extends JavaParserTest{
 	@Test
 	public void test_GenericTypeShouldBeIdentified() throws IOException {
         String src = "./src/test/resources/java-code-examples/GenericTypeTest.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("x.GenericTypeTest.v"),
         		DependencyType.PARAMETER, "x.Parent2.Enum");
@@ -26,8 +26,8 @@ public class JavaGenericTypeTest extends JavaParserTest{
 	@Test
 	public void test_GenericTypeEmbededShouldBeIdentified() throws IOException {
         String src = "./src/test/resources/java-code-examples/GenericTypeEmbededTest.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest"),
         		DependencyType.CONTAIN, "MyHashMap");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -16,8 +16,8 @@ public class JavaInternalClassTest extends JavaParserTest{
 	@Test
 	public void test_parameter() throws IOException {
         String src = "./src/test/resources/java-code-examples/InternalClass.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         assertNotNull(entityRepo.getEntity("a.InternalClass.Internal"));
 	}
 

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -16,8 +16,8 @@ public class JavaParameterParserTest extends JavaParserTest {
 	@Test
 	public void test_parameter() throws IOException {
         String src = "./src/test/resources/java-code-examples/FunctionParameters.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(4,entityRepo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -14,16 +14,16 @@ public class JavaParseErrorFileTest extends JavaParserTest{
 	@Test
 	public void test_incomplete_file_should_not_stop_process() throws IOException {
         String src = "./src/test/resources/java-code-examples/IncompleteFile.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
 	}
 	
 	@Test
 	public void test_should_resolve_types() throws IOException {
         String src = "./src/test/resources/java-code-examples/EclipseTestBase_No_ResponseDuirngTypeResolve.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
 	}
 	

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -8,7 +8,7 @@ public abstract class JavaParserTest  extends ParserTest{
 		super.init();
 	}
 	
-	public JavaFileParser createParser(String src) {
-		return new JavaFileParser(src,entityRepo, bindingResolver);
+	public JavaFileParser createParser() {
+		return new JavaFileParser(entityRepo, bindingResolver);
 	}
 }

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -16,11 +16,11 @@ public class JavaTypeInferUnderSamePackageTest extends JavaParserTest{
 	@Test
 	public void test_GenericTypeShouldBeIdentified() throws IOException {
         String src = "./src/test/resources/java-code-examples/TypeInferUnderSamePackageA.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         src = "./src/test/resources/java-code-examples/TypeInferUnderSamePackageB.java";
-        parser = createParser(src);
-        parser.parse();
+        parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("x.TypeInferUnderSamePackageA").getRelations().size());
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -21,8 +21,8 @@ public class JavaVarResolveTest extends JavaParserTest{
 	@Test
 	public void test_field_var_should_be_parsed() throws IOException {
         String src = "./src/test/resources/java-code-examples/FieldVar.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         Entity classEntity = entityRepo.getEntity("FieldVar");
         assertEquals(3,((TypeEntity)classEntity).getVars().size()); 
@@ -31,8 +31,8 @@ public class JavaVarResolveTest extends JavaParserTest{
 	@Test
 	public void test_local_var_should_be_parsed() throws IOException {
         String src = "./src/test/resources/java-code-examples/LocalVar.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(1,((TypeEntity)entityRepo.getEntity("LocalVar")).getVars().size());
         assertEquals(1,((FunctionEntity)entityRepo.getEntity("LocalVar.foo")).getVars().size());
@@ -41,8 +41,8 @@ public class JavaVarResolveTest extends JavaParserTest{
 	@Test
 	public void test_local_var_type_could_be_inferred() throws IOException {
         String src = "./src/test/resources/java-code-examples/LocalVarInferExample.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         ContainerEntity e = (ContainerEntity) entityRepo.getEntity("LocalVarInferExample.setExample");
         this.assertContainsRelation(e, DependencyType.CONTAIN, "MyInteger");
@@ -51,8 +51,8 @@ public class JavaVarResolveTest extends JavaParserTest{
 	@Test
 	public void test_field_access_could_be_inferred() throws IOException {
         String src = "./src/test/resources/java-code-examples/ComplexExpressionExample.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         Entity e = entityRepo.getEntity("test.ComplexExpressionExample.setExample");
         this.assertContainsRelation(e, DependencyType.PARAMETER, "test.ClassA");
@@ -71,8 +71,8 @@ public class JavaVarResolveTest extends JavaParserTest{
 	@Test
 	public void test_long_static_function_should_be_inferred() throws IOException {
         String src = "./src/test/resources/java-code-examples/LongExpressionWithAbsolutePath.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(5,entityRepo.getEntity("x.LongExpressionWithAbsolutePath.setExample").getRelations().size());
 	}
@@ -82,8 +82,8 @@ public class JavaVarResolveTest extends JavaParserTest{
 	@Test
 	public void test_call_should_be_referred() throws IOException {
         String src = "./src/test/resources/java-code-examples/ExpressionCallTest.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         assertEquals(10,entityRepo.getEntity("ValidateAll.validate").getRelations().size());
 	}
@@ -91,8 +91,8 @@ public class JavaVarResolveTest extends JavaParserTest{
 	@Test
 	public void test_could_detect_type_argument_in_field() throws IOException {
         String src = "./src/test/resources/java-code-examples/TypeArgument.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         resolveAllBindings();
         this.assertContainsRelation(entityRepo.getEntity("JDepObject.cells"),DependencyType.PARAMETER, "JCellObject");
 	}

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -1,14 +1,13 @@
 package depends.extractor.java;
 
-import static org.junit.Assert.assertEquals;
+import depends.extractor.UnsolvedBindings;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.IOException;
 import java.util.Set;
 
-import org.junit.Before;
-import org.junit.Test;
-
-import depends.extractor.UnsolvedBindings;
+import static org.junit.Assert.assertEquals;
 
 public class UnsolvedSymbolsTest extends JavaParserTest {
 	@Before
@@ -18,8 +17,8 @@ public class UnsolvedSymbolsTest extends JavaParserTest {
 	@Test
 	public void test_missing_import() throws IOException {
         String src = "./src/test/resources/java-code-examples/UnsolvedSymbols/MissingImport.java";
-        JavaFileParser parser = createParser(src);
-        parser.parse();
+        JavaFileParser parser = createParser();
+        parser.parse(src);
         Set<UnsolvedBindings> missing = resolveAllBindings();
         assertEquals(1,missing.size());
         assertEquals("a.b",missing.iterator().next().getRawName());

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -19,8 +19,8 @@ public class DependencyTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
@@ -34,8 +34,8 @@ public class DependencyTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    assertFalse(entityRepo.getEntity("parent-group.a-parent_1.0_") instanceof MultiDeclareEntities);
@@ -40,8 +40,8 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -19,8 +19,8 @@ public class DependencyWithPropertiesTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
@@ -34,8 +34,8 @@ public class DependencyWithPropertiesTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -19,8 +19,8 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomDependency, "a-dep-group.a-artifact_0.2_");
@@ -34,8 +34,8 @@ public class DependencyWithoutVersionTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("testgroup.test_1.0_"), DependencyType.PomPlugin, "aplugins.aplugin_0.1_");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -20,8 +20,8 @@ public class EntityExtractTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         assertEquals(0,entityRepo.getEntity("org.log4j-test.log4j_1.2.12_").getRelations().size());
@@ -35,8 +35,8 @@ public class EntityExtractTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         assertNotNull(entityRepo.getEntity("org.apache.maven.surefire.surefire-junit4_2.12.4_"));
@@ -49,8 +49,8 @@ public class EntityExtractTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         PomArtifactEntity entity = (PomArtifactEntity)(entityRepo.getEntity("properties-test.test_1_"));
@@ -71,8 +71,8 @@ public class EntityExtractTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         PomArtifactEntity entity = (PomArtifactEntity)(entityRepo.getEntity("properties-test.test_1_"));
@@ -91,8 +91,8 @@ public class EntityExtractTest extends MavenParserTest{
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PomFileParser parser = createParser(src);
-		    parser.parse();
+		    PomFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         PomArtifactEntity entity = (PomArtifactEntity)(entityRepo.getEntity("properties-test.test_1_"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -17,8 +17,8 @@ public abstract class MavenParserTest extends ParserTest{
 		super.init();
     }
 	
-	public PomFileParser createParser(String src) {
-		return (PomFileParser) langProcessor.createFileParser(src);
+	public PomFileParser createParser() {
+		return (PomFileParser) langProcessor.createFileParser();
 	}
 
 }

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -25,8 +25,8 @@ public class PythonClassTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         assertNotNull(entityRepo.getEntity(withPackageName(srcs[0],"Foo")));
@@ -39,8 +39,8 @@ public class PythonClassTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    TypeEntity type = (TypeEntity) entityRepo.getEntity(withPackageName(srcs[0],"Foo"));
@@ -54,8 +54,8 @@ public class PythonClassTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    TypeEntity type = (TypeEntity) entityRepo.getEntity(withPackageName(srcs[0],"Bar"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -25,8 +25,8 @@ public class PythonDecoratorTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class PythonFuncCallTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));
@@ -38,8 +38,8 @@ public class PythonFuncCallTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"baz"));
@@ -53,8 +53,8 @@ public class PythonFuncCallTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 
 	    resolveAllBindings();

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -24,8 +24,8 @@ public class PythonFunctionTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         assertNotNull(entityRepo.getEntity(withPackageName(srcs[0],"foo")));
@@ -38,8 +38,8 @@ public class PythonFunctionTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -22,8 +22,8 @@ public class PythonGlobalVarTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings(true);
         Entity foo = entityRepo.getEntity(withPackageName(srcs[0],"foo"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -26,8 +26,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[1]));
@@ -43,8 +43,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
@@ -60,8 +60,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
@@ -77,8 +77,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
@@ -95,8 +95,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
@@ -113,8 +113,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
@@ -132,8 +132,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
@@ -148,8 +148,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	}
@@ -163,8 +163,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
@@ -179,8 +179,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	   
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 		this.assertContainsRelation(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
@@ -195,8 +195,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	   
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"test"));
@@ -214,8 +214,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	   
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    
@@ -236,8 +236,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	   
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    
@@ -257,8 +257,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	   
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"bar"));
@@ -273,8 +273,8 @@ public class PythonImportTest extends PythonParserTest {
 	    	    };
 	   
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FileEntity f = (FileEntity) entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class PythonObjectCreationTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"foo"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"t1"));
@@ -39,8 +39,8 @@ public class PythonObjectThrowReturn extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    PythonFileParser parser = createParser(src);
-		    parser.parse();
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"t2"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -27,8 +27,8 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
@@ -47,8 +47,8 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");
@@ -66,8 +66,8 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test2");
@@ -86,8 +86,8 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    String name = withPackageName(srcs[0],"test");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -19,13 +19,13 @@ public abstract class PythonParserTest extends ParserTest implements ParserCreat
 		super.init(true);
     }
 	
-	public PythonFileParser createParser(String src) {
-		return (PythonFileParser)createFileParser(src);
+	public PythonFileParser createParser() {
+		return (PythonFileParser)createFileParser();
 	}
 	
 	@Override
-	public FileParser createFileParser(String src) {
-		return  langProcessor.createFileParser(FileUtil.uniqFilePath(src));
+	public FileParser createFileParser() {
+		return  langProcessor.createFileParser();
 	}
 	
 	protected String withPackageName(String theFile,String entityName) {

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -24,8 +24,8 @@ public class SelfShouldBeThisTypeTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity(withPackageName(srcs[0],"A.foo")));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity(withPackageName(srcs[0],"bar")));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -1,16 +1,15 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
 
 public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	@Before
@@ -25,8 +24,8 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));
@@ -52,8 +51,8 @@ public class RubyAssignedVariableTypeDedudceTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.operator_is_call"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -22,8 +22,8 @@ public class RubyClassMethodcallTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -24,8 +24,8 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
@@ -39,8 +39,8 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
@@ -54,8 +54,8 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    super.assertContainsRelation(entityRepo.getEntity("Cat"), DependencyType.INHERIT, "Animal");
@@ -68,8 +68,8 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    super.assertContainsRelation(entityRepo.getEntity("ZooCat"), DependencyType.INHERIT, "Zoo.Animal");
@@ -82,8 +82,8 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    this.assertContainsRelation(entityRepo.getEntity("Zoo.Cow"), DependencyType.INHERIT, "Zoo.Animal");
@@ -96,8 +96,8 @@ public class RubyInheritTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         assertEquals(1,entityRepo.getEntity("Cat").getRelations().size());

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -20,8 +20,8 @@ public class RubyMixinTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    assertContainsRelation(entityRepo.getEntity("MixedIn"),DependencyType.MIXIN,"ToBeMixin");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class RubyModuleLevelsTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    PackageEntity module = (PackageEntity)(entityRepo.getEntity("A.B"));
 	    assertNotNull(module);

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -22,8 +22,8 @@ public class RubyNameIBindingResolverTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("M1.test"));
@@ -38,8 +38,8 @@ public class RubyNameIBindingResolverTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("M2.M1.test2"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -23,8 +23,8 @@ public class RubyNameTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    PackageEntity module = (PackageEntity)(entityRepo.getEntity("A.B.C"));
 	    assertNotNull(module);

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -20,8 +20,8 @@ public class RubyObjectCreationTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    super.assertContainsRelation(entityRepo.getEntity("T.foo"), DependencyType.CREATE, "M");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -27,8 +27,8 @@ public class RubyParameterTypeDedudceTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -14,8 +14,8 @@ public abstract class RubyParserTest extends ParserTest implements ParserCreator
 		super.init(true);
 	}
 	
-	public FileParser createFileParser(String src) {
-		return new JRubyFileParser(src,entityRepo, new IncludedFileLocator(includePaths()), bindingResolver, this);
+	public FileParser createFileParser() {
+		return new JRubyFileParser(entityRepo, new IncludedFileLocator(includePaths()), bindingResolver, this);
 	}
 
 	private List<String> includePaths() {

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -22,8 +22,8 @@ public class RubyRaiseTypeDedudceTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -22,8 +22,8 @@ public class RubyRequireTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
         File f = new File(srcs[0]);

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -21,8 +21,8 @@ public class RubyReturnTypeDedudceTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("Class.test"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -25,8 +25,8 @@ public class RubySingletonMethodTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    ContainerEntity file = (ContainerEntity)(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
 	    VarEntity var = file.lookupVarLocally("var2");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -22,8 +22,8 @@ public class RubyVCallTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("called_from"));
@@ -37,8 +37,8 @@ public class RubyVCallTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -1,16 +1,15 @@
 package depends.extractor.ruby;
 
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.entity.ContainerEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 import multilang.depends.util.file.FileUtil;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
 
 public class RubyVarInvocationRecordTest extends RubyParserTest {
 	@Before
@@ -25,8 +24,8 @@ public class RubyVarInvocationRecordTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    ContainerEntity file = (ContainerEntity)(entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0])));
 	    VarEntity var = file.lookupVarLocally("var");

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -26,8 +26,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method1"));
 	    assertEquals(1,function.getParameters().size());
@@ -42,8 +42,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_with_local_var"));
 	    assertEquals(1,function.getVars().size());
@@ -58,8 +58,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_with_local_var_2times"));
 	    assertEquals(1,function.getVars().size());
@@ -72,8 +72,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_without_local_var_and_param"));
 	    assertEquals(0,function.getVars().size());
@@ -87,8 +87,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("method_access_file_level_var"));
 	    assertEquals(0,function.getVars().size());
@@ -101,8 +101,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("M.C.method"));
 	    assertEquals(1,function.getVars().size());
@@ -114,8 +114,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("M.C.method2"));
 	    assertEquals(1,function.getVars().size());
@@ -129,8 +129,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    TypeEntity c = (TypeEntity)(entityRepo.getEntity("M.C"));
 	    assertEquals(3,c.getVars().size());
@@ -146,8 +146,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    ContainerEntity c = (ContainerEntity)(entityRepo.getEntity("Block"));
 	    assertEquals(1,c.getVars().size());
@@ -161,8 +161,8 @@ public class RubyVarTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    ContainerEntity c = (ContainerEntity)(entityRepo.getEntity(EntityRepo.GLOBAL_SCOPE_NAME));
 	    assertEquals(1,c.getVars().size());

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -1,13 +1,12 @@
 package depends.extractor.ruby;
 
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 import depends.extractor.FileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
 
 public class RubyVariableCallTest extends RubyParserTest {
 	@Before
@@ -22,8 +21,8 @@ public class RubyVariableCallTest extends RubyParserTest {
 	    	    };
 	    
 	    for (String src:srcs) {
-		    FileParser parser = createFileParser(src);
-		    parser.parse();
+		    FileParser parser = createFileParser();
+		    parser.parse(src);
 	    }
 	    resolveAllBindings();
 	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity("test"));

4286870bf9580fb659721a3d06a6197f730a9761
@@ -50,7 +50,9 @@ public interface EntityRepo extends IdGenerator {
 
 	Iterator<Entity> sortedFileIterator();
 
-	void addFile(FileEntity currentFileEntity);
-
     void clear();
+
+	FileEntity getFileEntity(String fileFullPath);
+
+	void completeFile(String fileFullPath);
 }

4286870bf9580fb659721a3d06a6197f730a9761
@@ -4,6 +4,7 @@ import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.GenericName;
 import depends.entity.MultiDeclareEntities;
+import multilang.depends.util.file.FileUtil;
 
 import java.util.*;
 import java.util.Map.Entry;
@@ -98,15 +99,34 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 		return allFileEntitiesByOrder.iterator();
 	}
 
-	@Override
-	public void addFile(FileEntity fileEntity) {
-		allFileEntitiesByOrder.add(fileEntity);
-	}
-
 	@Override
 	public void clear() {
 		allEntieisByName.clear();
 		allEntitiesById.clear();
 		allFileEntitiesByOrder.clear();
 	}
+
+	@Override
+	public FileEntity getFileEntity(String fileFullPath) {
+		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
+		Entity entity = this.getEntity(fileFullPath);
+		if (entity ==null) return null;
+		if (entity instanceof FileEntity) return (FileEntity) entity;
+		if (entity instanceof  MultiDeclareEntities){
+			MultiDeclareEntities multiDeclare = (MultiDeclareEntities) entity;
+			for (Entity theEntity: multiDeclare.getEntities()){
+				if (theEntity instanceof FileEntity){
+					return (FileEntity) theEntity;
+				}
+			}
+		}
+		return null;
+	}
+
+	@Override
+	public void completeFile(String fileFullPath) {
+		FileEntity fileEntity = getFileEntity(fileFullPath);
+		fileEntity.cacheAllExpressions();
+		allFileEntitiesByOrder.add(fileEntity);
+	}
 }

4286870bf9580fb659721a3d06a6197f730a9761
@@ -160,32 +160,30 @@ abstract public class AbstractLangProcessor {
 			@Override
 			public void visit(File file) {
 				String fileFullPath = file.getAbsolutePath();
-				fileFullPath = FileUtil.uniqFilePath(fileFullPath);
 				if (!fileFullPath.startsWith(inputSrcPath)) {
 					return;
 				}
-				if (isPhase2Files(fileFullPath)) {
-
-				} else {
-					parseFile(fileFullPath);
-				}
+				parseFile(fileFullPath, phase2Files);
 			}
 
 		});
 		fileTransversal.extensionFilter(this.fileSuffixes());
 		fileTransversal.travers(this.inputSrcPath);
 		for (String f : phase2Files) {
-			parseFile(f);
+			parseFile(f, phase2Files);
 		}
 		System.out.println("all files procceed successfully...");
 
 	}
 
-	protected void parseFile(String fileFullPath) {
+	protected void parseFile(String fileFullPath, Set<String> phase2Files) {
 		FileParser fileParser = createFileParser();
 		try {
-			System.out.println("parsing " + fileFullPath + "...");
-			fileParser.parse(FileUtil.uniqFilePath(fileFullPath));
+			if (fileParser.isPhase2Files(fileFullPath)){
+				phase2Files.add(fileFullPath);
+			}else {
+				fileParser.parse(fileFullPath);
+			}
 		} catch (IOException e) {
 			e.printStackTrace();
 		} catch (Exception e) {
@@ -194,10 +192,6 @@ abstract public class AbstractLangProcessor {
 		}
 	}
 
-	protected boolean isPhase2Files(String fileFullPath) {
-		return false;
-	}
-
 	public List<String> includePaths() {
 		if (this.includePaths ==null) {
 			this.includePaths = buildIncludePath();

4286870bf9580fb659721a3d06a6197f730a9761
@@ -57,10 +57,6 @@ public abstract class HandlerContext {
 		return currentFileEntity;
 	}
 
-	public void done() {
-		entityRepo.addFile(this.currentFile());
-	}
-
 	public TypeEntity foundNewType(GenericName name, Integer startLine) {
 		TypeEntity currentTypeEntity = new TypeEntity(name, this.latestValidContainer(),
 				idGenerator.generateId());

4286870bf9580fb659721a3d06a6197f730a9761
@@ -97,13 +97,4 @@ public class CppProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(IMPLLINK);
 		return depedencyTypes;
 	}
-
-	@Override
-	protected boolean isPhase2Files(String fileFullPath) {
-		if (fileFullPath.endsWith(".h") || fileFullPath.endsWith(".hh") || fileFullPath.endsWith(".hpp")
-				|| fileFullPath.endsWith(".hxx"))
-			return true;
-		return false;
-	}
-
 }

4286870bf9580fb659721a3d06a6197f730a9761
@@ -334,9 +334,4 @@ public class JavaListener extends JavaParserBaseListener {
 			context.currentType().addTypeParameter(GenericName.build(typeParam.IDENTIFIER().getText()));
 		}
 	}
-
-	public void done() {
-		context.done();
-	}
-
 }

4286870bf9580fb659721a3d06a6197f730a9761
@@ -3,7 +3,6 @@ package depends.extractor.kotlin;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.relations.IBindingResolver;
-import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;
 import org.antlr.v4.runtime.CommonTokenStream;
@@ -12,11 +11,10 @@ import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
 import java.io.IOException;
 
-public class KotlinFileParser implements FileParser {
+public class KotlinFileParser extends FileParser {
 
 	@Override
-	public void parse(String fileFullPath) throws IOException {
-		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
+	public void parseFile(String fileFullPath) throws IOException {
 		CharStream input = CharStreams.fromFileName(fileFullPath);
 		Lexer lexer = new KotlinLexer(input);
 		CommonTokenStream tokens = new CommonTokenStream(lexer);

4286870bf9580fb659721a3d06a6197f730a9761
@@ -368,7 +368,4 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		expressionUsage.stopExpr();
 		super.exitAssert_stmt(ctx);
 	}
-	public void done() {
-		context.done();
-	}
 }

4286870bf9580fb659721a3d06a6197f730a9761
@@ -1,12 +1,10 @@
 package depends.extractor.python.union;
 
-import depends.entity.Entity;
-import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
+import depends.extractor.IncludedFileLocator;
 import depends.extractor.python.PythonLexer;
 import depends.extractor.python.PythonParser;
-import depends.extractor.IncludedFileLocator;
 import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.CharStream;
@@ -17,8 +15,7 @@ import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
 import java.io.IOException;
 
-public class PythonFileParser implements FileParser {
-	private EntityRepo entityRepo;
+public class PythonFileParser extends FileParser {
 	private IBindingResolver bindingResolver;
 	private IncludedFileLocator includeFileLocator;
 	private PythonProcessor processor;
@@ -32,13 +29,8 @@ public class PythonFileParser implements FileParser {
 	}
 
 	@Override
-	public void parse(String fileFullPath) throws IOException {
+	public void parseFile(String fileFullPath) throws IOException {
 		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
-		/** If file already exist, skip it */
-		Entity fileEntity = entityRepo.getEntity(fileFullPath);
-		if (fileEntity!=null && fileEntity instanceof FileEntity) {
-			return;
-		}
         CharStream input = CharStreams.fromFileName(fileFullPath);
         Lexer lexer = new PythonLexer(input);
         CommonTokenStream tokens = new CommonTokenStream(lexer);
@@ -48,9 +40,6 @@ public class PythonFileParser implements FileParser {
         PythonCodeListener bridge = new PythonCodeListener(fileFullPath, entityRepo, bindingResolver, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();
 	    walker.walk(bridge, parser.file_input());
-		fileEntity = entityRepo.getEntity(fileFullPath);
-		((FileEntity)fileEntity).cacheAllExpressions();
-		bridge.done();
 	}
 
 }

4286870bf9580fb659721a3d06a6197f730a9761
@@ -24,14 +24,11 @@ SOFTWARE.
 
 package depends.extractor.ruby.jruby;
 
-import depends.entity.Entity;
-import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.IncludedFileLocator;
 import depends.extractor.ParserCreator;
 import depends.relations.IBindingResolver;
-import multilang.depends.util.file.FileUtil;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CharStreams;
 import org.jrubyparser.CompatVersion;
@@ -41,8 +38,7 @@ import org.jrubyparser.parser.ParserConfiguration;
 
 import java.io.IOException;
 import java.io.StringReader;
-public class JRubyFileParser implements FileParser {
-	private EntityRepo entityRepo;
+public class JRubyFileParser extends FileParser {
 	private IncludedFileLocator includesFileLocator;
 	private IBindingResolver bindingResolver;
 	private ParserCreator parserCreator;
@@ -58,26 +54,16 @@ public class JRubyFileParser implements FileParser {
 
 	@SuppressWarnings("unchecked")
 	@Override
-	public void parse(String fileFullPath) throws IOException {
-		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
-		/** If file already exist, skip it */
-		Entity fileEntity = entityRepo.getEntity(fileFullPath);
-		if (fileEntity!=null && fileEntity instanceof FileEntity) {
-			return;
-		}
-		
+	public void parseFile(String fileFullPath) throws IOException {
         CharStream input = CharStreams.fromFileName(fileFullPath);
 		Parser rubyParser = new Parser();
 		StringReader in = new StringReader(input.toString());
 		CompatVersion version = CompatVersion.RUBY2_3;
 		ParserConfiguration config = new ParserConfiguration(0, version);
 		try {
-			Node node = rubyParser.parse("<code>", in, config);
+			Node node = rubyParser.parse(fileFullPath, in, config);
 			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator, bindingResolver,parserCreator);
 			node.accept(parser);
-			fileEntity = entityRepo.getEntity(fileFullPath);
-			((FileEntity)fileEntity).cacheAllExpressions();
-			parser.done();
 		}catch(Exception e) {
 			System.err.println("parsing error in "+fileFullPath);
 		}

4286870bf9580fb659721a3d06a6197f730a9761
@@ -277,7 +277,4 @@ public class JRubyVisitor extends NoopVisitor {
 		return super.visit(node);
 	}
 
-	public void done() {
-		context.done();
-	}
 }

4286870bf9580fb659721a3d06a6197f730a9761
@@ -37,7 +37,7 @@ public class ParseErrorTest extends CppParserTest{
 
 			Map<String, String> macroMap = new HashMap<>();
 			macroMap.put("AP_DECLARE(x)","x");
-			parser.parse(src,true,macroMap);
+			parser.parse(src,macroMap);
 		}
 		resolveAllBindings();
 	}

c1c275b9688258eac09c28091e7961252d9ae96c
@@ -126,7 +126,10 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	@Override
 	public void completeFile(String fileFullPath) {
 		FileEntity fileEntity = getFileEntity(fileFullPath);
-		fileEntity.cacheAllExpressions();
-		allFileEntitiesByOrder.add(fileEntity);
+		// in case of parse error(throw exception), the file entity may not exists
+		if (fileEntity!=null) {
+			fileEntity.cacheAllExpressions();
+			allFileEntitiesByOrder.add(fileEntity);
+		}
 	}
 }

c1c275b9688258eac09c28091e7961252d9ae96c
@@ -310,8 +310,13 @@ public abstract class HandlerContext {
 	private VarEntity getVarInLocalFile(ContainerEntity container, GenericName varName) {
 		Entity entity = bindingResolver.resolveName(container, varName, false);
 		if (entity ==null ) return null;
-		if (!entity.getAncestorOfType(FileEntity.class).equals(currentFileEntity)) return null;
-		if (entity instanceof VarEntity) return (VarEntity)entity;
+		Entity fileEntity = entity.getAncestorOfType(FileEntity.class);
+		if (fileEntity ==null ){
+			//may not exist in fileEntity, for example global vars
+		}else{
+			if (!fileEntity.equals(currentFileEntity)) return null;
+			if (entity instanceof VarEntity) return (VarEntity)entity;
+		}
 		return null;
 	}
 

c1c275b9688258eac09c28091e7961252d9ae96c
@@ -12,9 +12,8 @@ import org.antlr.v4.runtime.tree.ParseTreeWalker;
 import java.io.IOException;
 
 public class KotlinFileParser extends FileParser {
-
 	@Override
-	public void parseFile(String fileFullPath) throws IOException {
+	protected void parseFile(String fileFullPath) throws IOException {
 		CharStream input = CharStreams.fromFileName(fileFullPath);
 		Lexer lexer = new KotlinLexer(input);
 		CommonTokenStream tokens = new CommonTokenStream(lexer);
@@ -24,7 +23,6 @@ public class KotlinFileParser extends FileParser {
 		walker.walk(bridge, parser.kotlinFile());
 	}
 	
-	private EntityRepo entityRepo;
 	private IBindingResolver bindingResolver;
 	public KotlinFileParser(EntityRepo entityRepo, IBindingResolver bindingResolver) {
         this.entityRepo = entityRepo;

c1c275b9688258eac09c28091e7961252d9ae96c
@@ -29,7 +29,7 @@ public class PythonFileParser extends FileParser {
 	}
 
 	@Override
-	public void parseFile(String fileFullPath) throws IOException {
+	protected void parseFile(String fileFullPath) throws IOException {
 		fileFullPath = FileUtil.uniqFilePath(fileFullPath);
         CharStream input = CharStreams.fromFileName(fileFullPath);
         Lexer lexer = new PythonLexer(input);

c1c275b9688258eac09c28091e7961252d9ae96c
@@ -34,6 +34,7 @@ import org.antlr.v4.runtime.CharStreams;
 import org.jrubyparser.CompatVersion;
 import org.jrubyparser.Parser;
 import org.jrubyparser.ast.Node;
+import org.jrubyparser.lexer.SyntaxException;
 import org.jrubyparser.parser.ParserConfiguration;
 
 import java.io.IOException;
@@ -54,7 +55,7 @@ public class JRubyFileParser extends FileParser {
 
 	@SuppressWarnings("unchecked")
 	@Override
-	public void parseFile(String fileFullPath) throws IOException {
+	protected void parseFile(String fileFullPath) throws IOException {
         CharStream input = CharStreams.fromFileName(fileFullPath);
 		Parser rubyParser = new Parser();
 		StringReader in = new StringReader(input.toString());
@@ -64,8 +65,10 @@ public class JRubyFileParser extends FileParser {
 			Node node = rubyParser.parse(fileFullPath, in, config);
 			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator, bindingResolver,parserCreator);
 			node.accept(parser);
-		}catch(Exception e) {
-			System.err.println("parsing error in "+fileFullPath);
+		}catch(SyntaxException e) {
+			System.out.println("parsing error in "+fileFullPath + "(" + e.getMessage() +")");
+		}catch (Exception e){
+			e.printStackTrace();
 		}
 	}
 

75f07ae8c185ee0e89f6defaa16f80f7bcd930e3
@@ -66,7 +66,7 @@ public class JRubyFileParser extends FileParser {
 			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator, bindingResolver,parserCreator);
 			node.accept(parser);
 		}catch(SyntaxException e) {
-			System.out.println("parsing error in "+fileFullPath + "(" + e.getMessage() +")");
+			System.out.println("parsing error in "+e.getPosition()  + "(" + e.getMessage() + ")");
 		}catch (Exception e){
 			e.printStackTrace();
 		}

75f07ae8c185ee0e89f6defaa16f80f7bcd930e3
@@ -24,17 +24,17 @@ SOFTWARE.
 
 package depends.format.detail;
 
-import java.io.FileNotFoundException;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Collection;
-
 import depends.format.AbstractFormatDependencyDumper;
 import depends.matrix.core.DependencyDetail;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.core.DependencyPair;
 import depends.matrix.core.DependencyValue;
 
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+
 public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDumper{
 	ArrayList<String> files;
 	@Override
@@ -67,7 +67,7 @@ public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDu
         	writer.println("======="+files.get(src) + " -> " + files.get(dst) + "=========");
         	for (DependencyValue dependency:dependencyPair.getDependencies()) {
         		for (DependencyDetail item:dependency.getDetails()) {
-                	writer.println("["+dependency.getType()+"]"+item);
+                	writer.println("["+dependency.getType()+"]"+item.getSrc() + "->" + item.getDest());
         		}
         	}
         }		

7dfb555a4175123524018333f8da81e64d558fa3
@@ -59,7 +59,7 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitModuleNode(ModuleNode node) {
 		String name = helper.getName(node.getCPath());
-		context.foundNamespace(name,node.getPosition().getStartLine());
+		context.foundNamespace(name,node.getPosition().getStartLine()+1);
 		super.visitModuleNode(node);
 		context.exitLastedEntity();
 		return null;
@@ -67,7 +67,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitClassNode(ClassNode node) {
-		TypeEntity type = context.foundNewType(helper.getName(node.getCPath()),node.getPosition().getStartLine());
+		TypeEntity type = context.foundNewType(helper.getName(node.getCPath()),node.getPosition().getStartLine()+1);
 		Node superNode = node.getSuper();
 		
 		if (superNode instanceof ConstNode ||
@@ -96,7 +96,7 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitFCallNode(FCallNode node) {
 		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
-		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine()+1);
 		return super.visitFCallNode(node);
 	}
 
@@ -121,7 +121,7 @@ public class JRubyVisitor extends NoopVisitor {
 		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
 		addCallToReceiverVar(node, fname);
-		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine()+1);
 		return super.visitCallNode(node);
 	}
 
@@ -142,7 +142,7 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitUnaryCallNode(UnaryCallNode node) {
 		String fname = helper.getName(node);
 		Collection<String> params = new ArrayList<>();
-		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine()+1);
 		return super.visitUnaryCallNode(node);
 	}
 
@@ -156,8 +156,8 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDefnNode(DefnNode node) {
-		FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine());
-		method.setLine(node.getPosition().getStartLine());
+		FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine()+1);
+		method.setLine(node.getPosition().getStartLine()+1);
 
 		super.visitDefnNode(node);
 		context.exitLastedEntity();
@@ -174,8 +174,8 @@ public class JRubyVisitor extends NoopVisitor {
 			String className = ((INameNode) varNode).getName();
 			Entity entity = context.foundEntityWithName(GenericName.build(className));
 			if (entity != null && entity instanceof ContainerEntity) {
-				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) entity), node.getName(),node.getPosition().getStartLine());
-				method.setLine(node.getPosition().getStartLine());
+				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) entity), node.getName(),node.getPosition().getStartLine()+1);
+				method.setLine(node.getPosition().getStartLine()+1);
 				handled = true;
 			}
 
@@ -183,16 +183,16 @@ public class JRubyVisitor extends NoopVisitor {
 			String varName = ((INameNode) varNode).getName();
 			Entity var = context.foundEntityWithName(GenericName.build(varName));
 			if (var != null && var instanceof ContainerEntity) {
-				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) var), node.getName(),node.getPosition().getStartLine());
-				method.setLine(node.getPosition().getStartLine());
+				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) var), node.getName(),node.getPosition().getStartLine()+1);
+				method.setLine(node.getPosition().getStartLine()+1);
 				handled = true;
 			}
 		} 
 
 		if (!handled) {
 			// fallback to add it to last container
-			FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine());
-			method.setLine(node.getPosition().getStartLine());
+			FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine()+1);
+			method.setLine(node.getPosition().getStartLine()+1);
 		}
 		super.visitDefsNode(node);
 		context.exitLastedEntity();
@@ -201,31 +201,31 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitGlobalVarNode(GlobalVarNode node) {
-		context.foundVarDefinition(context.globalScope(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.globalScope(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitGlobalVarNode(node);
 	}
 
 	@Override
 	public Object visitInstVarNode(InstVarNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitInstVarNode(node);
 	}
 
 	@Override
 	public Object visitClassVarAsgnNode(ClassVarAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitClassVarAsgnNode(node);
 	}
 
 	@Override
 	public Object visitClassVarDeclNode(ClassVarDeclNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitClassVarDeclNode(node);
 	}
 
 	@Override
 	public Object visitClassVarNode(ClassVarNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitClassVarNode(node);
 	}
 
@@ -236,25 +236,26 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDVarNode(DVarNode node) {
-		context.foundVarDefinition(context.lastContainer(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.lastContainer(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitDVarNode(node);
 	}
 
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
+		expressionUsage.foundExpression(node.getValue());
 		return super.visitDAsgnNode(node);
 	}
 
 	@Override
 	public Object visitGlobalAsgnNode(GlobalAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitGlobalAsgnNode(node);
 	}
 
 	@Override
 	public Object visitInstAsgnNode(InstAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitInstAsgnNode(node);
 	}
 
@@ -267,7 +268,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitLocalAsgnNode(LocalAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitLocalAsgnNode(node);
 	}
 

8e144f23fa61ee9e6853a3dbc979d774b1da01b9
@@ -138,8 +138,6 @@ abstract public class AbstractLangProcessor {
 	}
 
 	/**
-	 * 
-	 * @param callAsImpl
 	 * @return unsolved bindings
 	 */
 	public void resolveBindings() {
@@ -233,7 +231,18 @@ abstract public class AbstractLangProcessor {
 		return relation;
 	}
 
+	/**
+	 * Whether to resolve expression immediately during parse
+	 * @return
+	 */
 	public boolean isEagerExpressionResolve(){
 		return false;
 	}
+
+	/**
+	 * Call as Impl:
+	 *     implicit call (for example polymorphic in cpp)
+	 * @return
+	 */
+	public boolean supportCallAsImpl(){return false;};
 }

8e144f23fa61ee9e6853a3dbc979d774b1da01b9
@@ -97,4 +97,9 @@ public class CppProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(IMPLLINK);
 		return depedencyTypes;
 	}
+
+	@Override
+	public boolean supportCallAsImpl() {
+		return true;
+	}
 }

8e144f23fa61ee9e6853a3dbc979d774b1da01b9
@@ -52,4 +52,9 @@ public abstract class BasePythonProcessor extends AbstractLangProcessor{
 		depedencyTypes.add(IMPLLINK);
 		return depedencyTypes;
 	}
+
+	@Override
+	public boolean supportCallAsImpl() {
+		return true;
+	}
 }

8e144f23fa61ee9e6853a3dbc979d774b1da01b9
@@ -26,6 +26,7 @@ package depends.relations;
 import depends.entity.*;
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
+import depends.extractor.AbstractLangProcessor;
 import depends.extractor.UnsolvedBindings;
 import depends.extractor.empty.EmptyBuiltInType;
 import depends.importtypes.Import;
@@ -47,17 +48,18 @@ public class BindingResolver implements IBindingResolver{
 	private boolean isDuckTypingDeduce = true;
 	private static Logger logger = LoggerFactory.getLogger(IBindingResolver.class);
 
-	public BindingResolver(EntityRepo repo, ImportLookupStrategy importLookupStrategy, BuiltInType buildInTypeManager,
+	public BindingResolver(AbstractLangProcessor langProcessor,
 							boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
-		this.repo = repo;
-		this.importLookupStrategy = importLookupStrategy;
-		this.buildInTypeManager = buildInTypeManager;
+		this.repo = langProcessor.getEntityRepo();
+		this.importLookupStrategy = langProcessor.getImportLookupStrategy();
+		this.buildInTypeManager = langProcessor.getBuiltInType();
 		this.isCollectUnsolvedBindings = isCollectUnsolvedBindings;
 		this.isDuckTypingDeduce = isDuckTypingDeduce;
 		unsolvedSymbols= new HashSet<>();
 		importLookupStrategy.setBindingResolver(this);
 	}
 
+
 	@Override
 	public  Set<UnsolvedBindings> resolveAllBindings(boolean isEagerExpressionResolve) {
 		System.out.println("Resolve type bindings....");

8e144f23fa61ee9e6853a3dbc979d774b1da01b9
@@ -41,11 +41,11 @@ public class RelationCounter {
 	private boolean callAsImpl;
 	private AbstractLangProcessor langProcessor;
 
-	public RelationCounter(EntityRepo repo, boolean callAsImpl, AbstractLangProcessor langProcessor, IBindingResolver bindingResolver) {
+	public RelationCounter(EntityRepo repo, AbstractLangProcessor langProcessor, IBindingResolver bindingResolver) {
 		this.entities = repo.getFileEntities();
 		this.bindingResolver = bindingResolver;
 		this.repo = repo;
-		this.callAsImpl = callAsImpl;
+		this.callAsImpl = langProcessor.supportCallAsImpl();
 		this.langProcessor = langProcessor;
 	}
 	

8e144f23fa61ee9e6853a3dbc979d774b1da01b9
@@ -24,27 +24,27 @@ public abstract class ParserTest {
 
 	protected  void init(){
 		entityRepo = langProcessor.getEntityRepo();
-		bindingResolver = new BindingResolver(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),true,false);
+		bindingResolver = new BindingResolver(langProcessor,true,false);
 		langProcessor.bindingResolver = bindingResolver;
 		TemporaryFile.reset();
 	}
 
 	protected  void init(boolean duckTypingDeduce){
 		entityRepo = langProcessor.getEntityRepo();
-		bindingResolver = new BindingResolver(langProcessor.getEntityRepo(),langProcessor.getImportLookupStrategy(),langProcessor.getBuiltInType(),false,duckTypingDeduce);
+		bindingResolver = new BindingResolver(langProcessor,false,duckTypingDeduce);
 		langProcessor.bindingResolver = bindingResolver;
 		TemporaryFile.reset();
 	}
 
 	public Set<UnsolvedBindings> resolveAllBindings() {
 		Set<UnsolvedBindings> result = bindingResolver.resolveAllBindings(langProcessor.isEagerExpressionResolve());
-		new RelationCounter(entityRepo,false,langProcessor, bindingResolver).computeRelations();
+		new RelationCounter(entityRepo,langProcessor, bindingResolver).computeRelations();
 		return result;
 	}
 
 	protected Set<UnsolvedBindings>  resolveAllBindings(boolean callAsImpl) {
 		Set<UnsolvedBindings> result = bindingResolver.resolveAllBindings(langProcessor.isEagerExpressionResolve());
-		new RelationCounter(entityRepo,callAsImpl,langProcessor, bindingResolver).computeRelations();
+		new RelationCounter(entityRepo,langProcessor, bindingResolver).computeRelations();
 		return result;
 	}
 

42dbac90d8498e69245b6571a8077601008a7310
@@ -70,6 +70,7 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 		String name = stripper.stripFilename(file.getRawName().uniqName());
 		name = filenameWritter.reWrite(name);
 		String functionName = EntityNameBuilder.build(entity);
+		functionName = stripper.stripFilename(functionName);
 		name = name + "("+functionName+")";
 		return name;
 	}

42dbac90d8498e69245b6571a8077601008a7310
@@ -1,16 +1,15 @@
 package depends.format.json;
 
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-
+import depends.format.excel.ExcelXlsxFormatDependencyDumper;
+import depends.matrix.core.DependencyMatrix;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.rules.TemporaryFolder;
 
-import depends.format.excel.ExcelXlsxFormatDependencyDumper;
-import depends.matrix.core.DependencyMatrix;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
 
 public class JsonFormatDependencyDumperTest {
 	DependencyMatrix dependencyMatrix;
@@ -38,7 +37,6 @@ public class JsonFormatDependencyDumperTest {
 		
 		String projectName = "test";
 		String outputDir =  folder.getRoot().getAbsolutePath();
-		outputDir = "/tmp/";
 		JsonFormatDependencyDumper dumper = new JsonFormatDependencyDumper(dependencyMatrix, projectName, outputDir);
 		dumper.output();
 		System.out.println(outputDir+File.separator+"test.json");
@@ -49,7 +47,6 @@ public class JsonFormatDependencyDumperTest {
 	public void testExcel() throws IOException {
 		String projectName = "test";
 		String outputDir =  folder.getRoot().getAbsolutePath();
-		outputDir = "/tmp/";
 		ExcelXlsxFormatDependencyDumper dumper = new ExcelXlsxFormatDependencyDumper(dependencyMatrix, projectName, outputDir);
 		dumper.output();
 		System.out.println(outputDir+File.separator+"test.xlsx");

37e47836910002a4e254fb5f7a5a9e85d3d202ad
@@ -46,7 +46,8 @@ public class DependencyType {
 	public static final String PomParent = "Parent";
 	public static final String PomPlugin = "Plugin";
 	public static final String PomDependency = "Dependency";
-	
+
+	public static final String DuckTypingLabel = "(duck)";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();

37e47836910002a4e254fb5f7a5a9e85d3d202ad
@@ -24,88 +24,24 @@ SOFTWARE.
 
 package depends.generator;
 
-import depends.entity.CandidateTypes;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
-import depends.entity.TypeEntity;
 import depends.entity.repo.EntityRepo;
-import depends.matrix.core.DependencyDetail;
-import depends.matrix.core.DependencyMatrix;
-import depends.matrix.core.LocationInfo;
-import depends.relations.Relation;
-
-import java.util.Iterator;
-import java.util.List;
 
 public class FileDependencyGenerator extends DependencyGenerator{
-	/**
-	 * Build the dependency matrix (without re-mapping file id)
-	 * @param entityRepo which contains entities and relations
-	 * @return the generated dependency matrix
-	 */
 	@Override
-	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
-		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
-		Iterator<Entity> iterator = entityRepo.entityIterator();
-		System.out.println("Start create dependencies matrix....");
-		while(iterator.hasNext()) {
-			Entity entity = iterator.next();
-			if (!entity.inScope()) continue;
-			if (entity instanceof FileEntity){
-				String name = stripper.stripFilename(entity.getDisplayName());
-				name = filenameWritter.reWrite(name);
-        		dependencyMatrix.addNode(name,entity.getId());
-        	}
-        	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
-        	if (fileEntityFrom==-1) continue;
-        	for (Relation relation:entity.getRelations()) {
-        		Entity relatedEntity = relation.getEntity();
-        		if (relatedEntity==null) continue;
-        		if (relatedEntity instanceof CandidateTypes) {
-        			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
-        			for (TypeEntity candidateType:candidateTypes) {
-    	        		if (candidateType.getId()>=0) {
-    	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,candidateType);
-    	        			if (fileEntityTo!=-1) {
-								DependencyDetail detail = buildDescription(entity,candidateType,relation.getFromLine());
-								detail = rewriteDetail(detail);
-								dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
-    	        			}
-    	        		}
-        			}
-        		}else {
-	        		if (relatedEntity.getId()>=0) {
-	        			int fileEntityTo = getFileEntityIdNoException(entityRepo,relatedEntity);
-	        			if (fileEntityTo!=-1) {
-							DependencyDetail detail = buildDescription(entity, relatedEntity, relation.getFromLine());
-							detail = rewriteDetail(detail);
-							dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
-	        			}
-	        		}
-        		}
-        	}
-        }
-		System.out.println("Finish create dependencies matrix....");
-
-		return dependencyMatrix;
+	protected String nameOf(Entity entity) {
+		String name = stripper.stripFilename(entity.getDisplayName());
+		return filenameWritter.reWrite(name);
 	}
 
-	private DependencyDetail rewriteDetail(DependencyDetail detail) {
-		if (detail==null) return null;
-		String srcFile = filenameWritter.reWrite(
-				stripper.stripFilename(detail.getSrc().getFile())
-				);
-		String dstFile = filenameWritter.reWrite(
-				stripper.stripFilename(detail.getDest().getFile()));
-		return new DependencyDetail(
-				new LocationInfo(detail.getSrc().getObject(),
-						srcFile, detail.getSrc().getLineNumber())
-		,
-				new LocationInfo(detail.getDest().getObject(),
-						dstFile, detail.getDest().getLineNumber()));
+	@Override
+	protected boolean outputLevelMatch(Entity entity) {
+		return (entity instanceof FileEntity);
 	}
 
-	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
+	@Override
+	protected int upToOutputLevelEntityId(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null) {
 			return -1;

37e47836910002a4e254fb5f7a5a9e85d3d202ad
@@ -25,47 +25,19 @@ SOFTWARE.
 package depends.generator;
 
 import depends.entity.Entity;
+import depends.entity.EntityNameBuilder;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
-import depends.entity.EntityNameBuilder;
 import depends.entity.repo.EntityRepo;
-import depends.matrix.core.DependencyMatrix;
-import depends.relations.Relation;
-
-import java.util.Iterator;
-import java.util.List;
 
 public class FunctionDependencyGenerator extends DependencyGenerator {
-	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
-		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
-		Iterator<Entity> iterator = entityRepo.entityIterator();
-		while(iterator.hasNext()) {
-			Entity entity = iterator.next();
-			if (!entity.inScope()) continue;
-			if (entity instanceof FunctionEntity) {
-				String name = getFunctionEntityDisplayName((FunctionEntity)entity);
-				dependencyMatrix.addNode(name,entity.getId());
-			}
-			int entityFrom = getFunctionEntityIdNoException(entity);
-			if (entityFrom == -1)
-				continue;
-			for (Relation relation : entity.getRelations()) {
-				Entity relatedEntity = relation.getEntity();
-        		if (relatedEntity==null) continue;
-				if (relatedEntity.getId() >= 0) {
-					int entityTo = getFunctionEntityIdNoException(relation.getEntity());
-					if (entityTo == -1)
-						continue;
-					dependencyMatrix.addDependency(relation.getType(), entityFrom, entityTo, 1,buildDescription(entity,
-							relation.getEntity(),relation.getFromLine()));
-				}
-			}
-		}
-		return dependencyMatrix;
+	@Override
+	protected boolean outputLevelMatch(Entity entity) {
+		return (entity instanceof FunctionEntity);
 	}
 
-
-	private String getFunctionEntityDisplayName(FunctionEntity entity) {
+	@Override
+	protected String nameOf(Entity entity) {
 		FileEntity file = (FileEntity) entity.getAncestorOfType(FileEntity.class);
 		String name = stripper.stripFilename(file.getRawName().uniqName());
 		name = filenameWritter.reWrite(name);
@@ -75,8 +47,8 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 		return name;
 	}
 
-
-	private int getFunctionEntityIdNoException(Entity entity) {
+	@Override
+	protected int upToOutputLevelEntityId(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
 		if (ancestor == null)
 			return -1;

37e47836910002a4e254fb5f7a5a9e85d3d202ad
@@ -26,68 +26,16 @@ package depends.generator;
 
 import depends.entity.*;
 import depends.entity.repo.EntityRepo;
-import depends.matrix.core.DependencyDetail;
-import depends.matrix.core.DependencyMatrix;
-import depends.matrix.core.LocationInfo;
-import depends.relations.Relation;
-
-import java.util.Iterator;
-import java.util.List;
 
 public class StructureDependencyGenerator extends DependencyGenerator{
-	/**
-	 * Build the dependency matrix (without re-mapping file id)
-	 * @param entityRepo which contains entities and relations
-	 * @return the generated dependency matrix
-	 */
 	@Override
-	public DependencyMatrix build(EntityRepo entityRepo,List<String> typeFilter) {
-		DependencyMatrix dependencyMatrix = new DependencyMatrix(typeFilter);
-		Iterator<Entity> iterator = entityRepo.entityIterator();
-		System.out.println("Start create dependencies matrix....");
-		while(iterator.hasNext()) {
-			Entity entity = iterator.next();
-			if (!entity.inScope()) continue;
-			if (isStructureEntityType(entity)){
-				String name = entity.getQualifiedName() + "|" + entity.getClass().getSimpleName().replace("Entity","");
-        		dependencyMatrix.addNode(name,entity.getId());
-        	}
-			
-        	int fileEntityFrom = getStructureEntityIdNoException(entity);
-        	if (fileEntityFrom==-1) continue;
-        	for (Relation relation:entity.getRelations()) {
-        		Entity relatedEntity = relation.getEntity();
-        		if (relatedEntity==null) continue;
-        		if (relatedEntity instanceof CandidateTypes) {
-        			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
-        			for (TypeEntity candidateType:candidateTypes) {
-    	        		if (candidateType.getId()>=0) {
-    	        			int fileEntityTo = getStructureEntityIdNoException(candidateType);
-    	        			if (fileEntityTo!=-1) {
-								DependencyDetail detail = buildDescription(entity,candidateType,relation.getFromLine());
-								dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
-    	        			}
-    	        		}
-        			}
-        		}else {
-	        		if (relatedEntity.getId()>=0) {
-	        			int fileEntityTo = getStructureEntityIdNoException(relatedEntity);
-	        			if (fileEntityTo!=-1) {
-							DependencyDetail detail = buildDescription(entity, relatedEntity, relation.getFromLine());
-							dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,1,detail);
-	        			}
-	        		}
-        		}
-        	}
-        }
-		System.out.println("Finish create dependencies matrix....");
-
-		return dependencyMatrix;
+	protected String nameOf(Entity entity) {
+		return entity.getQualifiedName() + "|" + entity.getClass().getSimpleName().replace("Entity","");
 	}
 
 
-
-	private boolean isStructureEntityType(Entity entity) {
+	@Override
+	protected boolean outputLevelMatch(Entity entity) {
 		if (entity instanceof FileEntity) return false;
 		if (entity instanceof TypeEntity) return true; //package included
 		if (entity instanceof VarEntity && entity.getParent() instanceof TypeEntity) return true;
@@ -95,7 +43,8 @@ public class StructureDependencyGenerator extends DependencyGenerator{
 		return false;
 	}
 
-	private int getStructureEntityIdNoException(Entity entity) {
+	@Override
+	protected int upToOutputLevelEntityId(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = getAncestorOfType(entity);
 		if (ancestor==null) {
 			return -1;
@@ -106,7 +55,7 @@ public class StructureDependencyGenerator extends DependencyGenerator{
 
 	public Entity getAncestorOfType(Entity fromEntity) {
 		while(fromEntity!=null) {
-			if (isStructureEntityType(fromEntity))
+			if (outputLevelMatch(fromEntity))
 				return fromEntity;
 			if (fromEntity.getParent()==null) return null;
 			fromEntity = fromEntity.getParent();

0be07f93f6c83785fbc25be0b7e4ce97d16c89db
@@ -11,8 +11,7 @@ import org.junit.Test;
 
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	@Before
@@ -98,6 +97,22 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
 	}
 
+	@Test
+	public void test_expression_count_should_be_only_1() throws IOException {
+		String[] srcs = new String[] {
+				"./src/test/resources/python-code-examples/deducetype_parameter.py",
+		};
+
+		for (String src:srcs) {
+			FileParser parser = createFileParser();
+			parser.parse(src);
+		}
+		resolveAllBindings();
+		String name = withPackageName(srcs[0],"test_expression");
+		FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
+		assertNotNull(function);
+	}
+
 
 }
 

dbabb7e459681d357fa489658976420065cf5989
@@ -113,8 +113,12 @@ public class Expression implements Serializable{
 		}
 		
 		//referer referredEntity -- TODO:maybe not require
-		if (this.referredEntityId!=null && this.referredEntity==null)
+		if (this.referredEntityId!=null && this.referredEntity==null) {
 			this.referredEntity = repo.getEntity(this.referredEntityId);
+			if (this.referredEntity ==null){
+				System.err.println("unexpected: referred Entity is null" + this.referredEntityId + this.text+this.id);
+			}
+		}
 	}
 	
 	/**

dbabb7e459681d357fa489658976420065cf5989
@@ -286,6 +286,7 @@ public abstract class HandlerContext {
 		if (currentFunction()==null) return null;
 		VarEntity varEntity = new VarEntity(GenericName.build(paramName),null,currentFunction(),idGenerator.generateId());
 		currentFunction().addParameter(varEntity);
+		addToRepo(varEntity);
 		return varEntity;
 	}
 

dbabb7e459681d357fa489658976420065cf5989
@@ -100,7 +100,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	@Test
 	public void test_expression_count_should_be_only_1() throws IOException {
 		String[] srcs = new String[] {
-				"./src/test/resources/python-code-examples/deducetype_parameter.py",
+				"./src/test/resources/python-code-examples/expression_reload_issue_test.py",
 		};
 
 		for (String src:srcs) {

d003ee4afa4123608df5fcb19954254a89ec4920
@@ -182,24 +182,7 @@ public class Expression implements Serializable{
 		else if (parent.isDot) {
 			if (parent.isCall()) {
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-				if (funcs!=null) {
-					//funcs = funcs.stream().filter(item->!(item instanceof MultiDeclareEntities)).collect(Collectors.toList());
-					if (funcs.size()>0) {
-						Entity func = funcs.get(0);
-						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
-							bindingResolver.getRepo().add(m);
-							for (int i=1;i<funcs.size();i++) {
-								m.add(funcs.get(i));
-							}
-							parent.setType(func.getType(), m, bindingResolver);
-							parent.setReferredEntity(m);
-						}else {
-							parent.setType(func.getType(), func, bindingResolver);
-							parent.setReferredEntity(func);
-						}
-					}
-				}
+				setReferredFunctions(bindingResolver, parent, funcs);
 			}else {
 				Entity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
@@ -207,22 +190,7 @@ public class Expression implements Serializable{
 					parent.setReferredEntity(var);
 				}else {
 					List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-					if (funcs!=null) {
-						Entity func = funcs.get(0);
-						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
-							bindingResolver.getRepo().add(m);
-
-							for (int i=1;i<funcs.size();i++) {
-								m.add(funcs.get(i));
-							}
-							parent.setType(func.getType(), m, bindingResolver);
-							parent.setReferredEntity(m);
-						}else {
-							parent.setType(func.getType(), func, bindingResolver);
-							parent.setReferredEntity(func);
-						}
-					}
+					setReferredFunctions(bindingResolver,parent,funcs);
 				}
 			}
 			if (parent.getType()==null) {
@@ -237,6 +205,23 @@ public class Expression implements Serializable{
 			parent.setReferredEntity(parent.type);
 	}
 
+	private void setReferredFunctions(IBindingResolver bindingResolver, Expression expr, List<Entity> funcs) {
+		if (funcs ==null ||funcs.size()==0) return;
+		Entity func = funcs.get(0);
+		if (funcs.size()==1){
+			expr.setType(func.getType(), func, bindingResolver);
+			expr.setReferredEntity(func);
+			return;
+		}
+		MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
+		bindingResolver.getRepo().add(m);
+		for (int i = 1; i< funcs.size(); i++) {
+			m.add(funcs.get(i));
+		}
+		expr.setType(func.getType(), m, bindingResolver);
+		expr.setReferredEntity(m);
+	}
+
 	private void setReferredEntity(Entity referredEntity) {
 		this.referredEntity = referredEntity;
 		if (this.referredEntity!=null) {

d003ee4afa4123608df5fcb19954254a89ec4920
@@ -24,13 +24,13 @@ SOFTWARE.
 
 package depends.entity;
 
+import depends.relations.IBindingResolver;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 
-import depends.relations.IBindingResolver;
-
 /**
  * MultiDeclareEntity is a special container, which is used as a wrapper
  * of multi-declaration. for example, 
@@ -57,8 +57,11 @@ public class MultiDeclareEntities extends ContainerEntity {
 		entity.setMutliDeclare(this);
 		if (entity instanceof TypeEntity) 
 			this.containsTypeEntity = true;
-		
-		entities.add(entity);
+		if (entity instanceof  MultiDeclareEntities){
+			((MultiDeclareEntities)entity).entities.forEach(e->add(e));
+		}else {
+			entities.add(entity);
+		}
 	}
 
 	public List<Entity> getEntities() {

d003ee4afa4123608df5fcb19954254a89ec4920
@@ -98,7 +98,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	}
 
 	@Test
-	public void test_expression_count_should_be_only_1() throws IOException {
+	public void test_expression_count_should_be_() throws IOException {
 		String[] srcs = new String[] {
 				"./src/test/resources/python-code-examples/expression_reload_issue_test.py",
 		};

f114c9c371062b1aebc55861844ba9d3770dda7d
@@ -1,9 +1,6 @@
 package depends.entity.repo;
 
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.GenericName;
-import depends.entity.MultiDeclareEntities;
+import depends.entity.*;
 import multilang.depends.util.file.FileUtil;
 
 import java.util.*;
@@ -39,6 +36,7 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 		allEntieisByName = new TreeMap<>();
 		allEntitiesById = new TreeMap<>();
 		allFileEntitiesByOrder = new LinkedList<>();
+		add(TypeEntity.buildInType);
 	}
 
 	@Override

55854a2a5c80130035a17e3c864ae2c058aebfff
@@ -47,7 +47,7 @@ public class DependencyType {
 	public static final String PomPlugin = "Plugin";
 	public static final String PomDependency = "Dependency";
 
-	public static final String DuckTypingLabel = "(duck)";
+	public static final String POSSIBLE_DEP = "(possible)";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();

55854a2a5c80130035a17e3c864ae2c058aebfff
@@ -35,11 +35,13 @@ public class Relation {
 	private Location location;
 	private String type;
 	private Entity toEntity;
+	private boolean possibleDependency;
 	
-	public Relation(String type, Entity toEntity,Location location) {
+	public Relation(String type, Entity toEntity,Location location, boolean possibleDependency) {
 		this.toEntity = toEntity;
 		this.type = type;
 		this.location = location;
+		this.possibleDependency = possibleDependency;
 	}
 	public String getType() {
 		return type;
@@ -57,4 +59,8 @@ public class Relation {
 		if (location==null) return null;
 		return location.getLine();
 	}
+
+	public boolean possible() {
+		return this.possibleDependency;
+	}
 }

55854a2a5c80130035a17e3c864ae2c058aebfff
@@ -102,12 +102,13 @@ public class RelationCounter {
 				continue;
 			}
 			Entity referredEntity = expression.getReferredEntity();
-			addRelationFromExpression(entity, expression, referredEntity);
+			addRelationFromExpression(entity, expression, referredEntity, false);
 		}
 		entity.clearExpressions();
 	}
 
-	private void addRelationFromExpression(ContainerEntity entity, Expression expression, Entity referredEntity) {
+
+	private void addRelationFromExpression(ContainerEntity entity, Expression expression, Entity referredEntity, boolean possibleDependency) {
 		
 		if (referredEntity==null) {
 			return;
@@ -117,7 +118,7 @@ public class RelationCounter {
 		}
 		if (referredEntity instanceof MultiDeclareEntities) {
 			for (Entity e:((MultiDeclareEntities)referredEntity).getEntities()) {
-				addRelationFromExpression(entity,expression,e);
+				addRelationFromExpression(entity,expression,e, true);
 			}
 			return;
 		}
@@ -127,7 +128,7 @@ public class RelationCounter {
 			/* if it is a FunctionEntityProto, add Relation to all Impl Entities*/
 			if (callAsImpl && referredEntity instanceof FunctionEntityProto) {
 				if (entity.getAncestorOfType(FileEntity.class).getId().equals(referredEntity.getAncestorOfType(FileEntity.class).getId())){
-					entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity,expression.getLocation()));
+					entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity,expression.getLocation(), possibleDependency));
 				}else {
 					Entity multiDeclare = repo.getEntity(referredEntity.getQualifiedName());
 					if (multiDeclare instanceof MultiDeclareEntities) {
@@ -135,56 +136,63 @@ public class RelationCounter {
 						List<Entity> entities = m.getEntities().stream().filter(item -> (item instanceof FunctionEntityImpl))
 								.collect(Collectors.toList());
 						for (Entity e : entities) {
-							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation()));
+							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation(), true));
 							matched = true;
 						}
 					}
 				}
 			}
-			entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity,expression.getLocation()));
+			entity.addRelation(buildRelation(entity,DependencyType.CALL,referredEntity,expression.getLocation(), possibleDependency));
 			matched = true;
 
 		}
 		if (expression.isCreate()) {
-			entity.addRelation(buildRelation(entity,DependencyType.CREATE,referredEntity,expression.getLocation()));
+			entity.addRelation(buildRelation(entity,DependencyType.CREATE,referredEntity,expression.getLocation(), possibleDependency));
 			matched = true;
 		}
 		if (expression.isThrow()) {
-			entity.addRelation(buildRelation(entity,DependencyType.THROW,referredEntity,expression.getLocation()));
+			entity.addRelation(buildRelation(entity,DependencyType.THROW,referredEntity,expression.getLocation(), possibleDependency));
 			matched = true;
 		}
 		if (expression.isCast()) { 
-			entity.addRelation(buildRelation(entity,DependencyType.CAST,referredEntity,expression.getLocation()));
+			entity.addRelation(buildRelation(entity,DependencyType.CAST,referredEntity,expression.getLocation(), possibleDependency));
 			matched = true;
 		}
 		if (!matched)  {
 			if (callAsImpl && repo.getEntity(referredEntity.getQualifiedName()) instanceof MultiDeclareEntities &&
 					(referredEntity instanceof VarEntity ||referredEntity instanceof FunctionEntity)) {
 				if (entity.getAncestorOfType(FileEntity.class).getId().equals(referredEntity.getAncestorOfType(FileEntity.class).getId())){
-					entity.addRelation(buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation()));
+					entity.addRelation(buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation(), possibleDependency));
 				}else {
 					MultiDeclareEntities m = (MultiDeclareEntities) (repo.getEntity(referredEntity.getQualifiedName()));
 					for (Entity e : m.getEntities()) {
 						if (e == referredEntity) {
-							entity.addRelation(expression, buildRelation(entity, DependencyType.USE, e, expression.getLocation()));
+							entity.addRelation(expression, buildRelation(entity, DependencyType.USE, e, expression.getLocation(), true));
 						} else {
-							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation()));
+							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation(), true));
 						}
 						matched = true;
 					}
 				}
 			}
 			else {
-				entity.addRelation(expression,buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation()));
+				entity.addRelation(expression,buildRelation(entity,DependencyType.USE,referredEntity,expression.getLocation(), possibleDependency));
 			}
 		}
 	}
 
-	private Relation buildRelation(Entity from, String type, Entity referredEntity) {
-		return buildRelation(from,type,referredEntity,from.getLocation());
+	private Relation buildRelation(Entity from, String type, Entity referredEntity, boolean possibleDependency) {
+		return buildRelation(from,type,referredEntity,from.getLocation(), possibleDependency);
+	}
+
+	private Relation buildRelation(ContainerEntity from, String type, Entity referredEntity) {
+		return buildRelation(from,type,referredEntity, false);
 	}
 
 	private Relation buildRelation(Entity from, String type, Entity referredEntity,Location location) {
+		return buildRelation(from,type,referredEntity, location,false);
+	}
+	private Relation buildRelation(Entity from, String type, Entity referredEntity,Location location, boolean possibleDependency) {
 		if (referredEntity instanceof AliasEntity) {
 			if (from.getAncestorOfType(FileEntity.class).equals(referredEntity.getAncestorOfType(FileEntity.class))) {
 				AliasEntity alias = ((AliasEntity) referredEntity);
@@ -193,9 +201,11 @@ public class RelationCounter {
 				}
 			}
 		}
+		if (referredEntity instanceof  CandidateTypes)
+			possibleDependency = true;
 		if (this.langProcessor==null)
-			return new Relation(type,referredEntity,location);
-		return new Relation(langProcessor.getRelationMapping(type),referredEntity,location);
+			return new Relation(type,referredEntity,location, possibleDependency);
+		return new Relation(langProcessor.getRelationMapping(type),referredEntity,location, possibleDependency);
 	}
 
 	private void computeTypeRelations(TypeEntity type) {

55854a2a5c80130035a17e3c864ae2c058aebfff
@@ -98,7 +98,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	}
 
 	@Test
-	public void test_expression_count_should_be_() throws IOException {
+	public void test_expression_with_duck_type_should_introduce_possibile_relation() throws IOException {
 		String[] srcs = new String[] {
 				"./src/test/resources/python-code-examples/expression_reload_issue_test.py",
 		};
@@ -110,7 +110,8 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		resolveAllBindings();
 		String name = withPackageName(srcs[0],"test_expression");
 		FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
-		assertNotNull(function);
+		for (int r= 2;r<4;r++)
+			assertTrue(function.getRelations().get(r).possible());
 	}
 
 

dc6e7fdf8b2ba8b380dfc6e6ac3ddf0c0a2b999c
@@ -5,11 +5,14 @@ import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
+import edu.emory.mathcs.backport.java.util.Arrays;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
+import java.util.List;
+import java.util.stream.Collectors;
 
 import static org.junit.Assert.*;
 
@@ -110,8 +113,9 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		resolveAllBindings();
 		String name = withPackageName(srcs[0],"test_expression");
 		FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
-		for (int r= 2;r<4;r++)
-			assertTrue(function.getRelations().get(r).possible());
+		List<Boolean> result = function.getRelations().stream().map(r -> r.possible()).collect(Collectors.toList());
+		List<Boolean> expected = Arrays.asList(new Boolean[]{false,false,true,true,true,false, false, true, true,false});
+		assertArrayEquals(expected.toArray(),result.toArray());
 	}
 
 

40399d6885d0fb7e96f778976a8a32bf5e6041b0
@@ -123,9 +123,15 @@ public class Expression implements Serializable{
 	
 	/**
 	 * Set type of the expression
-	 * @param type
-	 * @param referredEntity
-	 * @param bindingResolver
+	 *      if it is already has type, it will skip
+	 *      if it is already referered entity, it will skip
+	 *      if the type changed, parent expression will be re-caculated
+	 * For dynamic type language, return type or parameters, variables may depends on the expression type,
+	 *      so once we get the type of expression, we will assign type to them.
+	 *
+	 * @param type  the type of the expression
+	 * @param referredEntity the entity of the expression point to, which is used to calculate dependency relation
+	 * @param bindingResolver a parameter which will be passed to deduced parent type
 	 */
 	public void setType(TypeEntity type, Entity referredEntity, IBindingResolver bindingResolver) {
 		if (this.getReferredEntity()==null && referredEntity!=null) {
@@ -135,6 +141,7 @@ public class Expression implements Serializable{
 		boolean changedType = false;
 		if (this.type==null && type!=null) {
 			this.type = type;
+			changedType = true;
 			for (VarEntity var:deducedTypeVars) {
 				if (var!=null) {
 					var.setType(this.type);
@@ -145,7 +152,6 @@ public class Expression implements Serializable{
 					func.addReturnType(this.type);
 				}
 			}
-			changedType = true;
 		}
 		if (this.referredEntity==null)
 			this.setReferredEntity(this.type);
@@ -157,6 +163,7 @@ public class Expression implements Serializable{
 
 	/**
 	 * deduce type of parent based on child's type
+	 *
 	 * @param bindingResolver
 	 */
 	private void deduceTheParentType(IBindingResolver bindingResolver) {
@@ -182,7 +189,7 @@ public class Expression implements Serializable{
 		else if (parent.isDot) {
 			if (parent.isCall()) {
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-				setReferredFunctions(bindingResolver, parent, funcs);
+				parent.setReferredFunctions(bindingResolver, funcs);
 			}else {
 				Entity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
@@ -190,7 +197,7 @@ public class Expression implements Serializable{
 					parent.setReferredEntity(var);
 				}else {
 					List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-					setReferredFunctions(bindingResolver,parent,funcs);
+					parent.setReferredFunctions(bindingResolver,funcs);
 				}
 			}
 			if (parent.getType()==null) {
@@ -205,12 +212,22 @@ public class Expression implements Serializable{
 			parent.setReferredEntity(parent.type);
 	}
 
-	private void setReferredFunctions(IBindingResolver bindingResolver, Expression expr, List<Entity> funcs) {
+	/**
+	 * set expr's referred entity to functions
+	 *    why do not use 'setReferredEntity' directly?
+	 *    in case of multiple functions, we should first construct a multi-declare entities object,
+	 *    than set the type to multi-declare entity, for future resolver,
+	 *    for example in duck typing case:
+	 *        conn.send().foo, if conn is mutiple type (A, B), send should be search in both A and B
+	 * @param bindingResolver
+	 * @param funcs
+	 */
+	private void setReferredFunctions(IBindingResolver bindingResolver, List<Entity> funcs) {
 		if (funcs ==null ||funcs.size()==0) return;
 		Entity func = funcs.get(0);
 		if (funcs.size()==1){
-			expr.setType(func.getType(), func, bindingResolver);
-			expr.setReferredEntity(func);
+			setType(func.getType(), func, bindingResolver);
+			setReferredEntity(func);
 			return;
 		}
 		MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
@@ -218,8 +235,8 @@ public class Expression implements Serializable{
 		for (int i = 1; i< funcs.size(); i++) {
 			m.add(funcs.get(i));
 		}
-		expr.setType(func.getType(), m, bindingResolver);
-		expr.setReferredEntity(m);
+		setType(func.getType(), m, bindingResolver);
+		setReferredEntity(m);
 	}
 
 	private void setReferredEntity(Entity referredEntity) {
@@ -229,11 +246,19 @@ public class Expression implements Serializable{
 		}
 	}
 
+	/**
+	 * remember the vars depends on the expression type
+	 * @param var
+	 */
 	public void addDeducedTypeVar(VarEntity var) {
 		this.deducedTypeVars.add(var);
 		this.deducedTypeVarsId.add(var.getId());
 	}
 
+	/**
+	 * remember the functions depends on the expression type
+	 * @param var
+	 */
 	public void addDeducedTypeFunction(FunctionEntity function) {
 		this.deducedTypeFunctions.add(function);
 		this.deducedTypeFunctionsId.add(function.id);

80cc02fe91c389d6a798e1a72bda6c1e8d67d518
@@ -40,7 +40,7 @@ public class DependencyType {
 	public static final String CREATE = "Create";
 	public static final String CAST = "Cast";
 	public static final String THROW = "Throw";
-	public static final String IMPLLINK = "ImplLink";
+	public static final String LINK = "Link";
 	public static final String ANNOTATION = "Annotation";
 	public static final String MIXIN = "MixIn";
 	public static final String PomParent = "Parent";
@@ -66,7 +66,7 @@ public class DependencyType {
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
 		depedencyTypes.add(MIXIN);
-		depedencyTypes.add(IMPLLINK);
+		depedencyTypes.add(LINK);
 		depedencyTypes.add(PomParent);
 		depedencyTypes.add(PomPlugin);
 		depedencyTypes.add(PomDependency);

80cc02fe91c389d6a798e1a72bda6c1e8d67d518
@@ -94,7 +94,7 @@ public class CppProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(USE);
 		depedencyTypes.add(CAST);
 		depedencyTypes.add(THROW);
-		depedencyTypes.add(IMPLLINK);
+		depedencyTypes.add(LINK);
 		return depedencyTypes;
 	}
 

80cc02fe91c389d6a798e1a72bda6c1e8d67d518
@@ -81,7 +81,7 @@ public class GoProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(USE);
 		depedencyTypes.add(CAST);
 		depedencyTypes.add(THROW);
-		depedencyTypes.add(IMPLLINK);
+		depedencyTypes.add(LINK);
 		return depedencyTypes;
 	}
 

80cc02fe91c389d6a798e1a72bda6c1e8d67d518
@@ -49,7 +49,7 @@ public abstract class BasePythonProcessor extends AbstractLangProcessor{
 		depedencyTypes.add(CREATE);
 		depedencyTypes.add(USE);
 		depedencyTypes.add(THROW);
-		depedencyTypes.add(IMPLLINK);
+		depedencyTypes.add(LINK);
 		return depedencyTypes;
 	}
 

80cc02fe91c389d6a798e1a72bda6c1e8d67d518
@@ -136,7 +136,7 @@ public class RelationCounter {
 						List<Entity> entities = m.getEntities().stream().filter(item -> (item instanceof FunctionEntityImpl))
 								.collect(Collectors.toList());
 						for (Entity e : entities) {
-							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation(), true));
+							entity.addRelation(expression, buildRelation(entity, DependencyType.LINK, e, expression.getLocation(), true));
 							matched = true;
 						}
 					}
@@ -169,7 +169,7 @@ public class RelationCounter {
 						if (e == referredEntity) {
 							entity.addRelation(expression, buildRelation(entity, DependencyType.USE, e, expression.getLocation(), true));
 						} else {
-							entity.addRelation(expression, buildRelation(entity, DependencyType.IMPLLINK, e, expression.getLocation(), true));
+							entity.addRelation(expression, buildRelation(entity, DependencyType.LINK, e, expression.getLocation(), true));
 						}
 						matched = true;
 					}

877c1ac1d363deffd6ba74c2d6b1e53226ce114b
@@ -7,7 +7,6 @@ import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 import edu.emory.mathcs.backport.java.util.Arrays;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -81,7 +80,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	}
 	
 	
-	@Ignore
+	@Test
 	public void test_deduce_type_of_non_param_var() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/python-code-examples/deducetype_nonparam.py",
@@ -97,7 +96,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    VarEntity var = function.lookupVarLocally("t2");
 	    TypeEntity type = var.getType();
 	    assertTrue(type instanceof CandidateTypes);
-	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
+	    assertEquals(1,((CandidateTypes)type).getCandidateTypes().size());
 	}
 
 	@Test

27f1206a1aab12fc321a4993bc6b199789f767d5
@@ -24,15 +24,15 @@ SOFTWARE.
 
 package depends;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.deptypes.DependencyType;
 import depends.extractor.LangProcessorRegistration;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
+import java.util.ArrayList;
+import java.util.List;
+
 @Command(name = "depends")
 public class DependsCommand {
 	public static class SupportedLangs extends ArrayList<String> {
@@ -62,8 +62,8 @@ public class DependsCommand {
 	@Option(names = {"--strip-paths"}, split=",", description =  "The path(s) to be stripped. if -s enabled, the path(s) start after <src>. "
 			+ "Otherwise, the path(s) should be valid.")
 	private String[] strippedPaths = new String[]{};
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,structure,L#(the level of folder. e.g. L1=1st level folder)]")
-    private String granularity="file";
+	@Option(names = {"-g", "--granularity"}, split=",",  description = "Granularity of dependency.[file(default),method,structure]")
+    private String[] granularity=new String[]{"file"};
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
     private String namePathPattern="";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
@@ -120,7 +120,7 @@ public class DependsCommand {
 	public boolean isHelp() {
 		return help;
 	}
-    public String getGranularity() {
+    public String[] getGranularity() {
 		return granularity;
 	}
 	public String getNamePathPattern() {

27f1206a1aab12fc321a4993bc6b199789f767d5
@@ -40,6 +40,11 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		return (entity instanceof FileEntity);
 	}
 
+	@Override
+	public String getType() {
+		return "file";
+	}
+
 	@Override
 	protected int upToOutputLevelEntityId(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);

27f1206a1aab12fc321a4993bc6b199789f767d5
@@ -56,4 +56,9 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 		return ancestor.getId();
 	}
 
+	@Override
+	public String getType() {
+		return "method";
+	}
+
 }

27f1206a1aab12fc321a4993bc6b199789f767d5
@@ -43,6 +43,11 @@ public class StructureDependencyGenerator extends DependencyGenerator{
 		return false;
 	}
 
+	@Override
+	public String getType() {
+		return "structure";
+	}
+
 	@Override
 	protected int upToOutputLevelEntityId(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = getAncestorOfType(entity);

a7f33f2d1f2eeb5ce8b968d2dce95eca534acb38
@@ -79,7 +79,9 @@ public class DependsCommand {
 	@Option(names = {"--external-deps"}, description = "Output external dependencies")
 	private boolean outputExternalDependencies = false;	
 	@Option(names = {"--duck-typing-deduce"}, description = "Deduce implicit variable types")
-	private boolean duckTypingDeduce = true;	
+	private boolean duckTypingDeduce = true;
+	@Option(names = {"--output-self-deps"}, description = "Output self dependencies")
+	private boolean outputSelfDependencies = false;
 	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
@@ -154,7 +156,9 @@ public class DependsCommand {
 	public boolean isOutputExternalDependencies() {
 		return outputExternalDependencies;
 	}
-	
+	public boolean isOutputSelfDependencies() {
+		return outputSelfDependencies;
+	}
 	public boolean isDuckTypingDeduce() {
 		return this.duckTypingDeduce;
 	}

a7f33f2d1f2eeb5ce8b968d2dce95eca534acb38
@@ -23,14 +23,14 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
 
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.HashMap;
-
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.core.DependencyPair;
 import depends.matrix.core.DependencyValue;
 
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashMap;
+
 public class OrderedMatrixGenerator  {
 	private DependencyMatrix matrix;
 	public OrderedMatrixGenerator(DependencyMatrix matrix) {
@@ -46,7 +46,7 @@ public class OrderedMatrixGenerator  {
 			}
 		});
 	    
-	    DependencyMatrix ordered = new DependencyMatrix((int)(matrix.getDependencyPairs().size()/0.75+1));
+	    DependencyMatrix ordered = new DependencyMatrix((int)(matrix.getDependencyPairs().size()/0.75+1),null,matrix.isOutputSelfDependencies());
 		HashMap<String, Integer> nodesMap = new HashMap<>();
 		for (int id=0;id<reMappedNodes.size();id++) {
 			nodesMap.put(reMappedNodes.get(id), id);

a7f33f2d1f2eeb5ce8b968d2dce95eca534acb38
@@ -19,7 +19,7 @@ public class JsonFormatDependencyDumperTest {
 	 @Before
 	 public void init() {
 		 int SIZE = 4000;
-			dependencyMatrix = new DependencyMatrix(SIZE*100);
+			dependencyMatrix = new DependencyMatrix(SIZE*100,null,false);
 			for (int i=0;i<SIZE;i++)
 				dependencyMatrix.addNode(""+i,i);
 			System.out.print("here1");

c09675c980b1e0fe17feb6ec379151ce0d3e0433
@@ -243,7 +243,7 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
 		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
-		expressionUsage.foundExpression(node.getValue());
+		expressionUsage.foundExpression(node);
 		return super.visitDAsgnNode(node);
 	}
 

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -145,7 +145,7 @@ public abstract class Entity {
 		deduceQualifiedName();
 	}
 	
-	public final String getQualifiedName() {
+	public String getQualifiedName() {
 		return qualifiedName;
 	}
 

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -37,16 +37,20 @@ public class FileEntity extends TypeEntity {
 	private Collection<Entity> importedTypes = new ArrayList<>();
 	private List<TypeEntity> declaredTypes = new ArrayList<>();
 	private ImportedFileCollector importedFileCollector = null;
+	private boolean fileAsModule = false;
+	private String moduleName = "";
+
 	public FileEntity() {}
 
-	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
+	public FileEntity(boolean fileAsModule,String fullName, int fileId, boolean isInProjectScope) {
 		super(GenericName.build(fullName), null, fileId);
 		setQualifiedName(fullName);
 		this.isInProjectScope = isInProjectScope;
+		this.fileAsModule = fileAsModule;
 	}
 
-	public FileEntity(String fullName, int fileId) {
-		this(fullName, fileId, true);
+	public FileEntity(boolean fileAsModule,String fullName, int fileId) {
+		this(fileAsModule,fullName, fileId, true);
 	}
 
 	public void addImport(Import imported) {
@@ -74,20 +78,26 @@ public class FileEntity extends TypeEntity {
 		}
 		return null;
 	}
-	
+
 
 	@Override
 	public String getQualifiedName(boolean overrideFileWithPackage) {
-		if (!overrideFileWithPackage) {
-			return super.getQualifiedName();
-		}
-		if (this.getParent() == null) {
+		if (this.getParent() == null ||
+			!(this.getParent() instanceof PackageEntity)) {
+			if (fileAsModule){
+				return super.getQualifiedName();
+			}
 			return "";
 		}
-		if (this.getParent() instanceof PackageEntity)
+		//parent is  PackageEntity
+		if (!fileAsModule) {
 			return this.getParent().getQualifiedName();
-		else
-			return super.getQualifiedName();
+		}else {
+			if (moduleName==null || moduleName.equals("")){
+				return this.getParent().getQualifiedName();
+			}
+			return this.getParent().getQualifiedName() + "." +moduleName;
+		}
 	}
 
 	@Override
@@ -166,4 +176,7 @@ public class FileEntity extends TypeEntity {
 		}
 	}
 
+	public void setModuleName(String moduleName) {
+		this.moduleName = moduleName;
+	}
 }

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -50,8 +50,8 @@ public abstract class HandlerContext {
 		this.bindingResolver = bindingResolver;
 	}
 
-	public FileEntity startFile(String fileName) {
-		currentFileEntity = new FileEntity(fileName, idGenerator.generateId(),true);
+	public FileEntity startFile(boolean fileAsModule, String fileName) {
+		currentFileEntity = new FileEntity(fileAsModule, fileName, idGenerator.generateId(),true);
 		pushToStack(currentFileEntity);
 		addToRepo(currentFileEntity);
 		return currentFileEntity;

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -12,7 +12,8 @@ import java.util.List;
 
 public class PythonBuiltInType extends BuiltInType {
 
-	public static String[] BUILT_IN_FUNCTIONS = { "abs", "delattr", "hash", "memoryview", "set", "all", "dict", "help",
+    public static final String PACKAGE_PY_NAME = "__init__.py";
+    public static String[] BUILT_IN_FUNCTIONS = { "abs", "delattr", "hash", "memoryview", "set", "all", "dict", "help",
 			"min", "setattr", "any", "dir", "hex", "next", "slice", "exit", "ascii", "divmod", "id", "object", "sorted",
 			"bin", "enumerate", "input", "oct", "staticmethod", "bool", "eval", "int", "open", "str", "breakpoint",
 			"exec", "isinstance", "ord", "sum", "bytearray", "filter", "issubclass", "pow", "super", "bytes", "float",

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -3,6 +3,7 @@ package depends.extractor.python.union;
 import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.python.NameAliasImport;
+import depends.extractor.python.PythonBuiltInType;
 import depends.extractor.python.PythonHandlerContext;
 import depends.extractor.python.PythonParser.*;
 import depends.extractor.python.PythonParserBaseListener;
@@ -43,7 +44,11 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		PackageEntity packageEntity = (PackageEntity) entityRepo.getEntity(dir);
 		String moduleName = fileEntity.getRawName().uniqName().substring(packageEntity.getRawName().uniqName().length() + 1);
 		if (moduleName.endsWith(".py"))
-			moduleName.substring(0, moduleName.length() - ".py".length());
+			moduleName = moduleName.substring(0, moduleName.length() - ".py".length());
+		if (fileEntity.getRawName().uniqName().endsWith(PythonBuiltInType.PACKAGE_PY_NAME)){
+			moduleName = "";
+		}
+		fileEntity.setModuleName(moduleName);
 		Entity.setParent(fileEntity, packageEntity);
 		packageEntity.addChild(FileUtil.getShortFileName(fileEntity.getRawName().uniqName()).replace(".py", ""), fileEntity);
 	}
@@ -176,8 +181,8 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		ArrayList<String> r = new ArrayList<>();
 		if (fullName==null) return r;
 		r.add(fullName);
-		if (FileUtil.existFile(fullName+File.separator + "__init__.py")) {
-			r.add( fullName+File.separator +"__init__.py");
+		if (FileUtil.existFile(fullName+File.separator + PythonBuiltInType.PACKAGE_PY_NAME)) {
+			r.add( fullName+File.separator +PythonBuiltInType.PACKAGE_PY_NAME);
 		}
 		return r;
 	}

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -0,0 +1,30 @@
+package depends.extractor.python;
+
+import depends.extractor.python.union.PythonFileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+public class ImportWithSameNameTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_with_same_name/pkg/a.py",
+				"./src/test/resources/python-code-examples/import_with_same_name/b.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
+	    }
+	    resolveAllBindings();
+	    System.out.println("he");
+		//this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
+	}
+}

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -4,7 +4,6 @@ import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
-import depends.entity.MultiDeclareEntities;
 import depends.extractor.python.union.PythonFileParser;
 import multilang.depends.util.file.FileUtil;
 import org.junit.Before;
@@ -49,7 +48,7 @@ public class PythonImportTest extends PythonParserTest {
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"imported_a","foo"));
 	}
 	
 	@Test
@@ -66,7 +65,7 @@ public class PythonImportTest extends PythonParserTest {
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0], "imported_a", "foo"));
 	}
 	
 	@Test
@@ -82,7 +81,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0], "imported_a","foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
@@ -100,7 +99,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    Entity file = entityRepo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"foo"));
+		this.assertContainsRelation(file, DependencyType.CALL,withPackageName(srcs[0],"imported_a","foo"));
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 	
@@ -219,8 +218,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    
-	    MultiDeclareEntities funcs = (MultiDeclareEntities) entityRepo.getEntity(withPackageName(srcs[1],"in_the_forest"));
-	    Entity func = funcs.getEntities().get(0);
+	    Entity func = entityRepo.getEntity(withPackageName(srcs[1], "forest","in_the_forest"));
 
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Duck.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[1],"Doge.quack"));
@@ -240,9 +238,8 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse(src);
 	    }
 	    resolveAllBindings();
-	    
-	    MultiDeclareEntities funcs = (MultiDeclareEntities) entityRepo.getEntity(withPackageName(srcs[1],"in_the_forest"));
-	    Entity func = funcs.getEntities().get(0);
+
+		Entity func = entityRepo.getEntity(withPackageName(srcs[1], "forest","in_the_forest"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Duck.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Bird.quack"));
 	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"Doge.quack"));
@@ -261,8 +258,8 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse(src);
 	    }
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"bar"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[2],"C"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"use_imported", "bar"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName2(srcs[2],"C"));
 	}
 
 	@Test

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -29,7 +29,18 @@ public abstract class PythonParserTest extends ParserTest implements ParserCreat
 	}
 	
 	protected String withPackageName(String theFile,String entityName) {
-		return FileUtil.uniqFilePath(FileUtil.getLocatedDir(theFile))+"."+entityName;
+		String uniqName = FileUtil.uniqFilePath(theFile);
+		return FileUtil.getLocatedDir(uniqName)+"."+FileUtil.getShortFileName(uniqName).replace(".py","")+"."+entityName;
+	}
+
+	protected String withPackageName(String theFile, String moduleName, String entityName) {
+		String uniqName = FileUtil.uniqFilePath(theFile);
+		return FileUtil.getLocatedDir(uniqName)+"."+moduleName+"."+entityName;
+	}
+
+	protected String withPackageName2(String theFile, String entityName) {
+		String uniqName = FileUtil.uniqFilePath(theFile);
+		return FileUtil.getLocatedDir(uniqName)+"."+entityName;
 	}
 
 

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -1,13 +1,12 @@
 package depends.extractor.python;
 
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 import depends.extractor.FileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
 
 public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
 	@Before
@@ -16,10 +15,10 @@ public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
 	}
 	
 	@Test
-	public void test_relations_of_sampe_package() throws IOException {
+	public void test_relations_of_same_package() throws IOException {
 		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/a.py",
-	    		"./src/test/resources/python-code-examples/relations_of_sampe_package/b.py"
+	    		"./src/test/resources/python-code-examples/relations_of_same_package/a.py",
+	    		"./src/test/resources/python-code-examples/relations_of_same_package/b.py"
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -27,8 +26,8 @@ public class ShouldGetRelationInSamePackageTest extends PythonParserTest {
 		    parser.parse(src);
 	    }
 	    resolveAllBindings();
-	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity(withPackageName(srcs[0],"bar")));
-	    this.assertContainsRelation(function, DependencyType.CALL, withPackageName(srcs[0],"foo"));
+	    FunctionEntity function = (FunctionEntity)(entityRepo.getEntity(withPackageName(srcs[0],"b","bar")));
+	    this.assertContainsRelation(function, DependencyType.CALL, withPackageName(srcs[0],"a","foo"));
 	}
 }
 

982b1e2859f7082793495a6d0550e3115faaa28e
@@ -50,6 +50,15 @@ public class ExpressionUsage {
 			return names;
 	}
 
+	private List<String> getName(List<Testlist_star_exprContext> testlist_star_expr) {
+		List<String> names = new ArrayList<>();
+		for (Testlist_star_exprContext expr:testlist_star_expr){
+			expr.accept(new NameCollector(names));
+		}
+		return names;
+	}
+
+
 	public void foundExpression(ParserRuleContext ctx) {
 		if (!isStartOfContainerRule(ctx)) {
 			return ;
@@ -79,7 +88,9 @@ public class ExpressionUsage {
 				expression.setSet(true);
 				expression.setIdentifier(exprAssign.testlist_star_expr().getText());
 				if (isValidIdentifier(expression.getIdentifier())) {
-					makeSureVarExist(expression.getIdentifier(), ctx);
+					if (!isAlias(exprAssign)){
+						makeSureVarExist(expression.getIdentifier(), ctx);
+					}
 				}
 				deduceVarTypeInCaseOfAssignment((Expr_stmtContext)ctx,expression);
 			}
@@ -96,6 +107,22 @@ public class ExpressionUsage {
 		
 	}
 
+	private boolean isAlias(Expr_stmtContext exprAssign) {
+		String theName = exprAssign.testlist_star_expr().getText();
+
+		List<String> assignNames = this.getName(exprAssign.assign_part().testlist_star_expr());
+		if (assignNames.size()==0) return false;
+		String assignName = assignNames.get(0);
+		Entity type = bindingResolver.resolveName(context.lastContainer(), GenericName.build(assignName),true);
+		if (type==null)
+			return false;
+		if (!(type instanceof TypeEntity))
+			return false;
+		context.foundNewAlias(theName,assignName);
+		return true;
+	}
+
+
 	private void deduceReturnTypeInCaseOfReturn(Return_stmtContext ctx, Expression expression) {
 		FunctionEntity currentFunction = context.currentFunction();
 		if (currentFunction == null)
@@ -106,9 +133,8 @@ public class ExpressionUsage {
 
 	private void makeSureVarExist(GenericName identifier, ParserRuleContext ctx) {
 		if (null==context.foundEntityWithName(identifier)) {
-			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName(),ctx.getStart().getLine());
+			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName(), ctx.getStart().getLine());
 			var.setLine(ctx.getStart().getLine());
-
 		}
 	}
 

982b1e2859f7082793495a6d0550e3115faaa28e
@@ -1,11 +1,15 @@
 package depends.extractor.python;
 
+import depends.entity.VarEntity;
 import depends.extractor.python.union.PythonFileParser;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.io.IOException;
 
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+
 public class ImportWithSameNameTest extends PythonParserTest {
     @Before
     public void setUp() {
@@ -13,7 +17,7 @@ public class ImportWithSameNameTest extends PythonParserTest {
     }
 	
 	@Test
-	public void should_parse_class() throws IOException {
+	public void same_name_in_different_file_should_be_treat_as_two_vars() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/python-code-examples/import_with_same_name/pkg/a.py",
 				"./src/test/resources/python-code-examples/import_with_same_name/b.py",
@@ -24,7 +28,10 @@ public class ImportWithSameNameTest extends PythonParserTest {
 		    parser.parse(src);
 	    }
 	    resolveAllBindings();
-	    System.out.println("he");
-		//this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
+		VarEntity foo_a = (VarEntity) entityRepo.getEntity(withPackageName(srcs[0],"a","foo"));
+		assertNotNull(foo_a);
+		VarEntity foo_b = (VarEntity) entityRepo.getEntity(withPackageName(srcs[1],"b","foo"));
+		assertNotNull(foo_b);
+		assertFalse(foo_a.equals(foo_b));
 	}
 }

982b1e2859f7082793495a6d0550e3115faaa28e
@@ -0,0 +1,32 @@
+package depends.extractor.python;
+
+import depends.entity.Entity;
+import depends.extractor.python.union.PythonFileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertNotNull;
+
+public class PythonClassAssignmentTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void class_assignment_should_be_treat_as_alias() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class_assignment.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser();
+		    parser.parse(src);
+	    }
+	    resolveAllBindings();
+		Entity classB = entityRepo.getEntity(withPackageName(srcs[0],"class_assignment","ClassB"));
+        assertNotNull(classB);
+	}
+}

9e012e4d0c41e28be14a2c0be87993b28a1f68fa
@@ -5,10 +5,12 @@ import depends.entity.repo.IdGenerator;
 import depends.extractor.HandlerContext;
 import depends.extractor.python.PythonHandlerContext;
 import depends.extractor.python.PythonParser.*;
+import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.python.PythonParserBaseVisitor;
 import depends.relations.IBindingResolver;
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.RuleContext;
+import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -108,6 +110,10 @@ public class ExpressionUsage {
 	}
 
 	private boolean isAlias(Expr_stmtContext exprAssign) {
+		//if contain arguments, like a = A(), it must be a variable
+		if (containArguments(exprAssign)){
+			return false;
+		}
 		String theName = exprAssign.testlist_star_expr().getText();
 
 		List<String> assignNames = this.getName(exprAssign.assign_part().testlist_star_expr());
@@ -122,6 +128,19 @@ public class ExpressionUsage {
 		return true;
 	}
 
+	private boolean containArguments(Expr_stmtContext expr) {
+		final boolean[] containsArgument = {false};
+		PythonParserBaseListener visitor = new PythonParserBaseListener() {
+			@Override
+			public void enterArguments(ArgumentsContext ctx) {
+				containsArgument[0] = true;
+				super.enterArguments(ctx);
+			}
+		};
+		ParseTreeWalker walker = new ParseTreeWalker();
+		walker.walk(visitor,expr);
+		return containsArgument[0];
+	}
 
 	private void deduceReturnTypeInCaseOfReturn(Return_stmtContext ctx, Expression expression) {
 		FunctionEntity currentFunction = context.currentFunction();

9e012e4d0c41e28be14a2c0be87993b28a1f68fa
@@ -20,6 +20,12 @@ import java.util.List;
 
 public class PythonCodeListener extends PythonParserBaseListener{
 	private final PythonHandlerContext context;
+
+//	@Override
+//	public void exitEveryRule(ParserRuleContext ctx) {
+//		System.out.println(ctx.getClass().getSimpleName().replace("Context","")+":"+ctx.getText());
+//		super.exitEveryRule(ctx);
+//	}
 	private final ExpressionUsage expressionUsage;
 	private final EntityRepo entityRepo;
 	private final IncludedFileLocator  includeFileLocator;

9e012e4d0c41e28be14a2c0be87993b28a1f68fa
@@ -1,13 +1,12 @@
 package depends.extractor.python;
 
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.FunctionEntity;
 import depends.extractor.python.union.PythonFileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
 
 public class PythonFuncCallTest extends PythonParserTest {
     @Before
@@ -58,9 +57,9 @@ public class PythonFuncCallTest extends PythonParserTest {
 	    }
 
 	    resolveAllBindings();
-	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"C.test"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"A.fooA"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"B.fooB"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"C.fooC"));
+	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"func_call_multi_dots","C.test"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"func_call_multi_dots","A.fooA"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"func_call_multi_dots","B.fooB"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[0],"func_call_multi_dots","C.fooC"));
 	}
 }

66db5d509e4dd337cf89b65a079009fb8ffe2349
@@ -251,8 +251,14 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		List<String> result = new ArrayList<>();
 		for (Def_parametersContext params:def_parameters) {
 			for (Def_parameterContext param:params.def_parameter()) {
-				String p = getName( param.named_parameter().name());
-				result.add(p);
+				if (!(param.named_parameter()==null)){
+					String p = getName( param.named_parameter().name());
+					result.add(p);
+				}
+				else{
+					// STAR, we ignore it
+					//    refer to definition: def_parameter:named_parameter (ASSIGN test)? | STAR
+				}
 			}
 		
 		}

6bd17bb8eaabfe6e1a18cd3fc41d463f85a13d1d
@@ -115,10 +115,9 @@ public class ExpressionUsage {
 			return false;
 		}
 		String theName = exprAssign.testlist_star_expr().getText();
-
 		List<String> assignNames = this.getName(exprAssign.assign_part().testlist_star_expr());
 		if (assignNames.size()==0) return false;
-		String assignName = assignNames.get(0);
+		String assignName = namesToDot(assignNames);
 		Entity type = bindingResolver.resolveName(context.lastContainer(), GenericName.build(assignName),true);
 		if (type==null)
 			return false;
@@ -128,6 +127,17 @@ public class ExpressionUsage {
 		return true;
 	}
 
+	private String namesToDot(List<String> assignNames) {
+		StringBuilder sb = new StringBuilder();
+		for (String s:assignNames){
+			if (sb.length()>0){
+				sb.append(".");
+			}
+			sb.append(s);
+		}
+		return sb.toString();
+	}
+
 	private boolean containArguments(Expr_stmtContext expr) {
 		final boolean[] containsArgument = {false};
 		PythonParserBaseListener visitor = new PythonParserBaseListener() {
@@ -335,9 +345,8 @@ class NameCollector extends PythonParserBaseVisitor<Void>{
 		this.names = names;
 	}
 	@Override
-	public Void visitAtom(AtomContext ctx) {
-		if (ctx.name()!=null)
-			names.add(ctx.name().getText());
-		return super.visitAtom(ctx);
+	public Void visitName(NameContext ctx) {
+			names.add(ctx.getText());
+		return super.visitName(ctx);
 	}
 }
\ No newline at end of file

6bd17bb8eaabfe6e1a18cd3fc41d463f85a13d1d
@@ -1,5 +1,6 @@
 package depends.extractor.python;
 
+import depends.entity.AliasEntity;
 import depends.entity.Entity;
 import depends.extractor.python.union.PythonFileParser;
 import org.junit.Before;
@@ -7,7 +8,7 @@ import org.junit.Test;
 
 import java.io.IOException;
 
-import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 public class PythonClassAssignmentTest extends PythonParserTest {
     @Before
@@ -27,6 +28,6 @@ public class PythonClassAssignmentTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 		Entity classB = entityRepo.getEntity(withPackageName(srcs[0],"class_assignment","ClassB"));
-        assertNotNull(classB);
+        assertTrue(classB instanceof AliasEntity);
 	}
 }

2c272809aea906584d6dd3e1165895bcea631002
@@ -40,7 +40,6 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		this.includeFileLocator = includeFileLocator;
 		this.bindingResolver = bindingResolver;
 		this.pythonProcessor = pythonProcessor;
-
 		String dir = FileUtil.uniqFilePath(FileUtil.getLocatedDir(fileFullPath));
 		if (entityRepo.getEntity(dir) == null) {
 			PackageEntity pacakgeEntity = new PackageEntity(dir, entityRepo.generateId());
@@ -67,7 +66,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 			if (dotted_as_name.name()!=null) {
 				aliasName = dotted_as_name.name().getText();
 			}
-			List<String> fullNames = foundImportedModuleOrPackage(0,moduleName);
+			List<String> fullNames = sureImportedModulesParsed(0,moduleName,null);
 			 
 			for (String fullName:fullNames) {
 				if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
@@ -80,15 +79,15 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	}
 	@Override
 	public void enterFrom_stmt(From_stmtContext ctx) {
-		String moduleName = null;
+		String fromName = null;
 		if (ctx.dotted_name() != null) {
-			moduleName = ctx.dotted_name().getText();
+			fromName = ctx.dotted_name().getText();
 		}
 		int prefixDotCount = getDotCounter(ctx);
+		List<String> moduleNames = getModuleNames(ctx.import_as_names());
+		List<String> fullNames = sureImportedModulesParsed(prefixDotCount, fromName,moduleNames);
 
-		 List<String> fullNames = foundImportedModuleOrPackage(prefixDotCount, moduleName);
 		for (String fullName:fullNames) {
-
 			if (ctx.import_as_names() == null) {// import *
 				ContainerEntity moduleEntity = (ContainerEntity) (entityRepo.getEntity(fullName));
 				if (moduleEntity != null) {
@@ -124,8 +123,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 						if (FileUtil.existFile(fileName) && !(FileUtil.isDirectory(fileName))) {
 							context.foundNewImport(new FileImport(fileName));
 						}
-					}
-					if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
+					}else if (FileUtil.existFile(fullName)) {
 						context.foundNewImport(new FileImport(fullName));
 					}
 					Entity itemEntity = bindingResolver.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
@@ -138,8 +136,18 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		super.enterFrom_stmt(ctx);
 	}
-	
-	
+
+	private List<String> getModuleNames(Import_as_namesContext import_as_names) {
+		List<String> names = new ArrayList<>();
+		if (import_as_names==null)
+			return names;
+		for (Import_as_nameContext item : import_as_names.import_as_name()) {
+			String name = item.name(0).getText();
+			names.add(name);
+		}
+		return names;
+	}
+
 	private int getDotCounter(From_stmtContext ctx) {
 		int total = 0;
 		if (ctx.DOT()!=null){
@@ -150,54 +158,82 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		return total;
 	}
-	private List<String> foundImportedModuleOrPackage(int prefixDotCount, String originalName) {
+
+
+	private List<String> sureImportedModulesParsed(int prefixDotCount, String fromName, List<String> moduleNames) {
+		ArrayList<String> visitedFiles = new ArrayList<>();
+
+		/*  compute prefix path */
 		String dir = FileUtil.getLocatedDir(context.currentFile().getRawName().uniqName());
 		String preFix = "";
 		for (int i = 0; i < prefixDotCount - 1; i++) {
 			preFix = preFix + ".." + File.separator;
 		}
 		dir = dir + File.separator + preFix;
-		String fullName = null;
-		if (originalName != null) {
-			String importedName = originalName.replace(".", File.separator);
-			fullName = includeFileLocator.uniqFileName(dir, importedName);
-			if (fullName == null) {
-				fullName = includeFileLocator.uniqFileName(dir, importedName + ".py");
+
+		/* compute importedName */
+		String importedName = "";
+		if (fromName!=null) {
+			importedName = fromName.replace(".", File.separator);
+		}
+
+		/* search importedName from all included paths */
+		String uniqFrom = includeFileLocator.uniqFileName(dir, importedName);
+		if (uniqFrom==null)
+			uniqFrom = includeFileLocator.uniqFileName(dir,importedName+".py");
+		if (uniqFrom==null){ //cannot find the path
+			return visitedFiles;
+		}
+		if (uniqFrom.endsWith(".py")){
+			return visitIncludedFile(uniqFrom);
+		}
+		if (moduleNames!=null && moduleNames.size()>0){
+			for (String moduleName:moduleNames){
+				String fileName = uniqFrom + File.separator + moduleName;
+				if (!FileUtil.existFile(fileName)){
+					fileName +=".py";
+				}else if (FileUtil.isDirectory(fileName)){
+					fileName += File.separator + PythonBuiltInType.PACKAGE_PY_NAME;
+				}
+
+				List<String> files = visitIncludedFile(fileName);
+				visitedFiles.addAll(files);
 			}
-		} else {
-			fullName = FileUtil.uniqFilePath(dir);
+		}else{
+			return visitIncludedFile(uniqFrom);
 		}
-		if (fullName != null) {
-			if (FileUtil.isDirectory(fullName)) {
-				if (!FileUtil.uniqFilePath(fullName).equals(FileUtil.uniqFilePath(dir))) {
-					File d = new File(fullName);
-					File[] files = d.listFiles();
-					for (File file : files) {
-						if (!file.isDirectory()) {
-							if (file.getAbsolutePath().endsWith(".py")) {
-								visitIncludedFile(FileUtil.uniqFilePath(file.getAbsolutePath()));
-							}
-						}
+		return visitedFiles;
+	}
+
+	private List<String> visitIncludedFile(String fullName) {
+		List<String> visitedFiles = new ArrayList<>();
+		if (FileUtil.isDirectory(fullName)){
+			File d = new File(fullName);
+			File[] files = d.listFiles();
+			for (File file : files) {
+				if (!file.isDirectory()) {
+					if (file.getAbsolutePath().endsWith(".py")) {
+						String fileName = FileUtil.uniqFilePath(file.getAbsolutePath());
+						visitIncludedFile(fileName);
+						visitedFiles.add(fileName);
 					}
 				}
-			} else {
-				visitIncludedFile(fullName);
 			}
+			if (FileUtil.existFile(fullName+File.separator + PythonBuiltInType.PACKAGE_PY_NAME)) {
+				visitedFiles.add( fullName+File.separator +PythonBuiltInType.PACKAGE_PY_NAME);
+			}
+		}else{
+			invokeParser(fullName);
+			visitedFiles.add(fullName);
 		}
-		ArrayList<String> r = new ArrayList<>();
-		if (fullName==null) return r;
-		r.add(fullName);
-		if (FileUtil.existFile(fullName+File.separator + PythonBuiltInType.PACKAGE_PY_NAME)) {
-			r.add( fullName+File.separator +PythonBuiltInType.PACKAGE_PY_NAME);
-		}
-		return r;
+		return visitedFiles;
 	}
 
-	private void visitIncludedFile(String fullName) {
+	private void invokeParser(String fileName){
 		PythonFileParser importedParser = new PythonFileParser(entityRepo, includeFileLocator, bindingResolver,
 				pythonProcessor);
 		try {
-			importedParser.parse(fullName);
+			importedParser.parse(fileName);
 		} catch (IOException e) {
 			e.printStackTrace();
 		}

2c272809aea906584d6dd3e1165895bcea631002
@@ -19,8 +19,8 @@ public class ImportWithSameNameTest extends PythonParserTest {
 	@Test
 	public void same_name_in_different_file_should_be_treat_as_two_vars() throws IOException {
 		String[] srcs = new String[] {
-	    		"./src/test/resources/python-code-examples/import_with_same_name/pkg/a.py",
 				"./src/test/resources/python-code-examples/import_with_same_name/b.py",
+				"./src/test/resources/python-code-examples/import_with_same_name/pkg/a.py",
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -28,10 +28,29 @@ public class ImportWithSameNameTest extends PythonParserTest {
 		    parser.parse(src);
 	    }
 	    resolveAllBindings();
+		VarEntity foo_a = (VarEntity) entityRepo.getEntity(withPackageName(srcs[1],"a","foo"));
+		assertNotNull(foo_a);
+		VarEntity foo_b = (VarEntity) entityRepo.getEntity(withPackageName(srcs[0],"b","foo"));
+		assertNotNull(foo_b);
+		assertFalse(foo_a.equals(foo_b));
+	}
+	@Test
+	public void same_name_in_different_file_should_be_treat_as_two_vars_diff_order() throws IOException {
+		String[] srcs = new String[] {
+				"./src/test/resources/python-code-examples/import_with_same_name/pkg/a.py",
+				"./src/test/resources/python-code-examples/import_with_same_name/b.py",
+		};
+
+		for (String src:srcs) {
+			PythonFileParser parser = createParser();
+			parser.parse(src);
+		}
+		resolveAllBindings();
 		VarEntity foo_a = (VarEntity) entityRepo.getEntity(withPackageName(srcs[0],"a","foo"));
 		assertNotNull(foo_a);
 		VarEntity foo_b = (VarEntity) entityRepo.getEntity(withPackageName(srcs[1],"b","foo"));
 		assertNotNull(foo_b);
 		assertFalse(foo_a.equals(foo_b));
 	}
+
 }

2c272809aea906584d6dd3e1165895bcea631002
@@ -259,7 +259,7 @@ public class PythonImportTest extends PythonParserTest {
 	    }
 	    resolveAllBindings();
 	    FunctionEntity func = (FunctionEntity) entityRepo.getEntity(withPackageName(srcs[0],"use_imported", "bar"));
-	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName2(srcs[2],"C"));
+	    this.assertContainsRelation(func, DependencyType.CALL, withPackageName(srcs[2],"core","C"));
 	}
 
 	@Test

c3874e4b7098fafb8759abe335fd166868d674fa
@@ -79,7 +79,7 @@ public class RelationCounter {
 			if (var.getType()!=null)
 				entity.addRelation(buildRelation(entity,DependencyType.CONTAIN,var.getType(),var.getLocation()));
 			for (Entity type:var.getResolvedTypeParameters()) {
-				var.addRelation(buildRelation(var, DependencyType.PARAMETER,type,type.getLocation()));
+				var.addRelation(buildRelation(var, DependencyType.PARAMETER,type));
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {

