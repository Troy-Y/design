44948be992c936553ec976fc36264129ccaf1630
@@ -0,0 +1,79 @@
+package depends.deptypes;
+
+import java.util.ArrayList;
+
+public class DependencyType {
+	
+    // struct->method
+    public static final String RELATION_RECEIVED_BY = "Received by";
+    public static final String RELATION_RECEIVE = "Receive";
+
+    //structType/aliasType->interface
+    public static final String RELATION_IMPLEMENT = "Implement";
+    public static final String RELATION_IMPLEMENTED_BY = "Implemented by";
+
+    //file->package
+    public static final String RELATION_IMPORT = "Import";
+
+    //function-function; function->method; method->function; method->method
+    public static final String RELATION_CALL = "Call";
+
+    //function/method->var
+    public static final String RELATION_PARAMETER = "Parameter";
+
+    //function/method->var
+    public static final String RELATION_RETURN = "Return";
+
+    //function/method->OperandVar
+    public static final String RELATION_SET = "Set";
+
+    //function/method->OperandVar
+    public static final String RELATION_USE = "Use";
+
+    //class->class in python
+    //struct-> struct , interface->interface in golang
+    public static final String RELATION_INHERIT = "Inherit";
+    
+	public static final String RELATION_DEFINE = "Define";
+
+    //struct1->struct2, interface1->interface2
+    //public static final String RELATION_INHERIT = "Embed";
+    //public static final String RELATION_INHERITED_BY = "Embeded by";
+
+	public static final ArrayList<String> resolveMask(String depMask) {
+        ArrayList<String> depedencyTypes = new ArrayList<String>();
+        for(int i = 0; i < depMask.toCharArray().length; i++) {
+            if(depMask.toCharArray()[i] == '1') {
+                if(i == 0) {
+                    depedencyTypes.add(RELATION_IMPORT);
+                }
+                else if (i == 1) {
+                    depedencyTypes.add(RELATION_INHERIT);
+                }
+                else if (i == 2) {
+                    depedencyTypes.add(RELATION_IMPLEMENT);
+                }
+                else if (i == 3) {
+                    depedencyTypes.add(RELATION_RECEIVE);
+                }
+                else if (i == 4) {
+                    depedencyTypes.add(RELATION_CALL);
+                }
+                else if (i == 5) {
+                    depedencyTypes.add(RELATION_SET);
+                }
+                else if (i == 6) {
+                    depedencyTypes.add(RELATION_USE);
+                }
+                else if (i == 7) {
+                    depedencyTypes.add(RELATION_PARAMETER);
+                }
+                else if (i == 8) {
+                    depedencyTypes.add(RELATION_RETURN);
+                }
+            }
+        }
+        return depedencyTypes;
+    }
+
+}

14facfd0e7b0248bb22972b90c8c4aa519401f5c
@@ -6,15 +6,23 @@ import java.util.List;
 
 import depends.javaextractor.Java9Parser.FormalParameterContext;
 import depends.javaextractor.Java9Parser.FormalParameterListContext;
+import depends.javaextractor.Java9Parser.IdentifierContext;
+import depends.javaextractor.Java9Parser.UnannTypeContext;
+import depends.javaextractor.Java9Parser.VariableDeclaratorIdContext;
+import depends.util.Tuple;
 
 public class FormalParameterListContextHelper {
 	
 	FormalParameterListContext context;
 	List<String> parameterTypes;
+	List<Tuple<String, String>> varList;
 	
 	public FormalParameterListContextHelper(FormalParameterListContext formalParameterListContext) {
 		this.context = formalParameterListContext;
 		parameterTypes = new ArrayList<>();
+		varList = new ArrayList<>();
+		if (formalParameterListContext!=null)
+			extractParameterTypeList();
 	}
 	/**
 	 * 
@@ -25,34 +33,58 @@ public class FormalParameterListContextHelper {
 	 * @param context
 	 * @return
 	 */
-	public Collection<String> extractParameterTypeList() {
+	public void extractParameterTypeList() {
 		if (context != null) {
 			System.out.println(context.getText());
 			if (context.formalParameters() != null) {
 				System.out.println(context.formalParameters().getText());
 				for (FormalParameterContext p : context.formalParameters().formalParameter()) {
-					// Primitive type will be ignored
-					addParameterType( new UnannTypeContextHelper().calculateType(p.unannType()));
+					foundParameterDefintion(p.unannType(),p.variableDeclaratorId());
 				}
 			}
+			/**
+			 * lastFormalParameter:
+			 *   	variableModifier* unannType annotation* '...' variableDeclaratorId
+		     *     |formalParameter
+			 */
 			if (context.lastFormalParameter() != null) {
 				if (context.lastFormalParameter().formalParameter() != null) {
-					// Primitive type will be ignored
-					addParameterType( new UnannTypeContextHelper().calculateType(
-							context.lastFormalParameter().formalParameter().unannType()));
+					foundParameterDefintion(context.lastFormalParameter().formalParameter().unannType(),
+							context.lastFormalParameter().formalParameter().variableDeclaratorId());
 				}
+				
 				if (context.lastFormalParameter().unannType() != null) {
-					addParameterType( new UnannTypeContextHelper().calculateType( context.lastFormalParameter().unannType()));
+					foundParameterDefintion(context.lastFormalParameter().unannType(),
+							context.lastFormalParameter().variableDeclaratorId());
 				}
 			}
+			/**
+			 * receiverParameter :	annotation* unannType (identifier '.')? 'this'
+			 */
 			if (context.receiverParameter() != null) {
-				addParameterType( new UnannTypeContextHelper().calculateType(context.receiverParameter().unannType()));
+				UnannTypeContext unannType =  context.receiverParameter().unannType();
+				String type =  new UnannTypeContextHelper().calculateType(unannType);
+				if (type!=null)
+					this.parameterTypes.add(type);
+				IdentifierContext var = context.receiverParameter().identifier();
+				if (var!=null)
+					varList.add(new Tuple<String, String>(type,var.Identifier().getText()));		
 			}
 		}
+		return;
+	}
+	public Collection<String> getParameterTypeList(){
 		return parameterTypes;
 	}
-	private void addParameterType(String type) {
+	public Collection<Tuple<String, String>> getVarList(){
+		return varList;
+	}
+	
+	private void foundParameterDefintion(UnannTypeContext unannType, VariableDeclaratorIdContext variableDeclaratorId) {
+		String type =  new UnannTypeContextHelper().calculateType(unannType);
 		if (type!=null)
 			this.parameterTypes.add(type);
+		String var = variableDeclaratorId.identifier().getText();
+		varList.add(new Tuple<String, String>(type,var));		
 	}
 }

6f31e63fc02cae9f5e8d76e0abd9df882f8d1fac
@@ -10,5 +10,9 @@ public class VarEntity extends Entity {
 		super(fullName,  parentId,id);
 		this.type = type;
 	}
+
+	public String getType() {
+		return type;
+	}
     
 }

09b25f297b78ccabaca1b67fcf9f92e43b2f03ee
@@ -0,0 +1,14 @@
+
+public class LocalVarInferExample {
+	String a;
+	void setExample(String b) {
+		Integer x;
+		x=1; //Set x
+		b="2"; //Set b
+		x=b.length(); //Set x
+		x++; //Set x
+		++x; //Set x
+		x--; //Set x
+		--x; //Set x
+	}
+}
\ No newline at end of file

99b712c4bfd3d17fb8d037a1b32c613cd446f68d
@@ -88,7 +88,7 @@ public class HandlerContext{
 		if (currentFile().getImport(typeName)!=null)
 			typeName = currentFile().getImport(typeName);
 		else
-			typeName = (currentPackageName.isEmpty()? "":".") + typeName;
+			typeName = currentPackageName + (currentPackageName.isEmpty()? "":".") + typeName;
 		return typeName;
 	}
 	public Entity newFunctionEntity(String methodName) {
@@ -132,4 +132,14 @@ public class HandlerContext{
 		}
 		return null;
 	}
+	public String inferType(String fromType, String varName) {
+		Entity type = entityRepo.getEntity(fromType);
+		if (type==null) return null;
+		if (!(type instanceof TypeEntity)) return null;
+		for (VarEntity var:type.getVars()) {
+			if (var.getFullName().equals(varName))
+				return var.getType();
+		}
+		return null;
+	}
 }
\ No newline at end of file

c5e3729e2b973bdc3f53e1d5844e7dff3c1e497d
@@ -37,7 +37,7 @@ public class JavaVarResolveTest {
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
         //7 set included
-        assertEquals(11,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
+        assertEquals(9,repo.getEntity("LocalVarInferExample.setExample").getRelations().size());
         
 	}
 	
@@ -47,7 +47,7 @@ public class JavaVarResolveTest {
         String src = "./src/test/resources/java-code-examples/FieldAccessInferExample.java";
         JavaFileParser parser = new JavaFileParser(src,repo);
         parser.parse();
-        assertEquals(11,repo.getEntity("test.FieldAccessInferExample.setExample").getRelations().size());
+        assertEquals(13,repo.getEntity("test.FieldAccessInferExample.setExample").getRelations().size());
 	}
 	
 }

a6135bdea297ea6389c844961e606caeaa45bb18
@@ -5,6 +5,7 @@ import java.util.HashSet;
 import java.util.Set;
 
 import depends.entity.repo.EntityRepo;
+import depends.entity.types.FunctionEntity;
 import depends.entity.types.VarEntity;
 
 public class Entity {
@@ -17,6 +18,7 @@ public class Entity {
 		this.setParentId(parentId);
 		this.setId(id);
 		vars = new ArrayList<>();
+		functions = new ArrayList<>();
 	}
 
 	public void setFileId(int fileId) {
@@ -34,6 +36,7 @@ public class Entity {
     protected ArrayList<Integer> childrenIds = new ArrayList<>();
     protected ArrayList<Relation> relations = new ArrayList<>();
     protected ArrayList<VarEntity> vars;
+    protected ArrayList<FunctionEntity> functions;
 
     public int getId() {
         return id;
@@ -111,4 +114,12 @@ public class Entity {
 	public ArrayList<VarEntity> getVars() {
 		return this.vars;
 	}
+
+	public void addFunction(FunctionEntity functionEntity) {
+		this.functions.add(functionEntity);
+	}
+	
+	public ArrayList<FunctionEntity> getFunctions() {
+		return this.functions;
+	}
 }

a447c227972f3eff0425e4931efb3ebd500d1fe2
@@ -30,16 +30,27 @@ public class DependencyType {
     //function/method->OperandVar
     public static final String RELATION_USE = "Use";
 
-    //class->class in python
-    //struct-> struct , interface->interface in golang
     public static final String RELATION_INHERIT = "Inherit";
     
 	public static final String RELATION_DEFINE = "Define";
 
-    //struct1->struct2, interface1->interface2
-    //public static final String RELATION_INHERIT = "Embed";
-    //public static final String RELATION_INHERITED_BY = "Embeded by";
+    public static final String RELATION_EMBED = "Embed";
+    public static final String RELATION_EMBED_BY = "Embeded by";
 
+    /**
+     * Mask of dependencies.
+     * 0 - IMPORT
+     * 1 - INHERIT
+     * 2 - IMPLEMENT
+     * 3 - RECEIVE
+     * 4 - CALL
+     * 5 - SET
+     * 6 - USE
+     * 7 - PARAMETER
+     * 8 - RETURN 
+     * @param depMask
+     * @return
+     */
 	public static final ArrayList<String> resolveMask(String depMask) {
         ArrayList<String> depedencyTypes = new ArrayList<String>();
         for(int i = 0; i < depMask.toCharArray().length; i++) {

010ee718f84bebb1e36a87b70e07069d5ccf6b6e
@@ -13,10 +13,9 @@ import depends.entity.types.PackageEntity;
 
 public class EntityRepo {
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
-	public HashMap<Integer, Entity> allEntieisById = new HashMap<>();
+	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
 	
-	
 	public EntityRepo() {
 		nextAvaliableIndex = 0;
 	}
@@ -24,13 +23,13 @@ public class EntityRepo {
 		return allEntieisByName.get(entityName);
 	}
 	public Entity getEntity(Integer entityId) {
-		return allEntieisById.get(entityId);
+		return allEntitiesById.get(entityId);
 	}
 	
 	public void add(Entity entity) {
 		if (!entity.getFullName().isEmpty())
 			allEntieisByName.put(entity.getFullName(),entity);
-		allEntieisById.put(entity.getId(), entity);
+		allEntitiesById.put(entity.getId(), entity);
 	}
 	
 	public void updateEntityNameIndex(String oldName, String newName, Entity entity) {
@@ -44,9 +43,9 @@ public class EntityRepo {
 	}
 	
 	public Collection<Entity> getEntities() {
-		return allEntieisById.values();
+		return allEntitiesById.values();
 	}
-	public Integer getCurrentIndex() {
+	public Integer generateId() {
 		return nextAvaliableIndex++;
 	}
 
@@ -63,7 +62,7 @@ public class EntityRepo {
 	
 	public Set<String> resolveAllBindings() {
     	HashSet<String> unsolved = new HashSet<>();
-        for (Entity entity:allEntieisByName.values()) {
+        for (Entity entity:allEntitiesById.values()) {
         	Set<String> u = entity.resolveBinding(this);
 			unsolved.addAll(u);
         }

5ea2a689666792a97f2201d598fa03068ed97f06
@@ -0,0 +1,12 @@
+package depends.entity;
+
+import depends.entity.types.FunctionEntity;
+import depends.entity.types.VarEntity;
+
+public interface BindingResolver {
+
+	FunctionEntity resolveFunctionBindings(Entity theContainer, String varName);
+
+	VarEntity resolveVarBindings(Entity theContainer, String varName);
+
+}

ac1f7d5a0c2d2a630bae9764de772e6983d1b3c8
@@ -1,12 +0,0 @@
-package depends.entity;
-
-import depends.entity.types.FunctionEntity;
-import depends.entity.types.VarEntity;
-
-public interface BindingResolver {
-
-	FunctionEntity resolveFunctionBindings(Entity theContainer, String varName);
-
-	VarEntity resolveVarBindings(Entity theContainer, String varName);
-
-}

607bf72d1f79e6461c908cb94089db39703178dc
@@ -59,7 +59,6 @@ public class Expression {
 		if (parent.type != null)return;
 		if (parent.firstChildId!=this.id) return;
 		if (parent.type!=null) return;
-		
 		if (parent.isLogic) {
 			parent.returnType = bindingResolver.inferType(this.returnType, "<Built-in>");
 			parent.type = bindingResolver.inferType(this.returnType, "<Built-in>");

1ed9cd2236051e99d928002465df3059e6665c74
@@ -285,7 +285,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 		if (rawName.equals("this")) {
 			Entity entityType = this.getAncestorOfType(fromEntity, TypeEntity.class);
 			if (entityType!=null) {
-				return (TypeEntity) type;
+				return (TypeEntity) entityType;
 			}
 		}
 		else if (rawName.equals("super")) {

c0871c6bedb8b77d874d90b3def499652b11dd72
@@ -43,7 +43,7 @@ public class ExpressionUsage {
 			}
 		}
 		else if (expression.identifier==null && (ctx.NEW()!=null && ctx.creator()!=null)){
-			expression.identifier = ctx.creator().createdName().IDENTIFIER(0).getText();
+			expression.identifier = CreatorContextHelper.getCreatorType(ctx.creator());
 		}
 		expression.isDot = isDot(ctx);
 		expression.isSet = isSet(ctx);
@@ -66,7 +66,7 @@ public class ExpressionUsage {
 			return new Tuple<String,String>(ctx.typeType().getText(),"");
 		}
 		if (ctx.NEW()!=null & ctx.creator()!=null) {
-			return new Tuple<String,String>(ctx.creator().createdName().IDENTIFIER(0).getText(),"");
+			return new Tuple<String,String>(CreatorContextHelper.getCreatorType(ctx.creator()),"");
 		}
 		return null;
 	}

c2ea9d6bf49c95a87e859d57631ace024baef230
@@ -4,7 +4,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 
-import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
@@ -59,20 +58,27 @@ public abstract class ContainerEntity extends Entity {
 		expressions.put(expression.id, expression);
 	}
 
-	public Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
+	/**
+	 * A common utility function used to transfer the identifiers 
+	 * to types.
+	 * @param typeInferer - the inferer object 
+	 * @param identifiers - the identifiers will be translated
+	 * @return The translated Types
+	 */
+	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = inferType(typeInferer, typeParameter);
+			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter);
 			if (typeEntity != null)
 				r.add(typeEntity);
 		}
 		return r;
 	}
 
-	private TypeEntity inferType(TypeInfer typeInferer, String rawName) {
-		return typeInferer.inferType(this, rawName);
-	}
-
+	/**
+	 * For all data in the class, infer their types.
+	 * Should be override in sub-classes 
+	 */
 	public void inferLocalLevelTypes(TypeInfer typeInferer) {
 		setResolvedTypeParameters(identiferToTypes(typeInferer, typeParameters));
 		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
@@ -82,20 +88,27 @@ public abstract class ContainerEntity extends Entity {
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);
 		}
-		resolveExpressions(this,typeInferer);
+		resolveExpressions(typeInferer);
 	}
 
-	private void resolveExpressions(ContainerEntity container, TypeInfer typeInferer) {
+	/**
+	 * Resolve all expression's type
+	 * @param typeInferer
+	 */
+	private void resolveExpressions(TypeInfer typeInferer) {
 		for (Expression expression : expressions.values()) {
+			//1. if expression's type existed, break;
 			if (expression.type != null)
 				continue;
+			
+			//2. if expression's rawType existed, directly infer type by rawType
+			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
 				expression.type = typeInferer.inferType(this, expression.rawType);
-			}
-
-			if (expression.identifier != null && expression.rawType == null) {
+			}else if(expression.identifier != null) {
 				if (expression.identifier.contains(".")) {
-					Tuple<TypeEntity, String> result = locateType(typeInferer, this, expression.identifier);
+					/* if it is a qualified name */
+					Tuple<TypeEntity, String> result = typeInferer.locateTypeOfQualifiedName(this, expression.identifier);
 					if (result != null) {
 						if (result.y == null) {
 							expression.type = result.x;
@@ -104,35 +117,29 @@ public abstract class ContainerEntity extends Entity {
 						}
 					}
 				} else {
+					/* expression identifiers could be a variable, or a type. try them */
 					expression.type = lookupVarDefinition(expression.identifier);
 					if (expression.type==null)
 						expression.type = typeInferer.inferType(this, expression.identifier);
 				}
 			}
+			
+			//3. if new found type of expression, update parent expressions
 			if (expression.type != null) {
-				expression.refreshParent(this.expressions,typeInferer);
+				expression.deduceParentType(this.expressions,typeInferer);
 			}
 		}
 	}
 
-	private Tuple<TypeEntity, String> locateType(TypeInfer typeInferer, ContainerEntity fromEntity,
-			String qualifiedName) {
-		String localName = null;
-		while (true) {
-			TypeEntity type = typeInferer.inferType(fromEntity, qualifiedName);
-			if (type != null)
-				return new Tuple<TypeEntity, String>(type, localName);
-			int lpos = qualifiedName.lastIndexOf(".");
-			if (lpos < 0)
-				return null;
-			localName = localName == null ? qualifiedName.substring(lpos + 1)
-					: localName + "." + qualifiedName.substring(lpos + 1);
-			qualifiedName = qualifiedName.substring(0, lpos);
-			type = typeInferer.inferType(fromEntity, qualifiedName);
-			return new Tuple<TypeEntity, String>(type,localName);
-		}
-	}
 
+	/**
+	 * Found the given type of given var;
+	 * Must be invoked after all vars' type have been resolved
+	 * Should be override if new vars have been added, for example 
+	 * Function Type could resolve parameters as vars
+	 * @param identifier  - var identifiers
+	 * @return
+	 */
 	public TypeEntity lookupVarDefinition(String identifier) {
 		for (VarEntity var : this.vars) {
 			if (var.getRawName().equals(identifier))

0255093c1d7bff912e2e4561835f0c2a72541f85
@@ -3,39 +3,17 @@ package depends.deptypes;
 import java.util.ArrayList;
 
 public class DependencyType {
-	
-    // struct->method
-    public static final String RELATION_RECEIVED_BY = "Received by";
     public static final String RELATION_RECEIVE = "Receive";
-
-    //structType/aliasType->interface
     public static final String RELATION_IMPLEMENT = "Implement";
-    public static final String RELATION_IMPLEMENTED_BY = "Implemented by";
-
-    //file->package
     public static final String RELATION_IMPORT = "Import";
-
-    //function-function; function->method; method->function; method->method
     public static final String RELATION_CALL = "Call";
-
-    //function/method->var
     public static final String RELATION_PARAMETER = "Parameter";
-
-    //function/method->var
     public static final String RELATION_RETURN = "Return";
-
-    //function/method->OperandVar
     public static final String RELATION_SET = "Set";
-
-    //function/method->OperandVar
     public static final String RELATION_USE = "Use";
-
-    public static final String RELATION_INHERIT = "Inherit";
-    
+    public static final String RELATION_INHERIT = "Extend";
 	public static final String RELATION_DEFINE = "Define";
-
-    public static final String RELATION_EMBED = "Embed";
-    public static final String RELATION_EMBED_BY = "Embeded by";
+	public static final String RELATION_CREATE = "Create";
 
     /**
      * Mask of dependencies.

cc02daf915ed3f85ea1ab938a8986c8243c7f46f
@@ -0,0 +1,21 @@
+package depends.extractor.cpp;
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import depends.entity.repo.EntityRepo;
+
+public class CppParameterParserTest {
+	@Test
+	public void test_parameter() throws IOException {
+		EntityRepo repo = new EntityRepo();
+        String src = "./src/test/resources/cpp-code-examples/FunctionParameters.cpp";
+        CppFileParser parser = new CppFileParser(src,repo);
+        parser.parse();
+        repo.resolveAllBindings();
+        //assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+	}
+
+}

a65bed10e91a8735f9292adf240ffb9ceedda185
@@ -15,7 +15,7 @@ public class CppParameterParserTest {
         CppFileParser parser = new CppFileParser(src,repo);
         parser.parse();
         repo.resolveAllBindings();
-        //assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

f15ea38f379074f8d5b15f34ec1db1998dd7cf1b
@@ -3,66 +3,31 @@ package depends.deptypes;
 import java.util.ArrayList;
 
 public class DependencyType {
-    public static final String RELATION_RECEIVE = "Receive";
-    public static final String RELATION_IMPLEMENT = "Implement";
-    public static final String RELATION_IMPORT = "Import";
-    public static final String RELATION_CALL = "Call";
-    public static final String RELATION_PARAMETER = "Parameter";
-    public static final String RELATION_RETURN = "Return";
-    public static final String RELATION_SET = "Set";
-    public static final String RELATION_USE = "Use";
-    public static final String RELATION_INHERIT = "Extend";
-	public static final String RELATION_DEFINE = "Define";
-	public static final String RELATION_CREATE = "Create";
-
-    /**
-     * Mask of dependencies.
-     * 0 - IMPORT
-     * 1 - INHERIT
-     * 2 - IMPLEMENT
-     * 3 - RECEIVE
-     * 4 - CALL
-     * 5 - SET
-     * 6 - USE
-     * 7 - PARAMETER
-     * 8 - RETURN 
-     * @param depMask
-     * @return
-     */
-	public static final ArrayList<String> resolveMask(String depMask) {
-        ArrayList<String> depedencyTypes = new ArrayList<String>();
-        for(int i = 0; i < depMask.toCharArray().length; i++) {
-            if(depMask.toCharArray()[i] == '1') {
-                if(i == 0) {
-                    depedencyTypes.add(RELATION_IMPORT);
-                }
-                else if (i == 1) {
-                    depedencyTypes.add(RELATION_INHERIT);
-                }
-                else if (i == 2) {
-                    depedencyTypes.add(RELATION_IMPLEMENT);
-                }
-                else if (i == 3) {
-                    depedencyTypes.add(RELATION_RECEIVE);
-                }
-                else if (i == 4) {
-                    depedencyTypes.add(RELATION_CALL);
-                }
-                else if (i == 5) {
-                    depedencyTypes.add(RELATION_SET);
-                }
-                else if (i == 6) {
-                    depedencyTypes.add(RELATION_USE);
-                }
-                else if (i == 7) {
-                    depedencyTypes.add(RELATION_PARAMETER);
-                }
-                else if (i == 8) {
-                    depedencyTypes.add(RELATION_RETURN);
-                }
-            }
-        }
-        return depedencyTypes;
-    }
+	public static final String IMPORT = "Import";
+	public static final String DEFINE = "Define";
+	public static final String IMPLEMENT = "Implement";
+	public static final String INHERIT = "Extend";
+	public static final String CALL = "Call";
+	public static final String PARAMETER = "Parameter";
+	public static final String RETURN = "Return";
+	public static final String SET = "Set";
+	public static final String CREATE = "Create";
+	public static final String USE = "Use";
+	public static final String RECEIVE = "Receive";
 
+	public static ArrayList<String> allDependencies() {
+		ArrayList<String> depedencyTypes = new ArrayList<String>();
+		depedencyTypes.add(IMPORT);
+		depedencyTypes.add(DEFINE);
+		depedencyTypes.add(IMPLEMENT);
+		depedencyTypes.add(INHERIT);
+		depedencyTypes.add(CALL);
+		depedencyTypes.add(PARAMETER);
+		depedencyTypes.add(RETURN);
+		depedencyTypes.add(SET);
+		depedencyTypes.add(CREATE);
+		depedencyTypes.add(USE);
+		depedencyTypes.add(RECEIVE);
+		return depedencyTypes;
+	}
 }

c3546aa8e251f4fa07c2cbc0f75bd05b3b9856b3
@@ -0,0 +1,17 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
+
+class ANSICParserExtensionConfigurationExtension extends ANSICParserExtensionConfiguration {
+
+	@Override
+	public boolean supportDeclspecSpecifiers() {
+		return true;
+	}
+
+	@Override
+	public boolean supportKnRC() {
+		return true;
+	}
+
+}

c06c44661c4b27e7f0e238160543367e6553fecf
@@ -107,6 +107,10 @@ public abstract class Entity {
 		this.qualifiedName = qualifiedName;
 	}
 
+	public void setRawName(String rawName) {
+		this.rawName = rawName;
+	}
+	
 	public String getQualifiedName() {
 		return qualifiedName;
 	}

929f78c23df835655fbbb558aff7da22eb3fa9d4
@@ -44,6 +44,9 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	
 	public void add(Entity entity) {
 		allEntitiesById.put(entity.getId(), entity);
+		if (entity instanceof FileEntity) {
+			System.out.println("**FOUND " + entity.getQualifiedName());
+		}
 		if (entity.getQualifiedName()!=null)
 			allEntieisByName.put(entity.getQualifiedName(), entity);
 		if (entity.getParent()!=null)
@@ -282,9 +285,9 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	}
 
 	@Override
-	public List<Entity> resolveImportEntity(String item) {
+	public List<Entity> resolveImportEntity(String importedName) {
 		ArrayList<Entity> result = new ArrayList<>();
-		Entity imported = this.getEntity(item);
+		Entity imported = this.getEntity(importedName);
 		if (imported==null) return result;
 		if (imported instanceof PackageEntity) { 
 			//expand import of package to all classes under the package due to we dis-courage the behavior

9e18a0c54d88fb6c260a5571c43700dd5e439e67
@@ -44,11 +44,13 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	
 	public void add(Entity entity) {
 		allEntitiesById.put(entity.getId(), entity);
-		if (entity instanceof FileEntity) {
-			System.out.println("**FOUND " + entity.getQualifiedName());
+		if (entity.getQualifiedName()!=null) {
+			if (entity.getQualifiedName().isEmpty()) {
+				allEntieisByName.put(entity.getRawName(), entity);
+			}else {
+				allEntieisByName.put(entity.getQualifiedName(), entity);
+			}
 		}
-		if (entity.getQualifiedName()!=null)
-			allEntieisByName.put(entity.getQualifiedName(), entity);
 		if (entity.getParent()!=null)
 			this.setParent(entity, entity.getParent());
 	}

fbda0152afdd1ff508bed47a1347428a9c055f91
@@ -26,10 +26,13 @@ public class FileEntity extends ContainerEntity{
 	 * @param importedName could be className, package Name  in JAVA
 	 *                     could be file in C/C++
 	 */
-	public void addImport(String importedName) {
+	public void addImport(String importedName, boolean useFileAsImportedKey) {
 		String lastName = importedName;
-        if (lastName.indexOf(".") > 0)
-        	lastName = lastName.substring(lastName.lastIndexOf(".")+1);
+		if (useFileAsImportedKey) {
+			;
+		}else if (lastName.indexOf(".") > 0) {
+			lastName = lastName.substring(lastName.lastIndexOf(".")+1);
+		}
         importedNames.put(lastName, importedName);
 	}
 	public String getImport(String lastName) {

693efac76f15e268b40b292e439296a71eadbeb9
@@ -1,6 +1,10 @@
 package depends.extractor.cpp.cdt;
 
 import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
@@ -11,6 +15,7 @@ import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
 import org.eclipse.cdt.core.parser.IScanner;
+import org.eclipse.cdt.core.parser.IScannerInfo;
 import org.eclipse.cdt.core.parser.NullLogService;
 import org.eclipse.cdt.core.parser.ParserLanguage;
 import org.eclipse.cdt.core.parser.ParserMode;
@@ -22,7 +27,12 @@ import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 
 public class CDTParser {
+	public CDTParser(List<String> includesPath) {
+		sysIncludePath = includesPath.toArray(new String[] {});
+	}
 	NullLogService NULL_LOG = new NullLogService();
+	String[] sysIncludePath = new String[] {};
+	Map<String, String> macroMap = new HashMap<>();
 	public IASTTranslationUnit parse(String file   ) {
 		/*
 		 * *    QUICK_PARSE
@@ -43,9 +53,9 @@ public class CDTParser {
 		CodeReader cr;
 		try {
 			cr = new CodeReader(file);
-			if (file.endsWith(".c"))
-				return getTranslationUnitofC(file, new String(cr.buffer));
-			else
+//			if (file.endsWith(".c"))
+//				return getTranslationUnitofC(file, new String(cr.buffer));
+//			else
 				return getTranslationUnitofCPP(file,new String(cr.buffer));
 		} catch (IOException e) {
 			System.err.println("File " + file + " does not exists!");
@@ -56,8 +66,9 @@ public class CDTParser {
 	private IASTTranslationUnit getTranslationUnitofC(String file, String content) {
 		IScannerExtensionConfiguration configuration = GCCScannerExtensionConfiguration
 				.getInstance();
+
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(), ParserLanguage.C,
+				content.toCharArray()),  new ScannerInfo(macroMap,sysIncludePath), ParserLanguage.C,
 				NULL_LOG, configuration, null);
 		ANSICParserExtensionConfiguration conf = new ANSICParserExtensionConfiguration();
 		
@@ -71,7 +82,7 @@ public class CDTParser {
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
 				.getInstance();
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(), ParserLanguage.CPP,
+				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath), ParserLanguage.CPP,
 				new NullLogService(), configuration, null);
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
 				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),

77cc6f6c24fe3a65356102f66a6dd940056c93be
@@ -4,21 +4,24 @@ import java.util.ArrayList;
 
 public class DependencyType {
 	public static final String IMPORT = "Import";
-	public static final String DEFINE = "Define";
+	public static final String CONTAIN = "Contain";
 	public static final String IMPLEMENT = "Implement";
 	public static final String INHERIT = "Extend";
 	public static final String CALL = "Call";
 	public static final String PARAMETER = "Parameter";
 	public static final String RETURN = "Return";
 	public static final String SET = "Set";
-	public static final String CREATE = "Create";
 	public static final String USE = "Use";
 	public static final String RECEIVE = "Receive";
+	public static final String CREATE = "Create";
+	public static final String CAST = "Cast";
+	public static final String THROW = "Throw";
+	public static final String ANNOTATION = "Annotation";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();
 		depedencyTypes.add(IMPORT);
-		depedencyTypes.add(DEFINE);
+		depedencyTypes.add(CONTAIN);
 		depedencyTypes.add(IMPLEMENT);
 		depedencyTypes.add(INHERIT);
 		depedencyTypes.add(CALL);
@@ -28,6 +31,9 @@ public class DependencyType {
 		depedencyTypes.add(CREATE);
 		depedencyTypes.add(USE);
 		depedencyTypes.add(RECEIVE);
+		depedencyTypes.add(CAST);
+		depedencyTypes.add(THROW);
+		depedencyTypes.add(ANNOTATION);
 		return depedencyTypes;
 	}
 }

514e5f50140c22e2fef4a6c0fec470c75acd66d7
@@ -42,7 +42,7 @@ public class RelationCounter {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType().getId(),var.getType().getQualifiedName()));
 			else
-				System.out.println("cannot resove type of "+var.getQualifiedName());
+				System.out.println("cannot resolve type of "+var.getQualifiedName());
 		}
 		for (TypeEntity type:entity.getResolvedAnnotations()) {
 			entity.addRelation(new Relation(DependencyType.USE,type.getId(),type.getQualifiedName()));
@@ -54,7 +54,7 @@ public class RelationCounter {
 		HashSet<TypeEntity> usedEntities = new HashSet<>();
 		for (Expression expression:entity.expressions().values()){
 			if (expression.type==null) {
-				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
+//				System.out.println("not resolved expression:" + expression.text + " in " + entity.getQualifiedName());
 				continue;
 			}
 			if (expression.isCall) {

2bbd11a99d45c8829ea155f47428c0fe8e7dd13e
@@ -7,7 +7,6 @@ import java.util.HashMap;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
-import depends.util.Tuple;
 
 public abstract class ContainerEntity extends Entity {
 	private ArrayList<VarEntity> vars;
@@ -68,7 +67,7 @@ public abstract class ContainerEntity extends Entity {
 	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter);
+			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter,true);
 			if (typeEntity != null)
 				r.add(typeEntity);
 		}
@@ -98,57 +97,44 @@ public abstract class ContainerEntity extends Entity {
 	private void resolveExpressions(TypeInfer typeInferer) {
 		for (Expression expression : expressions.values()) {
 			//1. if expression's type existed, break;
-			if (expression.type != null)
+			if (expression.getType() != null)
 				continue;
 			
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.type = typeInferer.inferType(this, expression.rawType);
-			}else if(expression.identifier != null) {
-				if (expression.identifier.contains(".")) {
-					/* if it is a qualified name */
-					Tuple<TypeEntity, String> result = typeInferer.locateTypeOfQualifiedName(this, expression.identifier);
-					if (result != null) {
-						if (result.y == null) {
-							expression.type = result.x;
-						} else {
-							expression.type = typeInferer.inferType(result.x, result.y);
-						}
-					}
-				} else {
-					/* expression identifiers could be a variable, or a type. try them */
-					expression.type = lookupVarDefinition(expression.identifier);
-					if (expression.type==null)
-						expression.type = typeInferer.inferType(this, expression.identifier);
+				expression.setType(typeInferer.inferType(this, expression.rawType,true),typeInferer);
+			}else if (expression.isDot){ //wait for previous
+				continue;
+			} else if (expression.rawType!=null) {
+				expression.setType(typeInferer.inferType(this, expression.rawType, true),typeInferer);
+				if (expression.getType() !=null) {
+					 continue;
 				}
 			}
-			
-			//3. if new found type of expression, update parent expressions
-			if (expression.type != null) {
-				expression.deduceParentType(this.expressions,typeInferer);
+			if (expression.identifier!=null) { 
+				TypeEntity type = typeInferer.inferType(this, expression.identifier, false);
+				if (type!=null) {
+					expression.setType(type,typeInferer);
+					continue;
+				}
+				if (expression.isCall) {
+					FunctionEntity func = typeInferer.resolveFunctionBindings(this, expression.identifier);
+					if (func!=null) {
+						expression.setType(func.getReturnType(),typeInferer);
+					}
+				}else {
+					VarEntity varEntity = this.resolveVarBindings(expression.identifier);
+					if (varEntity!=null) {
+						expression.setType( varEntity.getType(),typeInferer);
+					}
+				}
 			}
 		}
 	}
 
 
-	/**
-	 * Found the given type of given var;
-	 * Must be invoked after all vars' type have been resolved
-	 * Should be override if new vars have been added, for example 
-	 * Function Type could resolve parameters as vars
-	 * @param identifier  - var identifiers
-	 * @return
-	 */
-	public TypeEntity lookupVarDefinition(String identifier) {
-		for (VarEntity var : this.vars) {
-			if (var.getRawName().equals(identifier))
-				return var.getType();
-		}
-		if (this.parent != null && this.parent instanceof ContainerEntity)
-			return ((ContainerEntity) this.parent).lookupVarDefinition(identifier);
-		return null;
-	}
+	
 
 	public Collection<TypeEntity> getResolvedTypeParameters() {
 		return resolvedTypeParameters;
@@ -165,4 +151,28 @@ public abstract class ContainerEntity extends Entity {
 	public void setResolvedAnnotations(Collection<TypeEntity> resolvedAnnotations) {
 		this.resolvedAnnotations = resolvedAnnotations;
 	}
+
+	public String dumpExpressions() {
+		StringBuilder sb = new StringBuilder();
+		for (Expression exp:expressions.values()) {
+			sb.append(exp.toString()).append("\n");
+		}
+		return sb.toString();
+	}
+	
+	/**
+	 * To found the var. Must be invoked after all entities var binding solved
+	 * @param fromEntity
+	 * @param varName
+	 * @return
+	 */
+	public VarEntity resolveVarBindings(String varName) {
+		for (VarEntity var:getVars()) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		if (parent !=null && parent instanceof ContainerEntity)
+			return ((ContainerEntity)parent).resolveVarBindings(varName);
+		return null;
+	}
 }

49f027b2a9bf58cdd3977f254da5ecc11a1015b4
@@ -3,6 +3,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
@@ -32,6 +33,10 @@ public abstract class ContainerEntity extends Entity {
 	public void addTypeParameter(String typeName) {
 		this.typeParameters.add(typeName);
 	}
+	
+	public void addTypeParameter(List<String> parameters) {
+		this.typeParameters.addAll(parameters);
+	}
 
 	public void addVar(VarEntity var) {
 		this.vars.add(var);
@@ -87,14 +92,13 @@ public abstract class ContainerEntity extends Entity {
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);
 		}
-		resolveExpressions(typeInferer);
 	}
 
 	/**
 	 * Resolve all expression's type
 	 * @param typeInferer
 	 */
-	private void resolveExpressions(TypeInfer typeInferer) {
+	public void resolveExpressions(TypeInfer typeInferer) {
 		for (Expression expression : expressions.values()) {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
@@ -175,4 +179,11 @@ public abstract class ContainerEntity extends Entity {
 			return ((ContainerEntity)parent).resolveVarBindings(varName);
 		return null;
 	}
+
+	public boolean isGenericTypeParameter(String rawType) {
+		if (this.typeParameters.contains(rawType)) return true;
+		if (this.getParent()==null || !(this.getParent() instanceof ContainerEntity))
+			return false;
+		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
+	}
 }

1c61f764c336b8eee01947e503f3fa03e7994566
@@ -73,6 +73,11 @@ public abstract class ContainerEntity extends Entity {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
 			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter,true);
+			if (typeEntity==null) {
+				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
+					typeEntity = TypeInfer.genericParameterType;
+				}
+			}
 			if (typeEntity != null)
 				r.add(typeEntity);
 		}

bd983fec851a961323dab11367d9e59a7023ca61
@@ -1,6 +1,8 @@
 package depends.extractor.cpp.cdt;
 
+import java.io.File;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -9,7 +11,6 @@ import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.c.ANSICParserExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.c.GCCScannerExtensionConfiguration;
-import org.eclipse.cdt.core.dom.parser.cpp.GPPParserExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
@@ -25,15 +26,25 @@ import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 
 public class CDTParser {
+	List<String> sysIncludePath = new ArrayList<>();
+
 	public CDTParser() {
-		sysIncludePath = new String[0];
 	}
 	
 	public CDTParser(List<String> includesPath) {
-		sysIncludePath = includesPath.toArray(new String[] {});
+		for (String f:includesPath) {
+			File file = new File(f);
+			if (file.exists()) {
+				try {
+					sysIncludePath.add(file.getCanonicalPath());
+				} catch (IOException e) {
+				}
+			}else {
+				System.err.println("include path " + f + " does not exist!");
+			}
+		}
 	}
 	NullLogService NULL_LOG = new NullLogService();
-	String[] sysIncludePath = new String[] {};
 	Map<String, String> macroMap = new HashMap<>();
 	public IASTTranslationUnit parse(String file   ) {
 		/*
@@ -70,7 +81,7 @@ public class CDTParser {
 				.getInstance();
 
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()),  new ScannerInfo(macroMap,sysIncludePath), ParserLanguage.C,
+				content.toCharArray()),  new ScannerInfo(macroMap,sysIncludePath.toArray(new String[] {})), ParserLanguage.C,
 				NULL_LOG, configuration, null);
 		ANSICParserExtensionConfiguration conf = new ANSICParserExtensionConfiguration();
 		
@@ -84,7 +95,7 @@ public class CDTParser {
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
 				.getInstance();
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath), ParserLanguage.CPP,
+				content.toCharArray()), new ScannerInfo(new HashMap<>(),sysIncludePath.toArray(new String[] {})), ParserLanguage.CPP,
 				new NullLogService(), configuration, null);
 		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
 				scanner, ParserMode.COMPLETE_PARSE, new NullLogService(),

aba8fb72dd18a575c29b24940a2712782dd0b09a
@@ -0,0 +1,13 @@
+package depends.extractor.cpp;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.cpp.cdt.FileIndex;
+
+public abstract class CppParserTest {
+	protected EntityRepo repo = new EntityRepo();
+    protected FileIndex fileIndex = new FileIndex();
+    public void init() {
+    	repo = new EntityRepo();
+    	fileIndex = new FileIndex();
+    }
+}

29f15a38e90bf52a25c92c4054cb6770c9cc4d12
@@ -40,7 +40,7 @@ public class CDTParser {
 				} catch (IOException e) {
 				}
 			}else {
-				System.err.println("include path " + f + " does not exist!");
+				//System.err.println("include path " + f + " does not exist!");
 			}
 		}
 	}

341cc6eead0bea9559ac6d33889d3dbe66f078be
@@ -0,0 +1,61 @@
+package depends.extractor.cpp.cdt;
+
+import org.eclipse.cdt.core.dom.ast.IASTComment;
+import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
+import org.eclipse.cdt.internal.core.dom.parser.ASTTranslationUnit;
+
+public class CommentManager {
+
+	private IASTTranslationUnit translationUnit;
+	IASTComment[] comments;
+	boolean[] joinWithNext;
+	public CommentManager(IASTTranslationUnit translationUnit) {
+		this.translationUnit = translationUnit;
+		comments = ((ASTTranslationUnit) translationUnit).getComments();
+		joinWithNext = new boolean[comments.length];
+		
+		
+		for (int i=1;i<comments.length;i++) {
+			IASTComment previous = comments[i-1];
+			int previousEnd = (previous.getFileLocation().getNodeOffset()+
+					previous.getFileLocation().getNodeLength());
+			IASTComment current = comments[i];
+			if (current.getFileLocation().getNodeOffset()-previousEnd<5)
+				joinWithNext[i-1] = true;
+			else
+				joinWithNext[i-1] = false;
+		}
+		joinWithNext[comments.length-1] = false;
+	}
+
+	public String getLeadingCommentText(int startOffset) {
+		int adjacent = findCommentIndex(startOffset);
+		if (adjacent==-1) return "";
+		String comment = new String( comments[adjacent].getComment());
+		int i=adjacent-1;
+		while(i>=0) {
+			if (joinWithNext[i]) {
+				comment = new String(comments[i].getComment())+comment;
+				i--;
+			}else {
+				break;
+			}
+		}
+		return comment;
+	}
+	private int findCommentIndex(int startOffset) {
+		
+		IASTComment[] comments = ((ASTTranslationUnit) translationUnit).getComments();
+		int i=0;
+		for (;i<comments.length;i++) {
+			IASTComment c = comments[i];
+			int gap = startOffset-(c.getFileLocation().getNodeOffset()+
+					c.getFileLocation().getNodeLength());
+			if (gap>0 && gap<10) {
+				break;
+			}
+			if (gap<0) return -1;
+		}
+		return i>=comments.length?-1:i;
+	}
+}

ef6313afbf9eed528f73188beec32975621fe6f5
@@ -107,7 +107,13 @@ public class RelationCounter {
 	private void computeImports(FileEntity file) {
 		List<Entity> imports = file.getResolvedImportedEntities();
 		for (Entity imported:imports) {
-			file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			if (imported instanceof FileEntity)
+			{
+				if (((FileEntity)imported).isInProjectScope())
+					file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			}else {
+				file.addRelation(new Relation(DependencyType.IMPORT,imported.getId()));
+			}
 		}
 	}
 

d5a1da5bf7c11be6b6bc1f8e10061d0b430edf63
@@ -99,7 +99,11 @@ public class RelationCounter {
 				System.out.println("unsolved param: "+parameter);
 			}
 		}
+		if (func==null || func.getThrowTypes()==null) {
+			System.out.println("ERROR");
+		}
 		for (TypeEntity throwType:func.getThrowTypes()) {
+			
 			func.addRelation(new Relation(DependencyType.THROW,throwType.getId(),throwType.getQualifiedName()));
 		}
 	}

e4d476ed33ca7ac4532a05d4573d69197786ed22
@@ -33,6 +33,7 @@ public abstract class Entity {
 	}
     
 	private void deduceQualifiedName() {
+		rawName = rawName.replace("::","." );
 		if (this.rawName.contains(".")) {
 			this.qualifiedName = this.rawName;
 			return; //already qualified
@@ -50,7 +51,9 @@ public abstract class Entity {
 			return;
 		}
 		this.qualifiedName= parent.getQualifiedName()+"." + rawName;
-
+		if (rawName.startsWith(".")) {
+			rawName = rawName.substring(2);
+		}
 	}
 
 

5e0c9d2342725070a1388ec75b00e52d4f039b27
@@ -0,0 +1,21 @@
+package depends.extractor.cpp;
+
+import depends.entity.Entity;
+import depends.entity.repo.EntityRepo;
+import depends.entity.types.FileEntity;
+import depends.extractor.ImportLookupStrategy;
+
+public class CppImportLookupStrategy implements ImportLookupStrategy {
+
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, boolean typeOnly) {
+		for (String file:fileEntity.imports()) {
+			FileEntity importedFile = (FileEntity) repo.getEntity(file);
+			if (importedFile==null) continue;
+			Entity entity = repo.lookupTypes(importedFile,name,typeOnly);
+			if (entity!=null) return entity;
+		}		
+		return null;
+	}
+
+}

181e9d674d5eed1289ab4db6f21fa27ed4e8c346
@@ -149,4 +149,6 @@ public abstract class Entity {
 		}
 		return null;
 	}
+
+	
 }

db5fefa01250cf0eb31d7956fe3b707028703da8
@@ -4,7 +4,10 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Set;
 
+import depends.addons.InvalidTypeChecker;
+import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
@@ -93,6 +96,13 @@ public abstract class ContainerEntity extends Entity {
 		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelTypes(typeInferer);
+			VarEntity param = var;
+			if (InvalidTypeChecker.getInst().isInvalid(param.getRawType()) &&
+					(param.getType()==null ||
+					param.getType()==TypeInfer.externalType)) {
+				System.out.println("...");
+				param.inferLocalLevelTypes(typeInferer);
+			}
 		}
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);
@@ -191,4 +201,26 @@ public abstract class ContainerEntity extends Entity {
 			return false;
 		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
 	}
+
+	@Override
+	public Set<String> resolveBinding(EntityRepo registry) {
+		Set<String> unsolved =  super.resolveBinding(registry);
+		for (VarEntity var:this.vars) {
+			if (var.getType()==null)
+				unsolved.add(var.getRawType());
+			else if (var.getType()==(TypeInfer.externalType))
+				unsolved.add(var.getRawType());
+		}
+		for (FunctionEntity func:this.functions) {
+			for (VarEntity param:func.getParameters()) {
+				if (param.getType()==null)
+					unsolved.add(param.getRawType());
+				else if (param.getType()==(TypeInfer.externalType))
+					unsolved.add(param.getRawType());
+			}
+		}
+		return unsolved;
+	}
+	
+	
 }

a22c9ff2e032f91499c716c660cfa1f30d5799db
@@ -6,7 +6,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
-import depends.addons.InvalidTypeChecker;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
@@ -96,13 +95,6 @@ public abstract class ContainerEntity extends Entity {
 		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelTypes(typeInferer);
-			VarEntity param = var;
-			if (InvalidTypeChecker.getInst().isInvalid(param.getRawType()) &&
-					(param.getType()==null ||
-					param.getType()==TypeInfer.externalType)) {
-				System.out.println("...");
-				param.inferLocalLevelTypes(typeInferer);
-			}
 		}
 		for (FunctionEntity func:this.functions) {
 			func.inferLocalLevelTypes(typeInferer);

ce0800e38c7c40f081366c3fa7da3333d5b7c127
@@ -1,6 +1,5 @@
 package depends.entity.repo;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -16,11 +15,11 @@ import depends.entity.RelationCounter;
 import depends.entity.TypeInfer;
 import depends.entity.types.FileEntity;
 import depends.entity.types.FunctionEntity;
-import depends.entity.types.PackageEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 import depends.extractor.BuiltInTypeIdenfier;
 import depends.extractor.ImportLookupStrategy;
+import depends.extractor.java.JavaImportLookupStrategy;
 import depends.importtypes.Import;
 import depends.util.Tuple;
 
@@ -29,7 +28,7 @@ public class EntityRepo implements IdGenerator,TypeInfer{
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
 	private int nextAvaliableIndex;
 	private BuiltInTypeIdenfier buildInProcessor = new NullParser();
-	private ImportLookupStrategy importLookupStrategy;
+	private ImportLookupStrategy importLookupStrategy = new JavaImportLookupStrategy();
 	public ImportLookupStrategy getImportLookupStrategy() {
 		return importLookupStrategy;
 	}

e4b618919987fce314df59a31e553e538acf61f0

46a2c7ff0cbeb8166f18c8819e65a3288dca77dc
@@ -6,6 +6,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
+import depends.entity.TypeInfer.InferData;
 import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
@@ -74,7 +75,7 @@ public abstract class ContainerEntity extends Entity {
 	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = typeInferer.inferType(this, typeParameter,true);
+			TypeEntity typeEntity = typeInferer.inferTypeType(this, typeParameter);
 			if (typeEntity==null) {
 				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
 					typeEntity = TypeInfer.genericParameterType;
@@ -114,30 +115,31 @@ public abstract class ContainerEntity extends Entity {
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.setType(typeInferer.inferType(this, expression.rawType,true),typeInferer);
+				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
 			}else if (expression.isDot){ //wait for previous
 				continue;
 			} else if (expression.rawType!=null) {
-				expression.setType(typeInferer.inferType(this, expression.rawType, true),typeInferer);
+				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
 				if (expression.getType() !=null) {
 					 continue;
 				}
 			}
 			if (expression.identifier!=null) { 
-				TypeEntity type = typeInferer.inferType(this, expression.identifier, false);
+				//TODO: how to infer type also include vars
+				InferData type = typeInferer.inferType(this, expression.identifier);
 				if (type!=null) {
-					expression.setType(type,typeInferer);
+					expression.setType(type.type,type.entity,typeInferer);
 					continue;
 				}
 				if (expression.isCall) {
 					FunctionEntity func = typeInferer.resolveFunctionBindings(this, expression.identifier);
 					if (func!=null) {
-						expression.setType(func.getReturnType(),typeInferer);
+						expression.setType(func.getReturnType(),func,typeInferer);
 					}
 				}else {
 					VarEntity varEntity = this.resolveVarBindings(expression.identifier);
 					if (varEntity!=null) {
-						expression.setType( varEntity.getType(),typeInferer);
+						expression.setType( varEntity.getType(),varEntity,typeInferer);
 					}
 				}
 			}

8b5422eebe485504a20d61d927770aad1c3d8864
@@ -4,14 +4,15 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
-import java.util.Set;
 
-import depends.entity.TypeInfer.InferData;
-import depends.entity.repo.EntityRepo;
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
 
+/**
+ * ContainerEntity for example file, class, method, etc.
+ * they could contain vars, functions, ecpressions, type parameters, etc.
+ */
 public abstract class ContainerEntity extends Entity {
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
@@ -21,10 +22,6 @@ public abstract class ContainerEntity extends Entity {
 	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
 	private Collection<TypeEntity> resolvedAnnotations = new ArrayList<>();
 
-	public void addAnnotation(String name) {
-		this.annotations.add(name);
-	}
-
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
@@ -32,7 +29,11 @@ public abstract class ContainerEntity extends Entity {
 		expressions = new HashMap<>();
 		typeParameters = new ArrayList<>();
 	}
-
+	
+	public void addAnnotation(String name) {
+		this.annotations.add(name);
+	}
+	
 	public void addTypeParameter(String typeName) {
 		this.typeParameters.add(typeName);
 	}
@@ -68,17 +69,17 @@ public abstract class ContainerEntity extends Entity {
 	/**
 	 * A common utility function used to transfer the identifiers 
 	 * to types.
-	 * @param typeInferer - the inferer object 
+	 * @param inferer - the inferer object 
 	 * @param identifiers - the identifiers will be translated
 	 * @return The translated Types
 	 */
-	protected Collection<TypeEntity> identiferToTypes(TypeInfer typeInferer, Collection<String> identifiers) {
+	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
 		ArrayList<TypeEntity> r = new ArrayList<>();
 		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = typeInferer.inferTypeType(this, typeParameter);
+			TypeEntity typeEntity = inferer.inferTypeFromName(this, typeParameter);
 			if (typeEntity==null) {
 				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
-					typeEntity = TypeInfer.genericParameterType;
+					typeEntity = Inferer.genericParameterType;
 				}
 			}
 			if (typeEntity != null)
@@ -91,22 +92,22 @@ public abstract class ContainerEntity extends Entity {
 	 * For all data in the class, infer their types.
 	 * Should be override in sub-classes 
 	 */
-	public void inferLocalLevelTypes(TypeInfer typeInferer) {
-		setResolvedTypeParameters(identiferToTypes(typeInferer, typeParameters));
-		resolvedAnnotations = identiferToTypes(typeInferer, annotations);
+	public void inferLocalLevelEntities(Inferer inferer) {
+		resolvedTypeParameters = identiferToTypes(inferer, typeParameters);
+		resolvedAnnotations = identiferToTypes(inferer, annotations);
 		for (VarEntity var : this.vars) {
-			var.inferLocalLevelTypes(typeInferer);
+			var.inferLocalLevelEntities(inferer);
 		}
 		for (FunctionEntity func:this.functions) {
-			func.inferLocalLevelTypes(typeInferer);
+			func.inferLocalLevelEntities(inferer);
 		}
 	}
 
 	/**
 	 * Resolve all expression's type
-	 * @param typeInferer
+	 * @param inferer
 	 */
-	public void resolveExpressions(TypeInfer typeInferer) {
+	public void resolveExpressions(Inferer inferer) {
 		for (Expression expression : expressions.values()) {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
@@ -115,31 +116,30 @@ public abstract class ContainerEntity extends Entity {
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
 			}else if (expression.isDot){ //wait for previous
 				continue;
 			} else if (expression.rawType!=null) {
-				expression.setType(typeInferer.inferTypeType(this, expression.rawType),null,typeInferer);
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
 				if (expression.getType() !=null) {
 					 continue;
 				}
 			}
 			if (expression.identifier!=null) { 
-				//TODO: how to infer type also include vars
-				InferData type = typeInferer.inferType(this, expression.identifier);
-				if (type!=null) {
-					expression.setType(type.type,type.entity,typeInferer);
+				Entity entity = inferer.resolveName(this, expression.identifier, true);
+				if (entity!=null) {
+					expression.setType(entity.getType(),entity,inferer);
 					continue;
 				}
 				if (expression.isCall) {
-					FunctionEntity func = typeInferer.resolveFunctionBindings(this, expression.identifier);
+					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
 					if (func!=null) {
-						expression.setType(func.getReturnType(),func,typeInferer);
+						expression.setType(func.getType(),func,inferer);
 					}
 				}else {
-					VarEntity varEntity = this.resolveVarBindings(expression.identifier);
+					VarEntity varEntity = this.lookupVarsInVisibleScope(expression.identifier);
 					if (varEntity!=null) {
-						expression.setType( varEntity.getType(),varEntity,typeInferer);
+						expression.setType( varEntity.getType(),varEntity,inferer);
 					}
 				}
 			}
@@ -153,17 +153,11 @@ public abstract class ContainerEntity extends Entity {
 		return resolvedTypeParameters;
 	}
 
-	public void setResolvedTypeParameters(Collection<TypeEntity> resolvedTypeParameters) {
-		this.resolvedTypeParameters = resolvedTypeParameters;
-	}
 
 	public Collection<TypeEntity> getResolvedAnnotations() {
 		return resolvedAnnotations;
 	}
 
-	public void setResolvedAnnotations(Collection<TypeEntity> resolvedAnnotations) {
-		this.resolvedAnnotations = resolvedAnnotations;
-	}
 
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();
@@ -173,21 +167,7 @@ public abstract class ContainerEntity extends Entity {
 		return sb.toString();
 	}
 	
-	/**
-	 * To found the var. Must be invoked after all entities var binding solved
-	 * @param fromEntity
-	 * @param varName
-	 * @return
-	 */
-	public VarEntity resolveVarBindings(String varName) {
-		for (VarEntity var:getVars()) {
-			if (var.getRawName().equals(varName))
-				return var;
-		}
-		if (parent !=null && parent instanceof ContainerEntity)
-			return ((ContainerEntity)parent).resolveVarBindings(varName);
-		return null;
-	}
+
 
 	public boolean isGenericTypeParameter(String rawType) {
 		if (this.typeParameters.contains(rawType)) return true;
@@ -196,25 +176,51 @@ public abstract class ContainerEntity extends Entity {
 		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
 	}
 
-	@Override
-	public Set<String> resolveBinding(EntityRepo registry) {
-		Set<String> unsolved =  super.resolveBinding(registry);
-		for (VarEntity var:this.vars) {
-			if (var.getType()==null)
-				unsolved.add(var.getRawType());
-			else if (var.getType()==(TypeInfer.externalType))
-				unsolved.add(var.getRawType());
+	protected FunctionEntity lookupFunctionLocally(String functionName) {
+		for (FunctionEntity func : getFunctions()) {
+			if (func.getRawName().equals(functionName))
+				return func;
 		}
-		for (FunctionEntity func:this.functions) {
-			for (VarEntity param:func.getParameters()) {
-				if (param.getType()==null)
-					unsolved.add(param.getRawType());
-				else if (param.getType()==(TypeInfer.externalType))
-					unsolved.add(param.getRawType());
+		return null;
+	}
+	
+	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+		ContainerEntity fromEntity = this;
+		while (fromEntity != null) {
+			if (fromEntity instanceof ContainerEntity) {
+				FunctionEntity func = ((ContainerEntity) fromEntity).lookupFunctionLocally(functionName);
+				if (func != null)
+					return func;
 			}
+			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
 		}
-		return unsolved;
+		return null;
 	}
 	
-	
+	/**
+	 * To found the var. Must be invoked after all entities var binding solved
+	 * @param fromEntity
+	 * @param varName
+	 * @return
+	 */
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		ContainerEntity fromEntity = this;
+		while (fromEntity != null) {
+			if (fromEntity instanceof ContainerEntity) {
+				VarEntity var = ((ContainerEntity) fromEntity).lookupVarLocally(varName);
+				if (var != null)
+					return var;
+			}
+			fromEntity = (ContainerEntity) this.getAncestorOfType(ContainerEntity.class);
+		}
+		return null;
+	}
+
+	private VarEntity lookupVarLocally(String varName) {
+		for (VarEntity var:getVars()) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		return null;
+	}
 }

ce24334dfe3996db900e2dac3024f0ada2221ad9
@@ -1,12 +1,8 @@
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.entity.types.FunctionEntity;
 import depends.entity.types.TypeEntity;
 import depends.entity.types.VarEntity;
-import depends.util.Tuple;
 
 public class Expression {
 	public Integer id;
@@ -23,7 +19,6 @@ public class Expression {
 	public boolean isCreate = false;
 	public boolean isCast = false;
 	public boolean deriveTypeFromChild = true;
-	List<Tuple<String, String>> relations = new ArrayList<>();
 
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy

8adac2f585f2d77b66648941dffe59cc38346cd0
@@ -6,7 +6,7 @@ import java.util.List;
 import org.antlr.v4.runtime.RuleContext;
 
 import depends.extractor.HandlerContext;
-import depends.javaextractor.JavaParser.AnnotationContext;
+import depends.extractor.java.JavaParser.AnnotationContext;
 
 public class AnnotationProcessor {
 	private HandlerContext context;

00839bc62c41d134d4b8940df6cfdf9735b39d24
@@ -100,7 +100,6 @@ public class ExpressionUsage {
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly
 			expression.rawType = ASTStringUtil.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
-			System.out.println(expression.rawType);
 			//TODO: check
 		}
 	}

cd1f50fb071c1fb639ea104624926524208cea5e
@@ -1,10 +1,7 @@
-package depends.entity.types;
+package depends.entity;
 
 import java.util.UUID;
 
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-
 public class AnonymousBlock extends ContainerEntity{
     public AnonymousBlock(Entity parent, Integer id) {
     	super(UUID.randomUUID().toString(),  parent, id);

4f0b1df3a334f787eb61192a37f3e287b119d4d6
@@ -26,7 +26,7 @@ public class FileDependencyGenerator {
         		if (relation.getEntity().getId()>=0) {
         			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
         			if (fileEntityTo==-1) continue;
-        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo);
+        			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
         		}
         	}
         }

f1049dbfb62200c376b84dbba7a85bcfe4790c84
@@ -34,18 +34,7 @@ public class FileDependencyGenerator {
 		return dependencyMatrix;
 	}
 
-	/**
-	 * Build the dependency matrix (re-mapped all dependencies with 0-based values 
-	 * to align with node indexes)
-	 * @param entityRepo which contains entities and relations
-	 * @return the generated dependency matrix
-	 */
-	public DependencyMatrix buildWithRemap(EntityRepo repo) {
-		DependencyMatrix r = build(repo);
-		r.remapIds(repo);
-		return r;
-	}
-
+	
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null)

5680591519e0ecdee063a350b54094fd4bc1be2e
@@ -0,0 +1,62 @@
+package depends;
+
+import picocli.CommandLine.Command;
+import picocli.CommandLine.Option;
+import picocli.CommandLine.Parameters;
+
+@Command(name = "Multi-Lanaguage Dependency Analyzer")
+public class DependsCommand {
+	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
+    private String lang;
+	@Parameters(index = "1", description = "The directory to be analyzed")
+    private String src;
+	@Parameters(index = "2",  description = "The output file name")
+	private String output;
+    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
+    private String[] format=new String[]{"json"};
+	@Option(names = {"-d", "--dir"},  description = "The output directory")
+	private String dir;
+	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
+    private boolean dv8map = true;
+    @Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
+    private String[] includes = new String[] {};
+    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+    boolean help;
+	public String getLang() {
+		return lang;
+	}
+	public void setLang(String lang) {
+		this.lang = lang;
+	}
+	public String getSrc() {
+		return src;
+	}
+	public void setSrc(String src) {
+		this.src = src;
+	}
+	public String getOutputName() {
+		return output;
+	}
+	public void setOutput(String output) {
+		this.output = output;
+	}
+	public String[] getFormat() {
+		return format;
+	}
+	public String getOutputDir() {
+		if (dir==null) {
+			dir = System.getProperty("user.dir");
+		}
+		return dir;
+	}
+	public boolean isDv8map() {
+		return dv8map;
+	}
+	public String[] getIncludes() {
+		return includes;
+	}
+	public boolean isHelp() {
+		return help;
+	}
+
+}

d75bb68166a3d2831a4cd3c2c2d1cb077a4d3c94
@@ -4,7 +4,7 @@ import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
-@Command(name = "Multi-Lanaguage Dependency Analyzer")
+@Command(name = "depends")
 public class DependsCommand {
 	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
     private String lang;

29fb9ac38c0b9c83ed8f93a08d59115e196d7c47
@@ -0,0 +1,38 @@
+package depends.extractor.ruby;
+
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.repo.EntityRepo;
+import depends.importtypes.Import;
+import depends.relations.ImportLookupStrategy;
+import depends.relations.Inferer;
+
+public class RubyImportLookupStrategy implements ImportLookupStrategy {
+
+	@Override
+	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public List<Entity> getImportedFiles(List<Import> importedNames, EntityRepo repo) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+}

c959bbff1e112d5ea1fbb8fa3122ebe247020799
@@ -18,7 +18,9 @@ public class DependsCommand {
 	private String dir;
 	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
     private boolean dv8map = true;
-    @Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
+    private String granularity="file";
+	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
@@ -58,5 +60,8 @@ public class DependsCommand {
 	public boolean isHelp() {
 		return help;
 	}
+    public String getGranularity() {
+		return granularity;
+	}
 
 }

f428f1b0d12cd8121dcbe98a558d7ddddd7e59cd
@@ -0,0 +1,56 @@
+package depends.matrix;
+
+import java.util.ArrayList;
+
+import depends.entity.Entity;
+import depends.entity.FileEntity;
+import depends.entity.FunctionEntity;
+import depends.entity.repo.EntityRepo;
+import depends.relations.Relation;
+
+public class FunctionDependencyGenerator implements DependencyGenerator {
+	/**
+	 * Build the dependency matrix (without re-mapping file id)
+	 * 
+	 * @param entityRepo which contains entities and relations
+	 * @return the generated dependency matrix
+	 */
+	@Override
+	public DependencyMatrix build(EntityRepo entityRepo) {
+		DependencyMatrix dependencyMatrix = new DependencyMatrix();
+		ArrayList<String> elements = new ArrayList<String>();
+		for (Entity entity : entityRepo.getEntities()) {
+			if (entity instanceof FunctionEntity) {
+				elements.add(entity.getRawName());
+			}
+			int fileEntityFrom = getFunctionEntityIdNoException(entity);
+			if (fileEntityFrom == -1)
+				continue;
+			for (Relation relation : entity.getRelations()) {
+				if (relation.getEntity().getId() >= 0) {
+					int fileEntityTo = getFunctionEntityIdNoException(relation.getEntity());
+					if (fileEntityTo == -1)
+						continue;
+					dependencyMatrix.addDependency(relation.getType(), fileEntityFrom, fileEntityTo, entity,
+							relation.getEntity());
+				}
+			}
+		}
+		dependencyMatrix.setNodes(elements);
+		return dependencyMatrix;
+	}
+
+	private String getFileNameNoException(Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
+		if (ancestor == null)
+			return "";
+		return ancestor.getRawName();
+	}
+
+	private int getFunctionEntityIdNoException(Entity entity) {
+		Entity ancestor = entity.getAncestorOfType(FunctionEntity.class);
+		if (ancestor == null)
+			return -1;
+		return ancestor.getId();
+	}
+}

71c2604390fa83b01f05f532a4bd517954cf9291
@@ -21,7 +21,7 @@ public class CppExpressionTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(19,repo.getEntity("foo").getRelations().size());
+        assertEquals(21,repo.getEntity("foo").getRelations().size());
 	}
 
 }

992902c9aae4fd38c81ec8de2339201d5713c288
@@ -1,11 +1,13 @@
 package depends.entity;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import depends.relations.Inferer;
 
 /**
@@ -13,6 +15,8 @@ import depends.relations.Inferer;
  * they could contain vars, functions, ecpressions, type parameters, etc.
  */
 public abstract class ContainerEntity extends Entity {
+	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
+
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Integer, Expression> expressions;
@@ -42,6 +46,9 @@ public abstract class ContainerEntity extends Entity {
 	}
 
 	public void addVar(VarEntity var) {
+		if (logger.isDebugEnabled()) {
+			logger.debug("var found: "+var.getRawName() +  ":" + var.getRawType());
+		}
 		this.vars.add(var);
 	}
 

33164746577c8f86213410cf8db64a6def541cbd
@@ -19,7 +19,7 @@ public abstract class ContainerEntity extends Entity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	private HashMap<Integer, Expression> expressions;
+	private HashMap<Object, Expression> expressions;
 	private Collection<String> typeParameters; // Generic type parameters like <T>, <String>, <? extends Object>
 	private Collection<String> annotations = new ArrayList<>();
 	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
@@ -64,7 +64,7 @@ public abstract class ContainerEntity extends Entity {
 		return this.functions;
 	}
 
-	public HashMap<Integer, Expression> expressions() {
+	public HashMap<Object, Expression> expressions() {
 		return expressions;
 	}
 

7de3a2b21ce01537ff6853c95bd0ba5dd1231691
@@ -8,6 +8,7 @@ import java.util.List;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import depends.extractor.java.JavaParser.ExpressionContext;
 import depends.relations.Inferer;
 
 /**
@@ -68,8 +69,8 @@ public abstract class ContainerEntity extends Entity {
 		return expressions;
 	}
 
-	public void addExpression(Expression expression) {
-		expressions.put(expression.id, expression);
+	public void addExpression(Object key, Expression expression) {
+		expressions.put(key, expression);
 	}
 
 	/**

01385475c619bd05e7e24f43d0ccb0ef5ced69cc
@@ -36,13 +36,14 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId(),parent==null?null:parent.id);
+		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
+		context.lastContainer().addExpression(ctx,expression);
+
 		if (parent!=null) {
 			if (parent.deduceTypeBasedId==null) parent.deduceTypeBasedId = expression.id;
 			expression.parent = parent;
 		}
 		
-		context.lastContainer().addExpression(ctx,expression);
-		expression.text = ctx.getRawSignature(); //for debug purpose. no actual effect
 		
 		if (isTerminalExpression(ctx)) {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);
@@ -55,23 +56,15 @@ public class ExpressionUsage {
 		if (ctx instanceof ICPPASTNewExpression){
 			expression.isCreate = true;
 		}		
-/**
+		expression.isDot = isDot(ctx);
+
+		/**
  *    | expression bop='.'
       ( IDENTIFIER
       | methodCall
       )
  */
-		expression.isDot = isDot(ctx);
-		if (expression.isDot) {
-			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
-			if (op2 instanceof IASTIdExpression)
-				expression.identifier = ((IASTIdExpression)op2).getName().toString();
-			else if (op2 instanceof IASTLiteralExpression)
-				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
-			else if (op2 instanceof IASTFunctionCallExpression)
-				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
-			return;
-		}
+
 		//method call
 		if (ctx instanceof IASTFunctionCallExpression) {
 			expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)ctx);
@@ -80,15 +73,25 @@ public class ExpressionUsage {
 		if (ctx instanceof ICPPASTNewExpression) {
 			expression.rawType = ASTStringUtil.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
 			expression.isCall = true;
+			expression.deriveTypeFromChild = false;
 		}
 
 		if (ctx instanceof IASTCastExpression) {
 			expression.isCast=true;
 			expression.rawType = ASTStringUtil.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
-		}
-		if ((ctx instanceof ICPPASTNewExpression) ||(ctx instanceof IASTFunctionCallExpression)) {
 			expression.deriveTypeFromChild = false;
+
 		}
+		if (expression.isDot) {
+			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
+			if (op2 instanceof IASTIdExpression)
+				expression.identifier = ((IASTIdExpression)op2).getName().toString();
+			else if (op2 instanceof IASTLiteralExpression)
+				expression.identifier = ((IASTLiteralExpression)op2).getRawSignature();
+			else if (op2 instanceof IASTFunctionCallExpression)
+				expression.identifier = getMethodCallIdentifier((IASTFunctionCallExpression)op2);
+			return;
+		}		
 	}
 
 	private boolean isTerminalExpression(IASTExpression ctx) {
@@ -107,7 +110,7 @@ public class ExpressionUsage {
 			expression.identifier = ((IASTIdExpression) ctx).getName().toString();
 		}else if (ctx instanceof IASTLiteralExpression) {
 		//2. if it is a var name, dertermine the type based on context.
-			expression.identifier = new String(((IASTLiteralExpression)ctx).getValue());
+			expression.identifier = "<Literal>";
 			expression.rawType =  "<Built-in>";
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly

74be84011aa607adf99655b976158488ddd825f9
@@ -27,10 +27,6 @@ public class FileDependencyGenerator implements DependencyGenerator{
         		if (relation.getEntity().getId()>=0) {
         			int fileEntityTo = getFileEntityIdNoException(entityRepo,relation.getEntity());
         			if (fileEntityTo==-1) continue;
-        			if (relation.getEntity().getRawName().contains("GenericRequestor") && 
-        					entity.getRawName().contains("sendRpcs")) {
-        				System.out.println("helo");
-        			}
         			dependencyMatrix.addDependency(relation.getType(), fileEntityFrom,fileEntityTo,entity,relation.getEntity());
         		}
         	}

ffd57d6b1d341f520535dc5c074c6ed7bfe8de20
@@ -145,5 +145,8 @@ public abstract class Entity {
 	public TypeEntity getType() {
 		return null;
 	}
-	
+
+	public String getDisplayName() {
+		return getRawName();
+	}
 }

a7a5e763fe8b8606f488857d214fb2f17de8880a
@@ -18,8 +18,12 @@ public class DependsCommand {
 	private String dir;
 	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
     private boolean dv8map = true;
+	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
+    private boolean stripLeadingPath = false;
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
     private String granularity="file";
+	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
+    private String namePathPattern="default";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
@@ -63,5 +67,10 @@ public class DependsCommand {
     public String getGranularity() {
 		return granularity;
 	}
-
+	public String getNamePathPattern() {
+		return namePathPattern;
+	}
+	public boolean isStripLeadingPath() {
+		return stripLeadingPath;
+	}
 }

7ea8a6451225bdda69b798d122f345ac715d6dbc
@@ -15,36 +15,22 @@ import depends.relations.Inferer;
  * ContainerEntity for example file, class, method, etc.
  * they could contain vars, functions, ecpressions, type parameters, etc.
  */
-public abstract class ContainerEntity extends Entity {
+public abstract class ContainerEntity extends DecoratedEntity {
 	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Object, Expression> expressions;
-	private Collection<String> typeParameters; // Generic type parameters like <T>, <String>, <? extends Object>
-	private Collection<String> annotations = new ArrayList<>();
-	private Collection<TypeEntity> resolvedTypeParameters = new ArrayList<>();
-	private Collection<TypeEntity> resolvedAnnotations = new ArrayList<>();
+
 
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
 		functions = new ArrayList<>();
 		expressions = new HashMap<>();
-		typeParameters = new ArrayList<>();
-	}
-	
-	public void addAnnotation(String name) {
-		this.annotations.add(name);
-	}
-	
-	public void addTypeParameter(String typeName) {
-		this.typeParameters.add(typeName);
 	}
 	
-	public void addTypeParameter(List<String> parameters) {
-		this.typeParameters.addAll(parameters);
-	}
+
 
 	public void addVar(VarEntity var) {
 		if (logger.isDebugEnabled()) {
@@ -73,35 +59,14 @@ public abstract class ContainerEntity extends Entity {
 		expressions.put(key, expression);
 	}
 
-	/**
-	 * A common utility function used to transfer the identifiers 
-	 * to types.
-	 * @param inferer - the inferer object 
-	 * @param identifiers - the identifiers will be translated
-	 * @return The translated Types
-	 */
-	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
-		ArrayList<TypeEntity> r = new ArrayList<>();
-		for (String typeParameter : identifiers) {
-			TypeEntity typeEntity = inferer.inferTypeFromName(this, typeParameter);
-			if (typeEntity==null) {
-				if (((ContainerEntity)getParent()).isGenericTypeParameter(typeParameter)) {
-					typeEntity = Inferer.genericParameterType;
-				}
-			}
-			if (typeEntity != null)
-				r.add(typeEntity);
-		}
-		return r;
-	}
+	
 
 	/**
 	 * For all data in the class, infer their types.
 	 * Should be override in sub-classes 
 	 */
 	public void inferLocalLevelEntities(Inferer inferer) {
-		resolvedTypeParameters = identiferToTypes(inferer, typeParameters);
-		resolvedAnnotations = identiferToTypes(inferer, annotations);
+		super.inferLocalLevelEntities(inferer);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelEntities(inferer);
 		}
@@ -157,14 +122,6 @@ public abstract class ContainerEntity extends Entity {
 
 	
 
-	public Collection<TypeEntity> getResolvedTypeParameters() {
-		return resolvedTypeParameters;
-	}
-
-
-	public Collection<TypeEntity> getResolvedAnnotations() {
-		return resolvedAnnotations;
-	}
 
 
 	public String dumpExpressions() {
@@ -177,13 +134,6 @@ public abstract class ContainerEntity extends Entity {
 	
 
 
-	public boolean isGenericTypeParameter(String rawType) {
-		if (this.typeParameters.contains(rawType)) return true;
-		if (this.getParent()==null || !(this.getParent() instanceof ContainerEntity))
-			return false;
-		return ((ContainerEntity)getParent()).isGenericTypeParameter(rawType);
-	}
-
 	protected FunctionEntity lookupFunctionLocally(String functionName) {
 		for (FunctionEntity func : getFunctions()) {
 			if (func.getRawName().equals(functionName))

ee0e52e9660cf74e666fcb750c65ab0c637b4232
@@ -26,6 +26,8 @@ public class DependsCommand {
     private String namePathPattern="default";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
+	@Option(names = {"--auto-include"},split=",", description = "auto include all paths under the source path (please notice the potential side effect)")
+	private boolean autoInclude = false;
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public String getLang() {
@@ -73,4 +75,8 @@ public class DependsCommand {
 	public boolean isStripLeadingPath() {
 		return stripLeadingPath;
 	}
+	
+	public boolean isAutoInclude () {
+		return autoInclude;
+	}
 }

b6482121d64539287ee517968758b6182048d7c5
@@ -1,16 +1,15 @@
 package depends.extractor.cpp.cdt;
-import org.eclipse.cdt.core.dom.ast.IASTNode;
-import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
-import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
 import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
-import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
 import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
 import org.eclipse.cdt.core.dom.ast.IASTExpression;
 import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
 import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
 import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
+import org.eclipse.cdt.core.dom.ast.IASTNode;
+import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
+import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 
 import depends.entity.Expression;
 import depends.entity.repo.IdGenerator;

1effdf25316aca0758babce13f917c853722dda9
@@ -0,0 +1,76 @@
+package depends;
+
+import picocli.CommandLine.Command;
+import picocli.CommandLine.Option;
+import picocli.CommandLine.Parameters;
+
+@Command(name = "depends")
+public class DependsCommand {
+	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
+    private String lang;
+	@Parameters(index = "1", description = "The directory to be analyzed")
+    private String src;
+	@Parameters(index = "2",  description = "The output file name")
+	private String output;
+    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
+    private String[] format=new String[]{"json"};
+	@Option(names = {"-d", "--dir"},  description = "The output directory")
+	private String dir;
+	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
+    private boolean dv8map = true;
+	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
+    private boolean stripLeadingPath = false;
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
+    private String granularity="file";
+	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
+    private String namePathPattern="default";
+	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
+    private String[] includes = new String[] {};
+    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+    boolean help;
+	public String getLang() {
+		return lang;
+	}
+	public void setLang(String lang) {
+		this.lang = lang;
+	}
+	public String getSrc() {
+		return src;
+	}
+	public void setSrc(String src) {
+		this.src = src;
+	}
+	public String getOutputName() {
+		return output;
+	}
+	public void setOutput(String output) {
+		this.output = output;
+	}
+	public String[] getFormat() {
+		return format;
+	}
+	public String getOutputDir() {
+		if (dir==null) {
+			dir = System.getProperty("user.dir");
+		}
+		return dir;
+	}
+	public boolean isDv8map() {
+		return dv8map;
+	}
+	public String[] getIncludes() {
+		return includes;
+	}
+	public boolean isHelp() {
+		return help;
+	}
+    public String getGranularity() {
+		return granularity;
+	}
+	public String getNamePathPattern() {
+		return namePathPattern;
+	}
+	public boolean isStripLeadingPath() {
+		return stripLeadingPath;
+	}
+}

87a6d02899f1384696c1d002491b1590209d4f1d
@@ -17,6 +17,7 @@ public class DependencyType {
 	public static final String CAST = "Cast";
 	public static final String THROW = "Throw";
 	public static final String ANNOTATION = "Annotation";
+	public static final String MIXIN = "MixIn";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();
@@ -34,6 +35,7 @@ public class DependencyType {
 		depedencyTypes.add(CAST);
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
+		depedencyTypes.add(MIXIN);
 		return depedencyTypes;
 	}
 }

3fb5e986c116063bafa36b46f00c4b85709778b0
@@ -1,46 +1,8 @@
 package depends.extractor.ruby;
 
-import java.util.ArrayList;
-import java.util.List;
+import depends.extractor.cpp.CppImportLookupStrategy;
 
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.repo.EntityRepo;
-import depends.importtypes.FileImport;
-import depends.importtypes.Import;
-import depends.relations.ImportLookupStrategy;
-import depends.relations.Inferer;
+public class RubyImportLookupStrategy extends  CppImportLookupStrategy {
 
-public class RubyImportLookupStrategy implements ImportLookupStrategy {
-
-	@Override
-	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	@Override
-	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
-		ArrayList<Entity> result = new ArrayList<>();
-		for (Import importedItem:importedList) {
-			if (importedItem instanceof FileImport) {
-				Entity imported = repo.getEntity(importedItem.getContent());
-				if (imported==null) continue;
-				result.add(imported);
-			}
-		}
-		return result;
-	}
-
-	@Override
-	public List<Entity> getImportedTypes(List<Import> importedNames, EntityRepo repo) {
-		// TODO Auto-generated method stub
-		return new ArrayList<>();
-	}
-
-	@Override
-	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
-		return getImportedRelationEntities(importedList,repo);
-	}
 
 }

2f9f7cd9e1671757e0e78687775b5da919ccd14b
@@ -0,0 +1,131 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+import depends.relations.Inferer;
+
+public class AliasEntity extends Entity {
+	private Entity referToEntity = new EmptyTypeEntity();
+	private String originName;
+
+	public AliasEntity(String simpleName, Entity parent, Integer id, String originTypeName) {
+		super(simpleName, parent, id);
+		this.originName = originTypeName;
+	}
+
+	public void inferLocalLevelEntities(Inferer inferer) {
+		Entity entity = inferer.resolveName(this, originName, true);
+		if (entity != null)
+			referToEntity = entity;
+		if (entity.equals(this)) {
+			referToEntity = new EmptyTypeEntity();
+		}
+		referToEntity.inferLocalLevelEntities(inferer);
+	}
+
+	public Collection<TypeEntity> getResolvedTypeParameters() {
+		if (!(referToEntity instanceof DecoratedEntity))
+			return new ArrayList<>();
+		DecoratedEntity origin = (DecoratedEntity) referToEntity;
+		return origin.getResolvedTypeParameters();
+	}
+
+	public Collection<TypeEntity> getResolvedAnnotations() {
+		if (!(referToEntity instanceof DecoratedEntity))
+			return new ArrayList<>();
+		DecoratedEntity origin = (DecoratedEntity) referToEntity;
+		return origin.getResolvedAnnotations();
+	}
+
+	public ArrayList<VarEntity> getVars() {
+		if (!(referToEntity instanceof ContainerEntity))
+			return new ArrayList<>();
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.getVars();
+	}
+
+	public ArrayList<FunctionEntity> getFunctions() {
+		if (!(referToEntity instanceof ContainerEntity))
+			return new ArrayList<>();
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.getFunctions();
+	}
+
+	protected FunctionEntity lookupFunctionLocally(String functionName) {
+		if (!(referToEntity instanceof ContainerEntity))
+			return null;
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.lookupFunctionLocally(functionName);
+	}
+
+	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+		if (!(referToEntity instanceof ContainerEntity))
+			return null;
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.lookupFunctionInVisibleScope(functionName);
+	}
+
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		if (!(referToEntity instanceof ContainerEntity))
+			return null;
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.lookupVarsInVisibleScope(varName);
+	}
+
+	public Collection<ContainerEntity> getResolvedMixins() {
+		if (!(referToEntity instanceof ContainerEntity))
+			return new ArrayList<>();
+		ContainerEntity origin = (ContainerEntity) referToEntity;
+		return origin.getResolvedMixins();
+	}
+
+	public Collection<TypeEntity> getInheritedTypes() {
+		if (referToEntity instanceof TypeEntity)
+			return ((TypeEntity) referToEntity).getInheritedTypes();
+		return new ArrayList<>();
+	}
+
+	public Collection<TypeEntity> getImplementedTypes() {
+		if (referToEntity instanceof TypeEntity)
+			return ((TypeEntity) referToEntity).getImplementedTypes();
+		return new ArrayList<>();
+	}
+
+	public TypeEntity getInheritedType() {
+		if (referToEntity instanceof TypeEntity)
+			return ((TypeEntity) referToEntity).getInheritedType();
+		return null;
+	}
+
+	public Collection<TypeEntity> getReturnTypes() {
+		if (!(referToEntity instanceof FunctionEntity))
+			return new ArrayList<>();
+		FunctionEntity origin = (FunctionEntity) referToEntity;
+		return origin.getReturnTypes();
+	}
+
+	public TypeEntity getType() {
+		return referToEntity.getType();
+	}
+
+	public Collection<VarEntity> getParameters() {
+		if (!(referToEntity instanceof FunctionEntity))
+			return new ArrayList<>();
+		FunctionEntity origin = (FunctionEntity) referToEntity;
+		return origin.getParameters();
+	}
+
+	public Collection<TypeEntity> getThrowTypes() {
+		if (!(referToEntity instanceof FunctionEntity))
+			return new ArrayList<>();
+		FunctionEntity origin = (FunctionEntity) referToEntity;
+		return origin.getThrowTypes();
+	}
+
+	public Entity getOriginType() {
+		return referToEntity;
+	}
+	
+
+}

63b19f145358c14da429e75fb9e3a00367915ec8
@@ -1,5 +1,8 @@
 package depends.entity;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import depends.relations.Inferer;
 
 public class Expression {
@@ -7,6 +10,7 @@ public class Expression {
 	public Integer parentId;
 	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;
+	private List<Expression> deduceTypeChildren = new ArrayList<>();
 	public String text; // for debug purpose
 	public String rawType; //the raw type name
 	public String identifier; // the varName, or method name, etc.
@@ -16,8 +20,8 @@ public class Expression {
 	public boolean isLogic = false;
 	public boolean isCreate = false;
 	public boolean isCast = false;
+	public boolean autoVar = false;
 	public boolean deriveTypeFromChild = true;
-
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
 	private Entity referredEntity;
@@ -49,7 +53,7 @@ public class Expression {
 		                      .append(isSet?"[set]":"")
 		                      .append(isLogic?"[bool]":"")
 		                      .append(isCall?"[call]":"").append("|")
-		    .append("parent:").append(parent==null?"none":parent.text)
+		    .append("parent:").append(parent==null?"nil":parent.text).append("|")
 			.append("type:").append(type).append("|");
 		return s.toString();
 	}
@@ -61,6 +65,17 @@ public class Expression {
 	 */
 	public void deduceParentType(Inferer inferer) {
 		if (this.type==null) return;
+		deduceChildrenType(inferer);
+		deduceTheParentType(inferer);
+	}
+
+	private void deduceChildrenType(Inferer inferer) {
+		for (Expression child:this.deduceTypeChildren) {
+			child.setType(type, type, inferer);
+		}
+	}
+
+	private void deduceTheParentType(Inferer inferer) {
 		if (this.parent==null) return;
 		Expression parent = this.parent;
 		if (parent.type != null)return;
@@ -104,4 +119,8 @@ public class Expression {
 	public Entity getReferredEntity() {
 		return referredEntity;
 	}
+
+	public void addDeduceTypeChild(Expression expression) {
+		deduceTypeChildren.add(expression);
+	}
 }
\ No newline at end of file

b5cd9f5dee63b9c081582e37e75b1919933f1858
@@ -3,12 +3,10 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.List;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import depends.extractor.java.JavaParser.ExpressionContext;
 import depends.relations.Inferer;
 
 /**
@@ -101,15 +99,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
 				continue;
+			if (expression.isDot){ //wait for previous
+				continue;
+			}
+			if (expression.rawType==null && expression.identifier ==null)
+				continue;
 			
 			//2. if expression's rawType existed, directly infer type by rawType
 			//   if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
 				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
-			}else if (expression.isDot){ //wait for previous
-				continue;
-			} else if (expression.rawType!=null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
 				if (expression.getType() !=null) {
 					 continue;
 				}

9c281c3eb6dfcba93642f9dc1f3a0497fa5a6b62
@@ -51,15 +51,15 @@ public abstract class Entity {
 			this.qualifiedName = this.rawName;
 			return;
 		}
-		if (parent.getQualifiedName()==null) {
+		if (parent.getQualifiedName(true)==null) {
 			this.qualifiedName = this.rawName;
 			return;
 		}
-		if (parent.getQualifiedName().isEmpty()) {
+		if (parent.getQualifiedName(true).isEmpty()) {
 			this.qualifiedName = rawName;
 			return;
 		}
-		this.qualifiedName= parent.getQualifiedName()+"." + rawName;
+		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName;
 		if (rawName.startsWith(".")) {
 			rawName = rawName.substring(2);
 		}
@@ -106,7 +106,11 @@ public abstract class Entity {
 		this.rawName = rawName;
 	}
 	
-	public String getQualifiedName() {
+	public final String getQualifiedName() {
+		return qualifiedName;
+	}
+
+	public String getQualifiedName(boolean overrideFileWithPackage) {
 		return qualifiedName;
 	}
 

b64d132343eae650f4f35572c89abbd9ed1d96ff
@@ -0,0 +1,24 @@
+package depends.extractor;
+
+import static org.junit.Assert.fail;
+
+import depends.entity.Entity;
+import depends.relations.Relation;
+
+public abstract class ParserTest {
+	protected void assertContainsRelation(Entity inEntity, String dependencyType, String dependedEntityFullName) {
+		Relation relation = null;
+		for (Relation r:inEntity.getRelations()) {
+			if (r.getType().equals(dependencyType)) {
+				relation = r;
+				if (r.getEntity().getQualifiedName().equals(dependedEntityFullName))
+					return;
+			}
+		}
+		if (relation==null) {
+			fail("cannot found relation type of "+ dependencyType);
+		}else {
+			fail("cannot found relation type of " + dependencyType + " to entity " + dependedEntityFullName);
+		}
+	}
+}

688be131883243dadff572e351c0bc4a04e2ab88
@@ -7,7 +7,6 @@ import depends.relations.Inferer;
 
 public class Expression {
 	public Integer id;
-	public Integer parentId;
 	public Integer deduceTypeBasedId; //by default, parent expression type determined by most left child
 	public Expression parent;
 	private List<Expression> deduceTypeChildren = new ArrayList<>();
@@ -38,9 +37,8 @@ public class Expression {
 		deduceParentType(inferer);
 	}
 	
-	public Expression(Integer id, Integer parentId) {
+	public Expression(Integer id) {
 		this.id = id;
-		this.parentId = parentId;
 	}
 
 	@Override

9c9690c06347324221b0a726098d00d255fe4d51
@@ -9,7 +9,7 @@ import depends.relations.ImportLookupStrategy;
 
 public class CppProcessor extends AbstractLangProcessor {
     private static final String LANG = "cpp";
-    private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh"};
+    private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh", ".cxx",".hxx"};
     PreprocessorHandler preprocessorHandler;
     public CppProcessor(String inputDir, String[] includeDir) {
     	super(inputDir,includeDir);

42fd7d1bfcfc8b61ab413b1ee32ae5ec409195c4
@@ -158,13 +158,27 @@ public abstract class HandlerContext {
 			foundVarDefinition(varName,type,typeArguments);
 		}
 	}
-
+	
+	public void foundVarDefinition(ContainerEntity container,String varName) {
+		if (container==null) {
+			System.err.println("potentail error:" + varName + " has no container");
+			return;
+		}
+		VarEntity var = new VarEntity(varName, null, container, idGenerator.generateId());
+		container.addVar(var);
+	}
 
 	public void foundVarDefinition(String varName, String type, List<String> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);		
 	}
+	
+	public void addMethodParameter(String paramName) {
+		if (currentFunction()==null) return;
+		VarEntity varEntity = new VarEntity(paramName,null,currentFunction(),idGenerator.generateId());
+		currentFunction().addParameter(varEntity);		
+	}
 
 	public void foundEnumConstDefinition(String varName) {
 		String type = lastContainer().getRawName();

5c25a329204cf658524b739e9d5d58547630a4d0
@@ -9,6 +9,7 @@ import depends.entity.MultiDeclareEntities;
 public class EntityRepo extends IdGenerator{
 	public HashMap<String, Entity> allEntieisByName = new HashMap<>();
 	public HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
+	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
 	public EntityRepo() {
 	}

f288d8263e49e1f1b2953acdeb1e15f68924bb82
@@ -70,7 +70,12 @@ public class ExpressionUsage {
 			String name = helper.getName(ctx);
 			if (name.equals("new")) {
 				expression.isCreate = true;
-				expression.identifier = helper.getName(ctx.childNodes().get(0));
+				List<Node> childNodes = ctx.childNodes();
+				if (childNodes.size()>0) {
+					expression.identifier = helper.getName(ctx.childNodes().get(0));
+				}else {
+					expression.identifier = context.currentType().getRawName();
+				}
 				expression.rawType = expression.identifier ;
 				expression.deriveTypeFromChild  = false;
 			}

2055b7fed35746d90b1822f9bf9b09dcb4b6ec6c
@@ -211,4 +211,12 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return resolvedMixins;
 	}
 
+	public VarEntity getVarOfName(String varName) {
+		for (VarEntity var:this.vars) {
+			if (var.getRawName().equals(varName))
+				return var;
+		}
+		return null;
+	}
+
 }

19174af827fd0b890dd17d8fa55fe9052b3b9a99
@@ -15,18 +15,21 @@ import depends.entity.VarEntity;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.IdGenerator;
 import depends.importtypes.Import;
+import depends.relations.Inferer;
 
 public abstract class HandlerContext {
 	protected EntityRepo entityRepo;
 	protected IdGenerator idGenerator;
 
 	protected FileEntity currentFileEntity;
+	protected Inferer inferer;
 
 	
-	public HandlerContext(EntityRepo entityRepo) {
+	public HandlerContext(EntityRepo entityRepo, Inferer inferer) {
 		this.entityRepo = entityRepo;
 		this.idGenerator = entityRepo;
 		entityStack = new Stack<Entity>();
+		this.inferer = inferer;
 	}
 
 	public FileEntity startFile(String fileName) {
@@ -214,4 +217,14 @@ public abstract class HandlerContext {
 		entityStack.pop();
 	}
 	
+	public boolean isNameExist(String rawName) {
+		Entity entity = inferer.resolveName(lastContainer(), rawName, true);
+		if (entity==null) return false;
+		if (entity.getId()!=-1) return true;
+		return false;
+	}
+
+	public Entity foundEntityWithName(String rawName) {
+		return inferer.resolveName(lastContainer(), rawName, true);
+	}
 }
\ No newline at end of file

b87e3b0630996c7695f020a0808422c495e7d006
@@ -1,76 +0,0 @@
-package depends;
-
-import picocli.CommandLine.Command;
-import picocli.CommandLine.Option;
-import picocli.CommandLine.Parameters;
-
-@Command(name = "depends")
-public class DependsCommand {
-	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
-    private String lang;
-	@Parameters(index = "1", description = "The directory to be analyzed")
-    private String src;
-	@Parameters(index = "2",  description = "The output file name")
-	private String output;
-    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
-    private String[] format=new String[]{"json"};
-	@Option(names = {"-d", "--dir"},  description = "The output directory")
-	private String dir;
-	@Option(names = {"-m", "--map"},  description = "Output DV8 dependency map file.")
-    private boolean dv8map = true;
-	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
-    private boolean stripLeadingPath = false;
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
-    private String granularity="file";
-	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
-    private String namePathPattern="default";
-	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
-    private String[] includes = new String[] {};
-    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
-    boolean help;
-	public String getLang() {
-		return lang;
-	}
-	public void setLang(String lang) {
-		this.lang = lang;
-	}
-	public String getSrc() {
-		return src;
-	}
-	public void setSrc(String src) {
-		this.src = src;
-	}
-	public String getOutputName() {
-		return output;
-	}
-	public void setOutput(String output) {
-		this.output = output;
-	}
-	public String[] getFormat() {
-		return format;
-	}
-	public String getOutputDir() {
-		if (dir==null) {
-			dir = System.getProperty("user.dir");
-		}
-		return dir;
-	}
-	public boolean isDv8map() {
-		return dv8map;
-	}
-	public String[] getIncludes() {
-		return includes;
-	}
-	public boolean isHelp() {
-		return help;
-	}
-    public String getGranularity() {
-		return granularity;
-	}
-	public String getNamePathPattern() {
-		return namePathPattern;
-	}
-	public boolean isStripLeadingPath() {
-		return stripLeadingPath;
-	}
-}

ca464cbab4ebc3be933fe827247018803d122721
@@ -0,0 +1,11 @@
+package depends.entity;
+
+public class FunctionCall {
+	private String rawName;
+	public FunctionCall(String rawName){
+		this.rawName = rawName;
+	}
+	public String getRawName() {
+		return rawName;
+	}
+}

2cee3f0f4605e00cc839e678b9c1a29972a1237a
@@ -65,6 +65,8 @@ public class ExpressionUsage {
 				expression.rawType = expression.identifier ;
 				expression.deriveTypeFromChild  = false;
 			}
+			expression.isCall = true;
+			expression.identifier = name;
 		}
 		return expression;
 	}

0ce243ecffceef70d2d01cb1a213b64119595e07
@@ -67,6 +67,10 @@ public class ExpressionUsage {
 			}
 			expression.isCall = true;
 			expression.identifier = name;
+			expression.rawType = helper.getReciever(ctx);
+			if (expression.rawType!=null) {
+				//expression.isDot = true;
+			}
 		}
 		return expression;
 	}

a7f83f84b8acb1b7359b70a2fae3fee8a75479c8
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 
+import org.jrubyparser.ast.Node;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -219,4 +220,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return null;
 	}
 
+
+
+
+
 }

f1e8f852944e7d21e4d0469f47e9dcd3c9b1de57
@@ -23,6 +23,7 @@ public class Expression {
 	private TypeEntity type; // the type we care - for relation calculation. 
 	                         //for leaf, it equals to referredEntity.getType. otherwise, depends on child's type strategy
 	private Entity referredEntity;
+	private List<VarEntity> deducedTypeVars;
 	public TypeEntity getType() {
 		return type;
 	}
@@ -41,11 +42,15 @@ public class Expression {
 		}
 		if (this.referredEntity==null)
 			this.referredEntity = type;
+		for (VarEntity var:deducedTypeVars) {
+			var.setType(this.type);
+		}
 		deduceParentType(inferer);
 	}
 	
 	public Expression(Integer id) {
 		this.id = id;
+		this.deducedTypeVars = new ArrayList<>();
 	}
 
 	@Override
@@ -122,4 +127,8 @@ public class Expression {
 	public void addDeduceTypeChild(Expression expression) {
 		deduceTypeChildren.add(expression);
 	}
+
+	public void addDeducedTypeVar(VarEntity var) {
+		this.deducedTypeVars.add(var);
+	}
 }
\ No newline at end of file

35ccde19cbb870a243d9c15f2314654284200ce3
@@ -20,6 +20,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
 	private HashMap<Object, Expression> expressions;
+	private ArrayList<Expression> expressionList;
 	private Collection<String> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
 
@@ -30,6 +31,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
 		expressions = new HashMap<>();
+		expressionList = new  ArrayList<>();
 	}
 	
 
@@ -59,6 +61,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	public void addExpression(Object key, Expression expression) {
 		expressions.put(key, expression);
+		expressionList.add(expression);
 	}
 
 	
@@ -96,7 +99,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
-		for (Expression expression : expressions.values()) {
+		for (Expression expression : expressionList) {
 			//1. if expression's type existed, break;
 			if (expression.getType() != null)
 				continue;
@@ -143,7 +146,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();
-		for (Expression exp:expressions.values()) {
+		for (Expression exp:expressionList) {
 			sb.append(exp.toString()).append("\n");
 		}
 		return sb.toString();

f3097f23bd591bf584d03ee77f915407489d27ef
@@ -2,8 +2,7 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
+import java.util.List;
 
 import depends.relations.Inferer;
 import depends.relations.Relation;
@@ -19,7 +18,7 @@ public abstract class Entity {
 	String qualifiedName = null;
 	String rawName = "";
 	Entity parent;
-	Set<Entity> children = new HashSet<>();
+	List<Entity> children = new ArrayList<>();
     ArrayList<Relation> relations = new ArrayList<>();
 
 	
@@ -39,7 +38,6 @@ public abstract class Entity {
      * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
      * Rule 4: otherwise, qualified name = parent_qualfied_name + "."+rawName
      * Rule 5: make sure the qualified name do not start with '.'
-     * TODO: the Rule 1 should be further check. Maybe issue exists - (C++中的ClassName::MethodName()会不会有问题？
      */
 	private void deduceQualifiedName() {
 		rawName = rawName.replace("::","." );

d5e4b8bd474fcb6563814918eb96219a8130ab2b
@@ -4,7 +4,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 
-import org.jrubyparser.ast.Node;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -79,6 +78,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			func.inferLocalLevelEntities(inferer);
 		}
 		resolvedMixins = identiferToContainerEntity(inferer, mixins);
+		this.resolveExpressions(inferer);
 	}
 
 	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<String> identifiers) {
@@ -139,10 +139,14 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 	}
 
-
-	
-
-
+	public TypeEntity getLastExpressionType() {
+		for (int i=this.expressionList.size()-1;i>=0;i--) {
+			Expression expr= this.expressionList.get(i);
+			if (expr.isStatement)
+				return expr.getType();
+		}
+		return null;
+	}
 
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();

b6da2c64b7cdcebbedc7b8b1563c85593bd078be
@@ -12,6 +12,7 @@ public class FileEntity extends ContainerEntity {
 	private List<Entity> importedRelationEntities = new ArrayList<>();
 	private List<Entity> importedFiles = new ArrayList<>();
 	private List<Entity> importedTypes = new ArrayList<>();
+	private List<TypeEntity> declaredTypes = new ArrayList<>();
 
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
 		super(fullName, null, fileId);
@@ -91,4 +92,12 @@ public class FileEntity extends ContainerEntity {
 		return importedTypes;
 	}
 
+	public List<TypeEntity> getDeclaredTypes() {
+		return this.declaredTypes;
+	}
+
+	public void addType(TypeEntity currentTypeEntity) {
+		this.declaredTypes.add(currentTypeEntity);
+	}
+
 }

c33ffa54d589507369795b9c2bb94db9238357c1
@@ -0,0 +1,287 @@
+package depends.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+import depends.relations.Inferer;
+import depends.relations.Relation;
+
+public class CandidateTypes extends TypeEntity {
+	private List<TypeEntity> candidateTypes;
+
+	public CandidateTypes(List<TypeEntity> candidateTypes) {
+		super("candidateTypes", null, -1);
+		this.candidateTypes = candidateTypes;
+	}
+
+	public List<TypeEntity> getCandidateTypes() {
+		return candidateTypes;
+	}
+
+ 	@Override
+	public Collection<TypeEntity> getInheritedTypes() {
+ 		List<TypeEntity> result = new ArrayList<>();
+		for (TypeEntity type:candidateTypes) {
+			result.addAll(type.getInheritedTypes());
+		}
+		return result;
+	}
+	
+ 	@Override
+	public Collection<TypeEntity> getImplementedTypes() {
+ 		List<TypeEntity> result = new ArrayList<>();
+		for (TypeEntity type:candidateTypes) {
+			result.addAll(type.getImplementedTypes());
+		}
+		return result;
+	}
+ 	
+	@Override
+	public ArrayList<FunctionEntity> getFunctions() {
+ 		ArrayList<FunctionEntity> result = new ArrayList<>();
+		for (TypeEntity type:candidateTypes) {
+			result.addAll(type.getFunctions());
+		}
+		return result;
+	}
+	
+ 	@Override
+ 	public TypeEntity getInheritedType() {
+		return inheritedType;
+	}
+ 	@Override
+ 	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+ 		for (TypeEntity type:candidateTypes) {
+			FunctionEntity f = type.lookupFunctionInVisibleScope(functionName);
+			if (f!=null) return f;
+		}
+ 		return null;
+	}
+ 	
+	@Override
+	public VarEntity lookupVarsInVisibleScope(String varName) {
+		for (TypeEntity type:candidateTypes) {
+			VarEntity v = type.lookupVarsInVisibleScope(varName);
+			if (v!=null) return v;
+		}
+ 		return null;	
+	}
+	
+	
+	@Override
+	public VarEntity getVarOfName(String varName) {
+		for (TypeEntity type:candidateTypes) {
+			VarEntity v = type.getVarOfName(varName);
+			if (v!=null) return v;
+		}
+		return null;
+	}
+	
+ 	@Override
+ 	public TypeEntity getType() {
+ 		if (candidateTypes.size()>0) return candidateTypes.get(0);
+		return null;
+	}
+
+	@Override
+	public void inferLocalLevelEntities(Inferer inferer) {
+		System.err.println("error: inferLocalLevelEntities should not been invoked");
+		super.inferLocalLevelEntities(inferer);
+	}
+
+	@Override
+	public void addImplements(String typeName) {
+		System.err.println("error: addImplements should not been invoked");
+		super.addImplements(typeName);
+	}
+
+	@Override
+	public void addExtends(String typeName) {
+		System.err.println("error: addExtends should not been invoked");
+		super.addExtends(typeName);
+	}
+
+	@Override
+	public void addVar(VarEntity var) {
+		System.err.println("error: addVar should not been invoked");
+		super.addVar(var);
+	}
+
+	@Override
+	public ArrayList<VarEntity> getVars() {
+		System.err.println("error: getVars should not been invoked");
+		return super.getVars();
+	}
+
+	@Override
+	public void addFunction(FunctionEntity functionEntity) {
+		System.err.println("error: addFunction should not been invoked");
+		super.addFunction(functionEntity);
+	}
+
+	@Override
+	public HashMap<Object, Expression> expressions() {
+		System.err.println("error: expressions should not been invoked");
+		return super.expressions();
+	}
+
+	@Override
+	public void addExpression(Object key, Expression expression) {
+		System.err.println("error: addExpression should not been invoked");
+		super.addExpression(key, expression);
+	}
+
+	@Override
+	public void resolveExpressions(Inferer inferer) {
+		System.err.println("error: resolveExpressions should not been invoked");
+		super.resolveExpressions(inferer);
+	}
+
+	@Override
+	public TypeEntity getLastExpressionType() {
+		System.err.println("error: getLastExpressionType should not been invoked");
+		return super.getLastExpressionType();
+	}
+
+	@Override
+	public void addMixin(String moduleName) {
+		System.err.println("error: addMixin should not been invoked");
+		super.addMixin(moduleName);
+	}
+
+	@Override
+	public Collection<ContainerEntity> getResolvedMixins() {
+		System.err.println("error: getResolvedMixins should not been invoked");
+		return super.getResolvedMixins();
+	}
+
+	@Override
+	public void addTypeParameter(List<String> typeArguments) {
+		System.err.println("error: addTypeParameter should not been invoked");
+		super.addTypeParameter(typeArguments);
+	}
+
+	@Override
+	public void addAnnotation(String name) {
+		System.err.println("error: addAnnotation should not been invoked");
+		super.addAnnotation(name);
+	}
+
+	@Override
+	public void addTypeParameter(String typeName) {
+		System.err.println("error: addTypeParameter should not been invoked");
+		super.addTypeParameter(typeName);
+	}
+
+	@Override
+	public Collection<TypeEntity> getResolvedTypeParameters() {
+		System.err.println("error: getResolvedTypeParameters should not been invoked");
+		return super.getResolvedTypeParameters();
+	}
+
+	@Override
+	public Collection<TypeEntity> getResolvedAnnotations() {
+		System.err.println("error: getResolvedAnnotations should not been invoked");
+		return super.getResolvedAnnotations();
+	}
+
+	@Override
+	public boolean isGenericTypeParameter(String rawType) {
+		System.err.println("error: isGenericTypeParameter should not been invoked");
+		return super.isGenericTypeParameter(rawType);
+	}
+
+	@Override
+	protected Collection<TypeEntity> identiferToTypes(Inferer inferer, Collection<String> identifiers) {
+		System.err.println("error: identiferToTypes should not been invoked");
+		return super.identiferToTypes(inferer, identifiers);
+	}
+
+	@Override
+	public String getRawName() {
+		System.err.println("error: getRawName should not been invoked");
+		return super.getRawName();
+	}
+
+	@Override
+	public int getId() {
+		System.err.println("error: getId should not been invoked");
+		return super.getId();
+	}
+
+	@Override
+	public void addRelation(Relation relation) {
+		System.err.println("error: addRelation should not been invoked");
+		super.addRelation(relation);
+	}
+
+	@Override
+	public ArrayList<Relation> getRelations() {
+		System.err.println("error: getRelations should not been invoked");
+		return super.getRelations();
+	}
+
+	@Override
+	public void addChild(Entity child) {
+		System.err.println("error: addChild should not been invoked");
+		super.addChild(child);
+	}
+
+	@Override
+	public Entity getParent() {
+		System.err.println("error: getParent should not been invoked");
+		return super.getParent();
+	}
+
+	@Override
+	public void setParent(Entity parent) {
+		System.err.println("error: setParent should not been invoked");
+		super.setParent(parent);
+	}
+
+	@Override
+	public Collection<Entity> getChildren() {
+		System.err.println("error: getChildren should not been invoked");
+		return super.getChildren();
+	}
+
+	@Override
+	public void setQualifiedName(String qualifiedName) {
+		System.err.println("error: setQualifiedName should not been invoked");
+		super.setQualifiedName(qualifiedName);
+	}
+
+	@Override
+	public void setRawName(String rawName) {
+		System.err.println("error: setRawName should not been invoked");
+		super.setRawName(rawName);
+	}
+
+	@Override
+	public String getQualifiedName(boolean overrideFileWithPackage) {
+		System.err.println("error: getQualifiedName should not been invoked");
+		return super.getQualifiedName(overrideFileWithPackage);
+	}
+
+	
+	@Override
+	public Entity getAncestorOfType(Class classType) {
+		System.err.println("error: getAncestorOfType should not been invoked");
+		return super.getAncestorOfType(classType);
+	}
+
+	@Override
+	public void inferEntities(Inferer inferer) {
+		System.err.println("error: inferEntities should not been invoked");
+		super.inferEntities(inferer);
+	}
+
+	@Override
+	public String getDisplayName() {
+		System.err.println("error: getDisplayName should not been invoked");
+		return super.getDisplayName();
+	}
+ 	
+}

e24e3960f77b60597272487b31a9d91720a3c8ff
@@ -105,6 +105,7 @@ public class FileEntity extends ContainerEntity {
 	public Set<FileEntity> getImportedFilesInAllLevel() {
 		if (importedFileCollector==null)
 			importedFileCollector = new ImportedFileCollector(this);
+
 		return importedFileCollector.getFiles();
 	}
 

a468b34326c2c9bb38f046acba12293c2ef7b863
@@ -16,12 +16,17 @@ public class AliasEntity extends Entity {
 
 	public void inferLocalLevelEntities(Inferer inferer) {
 		Entity entity = inferer.resolveName(this, originName, true);
+		while(entity instanceof AliasEntity) {
+			AliasEntity aliasEntity = (AliasEntity)entity;
+			entity = inferer.resolveName(aliasEntity, aliasEntity.originName,true);
+			if (entity==null) break;
+			if (entity.equals(this)) {
+				entity = null;
+				break;
+			}
+		}
 		if (entity != null)
 			referToEntity = entity;
-		if (entity.equals(this)) {
-			referToEntity = new EmptyTypeEntity();
-		}
-		referToEntity.inferLocalLevelEntities(inferer);
 	}
 
 	public Collection<TypeEntity> getResolvedTypeParameters() {

65c0b0c4055b0c16ac00850488ab68600ac7ff44
@@ -183,8 +183,8 @@ public abstract class HandlerContext {
 	
 	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
 		if (container==null) {
-			System.err.println("potentail error:" + varName + " has no container");
-			return null;
+			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
+			container = currentFile();
 		}
 		
 		VarEntity var = getVar(container,varName);

ff958d154cd7c759098fc9911071ce6f194a3466
@@ -18,6 +18,7 @@ public class Expression {
 	public boolean isLogic = false;
 	public boolean isCreate = false;
 	public boolean isCast = false;
+	public boolean isThrow = false;
 	public boolean isStatement = false; //statement is only used for return type calcuation in some langs such as ruby
 	                                    //they will not be treat as real expressions in case of relation calculation
 	public boolean deriveTypeFromChild = true;
@@ -67,6 +68,8 @@ public class Expression {
 		                      .append(isSet?"[set]":"")
 		                      .append(isLogic?"[bool]":"")
 		                      .append(isCall?"[call]":"").append("|")
+		                      .append(isCreate?"[new]":"").append("|")
+		                      .append(isThrow?"[throw]":"").append("|")
 		    .append("parent:").append(parent==null?"nil":parent.text).append("|")
 			.append("type:").append(type).append("|");
 		return s.toString();

4e7600c918fd9703c24a9baae5a9c0ac61016a7b
@@ -33,7 +33,7 @@ public abstract class Entity {
 	}
 
     /**
-     * Rule 1: if it contains '.' , then the name is equal to raw name
+     * Rule 1: if it start with '.' , then the name is equal to raw name
      * Rule 2: if parent not exists, the name is equal to raw name
      * Rule 3: if parent exists but no qualified name exists or empty, the name is equal to raw name
      * Rule 4: otherwise, qualified name = parent_qualfied_name + "."+rawName
@@ -41,8 +41,8 @@ public abstract class Entity {
      */
 	private void deduceQualifiedName() {
 		rawName = rawName.replace("::","." );
-		if (this.rawName.contains(".")) {
-			this.qualifiedName = this.rawName;
+		if (this.rawName.startsWith(".")) {
+			this.qualifiedName = this.rawName.substring(1);
 			return; //already qualified
 		}
 		if (parent==null) {
@@ -58,9 +58,6 @@ public abstract class Entity {
 			return;
 		}
 		this.qualifiedName= parent.getQualifiedName(true)+"." + rawName;
-		if (rawName.startsWith(".")) {
-			rawName = rawName.substring(2);
-		}
 	}
 
 

f0d9d3175387483307bc59ba422d5d65b0be4b23
@@ -75,7 +75,7 @@ public class AliasEntity extends Entity {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
-		return origin.lookupVarsInVisibleScope(varName);
+		return origin.lookupVarInVisibleScope(varName);
 	}
 
 	public Collection<ContainerEntity> getResolvedMixins() {

956454688ea4fba4a0103560f7e856989f9d2f6b
@@ -3,10 +3,10 @@ package depends.extractor.ruby.jruby;
 import java.util.List;
 
 import org.jrubyparser.ast.AndNode;
-import org.jrubyparser.ast.ArrayNode;
 import org.jrubyparser.ast.AssignableNode;
 import org.jrubyparser.ast.BlockNode;
 import org.jrubyparser.ast.ClassVarNode;
+import org.jrubyparser.ast.Colon3Node;
 import org.jrubyparser.ast.ConstNode;
 import org.jrubyparser.ast.FCallNode;
 import org.jrubyparser.ast.FalseNode;
@@ -81,7 +81,8 @@ public class ExpressionUsage {
 		} else if (ctx instanceof LocalVarNode ||
 				ctx instanceof GlobalVarNode ||
 				ctx instanceof ClassVarNode||
-				ctx instanceof InstVarNode)  {
+				ctx instanceof InstVarNode ||
+				ctx instanceof Colon3Node)  {
 			expression.identifier = helper.getName(ctx);
 		} 
 		if (ctx instanceof AssignableNode) {

9000e91ed96f9e9f1794d320ae5ad189c78bf16c
@@ -42,7 +42,6 @@ public class ExpressionUsage {
 		this.inferer = inferer;
 		this.helper = helper;
 	}
-	@SuppressWarnings("deprecation")
 	public Expression foundExpression(Node ctx) {
 		if (ctx instanceof RootNode) return null;
 		if (ctx instanceof BlockNode) return null;

a37e043184f41aae7c73c728f231819f2b68fa5e
@@ -71,6 +71,7 @@ public class FileEntity extends ContainerEntity {
 		this.importedRelationEntities = inferer.getImportedRelationEntities(importedNames);
 		this.importedTypes = inferer.getImportedTypes(importedNames);
 		this.importedFiles = inferer.getImportedFiles(importedNames);
+
 		super.inferLocalLevelEntities(inferer);
 	}
 

92a61b330674a6f9e99cf6c6ea6c8e621eaecf59
@@ -78,7 +78,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			func.inferLocalLevelEntities(inferer);
 		}
 		resolvedMixins = identiferToContainerEntity(inferer, mixins);
-		this.resolveExpressions(inferer);
+		if (inferer.isEagerExpressionResolve()) {
+			this.resolveExpressions(inferer);
+		}
 	}
 
 	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<String> identifiers) {

50a43ba3d0dd7e42af40cfa92371a2630864cb23
@@ -48,7 +48,6 @@ public class ExpressionUsage {
 		Expression expression = findExpression(ctx);
 		if (expression!=null) return expression;
 		Expression parent = findParentInStack(ctx);
-		//System.out.println("expr " + ctx.toString());
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
 		expression.text = ctx.toString();

732df06a5137eb2037e24c0b52305e6280eaec63
@@ -1,12 +1,19 @@
 package depends;
 
+import java.util.ArrayList;
+import depends.extractor.LangProcessorRegistration;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
 @Command(name = "depends")
 public class DependsCommand {
-	@Parameters(index = "0", description = "The lanauge of project files: [java, cpp]")
+	public static class SupportedLangs extends ArrayList<String> {
+		private static final long serialVersionUID = 1L;
+		public SupportedLangs() { super( LangProcessorRegistration.getRegistry().getLangs()); }
+	}
+	
+	@Parameters(index = "0", completionCandidates = DependsCommand.SupportedLangs.class, description = "The lanauge of project files: [${COMPLETION-CANDIDATES}]")
     private String lang;
 	@Parameters(index = "1", description = "The directory to be analyzed")
     private String src;
@@ -30,6 +37,8 @@ public class DependsCommand {
 	private boolean autoInclude = false;
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
+	public DependsCommand() {
+	}
 	public String getLang() {
 		return lang;
 	}

02140fab12c27d68728d1602e2aa481aec23846c
@@ -267,7 +267,7 @@ public class CandidateTypes extends TypeEntity {
 
 	
 	@Override
-	public Entity getAncestorOfType(Class classType) {
+	public Entity getAncestorOfType(@SuppressWarnings("rawtypes") Class classType) {
 		System.err.println("error: getAncestorOfType should not been invoked");
 		return super.getAncestorOfType(classType);
 	}

4c239662054d7375d9f5f7de95fadebea850c0f2
@@ -0,0 +1,21 @@
+package depends.extractor.empty;
+
+import depends.entity.repo.BuiltInType;
+
+public class EmptyBuiltInType extends BuiltInType {
+
+	@Override
+	public String[] getBuiltInMethods() {
+		return new String[] {};
+	}
+
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[] {};
+	}
+
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[] {};
+	}
+}

05c416f888dea9fc3eb9bf57f4e28aa914263c3d
@@ -0,0 +1,22 @@
+package depends.extractor.pom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import depends.entity.Entity;
+import depends.entity.repo.EntityRepo;
+import depends.extractor.empty.EmptyImportLookupStategy;
+import depends.importtypes.Import;
+
+public class PomImportLookupStategy extends EmptyImportLookupStategy  {
+	@Override
+	public List<Entity> getImportedRelationEntities(List<Import> importedList, EntityRepo repo) {
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) continue;
+			result.add(imported);
+		}
+		return result;
+	}
+}

e3f0512ef99bd46826a63b91f11912a25257aa7b
@@ -8,5 +8,8 @@ public class PomParent extends Import {
 		super(content);
 	}
 
+	public String groupId;
+	public String artifactId;
+	public String version;
 
 }

f40c7911a672c8863cc2bcf6b8a263ee7c48b1e7
@@ -1,5 +1,6 @@
-package depends.extractor.maven;
+package depends.extractor.pom;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
 
@@ -32,7 +33,7 @@ public class EntityExtractTest extends MavenParserTest{
 	@Test
 	public void test2() throws IOException {
 	    String[] srcs = new String[] {
-	    		"./src/test/resources/maven-code-examples/surefire-junit4-2.12.4.pom",
+	    		"./src/test/resources/maven-code-examples/use_parent_groupId_and_version.pom",
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -40,6 +41,6 @@ public class EntityExtractTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        //TODO: add assert 
+        assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4(2.12.4)"));
 	}
 }
\ No newline at end of file

7734d1f19ea4631b9952a69bee9d11c8d57b3365
@@ -31,7 +31,7 @@ public class EntityExtractTest extends MavenParserTest{
 	
 	
 	@Test
-	public void test2() throws IOException {
+	public void should_use_parent_groupId() throws IOException {
 	    String[] srcs = new String[] {
 	    		"./src/test/resources/maven-code-examples/use_parent_groupId_and_version.pom",
 	    	    };

3f1f6b70b5311ae1bbfce3c08a2864f19be1e4be
@@ -0,0 +1,40 @@
+package depends.extractor.pom;
+
+import java.io.File;
+import java.util.List;
+
+import depends.util.FileUtil;
+
+public class PomLocator {
+
+	private List<String> includePaths;
+	private PomParent pomParent;
+
+	public PomLocator(List<String> includePaths, PomParent pomParent) {
+		this.includePaths = includePaths;
+		this.pomParent = pomParent;
+	}
+
+	public String getLocation() {
+		StringBuilder sb = new StringBuilder();
+		sb.append(pomParent.groupId.replace(".", File.separator));
+		sb.append(File.separator);
+		sb.append(pomParent.artifactId);
+		sb.append(File.separator);
+		sb.append(pomParent.version);
+		sb.append(File.separator);
+		sb.append(pomParent.artifactId);
+		sb.append("-");
+		sb.append(pomParent.version);
+		sb.append(".pom");
+		System.out.println(sb.toString());
+		for (String includePath:includePaths) {
+			String path = includePath+File.separator+sb.toString();
+			if (FileUtil.existFile(path)) {
+				return FileUtil.uniqFilePath(path);
+			}
+		}
+		return null;
+	}
+
+}

2bf1d256e46649052957392a4e992bb689471576
@@ -43,4 +43,25 @@ public class EntityExtractTest extends MavenParserTest{
 	    inferer.resolveAllBindings();
         assertNotNull(repo.getEntity("org.apache.maven.surefire.surefire-junit4(2.12.4)"));
 	}
+	
+	@Test
+	public void should_parse_properties_in_same_pom() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/properties-test1.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+    	/*
+        <project.version>1.00</project.version>
+        <activeio-version>3.1.4</activeio-version>
+        <projectName>Apache ActiveMQ</projectName>
+        <siteId>activemq-${project.version}</siteId>	 */
+        assertEquals("1.00",entity.getProperty("project.version"));
+        assertEquals("activemq-1.00",entity.getProperty("siteId"));
+	}
 }
\ No newline at end of file

0015763f36796308409ae18dabf1546558d6b5de
@@ -3,6 +3,8 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 import java.io.IOException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -64,4 +66,34 @@ public class EntityExtractTest extends MavenParserTest{
         assertEquals("1.00",entity.getProperty("project.version"));
         assertEquals("activemq-1.00",entity.getProperty("siteId"));
 	}
+	
+	
+	@Test
+	public void should_parse_multiple_properties_in_same_pom() throws IOException {
+		Pattern p = Pattern.compile("cat");
+	     Matcher m = p.matcher("one cat two cats in the yard");
+	     StringBuffer sb = new StringBuffer();
+	     while (m.find()) {
+	         m.appendReplacement(sb, "dog");
+	     }
+	     m.appendTail(sb);
+	     
+	     System.out.println(sb.toString());
+		String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/properties-test1.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        PomArtifactEntity entity = (PomArtifactEntity)(repo.getEntity("properties-test.test(1)"));
+    	/*
+        <project.version>1.00</project.version>
+        <activeio-version>3.1.4</activeio-version>
+        <projectName>Apache ActiveMQ</projectName>
+        <anotherId>activemq-${project.version}--${activeio-version}</anotherId>	 */
+        assertEquals("activemq-1.00-3.1.4",entity.getProperty("anotherId"));
+	}
 }
\ No newline at end of file

f415479b5b75cd2a0932424e02ce9b1438a56695
@@ -45,11 +45,11 @@ abstract public class AbstractLangProcessor {
 	 */
     protected abstract FileParser createFileParser(String fileFullPath);
 
-	protected Inferer inferer;
+	public Inferer inferer;
 	protected EntityRepo entityRepo;
 	DependencyMatrix dependencyMatrix;
 	private String inputSrcPath;
-	private String[] includeDirs;
+	public String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {

0688146acd83aa9696cafc3ce8c59b15d963a44d
@@ -1,3 +1,27 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
 package depends;
 
 import java.util.ArrayList;

e60a7bb2778e88e2b649493b15828015b884e240
@@ -114,7 +114,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
-        dependencyMatrix.remapIds(entityRepo);
+        dependencyMatrix.remapIds();
         System.out.println("dependencie data generating done successfully...");	 	
     }
 

95e9c7693c8da589e8037167a804ae59c3f1fe16
@@ -114,7 +114,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
-        dependencyMatrix.remapIds();
+        dependencyMatrix = dependencyMatrix.orderedMatrix();
         System.out.println("dependencie data generating done successfully...");	 	
     }
 

87d26cacfee504df31ec6a30d77e29f81008038a
@@ -73,10 +73,6 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		return dependencyMatrix;
 	}
 
-	
-
-
-
 	private int getFileEntityIdNoException(EntityRepo entityRepo, Entity entity) {
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null)
@@ -84,6 +80,4 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		return ancestor.getId();
 	}
 
-
-
 }

0f46120a8a1bf842fb72c29a12fb32d14d191b5f
@@ -36,6 +36,7 @@ import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
 import depends.matrix.DependencyGenerator;
 import depends.matrix.DependencyMatrix;
+import depends.matrix.OrderedMatrixGenerator;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import depends.util.FileTraversal;
@@ -114,7 +115,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
-        dependencyMatrix = dependencyMatrix.orderedMatrix();
+        dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
         System.out.println("dependencie data generating done successfully...");	 	
     }
 

b3f3dc7849afc8742c1025e76a2652f27eb6bb49
@@ -51,7 +51,7 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method]")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
     private String namePathPattern="default";

f0d4e9dea522938cdd90d5c886d98456a5014b12
@@ -0,0 +1,84 @@
+package depends.format.plantuml;
+
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import depends.deptypes.DependencyType;
+import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.DependencyMatrix;
+import depends.matrix.DependencyPair;
+import depends.matrix.DependencyValue;
+
+public class PlantUmlFormatDependencyDumper extends AbstractFormatDependencyDumper {
+	@Override
+	public String getFormatName() {
+		return "plantuml";
+	}
+	
+	public PlantUmlFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+
+
+	@Override
+	public boolean output() {
+		PrintWriter writer;
+		try {
+			writer = new PrintWriter(composeFilename()+".uml");
+			ArrayList<String> files = matrix.getNodes();
+			
+			for (int i=0;i<files.size();i++) {
+				String file = files.get(i);
+				writer.println("class " + " "+file);
+			}
+			writer.println("@startuml");
+	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
+	        addRelations(writer,dependencyPairs); 
+			writer.println("@enduml");
+			writer.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
+		for (DependencyPair dependencyPair:dependencyPairs) {
+            int src = dependencyPair.getFrom();
+            int dst = dependencyPair.getTo();
+            Set<String> relations = new HashSet<>();
+            for (DependencyValue dep:dependencyPair.getDependencies()) {
+            	relations.add("\t"+ getNodeName(src) + getRelationSymbol(dep.getType()) +getNodeName(dst) + "");
+            }
+            for (String relation:relations) {
+            	writer.println(relation);
+            }
+		}		
+	}
+
+	private String getRelationSymbol(String type) {
+		if (type.equals(DependencyType.IMPLEMENT)) {
+			return "..|>";
+		}else if (type.equals(DependencyType.INHERIT)) {
+			return "--|>";
+		}else if (type.equals(DependencyType.CONTAIN)) {
+			return "*-->";
+		}else if (type.equals(DependencyType.MIXIN)) {
+			return "o-->";
+		}
+		return "..>";
+	}
+
+	private String getNodeName(int src) {
+		String result = matrix.getNodeName(src);
+//		if(result.startsWith(".")) result = result.substring(1);
+//		if(result.startsWith("/")) result = result.substring(1);
+//		if(result.startsWith("\\")) result = result.substring(1);
+		return result;
+	}
+}

7c73166c8a304f72fcd110424d570ce17be2ee18
@@ -43,7 +43,7 @@ public class DependsCommand {
     private String src;
 	@Parameters(index = "2",  description = "The output file name")
 	private String output;
-    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail(text format),dot]")
+    @Option(names = {"-f", "--format"},split=",",  description = "the output format: [json(default),xml,excel,detail,dot,plantuml]")
     private String[] format=new String[]{"json"};
 	@Option(names = {"-d", "--dir"},  description = "The output directory")
 	private String dir;

1d52a169b376302d9f452bb6f6c0370b3c840a38
@@ -34,9 +34,9 @@ import org.codehaus.plexus.util.FileUtils;
 
 import depends.entity.repo.BuiltInType;
 import depends.entity.repo.EntityRepo;
-import depends.matrix.DependencyGenerator;
-import depends.matrix.DependencyMatrix;
-import depends.matrix.OrderedMatrixGenerator;
+import depends.generator.DependencyGenerator;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.transform.OrderedMatrixGenerator;
 import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import depends.util.FileTraversal;

0ea6f03acd8e3fa13192ae1484fb31f60c9cbb94
@@ -94,14 +94,14 @@ public class ExpressionUsage {
 			expression.isCall = true;
 		}
 		if (ctx instanceof ICPPASTNewExpression) {
-			expression.rawType = ASTStringUtil.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
+			expression.rawType = ASTStringUtilExt.getTypeIdString(((ICPPASTNewExpression)ctx).getTypeId());
 			expression.isCall = true;
 			expression.deriveTypeFromChild = false;
 		}
 
 		if (ctx instanceof IASTCastExpression) {
 			expression.isCast=true;
-			expression.rawType = ASTStringUtil.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
+			expression.rawType = ASTStringUtilExt.getTypeIdString(((IASTCastExpression)ctx).getTypeId());
 			expression.deriveTypeFromChild = false;
 
 		}
@@ -137,7 +137,7 @@ public class ExpressionUsage {
 			expression.rawType =  "<Built-in>";
 		}else if (ctx instanceof IASTTypeIdExpression) {
 		//3. if given type directly
-			expression.rawType = ASTStringUtil.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
+			expression.rawType = ASTStringUtilExt.getTypeIdString(((IASTTypeIdExpression)ctx).getTypeId());
 			//TODO: check
 		}
 	}

cc39d49032383fc435d11548c4d1e11e72e48c43
@@ -0,0 +1,38 @@
+package depends.extractor.kotlin;
+
+import java.io.IOException;
+
+import org.antlr.v4.runtime.CharStream;
+import org.antlr.v4.runtime.CharStreams;
+import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.Lexer;
+import org.antlr.v4.runtime.tree.ParseTreeWalker;
+
+import depends.entity.repo.EntityRepo;
+import depends.extractor.FileParser;
+import depends.relations.Inferer;
+
+public class KotlinFileParser implements FileParser {
+
+	@Override
+	public void parse() throws IOException {
+	       CharStream input = CharStreams.fromFileName(fileFullPath);
+	        Lexer lexer = new KotlinLexer(input);
+	        CommonTokenStream tokens = new CommonTokenStream(lexer);
+	        KotlinParser parser = new KotlinParser(tokens);
+	        KotlinListener bridge = new KotlinListener(fileFullPath, entityRepo,inferer);
+		    ParseTreeWalker walker = new ParseTreeWalker();
+		    walker.walk(bridge, parser.kotlinFile());
+	}
+	
+	private String fileFullPath;
+	private EntityRepo entityRepo;
+	private Inferer inferer;
+	public KotlinFileParser(String fileFullPath,EntityRepo entityRepo, Inferer inferer) {
+        this.fileFullPath = fileFullPath;
+        this.entityRepo = entityRepo;
+        this.inferer = inferer;
+	}
+
+
+}

591411548f540dd2d9140a07d9664cdd89946ca0
@@ -170,5 +170,6 @@ abstract public class AbstractLangProcessor {
 	public void setDependencyGenerator(DependencyGenerator dependencyGenerator) {
 		this.dependencyGenerator = dependencyGenerator;
 	}
+	public abstract List<String> supportedRelations();
 
 }

1975777eaebe51249170858dd42764930f232962
@@ -53,7 +53,7 @@ public class PlantUmlFormatDependencyDumper extends AbstractFormatDependencyDump
             int dst = dependencyPair.getTo();
             Set<String> relations = new HashSet<>();
             for (DependencyValue dep:dependencyPair.getDependencies()) {
-            	relations.add("\t"+ getNodeName(src) + getRelationSymbol(dep.getType()) +getNodeName(dst) + "");
+            	relations.add("\t"+ getNodeName(src) + " " + getRelationSymbol(dep.getType()) +" " + getNodeName(dst) + "");
             }
             for (String relation:relations) {
             	writer.println(relation);
@@ -76,9 +76,7 @@ public class PlantUmlFormatDependencyDumper extends AbstractFormatDependencyDump
 
 	private String getNodeName(int src) {
 		String result = matrix.getNodeName(src);
-//		if(result.startsWith(".")) result = result.substring(1);
-//		if(result.startsWith("/")) result = result.substring(1);
-//		if(result.startsWith("\\")) result = result.substring(1);
+		result = result.replace("-", "_");
 		return result;
 	}
 }

4b76b093a48e6abfae442b288db9362b4a01467b
@@ -32,7 +32,7 @@ public class KotlinProcessor extends AbstractLangProcessor {
 
 	@Override
 	public String supportedLanguage() {
-		return "kotlin";
+		return "kotlin[on-going]";
 	}
 
 	@Override

86e7c895c7fb279a4ba51e20ffeba80b8afa533c
@@ -0,0 +1,5 @@
+package depends.extractor.python;
+
+public class ExpressionUsage {
+
+}

7360bdc13f9441981585a7ed36e9cf6c309feb7a
@@ -83,6 +83,15 @@ public abstract class HandlerContext {
 		return ;		
 	}
 	
+	/**
+	 * Tell the context that a new method was found.
+	 * Do not forget to tell the context leave the method when you finish
+	 * the process of the method
+	 * @param methodName
+	 * @param returnType  - if no return type information avaliable, keep it as null;
+	 * @param throwedType - if no throwed type information avaliable, keep it as empty list;  
+	 * @return the new function enity
+	 */
 	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
 		FunctionEntity functionEntity = new FunctionEntity(methodName, this.latestValidContainer(),
 				idGenerator.generateId(),returnType);

5bb575a6c9b0f0d40174657087ad682b5533d9e4
@@ -0,0 +1,50 @@
+package depends.extractor.python;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.entity.Entity;
+import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
+import depends.extractor.pom.PomFileParser;
+
+public class PythonClassTest extends PythonParserTest {
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_parse_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity("Foo"));
+	}
+	
+	@Test
+	public void should_parse_method_of_class() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/class.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    TypeEntity type = (TypeEntity)repo.getEntity("Foo");
+        assertEquals(2,type.getFunctions().size());
+	}
+}

78c3d0e8b4e5c48647a944833c7d1eef5a690848
@@ -64,8 +64,12 @@ public abstract class HandlerContext {
 	}
 
 	
-
-	public Entity foundNewType(String classOrInterfaceName) {
+	/**
+	 * Tell the context object that a new type founded.
+	 * @param classOrInterfaceName
+	 * @return
+	 */
+	public TypeEntity foundNewType(String classOrInterfaceName) {
 		TypeEntity currentTypeEntity = new TypeEntity(classOrInterfaceName, this.latestValidContainer(),
 			idGenerator.generateId());
 		pushToStack(currentTypeEntity);

abcfc508235d96e36355792435c7b60852db42b3
@@ -53,14 +53,14 @@ public class AliasEntity extends Entity {
 			referToEntity = entity;
 	}
 
-	public Collection<TypeEntity> getResolvedTypeParameters() {
+	public Collection<Entity> getResolvedTypeParameters() {
 		if (!(referToEntity instanceof DecoratedEntity))
 			return new ArrayList<>();
 		DecoratedEntity origin = (DecoratedEntity) referToEntity;
 		return origin.getResolvedTypeParameters();
 	}
 
-	public Collection<TypeEntity> getResolvedAnnotations() {
+	public Collection<Entity> getResolvedAnnotations() {
 		if (!(referToEntity instanceof DecoratedEntity))
 			return new ArrayList<>();
 		DecoratedEntity origin = (DecoratedEntity) referToEntity;
@@ -127,7 +127,7 @@ public class AliasEntity extends Entity {
 		return null;
 	}
 
-	public Collection<TypeEntity> getReturnTypes() {
+	public Collection<Entity> getReturnTypes() {
 		if (!(referToEntity instanceof FunctionEntity))
 			return new ArrayList<>();
 		FunctionEntity origin = (FunctionEntity) referToEntity;
@@ -145,7 +145,7 @@ public class AliasEntity extends Entity {
 		return origin.getParameters();
 	}
 
-	public Collection<TypeEntity> getThrowTypes() {
+	public Collection<Entity> getThrowTypes() {
 		if (!(referToEntity instanceof FunctionEntity))
 			return new ArrayList<>();
 		FunctionEntity origin = (FunctionEntity) referToEntity;

b74252b07c979d6e0cb2885c997db6c5e3defe65
@@ -1,5 +1,170 @@
 package depends.extractor.python;
 
+import java.util.List;
+
+import org.antlr.v4.runtime.ParserRuleContext;
+
+import depends.entity.ContainerEntity;
+import depends.entity.Expression;
+import depends.entity.FunctionEntity;
+import depends.entity.VarEntity;
+import depends.entity.repo.IdGenerator;
+import depends.extractor.python.Python3Parser.And_testContext;
+import depends.extractor.python.Python3Parser.Arith_exprContext;
+import depends.extractor.python.Python3Parser.AtomContext;
+import depends.extractor.python.Python3Parser.Atom_exprContext;
+import depends.extractor.python.Python3Parser.AugassignContext;
+import depends.extractor.python.Python3Parser.ComparisonContext;
+import depends.extractor.python.Python3Parser.Expr_stmtContext;
+import depends.extractor.python.Python3Parser.Not_testContext;
+import depends.extractor.python.Python3Parser.Or_testContext;
+import depends.extractor.python.Python3Parser.Raise_stmtContext;
+import depends.extractor.python.Python3Parser.Return_stmtContext;
+import depends.extractor.python.Python3Parser.Shift_exprContext;
+import depends.extractor.python.Python3Parser.Xor_exprContext;
+import depends.relations.Inferer;
+
 public class ExpressionUsage {
+	IdGenerator idGenerator;
+	Inferer inferer;
+	private PythonHandlerContext context;
+	private PythonParserHelper helper;
+	public ExpressionUsage(PythonHandlerContext context,IdGenerator idGenerator, PythonParserHelper helper, Inferer inferer) {
+		this.context = context;
+		this.idGenerator = idGenerator;
+		this.inferer = inferer;
+		this.helper = helper;
+	}
+	
+	public Expression foundExpression(ParserRuleContext ctx) {
+		Expression expression = findExpression(ctx);
+		if (expression!=null) return expression;
+		Expression parent = findParentInStack(ctx);
+		/* create expression and link it with parent*/
+		expression = new Expression(idGenerator.generateId());
+		expression.text = ctx.toString();
+		expression.parent = parent;
+		if (expression.parent!=null) {
+			if (expression.parent.deduceTypeBasedId==null) 
+				expression.parent.deduceTypeBasedId = expression.id;
+			/* Set operation always use the 2nd expr's type*/
+			if (expression.parent.isSet) {
+				expression.parent.deduceTypeBasedId = expression.id;
+			}
+		}
+		context.lastContainer().addExpression(ctx,expression);
+		if (ctx instanceof AtomContext) {
+			AtomContext atom = (AtomContext)ctx;
+			if (atom.NUMBER()!=null ||
+					atom.STRING()!=null &&
+					atom.STRING().size()>0) {
+				expression.identifier = "<literal>";
+				expression.rawType = Inferer.buildInType.getQualifiedName();
+			}else if (atom.getText().equals("True")||
+					atom.getText().equals("False")) {
+				expression.identifier = "<boolean>";
+				expression.rawType = Inferer.buildInType.getQualifiedName();
+			}else if (atom.getText().equals("None")) {
+				expression.identifier = "<null>";
+				expression.rawType = Inferer.buildInType.getQualifiedName();
+			}else if (atom.NAME()!=null) {
+				expression.identifier = atom.NAME().getText();
+			}
+		}else if (ctx instanceof Or_testContext || ctx instanceof And_testContext ||
+				ctx instanceof Not_testContext || ctx instanceof ComparisonContext){ 
+			expression.identifier = "<logical>";
+			expression.rawType = Inferer.buildInType.getQualifiedName();
+		}else if (ctx instanceof Xor_exprContext ||
+				ctx instanceof Shift_exprContext ||
+				ctx instanceof Arith_exprContext ||
+				ctx instanceof AugassignContext) {
+			expression.identifier = "<arith>";
+			expression.rawType = Inferer.buildInType.getQualifiedName();
+		}
+		
+		
+		if (ctx instanceof Expr_stmtContext) {
+			Expr_stmtContext expr = ((Expr_stmtContext)ctx);
+			if ((expr.expr_stmt_rhs()!=null)||
+					(expr.augassign()!=null)||
+					(expr.annassign()!=null))
+			{
+				expression.isSet = true;
+			}
+		}else if (ctx instanceof Atom_exprContext) {
+			Atom_exprContext expr = ((Atom_exprContext)ctx);
+			if (expr.func_call()!=null) {
+				expression.isCall = true;
+				expression.identifier = helper.getFirstName(expr.atom_expr());
+			}
+			else if (expr.member_access()!=null) {
+				expression.isDot = true;
+			}
+			//TODO: member access in python should be handled seperately. they could be different types;
+		}else if (ctx instanceof Return_stmtContext) {
+			deduceReturnTypeInCaseOfReturn(ctx,expression);
+		}else if (ctx instanceof Raise_stmtContext) {
+			expression.isThrow = true;
+			expression.deriveTypeFromChild = true;
+		}
+		deduceVarTypeInCaseOfAssignment(ctx, expression);
+		return expression;
+	}
+
+
+	/**
+	 * Auto deduce variable type from assignment.
+	 * for example:
+	 *       c = C.new  then c is type of C
+	 * @param node
+	 * @param expression
+	 */
+	private void deduceVarTypeInCaseOfAssignment(ParserRuleContext node, Expression expression) {
+		ParserRuleContext parentNode = node.getParent();
+		if (parentNode instanceof Expr_stmtContext) {
+			Expr_stmtContext expr = (Expr_stmtContext)parentNode;
+			if (expr.expr_stmt_rhs()!=null) {
+				ContainerEntity scope = helper.getScopeOfVar(expr, this.context);
+				if (scope==null) return;
+				String varName = null;
+				//TODO: should handle list properly;
+				List<String> names = helper.getName(expr.testlist_star_expr());
+				if (names.size()==1)
+					varName = names.get(0);
+				if (varName==null) return;
+				VarEntity var = scope.lookupVarLocally(varName );
+				if (var!=null) {
+					expression.addDeducedTypeVar(var);
+				}
+			}
+		}
+	}
+	
+	private void deduceReturnTypeInCaseOfReturn(ParserRuleContext ctx, Expression expression) {
+		FunctionEntity currentFunction = context.currentFunction();
+		if (currentFunction ==null) return;
+		if (ctx instanceof Return_stmtContext) {
+			expression.addDeducedTypeFunction(currentFunction);
+		}
+	}
+	
+	private Expression findParentInStack(ParserRuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		if (context.lastContainer().expressions().containsKey(ctx.getParent())) return context.lastContainer().expressions().get(ctx.getParent());
+		return findParentInStack(ctx.getParent());
+	}
+	
+	private Expression findExpression(ParserRuleContext ctx) {
+		if (ctx==null) return null;
+		if (ctx.getParent()==null) return null;
+		if (context.lastContainer()==null) {
+			return null;
+		}
+		return context.lastContainer().expressions().get(ctx);
+	}
 
 }

aa18f1a885d7b9f8460fa6b254ae3ef78876782d
@@ -5,8 +5,10 @@ import java.util.List;
 import org.antlr.v4.runtime.ParserRuleContext;
 
 import depends.entity.ContainerEntity;
+import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
+import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
 import depends.extractor.python.Python3Parser.And_testContext;
@@ -94,11 +96,18 @@ public class ExpressionUsage {
 		}else if (ctx instanceof Atom_exprContext) {
 			Atom_exprContext expr = ((Atom_exprContext)ctx);
 			if (expr.func_call()!=null) {
-				expression.isCall = true;
 				expression.identifier = helper.getFirstName(expr.atom_expr());
+
+				Entity entity = context.foundEntityWithName(expression.identifier);
+				if (entity instanceof TypeEntity) {
+					expression.isCreate = true;
+				}else {
+					expression.isCall = true;
+				}
 			}
 			else if (expr.member_access()!=null) {
 				expression.isDot = true;
+				expression.identifier = expr.member_access().NAME().getText();
 			}
 			//TODO: member access in python should be handled seperately. they could be different types;
 		}else if (ctx instanceof Return_stmtContext) {

19b8f2cc6573262bb35cf03aa69bff814ea13613
@@ -44,7 +44,7 @@ public class ExpressionUsage {
 		Expression parent = findParentInStack(ctx);
 		/* create expression and link it with parent*/
 		expression = new Expression(idGenerator.generateId());
-		expression.text = ctx.toString();
+		expression.text = ctx.getText();
 		expression.parent = parent;
 		if (expression.parent!=null) {
 			if (expression.parent.deduceTypeBasedId==null) 
@@ -72,16 +72,6 @@ public class ExpressionUsage {
 			}else if (atom.NAME()!=null) {
 				expression.identifier = atom.NAME().getText();
 			}
-		}else if (ctx instanceof Or_testContext || ctx instanceof And_testContext ||
-				ctx instanceof Not_testContext || ctx instanceof ComparisonContext){ 
-			expression.identifier = "<logical>";
-			expression.rawType = Inferer.buildInType.getQualifiedName();
-		}else if (ctx instanceof Xor_exprContext ||
-				ctx instanceof Shift_exprContext ||
-				ctx instanceof Arith_exprContext ||
-				ctx instanceof AugassignContext) {
-			expression.identifier = "<arith>";
-			expression.rawType = Inferer.buildInType.getQualifiedName();
 		}
 		
 		

f56f4bfef3d33338e25dd5ab6a1ec926641e6b67
@@ -18,12 +18,14 @@ public class PythonFileParser implements FileParser {
 	private String fileFullPath;
 	private EntityRepo entityRepo;
 	private Inferer inferer;
+	private IncludedFileLocator includeFileLocator;
 
-	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includedFileLocator,
+	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includeFileLocator,
 			Inferer inferer, PythonProcessor pythonProcessor) {
 		this.fileFullPath = fileFullPath;
 		this.entityRepo = entityRepo;
 		this.inferer = inferer;
+		this.includeFileLocator = includeFileLocator;
 	}
 
 	@Override

8b44b187b1c561cec399b1db222e1e04e0ac7e3d
@@ -8,6 +8,8 @@ import org.antlr.v4.runtime.CommonTokenStream;
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
+import depends.entity.Entity;
+import depends.entity.FileEntity;
 import depends.entity.repo.EntityRepo;
 import depends.extractor.FileParser;
 import depends.extractor.ruby.IncludedFileLocator;
@@ -19,6 +21,7 @@ public class PythonFileParser implements FileParser {
 	private EntityRepo entityRepo;
 	private Inferer inferer;
 	private IncludedFileLocator includeFileLocator;
+	private PythonProcessor processor;
 
 	public PythonFileParser(String fileFullPath, EntityRepo entityRepo, IncludedFileLocator includeFileLocator,
 			Inferer inferer, PythonProcessor pythonProcessor) {
@@ -26,17 +29,26 @@ public class PythonFileParser implements FileParser {
 		this.entityRepo = entityRepo;
 		this.inferer = inferer;
 		this.includeFileLocator = includeFileLocator;
+		this.processor = pythonProcessor;
 	}
 
 	@Override
 	public void parse() throws IOException {
+		/** If file already exist, skip it */
+		Entity fileEntity = entityRepo.getEntity(fileFullPath);
+		if (fileEntity!=null && fileEntity instanceof FileEntity) {
+			return;
+		}
         CharStream input = CharStreams.fromFileName(fileFullPath);
         Lexer lexer = new Python3Lexer(input);
         CommonTokenStream tokens = new CommonTokenStream(lexer);
         Python3Parser parser = new Python3Parser(tokens);
-        Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer);
+        Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();
 	    walker.walk(bridge, parser.file_input());
+	    
+		fileEntity = entityRepo.getEntity(fileFullPath);
+		fileEntity.inferEntities(inferer);
 	}
 
 }

46d74885110c34cd8e4f01990d5828ad7a4af826
@@ -133,4 +133,8 @@ public class FileEntity extends ContainerEntity {
 		return importedFileCollector.getFiles();
 	}
 
+	public List<Import> getImportedNames() {
+		return importedNames;
+	}
+
 }

ee7f8fb970603e83023c7ba9af905fa1e71bb0c9
@@ -31,7 +31,7 @@ import java.util.Set;
 import depends.importtypes.Import;
 import depends.relations.Inferer;
 
-public class FileEntity extends ContainerEntity {
+public class FileEntity extends TypeEntity {
 	private List<Import> importedNames = new ArrayList<>();
 	private boolean isInProjectScope = false;
 	private List<Entity> importedRelationEntities = new ArrayList<>();

53ea2c4e496abc989dc868a2700808e9d6aa061b
@@ -25,6 +25,7 @@ SOFTWARE.
 package depends.entity;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
@@ -34,9 +35,9 @@ import depends.relations.Inferer;
 public class FileEntity extends TypeEntity {
 	private List<Import> importedNames = new ArrayList<>();
 	private boolean isInProjectScope = false;
-	private List<Entity> importedRelationEntities = new ArrayList<>();
-	private List<Entity> importedFiles = new ArrayList<>();
-	private List<Entity> importedTypes = new ArrayList<>();
+	private Collection<Entity> importedRelationEntities = new ArrayList<>();
+	private Collection<Entity> importedFiles = new ArrayList<>();
+	private Collection<Entity> importedTypes = new ArrayList<>();
 	private List<TypeEntity> declaredTypes = new ArrayList<>();
 	private ImportedFileCollector importedFileCollector = null;
 	public FileEntity(String fullName, int fileId, boolean isInProjectScope) {
@@ -106,15 +107,15 @@ public class FileEntity extends TypeEntity {
 		this.isInProjectScope = isInProjectScope;
 	}
 
-	public List<Entity> getImportedRelationEntities() {
+	public Collection<Entity> getImportedRelationEntities() {
 		return importedRelationEntities;
 	}
 
-	public List<Entity> getImportedFiles() {
+	public Collection<Entity> getImportedFiles() {
 		return importedFiles;
 	}
 
-	public List<Entity> getImportedTypes() {
+	public Collection<Entity> getImportedTypes() {
 		return importedTypes;
 	}
 

26501da0b6cc85630c535fa5b756b0d8e60975b6
@@ -48,6 +48,9 @@ public class PythonFileParser implements FileParser {
 	    walker.walk(bridge, parser.file_input());
 	    
 		fileEntity = entityRepo.getEntity(fileFullPath);
+		if (fileEntity.getRawName().contains("av_bench.py")) {
+			System.out.println("hlo");
+		}
 		fileEntity.inferEntities(inferer);
 	}
 

2906517017bdb3e65b0000eb0f5b32c0f4233ab8
@@ -8,22 +8,13 @@ import depends.entity.ContainerEntity;
 import depends.entity.Entity;
 import depends.entity.Expression;
 import depends.entity.FunctionEntity;
-import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.entity.repo.IdGenerator;
-import depends.extractor.python.Python3Parser.And_testContext;
-import depends.extractor.python.Python3Parser.Arith_exprContext;
 import depends.extractor.python.Python3Parser.AtomContext;
 import depends.extractor.python.Python3Parser.Atom_exprContext;
-import depends.extractor.python.Python3Parser.AugassignContext;
-import depends.extractor.python.Python3Parser.ComparisonContext;
 import depends.extractor.python.Python3Parser.Expr_stmtContext;
-import depends.extractor.python.Python3Parser.Not_testContext;
-import depends.extractor.python.Python3Parser.Or_testContext;
 import depends.extractor.python.Python3Parser.Raise_stmtContext;
 import depends.extractor.python.Python3Parser.Return_stmtContext;
-import depends.extractor.python.Python3Parser.Shift_exprContext;
-import depends.extractor.python.Python3Parser.Xor_exprContext;
 import depends.relations.Inferer;
 
 public class ExpressionUsage {

3fbc714e2879967c93806f63b0d7a344ca60fb4f
@@ -48,9 +48,6 @@ public class PythonFileParser implements FileParser {
 	    walker.walk(bridge, parser.file_input());
 	    
 		fileEntity = entityRepo.getEntity(fileFullPath);
-		if (fileEntity.getRawName().contains("av_bench.py")) {
-			System.out.println("hlo");
-		}
 		fileEntity.inferEntities(inferer);
 	}
 

b499608b3494ccf7bf40fee3f24620f5aece9f29
@@ -29,7 +29,7 @@ import java.util.Collection;
 
 import depends.relations.Inferer;
 
-public class TypeEntity extends ContainerEntity{
+public class TypeEntity extends ContainerEntity {
 	Collection<TypeEntity> inheritedTypes = new ArrayList<>();
 	Collection<TypeEntity> implementedTypes = new ArrayList<>();
 	Collection<String> inhertedTypeIdentifiers;
@@ -37,51 +37,75 @@ public class TypeEntity extends ContainerEntity{
 	TypeEntity inheritedType;
 
 	public TypeEntity(String simpleName, Entity parent, Integer id) {
-		super(simpleName,parent,id);
+		super(simpleName, parent, id);
 		inhertedTypeIdentifiers = new ArrayList<>();
 		implementedIdentifiers = new ArrayList<>();
 	}
+
 	@Override
 	public void inferLocalLevelEntities(Inferer inferer) {
-		inheritedTypes= new ArrayList<>();
-		identiferToEntities(inferer,this.inhertedTypeIdentifiers).forEach(item->inheritedTypes.add((TypeEntity)item));
+		inheritedTypes = new ArrayList<>();
+		identiferToEntities(inferer, this.inhertedTypeIdentifiers).forEach(item -> {
+			if (item instanceof TypeEntity) {
+				inheritedTypes.add((TypeEntity) item);
+			}else {
+				System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
+			}
+		});
 		inheritedTypes.remove(this);
 
-		implementedTypes= new ArrayList<>();
-		identiferToEntities(inferer,this.implementedIdentifiers).forEach(item->implementedTypes.add((TypeEntity)item));
+		implementedTypes = new ArrayList<>();
+		identiferToEntities(inferer, this.implementedIdentifiers)
+				.forEach(item -> {
+					if (item instanceof TypeEntity) {
+						implementedTypes.add((TypeEntity) item);
+					}else {
+						System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
+					}
+				});
 		implementedTypes.remove(this);
-		if (inheritedTypes.size()>0)
+		if (inheritedTypes.size() > 0)
 			inheritedType = inheritedTypes.iterator().next();
 		super.inferLocalLevelEntities(inferer);
 	}
+
 	public void addImplements(String typeName) {
-		if (typeName.equals(this.getRawName())) return;
-		if (implementedIdentifiers.contains(typeName)) return;
-		if (typeName.equals(this.rawName)) return;
+		if (typeName.equals(this.getRawName()))
+			return;
+		if (implementedIdentifiers.contains(typeName))
+			return;
+		if (typeName.equals(this.rawName))
+			return;
 		this.implementedIdentifiers.add(typeName);
 	}
+
 	public void addExtends(String typeName) {
-		if (typeName.equals(this.getRawName())) return;
-		if (inhertedTypeIdentifiers.contains(typeName)) return;
-		if (typeName.equals(this.rawName)) return;
+		if (typeName.equals(this.getRawName()))
+			return;
+		if (inhertedTypeIdentifiers.contains(typeName))
+			return;
+		if (typeName.equals(this.rawName))
+			return;
 		this.inhertedTypeIdentifiers.add(typeName);
 	}
+
 	public Collection<TypeEntity> getInheritedTypes() {
 		return inheritedTypes;
 	}
-	
+
 	public Collection<TypeEntity> getImplementedTypes() {
 		return implementedTypes;
 	}
-	
- 	public TypeEntity getInheritedType() {
+
+	public TypeEntity getInheritedType() {
 		return inheritedType;
 	}
- 	
- 	@Override
- 	public FunctionEntity lookupFunctionLocally(String functionName) {
+
+	@Override
+	public FunctionEntity lookupFunctionLocally(String functionName) {
 		FunctionEntity func = super.lookupFunctionLocally(functionName);
-		if (func!=null) return func;
+		if (func != null)
+			return func;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
 			func = inhertedType.lookupFunctionLocally(functionName);
 			if (func != null)
@@ -90,16 +114,18 @@ public class TypeEntity extends ContainerEntity{
 		if (func != null)
 			return func;
 		for (TypeEntity implType : getImplementedTypes()) {
-			func = implType.lookupFunctionLocally( functionName);
+			func = implType.lookupFunctionLocally(functionName);
 			if (func != null)
 				break;
 		}
 		return func;
- 	}
- 	@Override
- 	public VarEntity lookupVarLocally(String varName) {
- 		VarEntity var = super.lookupVarLocally(varName);
-		if (var!=null) return var;
+	}
+
+	@Override
+	public VarEntity lookupVarLocally(String varName) {
+		VarEntity var = super.lookupVarLocally(varName);
+		if (var != null)
+			return var;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
 			var = inhertedType.lookupVarLocally(varName);
 			if (var != null)
@@ -108,14 +134,15 @@ public class TypeEntity extends ContainerEntity{
 		if (var != null)
 			return var;
 		for (TypeEntity implType : getImplementedTypes()) {
-			var = implType.lookupVarLocally( varName);
+			var = implType.lookupVarLocally(varName);
 			if (var != null)
 				break;
 		}
 		return var;
 	}
- 	@Override
- 	public TypeEntity getType() {
+
+	@Override
+	public TypeEntity getType() {
 		return this;
 	}
 }

aa0fc62e76ec5dd6f801cf3b2b84524879c10365
@@ -111,7 +111,7 @@ public class FunctionEntity extends ContainerEntity{
 	@Override
 	public String getDisplayName() {
 		FileEntity f = (FileEntity) this.getAncestorOfType(FileEntity.class);
-		return f.getRawName()+"("+getRawName()+")";
+		return f.getRawName()+"("+this.getQualifiedName()+")";
 	}
 	@Override
 	public VarEntity lookupVarLocally(String varName) {

f4c48c2854b43b3b3da8662775eedebf4e0705ec
@@ -27,6 +27,7 @@ package depends.extractor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Stack;
+import java.util.stream.Collectors;
 
 import depends.entity.ContainerEntity;
 import depends.entity.Entity;
@@ -212,10 +213,8 @@ public abstract class HandlerContext {
 	}
 
 
-	public void foundVarDefinitions(List<String> varNames, String type, List<String> typeArguments) {
-		for (String varName : varNames) {
-			foundVarDefinition(varName,type,typeArguments);
-		}
+	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<String> typeArguments) {
+		return varNames.stream().map(item->foundVarDefinition(item,type,typeArguments)).collect(Collectors.toList());
 	}
 	
 	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
@@ -228,15 +227,19 @@ public abstract class HandlerContext {
 		if (var!=null) return var;
 		var = new VarEntity(varName, null, container, idGenerator.generateId());
 		container.addVar(var);
+		entityRepo.add(var);
+
 		return var;
 	}
 	
 
 
-	public void foundVarDefinition(String varName, String type, List<String> typeArguments) {
+	public VarEntity foundVarDefinition(String varName, String type, List<String> typeArguments) {
 		VarEntity var = new VarEntity(varName, type, lastContainer(), idGenerator.generateId());
 		var.addTypeParameter(typeArguments);
-		lastContainer().addVar(var);		
+		lastContainer().addVar(var);	
+		entityRepo.add(var);
+		return var;
 	}
 	
 	public void addMethodParameter(String paramName) {

e70523571dbd04f8db9ee2e4fe3b8d56eaf4d3d8
@@ -89,19 +89,24 @@ public class RelationCounter {
 			if (referredEntity==null) {
 				continue;
 			}
+			boolean matched = false;
 			if (expression.isCall) {
 				entity.addRelation(new Relation(DependencyType.CALL,referredEntity));
+				matched = true;
 			}
-			else if (expression.isCreate) {
+			if (expression.isCreate) {
 				entity.addRelation(new Relation(DependencyType.CREATE,referredEntity));
+				matched = true;
 			}
-			else if (expression.isThrow) {
+			if (expression.isThrow) {
 				entity.addRelation(new Relation(DependencyType.THROW,referredEntity));
+				matched = true;
 			}
-			else if (expression.isCast) { 
+			if (expression.isCast) { 
 				entity.addRelation(new Relation(DependencyType.CAST,referredEntity));
+				matched = true;
 			}
-			else  {
+			if (!matched)  {
 				usedEntities.add(expression.getReferredEntity());
 			}
 		}

0088f1c359f852bd5d383395ca887338b0402fae
@@ -70,6 +70,9 @@ public class TypeEntity extends ContainerEntity {
 	}
 
 	public void addImplements(String typeName) {
+		if (typeName==null) {
+			return;
+		}
 		if (typeName.equals(this.getRawName()))
 			return;
 		if (implementedIdentifiers.contains(typeName))
@@ -80,6 +83,9 @@ public class TypeEntity extends ContainerEntity {
 	}
 
 	public void addExtends(String typeName) {
+		if (typeName==null) {
+			return;
+		}
 		if (typeName.equals(this.getRawName()))
 			return;
 		if (inhertedTypeIdentifiers.contains(typeName))
@@ -103,38 +109,52 @@ public class TypeEntity extends ContainerEntity {
 
 	@Override
 	public FunctionEntity lookupFunctionLocally(String functionName) {
+		Collection<TypeEntity> searchedTypes = new ArrayList<>();
+		return lookupFunctionLocally(functionName,searchedTypes);
+	}
+
+	private FunctionEntity lookupFunctionLocally(String functionName, Collection<TypeEntity> searched) {
+		if (searched.contains(this)) return null;
+		searched.add(this);
 		FunctionEntity func = super.lookupFunctionLocally(functionName);
 		if (func != null)
 			return func;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
-			func = inhertedType.lookupFunctionLocally(functionName);
+			func = inhertedType.lookupFunctionLocally(functionName, searched);
 			if (func != null)
 				break;
 		}
 		if (func != null)
 			return func;
 		for (TypeEntity implType : getImplementedTypes()) {
-			func = implType.lookupFunctionLocally(functionName);
+			func = implType.lookupFunctionLocally(functionName,searched);
 			if (func != null)
 				break;
 		}
 		return func;
 	}
-
+	
 	@Override
 	public VarEntity lookupVarLocally(String varName) {
+		Collection<TypeEntity> searchedTypes = new ArrayList<>();
+		return lookupVarLocally(varName,searchedTypes);
+	}
+	
+	private VarEntity lookupVarLocally(String varName, Collection<TypeEntity> searched) {
+		if (searched.contains(this)) return null;
+		searched.add(this);
 		VarEntity var = super.lookupVarLocally(varName);
 		if (var != null)
 			return var;
 		for (TypeEntity inhertedType : getInheritedTypes()) {
-			var = inhertedType.lookupVarLocally(varName);
+			var = inhertedType.lookupVarLocally(varName,searched);
 			if (var != null)
 				break;
 		}
 		if (var != null)
 			return var;
 		for (TypeEntity implType : getImplementedTypes()) {
-			var = implType.lookupVarLocally(varName);
+			var = implType.lookupVarLocally(varName,searched);
 			if (var != null)
 				break;
 		}

c06448455579ac860e3231c8340714e9fb1d011e
@@ -2,6 +2,7 @@ package depends.extractor.cpp;
 import java.io.IOException;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
@@ -13,7 +14,7 @@ public class TypeDefTest extends CppParserTest{
     	super.init();
     }
 	
-	@Test
+	@Ignore
 	public void test_ref_parameter() throws IOException {
 	    String[] srcs = new String[] {
 	    		"./src/test/resources/cpp-code-examples/TypeDefTest.cpp",

0aa68e1b303d8ecfaa9d070aef5f9edc02a773cc
@@ -27,6 +27,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -165,6 +166,10 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 	}
 
+	public void cleanExpression() {
+		this.expressions = null;
+	}
+
 	public TypeEntity getLastExpressionType() {
 		for (int i=this.expressionList.size()-1;i>=0;i--) {
 			Expression expr= this.expressionList.get(i);
@@ -285,4 +290,14 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public Collection<ContainerEntity> getResolvedMixins() {
 		return resolvedMixins;
 	}
+
+
+
+	public List<Expression> expressionList() {
+		return expressionList;
+	}
+
+
+
+	
 }

36da25ae72f6da4e0d352eb0c2f2c94453f1f1fe
@@ -60,7 +60,7 @@ public class IncludeRelationTest extends CppParserTest{
 	@Test
 	public void test_type_t_should_be_treat_as_structure() throws IOException {
 	    String[] srcs = new String[] {
-	    		"./src/test/resources/cpp-code-examples/typedefTest.cpp",
+	    		"./src/test/resources/cpp-code-examples/typedeftest2.cpp",
 	    	    };
 	    
 	    for (String src:srcs) {

c671159811f1b49cde87b2cd17a21b94a79d589b
@@ -51,7 +51,7 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#]")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
     private String namePathPattern="default";

5ece4e7c6b382d64750e632187291e71fdce43b4
@@ -118,4 +118,20 @@ public class PythonImportTest extends PythonParserTest {
 		this.assertContainsRelation(file, DependencyType.CALL,"foo");
 		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
+	
+	@Test
+	public void should_parse_import_with_prefix_dots() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/python-code-examples/import_with_dir/importing.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/imported_a.py",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PythonFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+	}
 }

0a1aba7f2ba19937fb75cd8aa93295091a277d3c
@@ -108,5 +108,9 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 	public List<Entity> getImportedFiles(List<Import> importedList, EntityRepo repo) {
 		return getImportedRelationEntities(importedList,repo);
 	}
-
+	
+	@Override
+	public boolean supportGlobalNameLookup() {
+		return false;
+	}
 }

e354996c47c39d7a72a036561d311a06cb6d8b39
@@ -43,4 +43,9 @@ public class PomImportLookupStategy extends EmptyImportLookupStategy  {
 		}
 		return result;
 	}
+	
+	@Override
+	public boolean supportGlobalNameLookup() {
+		return true;
+	}
 }

0a3c4e42401c04db8f657f9bd670741b5bfff1a9
@@ -124,6 +124,7 @@ public class PythonImportTest extends PythonParserTest {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/python-code-examples/import_with_dir/importing.py",
 	    		"./src/test/resources/python-code-examples/import_with_dir/imported_a.py",
+	    		"./src/test/resources/python-code-examples/import_with_dir/subdir/importing.py",
 	    	    };
 	    
 	    for (String src:srcs) {
@@ -131,7 +132,7 @@ public class PythonImportTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    Entity file = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
-		this.assertContainsRelation(file, DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
+		this.assertContainsRelation(repo.getEntity(FileUtil.uniqFilePath(srcs[2])), DependencyType.IMPORT,FileUtil.uniqFilePath(srcs[1]));
 	}
 }

4f4fa047ee1ae9222b6e1a2cbe3ef16a422e8c73
@@ -267,8 +267,11 @@ public class CandidateTypes extends TypeEntity {
 
 	@Override
 	public Collection<Entity> getChildren() {
-		System.err.println("error: getChildren should not been invoked");
-		return super.getChildren();
+		List<Entity> children = new ArrayList<>();
+		for (Entity entity:this.candidateTypes) {
+			children.addAll(entity.getChildren());
+		}
+		return children;
 	}
 
 	@Override

ef0685b6e20609a8dd403fb35c211c841e592143
@@ -28,7 +28,7 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertNotNull(repo.getEntity("Foo"));
+        assertNotNull(repo.getEntity(withPackageName(srcs[0],"Foo")));
 	}
 	
 	@Test
@@ -42,7 +42,7 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity("Foo");
+	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Foo"));
         assertEquals(2,type.getFunctions().size());
 	}
 	
@@ -57,8 +57,8 @@ public class PythonClassTest extends PythonParserTest {
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-	    TypeEntity type = (TypeEntity)repo.getEntity("Bar");
-	    this.assertContainsRelation(type, DependencyType.INHERIT, "Foo");
+	    TypeEntity type = (TypeEntity)repo.getEntity(withPackageName(srcs[0],"Bar"));
+	    this.assertContainsRelation(type, DependencyType.INHERIT, withPackageName(srcs[0],"Foo"));
 	}
 
 

56df947bb2d0eb23149ddb036f2e2aa34e1e33bb
@@ -0,0 +1,91 @@
+package depends.format.plantuml;
+
+import java.io.FileNotFoundException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+
+import depends.deptypes.DependencyType;
+import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.core.DependencyMatrix;
+import depends.matrix.core.DependencyPair;
+import depends.matrix.core.DependencyValue;
+
+public class BriefPlantUmlFormatDependencyDumper extends AbstractFormatDependencyDumper {
+	@Override
+	public String getFormatName() {
+		return "briefplantuml";
+	}
+	
+	public BriefPlantUmlFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+		super(dependencyMatrix,projectName,outputDir);
+	}
+
+
+	@Override
+	public boolean output() {
+		PrintWriter writer;
+		try {
+			writer = new PrintWriter(composeFilename()+".uml");
+			ArrayList<String> files = matrix.getNodes();
+			
+			for (int i=0;i<files.size();i++) {
+				String file = files.get(i);
+				writer.println("class " + " "+file);
+			}
+			writer.println("@startuml");
+	        Collection<DependencyPair> dependencyPairs = matrix.getDependencyPairs();
+	        addRelations(writer,dependencyPairs); 
+			writer.println("@enduml");
+			writer.close();
+			return true;
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return false;
+		}
+	}
+
+	private void addRelations(PrintWriter writer, Collection<DependencyPair> dependencyPairs) {
+		
+		HashMap <String,HashMap<String,Integer>> relationMap = new HashMap<>();
+		for (DependencyPair dependencyPair:dependencyPairs) {
+            int src = dependencyPair.getFrom();
+            int dst = dependencyPair.getTo();
+            for (DependencyValue dep:dependencyPair.getDependencies()) {
+            	String key = getNodeName(src)+"..>" + getNodeName(dst);
+            	if (!relationMap.containsKey(key)){
+            		relationMap.put(key, new HashMap<>());
+            	}
+            	HashMap<String, Integer> relationValues = relationMap.get(key);
+            	
+            	Integer value = 0;
+            	if (!relationValues.containsKey(dep.getType())) {
+            		relationValues.get(dep.getType());
+            	}
+            	relationValues.put(dep.getType(), value+=dep.getWeight());
+            }
+		}		
+		
+		for (String key:relationMap.keySet()) {
+        	writer.println("\t"+key + " : " +  buildNotes(relationMap.get(key)) );
+		}
+	}
+
+
+	private String buildNotes(HashMap<String, Integer> relations) {
+		StringBuffer sb = new StringBuffer();
+		for (String dep:relations.keySet()) {
+			sb.append(dep.substring(0,3).toUpperCase()).append(relations.get(dep));
+		}
+		return sb.toString();
+	}
+
+	private String getNodeName(int src) {
+		String result = matrix.getNodeName(src);
+		result = result.replace("-", "_");
+		return result;
+	}
+}

ee6513673e6ce32d9a20fb4d028dff3774490d8c
@@ -27,6 +27,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 
+
 import depends.relations.Inferer;
 
 public class AliasEntity extends Entity {

1f9e3949a4029c28578e7f390bdd0843ba0f1958
@@ -30,6 +30,10 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import org.neo4j.ogm.annotation.Id;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
 import depends.relations.Inferer;
 import depends.relations.Relation;
 
@@ -40,7 +44,9 @@ import depends.relations.Relation;
  * We also use entity to record relations 
  */
 public abstract class Entity {
-	int id=-1;
+	
+    @Id
+    Integer id=-1;
 	String qualifiedName = null;
 	String rawName = "";
 	Entity parent;

363a2f7966ace601867d66357314513bf203aae4
@@ -25,62 +25,20 @@ SOFTWARE.
 package depends.entity.repo;
 
 import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
 
 import depends.entity.Entity;
-import depends.entity.MultiDeclareEntities;
 
-public class EntityRepo extends IdGenerator{
-	private HashMap<String, Entity> allEntieisByName = new HashMap<>();
-	private HashMap<Integer, Entity> allEntitiesById = new HashMap<>();
-	private List<Entity> allEntitiesByOrder = new LinkedList<>();
+public interface EntityRepo extends IdGenerator {
 	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
-	public EntityRepo() {
-	}
-	
-	public Entity getEntity(String entityName) {
-		return allEntieisByName.get(entityName);
-	}
-	
-	public Entity getEntity(Integer entityId) {
-		return allEntitiesById.get(entityId);
-	}
-	
-	public void add(Entity entity) {
-		allEntitiesByOrder.add(entity);
-		allEntitiesById.put(entity.getId(), entity);
-		String name = entity.getRawName();
-		if (entity.getQualifiedName()!=null && !(entity.getQualifiedName().isEmpty()) ) {
-			name = entity.getQualifiedName();
-		}
-		if (allEntieisByName.containsKey(name)) {
-			Entity existedEntity = allEntieisByName.get(name);
-			if (existedEntity instanceof MultiDeclareEntities) {
-				((MultiDeclareEntities)existedEntity).add(entity);
-			}else {
-				MultiDeclareEntities eMultiDeclare = new MultiDeclareEntities(existedEntity,this.generateId());
-				eMultiDeclare.add(entity);
-				allEntieisByName.put(name, eMultiDeclare);
-			}
-		}else {
-			allEntieisByName.put(name, entity);
-		}
-		if (entity.getParent()!=null)
-			this.setParent(entity, entity.getParent());
-	}
-		
-	public Collection<Entity> getEntities() {
-		return allEntitiesByOrder;
-	}
-	
-	public void setParent(Entity child, Entity parent) {
-		if (parent==null) return;
-		if (child==null) return;
-		if (parent.equals(child.getParent())) return;
-		child.setParent(parent);
-		parent.addChild(child);
-	}
+	Entity getEntity(String entityName);
+
+	Entity getEntity(Integer entityId);
+
+	void add(Entity entity);
+
+	Collection<Entity> getEntities();
+
+	void setParent(Entity child, Entity parent);
+
 }

5f7f1716dc08ce8ffabf7cc9ee2890855da15aac
@@ -33,7 +33,9 @@ import depends.relations.Inferer;
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
 	private String originName;
-
+	public AliasEntity() {
+		
+	}
 	public AliasEntity(String simpleName, Entity parent, Integer id, String originTypeName) {
 		super(simpleName, parent, id);
 		this.originName = originTypeName;

54f62ce44ad8d8799f32ca9c8f9e9c8303285200
@@ -47,10 +47,11 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		Iterator<Entity> iterator = entityRepo.getEntities();
 		System.out.println("Start create dependencies matrix....");
 		while(iterator.hasNext()) {
-			System.out.print(".");
 			Entity entity = iterator.next();
 			if (entity instanceof FileEntity){
-        		dependencyMatrix.addNode(stripper.stripFilename(entity.getDisplayName()),entity.getId());
+				String name = stripper.stripFilename(entity.getDisplayName());
+				name = filenameWritter.reWrite(name);
+        		dependencyMatrix.addNode(name,entity.getId());
         	}
         	int fileEntityFrom = getFileEntityIdNoException(entityRepo, entity);
         	if (fileEntityFrom==-1) continue;

39d0771d71b254d4a742c9b33825fcaff09bb24e
@@ -38,14 +38,14 @@ import depends.matrix.core.DependencyMatrix;
 import depends.matrix.core.DependencyPair;
 import depends.matrix.core.DependencyValue;
 
-public class ExcelFormatDependencyDumper extends AbstractFormatDependencyDumper {
+public class ExcelXlsFormatDependencyDumper extends AbstractFormatDependencyDumper {
 	private HSSFWorkbook workbook;
 	private HSSFSheet sheet;
 	@Override
 	public String getFormatName() {
-		return "excel";
+		return "xls";
 	}
-	public ExcelFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
+	public ExcelXlsFormatDependencyDumper(DependencyMatrix dependencyMatrix, String projectName, String outputDir) {
 		super(dependencyMatrix, projectName,outputDir);
 	}
 

726e7cf33488092f65880606f55825fe308d1233
@@ -24,6 +24,11 @@ SOFTWARE.
 
 package depends.entity;
 
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -32,11 +37,13 @@ import java.util.List;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
+import depends.util.TemporaryFile;
 
 /**
- * ContainerEntity for example file, class, method, etc.
- * they could contain vars, functions, ecpressions, type parameters, etc.
+ * ContainerEntity for example file, class, method, etc. they could contain
+ * vars, functions, ecpressions, type parameters, etc.
  */
 public abstract class ContainerEntity extends DecoratedEntity {
 	private static final Logger logger = LoggerFactory.getLogger(ContainerEntity.class);
@@ -47,14 +54,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<Expression> expressionList;
 	private Collection<String> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
+
 	public ContainerEntity() {
 		vars = new ArrayList<>();
 		functions = new ArrayList<>();
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
 		expressions = new HashMap<>();
-		expressionList = new  ArrayList<>();
+		expressionList = new ArrayList<>();
 	}
+
 	public ContainerEntity(String rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
 		vars = new ArrayList<>();
@@ -62,14 +71,12 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
 		expressions = new HashMap<>();
-		expressionList = new  ArrayList<>();
+		expressionList = new ArrayList<>();
 	}
-	
-
 
 	public void addVar(VarEntity var) {
 		if (logger.isDebugEnabled()) {
-			logger.debug("var found: "+var.getRawName() +  ":" + var.getRawType());
+			logger.debug("var found: " + var.getRawName() + ":" + var.getRawType());
 		}
 		this.vars.add(var);
 	}
@@ -95,18 +102,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		expressionList.add(expression);
 	}
 
-	
-
 	/**
-	 * For all data in the class, infer their types.
-	 * Should be override in sub-classes 
+	 * For all data in the class, infer their types. Should be override in
+	 * sub-classes
 	 */
 	public void inferLocalLevelEntities(Inferer inferer) {
 		super.inferLocalLevelEntities(inferer);
 		for (VarEntity var : this.vars) {
 			var.inferLocalLevelEntities(inferer);
 		}
-		for (FunctionEntity func:this.functions) {
+		for (FunctionEntity func : this.functions) {
 			func.inferLocalLevelEntities(inferer);
 		}
 		resolvedMixins = identiferToContainerEntity(inferer, mixins);
@@ -119,85 +124,139 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		ArrayList<ContainerEntity> r = new ArrayList<>();
 		for (String identifier : identifiers) {
 			Entity entity = inferer.resolveName(this, identifier, true);
-			if (entity==null) {
+			if (entity == null) {
 				continue;
 			}
 			if (entity instanceof ContainerEntity)
-				r.add((ContainerEntity)entity);
+				r.add((ContainerEntity) entity);
 		}
 		return r;
 	}
 
 	/**
 	 * Resolve all expression's type
+	 * 
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
 		for (Expression expression : expressionList) {
-			//1. if expression's type existed, break;
+			// 1. if expression's type existed, break;
 			if (expression.getType() != null)
 				continue;
-			if (expression.isDot){ //wait for previous
+			if (expression.isDot) { // wait for previous
 				continue;
 			}
-			if (expression.rawType==null && expression.identifier ==null)
+			if (expression.rawType == null && expression.identifier == null)
 				continue;
-			
-			//2. if expression's rawType existed, directly infer type by rawType
-			//   if expression's rawType does not existed, infer type based on identifiers
+
+			// 2. if expression's rawType existed, directly infer type by rawType
+			// if expression's rawType does not existed, infer type based on identifiers
 			if (expression.rawType != null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType),null,inferer);
-				if (expression.getType() !=null) {
-					 continue;
+				expression.setType(inferer.inferTypeFromName(this, expression.rawType), null, inferer);
+				if (expression.getType() != null) {
+					continue;
 				}
 			}
-			if (expression.identifier!=null) { 
+			if (expression.identifier != null) {
 				Entity entity = inferer.resolveName(this, expression.identifier, true);
-				if (entity!=null) {
-					expression.setType(entity.getType(),entity,inferer);
+				if (entity != null) {
+					expression.setType(entity.getType(), entity, inferer);
 					continue;
 				}
 				if (expression.isCall) {
 					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
-					if (func!=null) {
-						expression.setType(func.getType(),func,inferer);
+					if (func != null) {
+						expression.setType(func.getType(), func, inferer);
 					}
-				}else {
-					
+				} else {
+
 					VarEntity varEntity = this.lookupVarInVisibleScope(expression.identifier);
-					if (varEntity!=null) {
-						expression.setType( varEntity.getType(),varEntity,inferer);
+					if (varEntity != null) {
+						expression.setType(varEntity.getType(), varEntity, inferer);
 					}
 				}
 			}
 		}
 	}
 
-	public void cleanExpression() {
-		this.expressions = null;
+	public void cacheExpressions() {
+		this.expressions = new HashMap<>();
+		cacheExpressionListToFile();
+		this.expressionList = new ArrayList<>();
 	}
 
+	public void clearExpressions() {
+		this.expressions = new HashMap<>();
+		this.expressionList = new ArrayList<>();
+	}
+	
+	private void cacheExpressionListToFile() {
+		try {
+			FileOutputStream fileOut = new FileOutputStream(TemporaryFile.getInstance().exprPath(this.id));
+			ObjectOutputStream out = new ObjectOutputStream(fileOut);
+			out.writeObject(this.expressionList);
+			out.close();
+			fileOut.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	public void reloadExpression(EntityRepo repo) {
+		try
+	      {
+	         FileInputStream fileIn = new FileInputStream(TemporaryFile.getInstance().exprPath(this.id));
+	         ObjectInputStream in = new ObjectInputStream(fileIn);
+	         expressionList = (ArrayList<Expression>) in.readObject();
+	         if (expressionList==null) expressionList = new ArrayList<>();
+	         for (Expression expr:expressionList) {
+	        	 expr.reload(repo,expressionList);
+	         }
+	         in.close();
+	         fileIn.close();
+	      }catch(IOException | ClassNotFoundException i)
+	      {
+	         return;
+	      }
+	}
+	
 	public TypeEntity getLastExpressionType() {
-		for (int i=this.expressionList.size()-1;i>=0;i--) {
-			Expression expr= this.expressionList.get(i);
+		//TODO: 
+		/*
+    java.lang.NullPointerException
+	at depends.entity.ContainerEntity.getLastExpressionType(ContainerEntity.java:228)
+	at depends.entity.FunctionEntity.inferLocalLevelEntities(FunctionEntity.java:92)
+	at depends.entity.ContainerEntity.inferLocalLevelEntities(ContainerEntity.java:118)
+	at depends.entity.TypeEntity.inferLocalLevelEntities(TypeEntity.java:69)
+	at depends.entity.Entity.inferEntities(Entity.java:171)
+	at depends.entity.Entity.inferEntities(Entity.java:173)
+	at depends.relations.Inferer.resolveTypes(Inferer.java:91)
+	at depends.relations.Inferer.resolveAllBindings(Inferer.java:78)
+	at depends.extractor.AbstractLangProcessor.resolveBindings(AbstractLangProcessor.java:112)
+	at depends.extractor.AbstractLangProcessor.buildDependencies(AbstractLangProcessor.java:101)
+	at depends.Main.executeCommand(Main.java:121)
+	at depends.Main.main(Main.java:60) 
+		 * */
+		for (int i = this.expressionList.size() - 1; i >= 0; i--) {
+			Expression expr = this.expressionList.get(i);
 			if (expr.isStatement)
 				return expr.getType();
 		}
 		return null;
 	}
-	
+
 	public List<Expression> expressionList() {
 		return expressionList;
 	}
 
 	public boolean containsExpression() {
-		return expressions.size()>0;
+		return expressions.size() > 0;
 	}
 
-
 	public String dumpExpressions() {
 		StringBuilder sb = new StringBuilder();
-		for (Expression exp:expressionList) {
+		for (Expression exp : expressionList) {
 			sb.append(exp.toString()).append("\n");
 		}
 		return sb.toString();
@@ -206,21 +265,22 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	
 	/**
-	 * The entry point of lookup functions. It will treat multi-declare entities and normal
-	 * entity differently.
-	 * - for multiDeclare entity, it means to lookup all entities
-	 * - for normal entity, it means to lookup entities from current scope still root 
+	 * The entry point of lookup functions. It will treat multi-declare entities and
+	 * normal entity differently. - for multiDeclare entity, it means to lookup all
+	 * entities - for normal entity, it means to lookup entities from current scope
+	 * still root
+	 * 
 	 * @param functionName
 	 * @return
 	 */
 	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
-		if (this.getMutliDeclare()!=null) {
-			for (ContainerEntity fromEntity:this.getMutliDeclare().getEntities()) {
+		if (this.getMutliDeclare() != null) {
+			for (ContainerEntity fromEntity : this.getMutliDeclare().getEntities()) {
 				FunctionEntity f = lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
-				if (f!=null)
+				if (f != null)
 					return f;
 			}
-		}else {
+		} else {
 			ContainerEntity fromEntity = this;
 			return lookupFunctionBottomUpTillTopContainer(functionName, fromEntity);
 		}
@@ -229,6 +289,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	/**
 	 * lookup function bottom up till the most outside container
+	 * 
 	 * @param functionName
 	 * @param fromEntity
 	 * @return
@@ -244,11 +305,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		}
 		return null;
 	}
-	
+
 	/**
-	 * lookup function in local entity. 
-	 * It could be override such as the type entity (it should also lookup the 
-	 * inherit/implemented types
+	 * lookup function in local entity. It could be override such as the type entity
+	 * (it should also lookup the inherit/implemented types
+	 * 
 	 * @param functionName
 	 * @return
 	 */
@@ -261,10 +322,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	/**
-	 * The entry point of lookup var. It will treat multi-declare entities and normal
-	 * entity differently.
-	 * - for multiDeclare entity, it means to lookup all entities
-	 * - for normal entity, it means to lookup entities from current scope still root 
+	 * The entry point of lookup var. It will treat multi-declare entities and
+	 * normal entity differently. - for multiDeclare entity, it means to lookup all
+	 * entities - for normal entity, it means to lookup entities from current scope
+	 * still root
+	 * 
 	 * @param varName
 	 * @return
 	 */
@@ -274,7 +336,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	/**
-	 * To found the var. 
+	 * To found the var.
+	 * 
 	 * @param fromEntity
 	 * @param varName
 	 * @return
@@ -292,7 +355,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public VarEntity lookupVarLocally(String varName) {
-		for (VarEntity var:getVars()) {
+		for (VarEntity var : getVars()) {
 			if (var.getRawName().equals(varName))
 				return var;
 		}
@@ -309,8 +372,4 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 
 
-
-
-
-	
 }

c3e4b3a4fc2adb7d51b05cd5c325dbcf8fe87618
@@ -30,7 +30,6 @@ import javax.xml.bind.annotation.XmlElement;
 import javax.xml.bind.annotation.XmlRootElement;
 import java.util.Map;
 
-@XmlRootElement(name = "cell")
 public class JCellObject {
     private int src;
     private int dest;

7545793da4fccfc898807820f12e37b8213995c1
@@ -0,0 +1,27 @@
+package depends.format.json;
+
+public class DetailItem {
+
+	private String src;
+	private String dest;
+	private String type;
+
+	public DetailItem(String src, String dest, String type) {
+		this.src = src;
+		this.dest = dest;
+		this.type = type;
+	}
+
+	public String getSrc() {
+		return src;
+	}
+
+	public String getDest() {
+		return dest;
+	}
+
+	public String getType() {
+		return type;
+	}
+
+}

627d0b94e4442b328d78cdb3173b0e414350e4b7
@@ -59,7 +59,9 @@ public class DependsCommand {
     private String[] includes = new String[] {};
 	@Option(names = {"--auto-include"},split=",", description = "auto include all paths under the source path (please notice the potential side effect)")
 	private boolean autoInclude = false;
-    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+	@Option(names = {"--detail"},split=",", description = "add detail dependency information to output (only applicable for JSON output format)")
+	private boolean detail = false;	
+	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
 	}
@@ -112,4 +114,7 @@ public class DependsCommand {
 	public boolean isAutoInclude () {
 		return autoInclude;
 	}
+	public boolean isDetail () {
+		return detail;
+	}
 }

acf62e63143ce117b2a0a298295a4ecbdf403a2e
@@ -27,12 +27,8 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
-import org.neo4j.ogm.annotation.Id;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
 
 import depends.relations.Inferer;
 import depends.relations.Relation;
@@ -45,7 +41,6 @@ import depends.relations.Relation;
  */
 public abstract class Entity {
 	
-    @Id
     Integer id=-1;
 	String qualifiedName = null;
 	String rawName = "";

a2c4289495228f1ab1290be3da1cc817258fd805
@@ -46,7 +46,7 @@ public class OrderedMatrixGenerator  {
 			}
 		});
 	    
-	    DependencyMatrix ordered = new DependencyMatrix();
+	    DependencyMatrix ordered = new DependencyMatrix((int)(matrix.getDependencyPairs().size()/0.75+1));
 		HashMap<String, Integer> nodesMap = new HashMap<>();
 		for (int id=0;id<reMappedNodes.size();id++) {
 			nodesMap.put(reMappedNodes.get(id), id);

e6e78726ec09b36570b0d97c754f4e768ea684d4
@@ -30,6 +30,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 
 import depends.format.AbstractFormatDependencyDumper;
+import depends.matrix.core.DependencyDetail;
 import depends.matrix.core.DependencyMatrix;
 import depends.matrix.core.DependencyPair;
 import depends.matrix.core.DependencyValue;
@@ -65,7 +66,9 @@ public class DetailTextFormatDependencyDumper extends AbstractFormatDependencyDu
             int dst = dependencyPair.getTo();
         	writer.println("======="+files.get(src) + " -> " + files.get(dst) + "=========");
         	for (DependencyValue dependency:dependencyPair.getDependencies()) {
-        	writer.println("["+dependency.getType()+"]"+dependency.getDetails()+"\n");
+        		for (DependencyDetail item:dependency.getDetails()) {
+                	writer.println("["+dependency.getType()+"]"+item);
+        		}
         	}
         }		
 	}

07a803db91f6f468a0778546bbb4c80b878ce771
@@ -117,6 +117,7 @@ abstract public class AbstractLangProcessor {
     private void identifyDependencies(){
 		System.out.println("dependencie data generating...");	
         dependencyMatrix  = dependencyGenerator.build(entityRepo);
+        entityRepo = null;
         dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
         System.out.println("dependencie data generating done successfully...");	 	
     }

6984e05975f9373d4e85fa81df47bf200627f754
@@ -140,4 +140,16 @@ public class FileEntity extends TypeEntity {
 		return importedNames;
 	}
 
+	public void cacheAllExpressions() {
+		cacheChildExpressions(this);
+	}
+
+	private void cacheChildExpressions(ContainerEntity containerEntity) {
+		this.cacheExpressions();
+		for (Entity child:containerEntity.getChildren()) {
+			if (child instanceof ContainerEntity) {
+				cacheChildExpressions((ContainerEntity)child);
+			}
+		}
+	}
 }

d65d3aad028f14df38972cd9679af3ad059a996c
@@ -42,6 +42,10 @@ public class PythonFileParser implements FileParser {
         CharStream input = CharStreams.fromFileName(fileFullPath);
         Lexer lexer = new Python3Lexer(input);
         CommonTokenStream tokens = new CommonTokenStream(lexer);
+        
+//        Python2Parser parser = new Python2Parser(tokens);
+//        Python2BaseListener bridge = new Python2BaseListener();
+        
         Python3Parser parser = new Python3Parser(tokens);
         Python3CodeListener bridge = new Python3CodeListener(fileFullPath, entityRepo,inferer, includeFileLocator, processor);
 	    ParseTreeWalker walker = new ParseTreeWalker();

16f682865e559a81bdf1b4ed8bdc7a224a3dfbbd
@@ -26,13 +26,14 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
-
+import java.util.List;
 
 import depends.relations.Inferer;
 
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
 	private String originName;
+	private List<Entity> referPath = new ArrayList<>();
 	public AliasEntity() {
 		
 	}
@@ -45,6 +46,11 @@ public class AliasEntity extends Entity {
 		Entity entity = inferer.resolveName(this, originName, true);
 		while(entity instanceof AliasEntity) {
 			AliasEntity aliasEntity = (AliasEntity)entity;
+			if (this.referPath.contains(aliasEntity)) {
+				entity = null;
+				break;
+			}
+			this.referPath.add(aliasEntity);
 			entity = inferer.resolveName(aliasEntity, aliasEntity.originName,true);
 			if (entity==null) break;
 			if (entity.equals(this)) {

df85ab0c0516af11202b3a5180ea3bfc13ef1491
@@ -53,7 +53,7 @@ public class DependsCommand {
     private boolean stripLeadingPath = false;
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
-	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[default(/),dot(.)")
+	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
     private String namePathPattern="default";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};

b8f9df99bc80f96b919ac4155b65a005fa055b35
@@ -51,10 +51,15 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
+	@Option(names = {"--additional-strip-paths"}, split=",", description = "(Only valid in case of -s swith parameter)" +
+			"The additional path to be stripped since parameter <src>.  "
+			+ "Depends will strip based on length (no matter the prefix is same as the paraemter).")
+	private String[] additionalStrippedPaths = new String[]{};
+
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
-    private String namePathPattern="default";
+    private String namePathPattern="";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
     private String[] includes = new String[] {};
 	@Option(names = {"--auto-include"},split=",", description = "auto include all paths under the source path (please notice the potential side effect)")
@@ -117,4 +122,10 @@ public class DependsCommand {
 	public boolean isDetail () {
 		return detail;
 	}
+	public String[] getAdditionalStrippedPaths() {
+		return additionalStrippedPaths;
+	}
+	public void setAdditionalStrippedPaths(String[] additionalStrippedPaths) {
+		this.additionalStrippedPaths = additionalStrippedPaths;
+	}
 }

57c503c3c73449ea92cc6724d5ee4b31560cf138
@@ -130,6 +130,9 @@ abstract public class AbstractLangProcessor {
 			public void visit(File file) {
 				String fileFullPath = file.getAbsolutePath();
 				fileFullPath = FileUtil.uniqFilePath(fileFullPath);
+				if (!fileFullPath.startsWith(inputSrcPath)) {
+					return;
+				}
 	            FileParser fileParser = createFileParser(fileFullPath);
 	            try {
 	                System.out.println("parsing " + fileFullPath 

a11589b4c77d6b7e160aaf42c4e43b68cf307ff2
@@ -52,10 +52,8 @@ public class DependsCommand {
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
 	@Option(names = {"--additional-strip-paths"}, split=",", description = "(Only valid in case of -s swith parameter)" +
-			"The additional path to be stripped since parameter <src>.  "
-			+ "Depends will strip based on length (no matter the prefix is same as the paraemter).")
+			"The additional path to be stripped since parameter <src>.  ")
 	private String[] additionalStrippedPaths = new String[]{};
-
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")

0930bcc29e0373a50dd49307f487792844e719e7
@@ -52,10 +52,7 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 			Entity imported = repo.getEntity(importedItem.getContent());
 			if (imported==null) continue;
 			if (imported instanceof PackageEntity) { 
-				//expand import of package to all classes under the package due to we dis-courage the behavior
-				for (Entity child:imported.getChildren()) {
-					result.add(child);
-				}
+				//ignore wildcard import relation
 			}else {
 				result.add(imported);
 			}
@@ -65,7 +62,20 @@ public class JavaImportLookupStrategy implements ImportLookupStrategy{
 
 	@Override
 	public List<Entity> getImportedTypes(List<Import> importedList, EntityRepo repo) {
-		return getImportedRelationEntities(importedList,repo);
+		ArrayList<Entity> result = new ArrayList<>();
+		for (Import importedItem:importedList) {
+			Entity imported = repo.getEntity(importedItem.getContent());
+			if (imported==null) continue;
+			if (imported instanceof PackageEntity) { 
+				//expand import of package to all classes under the package due to we dis-courage the behavior
+				for (Entity child:imported.getChildren()) {
+					result.add(child);
+				}
+			}else {
+				result.add(imported);
+			}
+		}
+		return result;
 	}
 
 	@Override

61edc7a615a530bdbb27d3a53d524021c890e2f6
@@ -51,9 +51,9 @@ public class DependsCommand {
     private boolean dv8map = true;
 	@Option(names = {"-s", "--strip-leading-path"},  description = "Strip the leading path.")
     private boolean stripLeadingPath = false;
-	@Option(names = {"--additional-strip-paths"}, split=",", description = "(Only valid in case of -s swith parameter)" +
-			"The additional path to be stripped since parameter <src>.  ")
-	private String[] additionalStrippedPaths = new String[]{};
+	@Option(names = {"--strip-paths"}, split=",", description =  "The path(s) to be stripped. if -s enabled, the path(s) start after <src>. "
+			+ "Otherwise, the path(s) should be valid.")
+	private String[] strippedPaths = new String[]{};
 	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
@@ -120,10 +120,10 @@ public class DependsCommand {
 	public boolean isDetail () {
 		return detail;
 	}
-	public String[] getAdditionalStrippedPaths() {
-		return additionalStrippedPaths;
+	public String[] getStrippedPaths() {
+		return strippedPaths;
 	}
-	public void setAdditionalStrippedPaths(String[] additionalStrippedPaths) {
-		this.additionalStrippedPaths = additionalStrippedPaths;
+	public void setStrippedPaths(String[] strippedPaths) {
+		this.strippedPaths = strippedPaths;
 	}
 }

19905e02bef259e154ffb4601b513ac813222244
@@ -139,6 +139,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
+
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
 			if (expression.getType() != null)

7bda2a3d2ed1c37a66bf7d62615f42907d9ff196
@@ -206,4 +206,29 @@ public abstract class Entity {
 		child.setParent(parent);
 		parent.addChild(child);
 	}
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((id == null) ? 0 : id.hashCode());
+		return result;
+	}
+	
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		Entity other = (Entity) obj;
+		if (id == null) {
+			if (other.id != null)
+				return false;
+		} else if (!id.equals(other.id))
+			return false;
+		return true;
+	}
+	
 }

b85b588c09022c409e4fadb03776162541d770df
@@ -64,6 +64,8 @@ public class DependsCommand {
 	private boolean autoInclude = false;
 	@Option(names = {"--detail"},split=",", description = "add detail dependency information to output (only applicable for JSON output format)")
 	private boolean detail = false;	
+	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
+	private boolean autoStub = false;	
 	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
@@ -126,4 +128,7 @@ public class DependsCommand {
 	public void setStrippedPaths(String[] strippedPaths) {
 		this.strippedPaths = strippedPaths;
 	}
+	public boolean isAutoStub() {
+		return autoStub;
+	}
 }

aa24d5986c6687569e1ec50e46d9f9d6e6e26e7b
@@ -25,7 +25,11 @@ SOFTWARE.
 package depends;
 
 import java.util.ArrayList;
+import java.util.List;
+
+import depends.deptypes.DependencyType;
 import depends.extractor.LangProcessorRegistration;
+import edu.emory.mathcs.backport.java.util.Arrays;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
@@ -37,6 +41,11 @@ public class DependsCommand {
 		public SupportedLangs() { super( LangProcessorRegistration.getRegistry().getLangs()); }
 	}
 	
+	public static class SupportedTypes extends ArrayList<String> {
+		private static final long serialVersionUID = 1L;
+		public SupportedTypes() { super( DependencyType.allDependencies()); }
+	}
+	
 	@Parameters(index = "0", completionCandidates = DependsCommand.SupportedLangs.class, description = "The lanauge of project files: [${COMPLETION-CANDIDATES}]")
     private String lang;
 	@Parameters(index = "1", description = "The directory to be analyzed")
@@ -66,7 +75,9 @@ public class DependsCommand {
 	private boolean detail = false;	
 	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
 	private boolean autoStub = false;	
-	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+    @Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
+    private String[] typeFilter=new String[]{};
+    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
 	}
@@ -131,4 +142,10 @@ public class DependsCommand {
 	public boolean isAutoStub() {
 		return autoStub;
 	}
+	public List<String> getTypeFilter() {
+		if (typeFilter.length==0) {
+			return DependencyType.allDependencies();
+		}
+		return java.util.Arrays.asList(typeFilter);
+	}
 }

bb887997ab2826a6488d5d700a4fc8ce367d06f8
@@ -78,7 +78,7 @@ public class RelationCounter {
 			if (var.getType()!=null)
 				entity.addRelation(new Relation(DependencyType.CONTAIN,var.getType()));
 			for (Entity type:var.getResolvedTypeParameters()) {
-				entity.addRelation(new Relation(DependencyType.USE,type));
+				var.addRelation(new Relation(DependencyType.PARAMETER,type));
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {

ea0cf029286c322a92de1f33ae11f00071de3a91
@@ -141,7 +141,7 @@ public class ExpressionUsage {
 	private String getMethodCallIdentifier(IASTFunctionCallExpression methodCall) {
 		IASTExpression f = methodCall.getFunctionNameExpression();
 		if (f instanceof IASTIdExpression) {
-			return ((IASTIdExpression)f).getName().toString();
+			return ((IASTIdExpression)f).getName().toString().replace("::", ".");
 		}
 		return null;
 	}

660a4ca1672387e472d4afdcb4b32f06add02260
@@ -1,4 +1,6 @@
 package depends.extractor.cpp;
+import static org.junit.Assert.assertNotNull;
+
 import java.io.IOException;
 
 import org.junit.Before;
@@ -13,12 +15,33 @@ public class GenericTypeTest extends CppParserTest{
     }
 	
 	@Test
-	public void test_genericTypes() throws IOException {
+	public void test_templateSpecializationOfStruct() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity("hash"));
+	}
+
+    @Test
+	public void test_genericTypesVarDefinition() throws IOException {
 	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
         this.assertContainsRelation(repo.getEntity("xStack"), DependencyType.PARAMETER, "X");
 	}
+	
+    @Test
+	public void test_extendGenericTypes() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
+	}
+	
+	
+	
 
 }

4f47c91b8afdbec29e73ee4d3c49a1d54963e8ff
@@ -16,7 +16,7 @@ public class GenericTypeTest extends CppParserTest{
 	
 	@Test
 	public void test_templateSpecializationOfStruct() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	    String src = "./src/test/resources/cpp-code-examples/template/TempateStructure.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
@@ -24,8 +24,8 @@ public class GenericTypeTest extends CppParserTest{
 	}
 
     @Test
-	public void test_genericTypesVarDefinition() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	public void test_genericTypesVarParameterReference() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
@@ -33,8 +33,8 @@ public class GenericTypeTest extends CppParserTest{
 	}
 	
     @Test
-	public void test_extendGenericTypes() throws IOException {
-	    String src = "./src/test/resources/cpp-code-examples/GenericTypes.cpp";
+	public void test_genericTypesExtends() throws IOException {
+	    String src = "./src/test/resources/cpp-code-examples/template/GenericTypes.cpp";
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();

0f27f45e35c0714b1aac19ddfd898a40c77838e0
@@ -185,7 +185,7 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void addTypeParameter(List<String> typeArguments) {
+	public void addTypeParameter(List<GenericTypeArgument> typeArguments) {
 		System.err.println("error: addTypeParameter should not been invoked");
 		super.addTypeParameter(typeArguments);
 	}
@@ -197,7 +197,7 @@ public class CandidateTypes extends TypeEntity {
 	}
 
 	@Override
-	public void addTypeParameter(String typeName) {
+	public void addTypeParameter(GenericTypeArgument typeName) {
 		System.err.println("error: addTypeParameter should not been invoked");
 		super.addTypeParameter(typeName);
 	}

e4aee9821aa7bdbf986ca83374d8825100bd1e05
@@ -23,4 +23,18 @@ public class JavaGenericTypeTest extends JavaParserTest{
         this.assertContainsRelation(entityRepo.getEntity("x.GenericTypeTest.v"),
         		DependencyType.PARAMETER, "x.Parent2.Enum");
 	}
+	
+	@Test
+	public void test_GenericTypeEmbededShouldBeIdentified() throws IOException {
+        String src = "./src/test/resources/java-code-examples/GenericTypeEmbededTest.java";
+        JavaFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest"),
+        		DependencyType.CONTAIN, "MyHashMap");
+        this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyList");
+        this.assertContainsRelation(entityRepo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyArray");
+	}
 }

9b475588a45e0b9b3047abd7c885c4a453bbe838
@@ -7,6 +7,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.extractor.java.JavaFileParser;
 
 public class GenericTypeTest extends CppParserTest{
     @Before
@@ -41,6 +42,20 @@ public class GenericTypeTest extends CppParserTest{
         this.assertContainsRelation(repo.getEntity("XStack"), DependencyType.INHERIT, "Stack");
 	}
 	
+    
+    @Test
+	public void test_GenericTypeEmbededShouldBeIdentified() throws IOException {
+        String src = "./src/test/resources/cpp-code-examples/template/EmbededTemplates.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest"),
+        		DependencyType.CONTAIN, "MyHashMap");
+        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyList");
+        this.assertContainsRelation(repo.getEntity("GenericTypeEmbededTest.data"),
+        		DependencyType.PARAMETER, "MyArray");
+	}
 	
 	
 

798ea0a62faa74ceb61b5966b9724fd7e37b0c56
@@ -7,6 +7,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.entity.FunctionEntity;
 import depends.extractor.java.JavaFileParser;
 
 public class GenericTypeTest extends CppParserTest{
@@ -57,6 +58,25 @@ public class GenericTypeTest extends CppParserTest{
         		DependencyType.PARAMETER, "MyArray");
 	}
 	
+    @Test
+	public void test_TemplateWithDots() throws IOException {
+        String src = "./src/test/resources/cpp-code-examples/template/TemplateWithDots.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        assertNotNull(repo.getEntity("foo.t2"));
+	}
+	
+    @Test
+	public void test_TemplateInReturn() throws IOException {
+        String src = "./src/test/resources/cpp-code-examples/template/TemplateInReturnValue.cpp";
+	    CppFileParser parser = createParser(src);
+        parser.parse();
+        inferer.resolveAllBindings();
+        FunctionEntity func = (FunctionEntity)repo.getEntity("get");
+      	this.assertContainsRelation(func, DependencyType.RETURN, "std.tuple_element.type");
+	}
+	
 	
 
 }

8c1fca12eb0f1cb7ed6ba4bf6b7ad6c7c7f94053
@@ -32,12 +32,12 @@ import depends.relations.Inferer;
 
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
-	private String originName;
+	private GenericName originName;
 	private List<Entity> referPath = new ArrayList<>();
 	public AliasEntity() {
 		
 	}
-	public AliasEntity(String simpleName, Entity parent, Integer id, String originTypeName) {
+	public AliasEntity(GenericName simpleName, Entity parent, Integer id, GenericName originTypeName) {
 		super(simpleName, parent, id);
 		this.originName = originTypeName;
 	}
@@ -90,21 +90,21 @@ public class AliasEntity extends Entity {
 		return origin.getFunctions();
 	}
 
-	protected FunctionEntity lookupFunctionLocally(String functionName) {
+	protected FunctionEntity lookupFunctionLocally(GenericName functionName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
 		return origin.lookupFunctionLocally(functionName);
 	}
 
-	public FunctionEntity lookupFunctionInVisibleScope(String functionName) {
+	public FunctionEntity lookupFunctionInVisibleScope(GenericName functionName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;
 		return origin.lookupFunctionInVisibleScope(functionName);
 	}
 
-	public VarEntity lookupVarsInVisibleScope(String varName) {
+	public VarEntity lookupVarsInVisibleScope(GenericName varName) {
 		if (!(referToEntity instanceof ContainerEntity))
 			return null;
 		ContainerEntity origin = (ContainerEntity) referToEntity;

c43629622d23d653d5e4b8e1c7b407ed773d8690
@@ -29,7 +29,6 @@ import java.util.List;
 
 import depends.deptypes.DependencyType;
 import depends.extractor.LangProcessorRegistration;
-import edu.emory.mathcs.backport.java.util.Arrays;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;

07a4dc79c6771732a39735d3f688e2dab25bc660
@@ -184,23 +184,12 @@ public class CandidateTypes extends TypeEntity {
 		return super.getResolvedMixins();
 	}
 
-	@Override
-	public void addTypeParameter(List<GenericName> typeArguments) {
-		System.err.println("error: addTypeParameter should not been invoked");
-		super.addTypeParameter(typeArguments);
-	}
-
 	@Override
 	public void addAnnotation(GenericName name) {
 		System.err.println("error: addAnnotation should not been invoked");
 		super.addAnnotation(name);
 	}
 
-	@Override
-	public void addTypeParameter(GenericName typeName) {
-		System.err.println("error: addTypeParameter should not been invoked");
-		super.addTypeParameter(typeName);
-	}
 
 	@Override
 	public Collection<Entity> getResolvedTypeParameters() {

80f7b6e10f97eabe1f34240c31b5434168d284b0
@@ -84,8 +84,13 @@ public class FunctionEntity extends ContainerEntity{
 			param.fillCandidateTypes(inferer);
 			param.inferLocalLevelEntities(inferer);
 		}
-		if (returnTypes.size()<returnTypeIdentifiers.size())
+		if (returnTypes.size()<returnTypeIdentifiers.size()) {
 			returnTypes = identiferToEntities(inferer,this.returnTypeIdentifiers);
+			for ( GenericName returnTypeName: returnTypeIdentifiers) {
+				Collection<Entity> typeEntities = typeParametersToEntities(inferer, returnTypeName);
+				this.appendTypeParameters(typeEntities);
+			}
+		}
 		if (throwTypes.size()<throwTypesIdentifiers.size())
 			throwTypes = identiferToEntities(inferer,this.throwTypesIdentifiers);
 		super.inferLocalLevelEntities(inferer);
@@ -93,6 +98,17 @@ public class FunctionEntity extends ContainerEntity{
 			this.returnTypes.add(this.getLastExpressionType());
 		}
 	}
+	
+
+	private Collection<Entity> typeParametersToEntities(Inferer inferer,GenericName name) {
+		ArrayList<Entity> r = new ArrayList<>();
+		for (GenericName typeParameter:name.getArguments()) {
+			toEntityList(inferer, r,typeParameter);
+		}
+		return r;
+	}
+
+	
 	public Collection<VarEntity> getParameters() {
 		return parameters;
 	}

c9df1b69bc156d1a1b733578edcac4a5ecfb27cc
@@ -147,31 +147,31 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			if (expression.isDot) { // wait for previous
 				continue;
 			}
-			if (expression.rawType == null && expression.identifier == null)
+			if (expression.getRawType() == null && expression.getIdentifier() == null)
 				continue;
 
 			// 2. if expression's rawType existed, directly infer type by rawType
 			// if expression's rawType does not existed, infer type based on identifiers
-			if (expression.rawType != null) {
-				expression.setType(inferer.inferTypeFromName(this, expression.rawType), null, inferer);
+			if (expression.getRawType() != null) {
+				expression.setType(inferer.inferTypeFromName(this, expression.getRawType()), null, inferer);
 				if (expression.getType() != null) {
 					continue;
 				}
 			}
-			if (expression.identifier != null) {
-				Entity entity = inferer.resolveName(this, expression.identifier, true);
+			if (expression.getIdentifier() != null) {
+				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;
 				}
 				if (expression.isCall) {
-					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.identifier);
+					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.getIdentifier());
 					if (func != null) {
 						expression.setType(func.getType(), func, inferer);
 					}
 				} else {
 
-					VarEntity varEntity = this.lookupVarInVisibleScope(expression.identifier);
+					VarEntity varEntity = this.lookupVarInVisibleScope(expression.getIdentifier());
 					if (varEntity != null) {
 						expression.setType(varEntity.getType(), varEntity, inferer);
 					}

0533771ccd160d4a99805aba4430868ff3fe1297
@@ -49,7 +49,6 @@ class TemplateParameterASTVisitor extends ASTVisitor{
 
 	@Override
 	public int visit(ICPPASTTemplateParameter templateParameter) {
-		System.out.println(templateParameter.getRawSignature());
 		return super.visit(templateParameter);
 	}
 

3cc5f49916278bbee16c90c01c2b08160616fde8
@@ -6,12 +6,14 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.commons.io.FileUtils;
 import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.AliasEntity;
 import depends.extractor.cpp.CppFileParser;
+import depends.util.FileUtil;
 
 public class IncludeRelationTest extends CppParserTest{
     @Before
@@ -89,4 +91,21 @@ public class IncludeRelationTest extends CppParserTest{
 	    this.assertContainsRelation(this.repo.getEntity("foo"), DependencyType.CALL, "bar");
 	    this.assertNotContainsRelation(this.repo.getEntity("foo2"), DependencyType.CALL, "bar");
 	}
+	
+	@Test
+	public void should_find_include_relation_in_conditional_macro_block() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/includeTest3/inc_macro_test.c",
+	    		"./src/test/resources/cpp-code-examples/includeTest3/fx.h",
+	    		"./src/test/resources/cpp-code-examples/includeTest3/fy.h",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[1]));
+	    this.assertContainsRelation(this.repo.getEntity(FileUtil.uniqFilePath(srcs[0])), DependencyType.IMPORT, FileUtil.uniqFilePath(srcs[2]));
+	} 
 }

ae104912354ee27ca24cc838b0e3aed3d90091a5
@@ -37,7 +37,7 @@ public class IncludeRelationTest extends CppParserTest{
 	    }
 	    inferer.resolveAllBindings();
         File f = new File(srcs[0]);
-        assertEquals(3,repo.getEntity(f.getCanonicalPath()).getRelations().size());
+        assertEquals(4,repo.getEntity(f.getCanonicalPath()).getRelations().size());
 	}
 	
 	

822bd7fd28c95c7a5a686bc84af6f952eae3ec83
@@ -291,7 +291,7 @@ public abstract class HandlerContext {
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();
 
-	private void pushToStack(Entity entity) {
+	protected void pushToStack(Entity entity) {
 		entityStack.push(entity);
 	}
 	

4d1742fa08b667932fac3972d52eafcafcb3d830
@@ -18,7 +18,7 @@ public class CppParameterParserTest extends CppParserTest{
 	    CppFileParser parser = createParser(src);
         parser.parse();
         inferer.resolveAllBindings();
-        assertEquals(4,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
+        assertEquals(5,repo.getEntity("FunctionParameters.function_with_parameters_same_type").getRelations().size());
 	}
 
 }

ed49e71ca2c6cc8fc001ed4881d113f73510ddaa
@@ -74,7 +74,9 @@ public class DependsCommand {
 	private boolean detail = false;	
 	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
 	private boolean autoStub = false;	
-    @Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
+	@Option(names = {"--call-as-impl"}, description = "(only for C/C++)convert the call relation to implementation instead of declaration")
+	private boolean callAsImpl = false;	
+	@Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
     private String[] typeFilter=new String[]{};
     @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
@@ -147,4 +149,7 @@ public class DependsCommand {
 		}
 		return java.util.Arrays.asList(typeFilter);
 	}
+	public boolean isCallAsImpl() {
+		return callAsImpl;
+	}
 }

ae7c68dea03147c62dd76dfd4abc3de1eaf3e443
@@ -53,7 +53,8 @@ public class FileEntity extends TypeEntity {
 	}
 
 	public void addImport(Import imported) {
-		importedNames.add(imported);
+		if (!importedNames.contains(imported))
+			importedNames.add(imported);
 	}
 	
 	/**

dbbf80236fdfe6b22ccbc08d0343900cae193f34
@@ -35,9 +35,7 @@ import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
 import org.eclipse.cdt.core.dom.ast.IMacroBinding;
 import org.eclipse.cdt.core.dom.parser.IScannerExtensionConfiguration;
 import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
-import org.eclipse.cdt.core.index.IIndex;
 import org.eclipse.cdt.core.index.IIndexFileLocation;
-import org.eclipse.cdt.core.model.ILanguage;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
 import org.eclipse.cdt.core.parser.IParserLogService;
@@ -47,17 +45,16 @@ import org.eclipse.cdt.core.parser.NullLogService;
 import org.eclipse.cdt.core.parser.ParserLanguage;
 import org.eclipse.cdt.core.parser.ParserMode;
 import org.eclipse.cdt.core.parser.ScannerInfo;
-import org.eclipse.cdt.internal.core.dom.IIncludeFileResolutionHeuristics;
 import org.eclipse.cdt.internal.core.dom.parser.AbstractGNUSourceCodeParser;
 import org.eclipse.cdt.internal.core.dom.parser.c.CASTTranslationUnit;
 import org.eclipse.cdt.internal.core.dom.parser.cpp.GNUCPPSourceParser;
-import org.eclipse.cdt.internal.core.index.CIndex;
-import org.eclipse.cdt.internal.core.index.IIndexFragment;
 import org.eclipse.cdt.internal.core.parser.IMacroDictionary;
 import org.eclipse.cdt.internal.core.parser.scanner.CPreprocessor;
 import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContent;
 import org.eclipse.cdt.internal.core.parser.scanner.InternalFileContentProvider;
 
+import depends.util.FileUtil;
+
 @SuppressWarnings("deprecation")
 public class CDTParser {
 	List<String> sysIncludePath = new ArrayList<>();
@@ -81,18 +78,44 @@ public class CDTParser {
 	NullLogService NULL_LOG = new NullLogService();
 	Map<String, String> macroMap = new HashMap<>();
 	public IASTTranslationUnit parse(String file   ) {
-		CodeReader cr;
 		try {
-			cr = new CodeReader(file);
-			return getTranslationUnitofCPP(file,new String(cr.buffer));
+			return getTranslationUnitofCPP(file);
 		} catch (IOException e) {
 		}
 		return new CASTTranslationUnit();
 	}
 
 	
-	private IASTTranslationUnit getTranslationUnitofCPP(String file, String content) {
-		IScannerInfo scannerInfo = new ScannerInfo(new HashMap<>(), sysIncludePath.toArray(new String[] {}));
+	private IASTTranslationUnit getTranslationUnitofCPP(String file) throws IOException {
+		for (String p:sysIncludePath) {
+			if (!FileUtil.isDirectory(p)) {
+				IScanner scanner = buildScanner(p);
+				AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
+						scanner, ParserMode.COMPLETE_PARSE,  new NullLogService(),
+						new GPPParserExtensionConfigurationExtension(), null);
+				sourceCodeParser.parse();
+				Map<String, IMacroBinding> macros = scanner.getMacroDefinitions();
+				for (String key:macros.keySet()) {
+					 String exp = new String(macros.get(key).getExpansion());
+					 if (exp.length()>0) {
+						 macroMap.put(key, exp);
+					 }
+					
+				}
+			}
+		}
+		IScanner scanner = buildScanner(file);
+		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
+				scanner, ParserMode.COMPLETE_PARSE,  new NullLogService(),
+				new GPPParserExtensionConfigurationExtension(), null);
+		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
+		return astTranslationUnit;
+	}
+
+	private IScanner buildScanner(String file) throws IOException {
+		CodeReader cr = new CodeReader(file);
+		String content = new String(cr.buffer);
+		IScannerInfo scannerInfo = new ScannerInfo(macroMap, sysIncludePath.toArray(new String[] {}));
 		IScannerExtensionConfiguration configuration = GPPScannerExtensionConfiguration
 				.getInstance(scannerInfo);
 		InternalFileContentProvider ifcp = new InternalFileContentProvider() {
@@ -106,19 +129,14 @@ public class CDTParser {
 				return (InternalFileContent) FileContent.create(ifl);
 			}
 		};
-
-
-		IParserLogService log = new NullLogService();
+		ParserLanguage lang = ParserLanguage.CPP;
+		if (file.endsWith(".c"))
+			lang = ParserLanguage.C;
 		IScanner scanner = new CPreprocessor(FileContent.create(file,
-				content.toCharArray()),scannerInfo, ParserLanguage.CPP,
-				log, configuration, ifcp);
+				content.toCharArray()),scannerInfo, lang,
+				 new NullLogService(), configuration, ifcp);
 		scanner.setProcessInactiveCode(true);
-		scanner.setComputeImageLocations(true);
-		AbstractGNUSourceCodeParser sourceCodeParser = new GNUCPPSourceParser(
-				scanner, ParserMode.COMPLETE_PARSE, log,
-				new GPPParserExtensionConfigurationExtension(), null);
-		IASTTranslationUnit astTranslationUnit =  sourceCodeParser.parse();
-		return astTranslationUnit;
+		return scanner;
 	}
 
 }

8a5e41b6fffda85f642c62d91a3918e5487e4643
@@ -38,7 +38,6 @@ import org.eclipse.cdt.core.dom.parser.cpp.GPPScannerExtensionConfiguration;
 import org.eclipse.cdt.core.index.IIndexFileLocation;
 import org.eclipse.cdt.core.parser.CodeReader;
 import org.eclipse.cdt.core.parser.FileContent;
-import org.eclipse.cdt.core.parser.IParserLogService;
 import org.eclipse.cdt.core.parser.IScanner;
 import org.eclipse.cdt.core.parser.IScannerInfo;
 import org.eclipse.cdt.core.parser.NullLogService;

82bcbbee9f557eef74efd2a3cbff58cd6e4ccd5e
@@ -120,12 +120,22 @@ public class CDTParser {
 		InternalFileContentProvider ifcp = new InternalFileContentProvider() {
 			@Override
 			public InternalFileContent getContentForInclusion(String filePath, IMacroDictionary macroDictionary) {
-				return (InternalFileContent) FileContent.createForExternalFileLocation(filePath);
+				InternalFileContent c = FileCache.getInstance().get(filePath);
+				if (c==null) { 
+					c = (InternalFileContent) FileContent.createForExternalFileLocation(filePath);
+					FileCache.getInstance().put(filePath,c);
+				}
+				return c;
 			}
 
 			@Override
 			public InternalFileContent getContentForInclusion(IIndexFileLocation ifl, String astPath) {
-				return (InternalFileContent) FileContent.create(ifl);
+				InternalFileContent c = FileCache.getInstance().get(ifl);
+				if (c==null) { 
+					c = (InternalFileContent) FileContent.create(ifl);
+					FileCache.getInstance().put(ifl,c);
+				}
+				return c;
 			}
 		};
 		ParserLanguage lang = ParserLanguage.CPP;

29b9a359dece86f5dcaf1c1a477d7473dc1e5833
@@ -39,6 +39,8 @@ public class CppProcessor extends AbstractLangProcessor {
     private static final String LANG = "cpp";
     private static final String[] SUFFIX = new String[] {".cpp",".cc",".c",".h",".hpp",".hh", ".cxx",".hxx"};
     PreprocessorHandler preprocessorHandler;
+    
+    MacroRepo macroRepo = null;
     public CppProcessor() {
     	super(false);
     }
@@ -57,8 +59,12 @@ public class CppProcessor extends AbstractLangProcessor {
 
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
+		if (macroRepo==null) {
+	    	macroRepo = new MacroRepo();
+	    	macroRepo.buildDefaultMap(super.includePaths());
+		}
     	preprocessorHandler = new PreprocessorHandler(super.includePaths());
-		return new CdtCppFileParser(fileFullPath,entityRepo,preprocessorHandler,inferer);
+		return new CdtCppFileParser(fileFullPath,entityRepo,preprocessorHandler,inferer,macroRepo);
 	}
 
 	@Override

afc64d54694e15059c6e391c8b46b03f16fe447b
@@ -27,6 +27,7 @@ package depends.extractor;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -127,6 +128,7 @@ abstract public class AbstractLangProcessor {
 
     private final void parseAllFiles() {
         System.out.println("start parsing files...");		
+        Set<String> phase2Files = new HashSet<>();
     	FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor(){
 			@Override
 			public void visit(File file) {
@@ -135,24 +137,39 @@ abstract public class AbstractLangProcessor {
 				if (!fileFullPath.startsWith(inputSrcPath)) {
 					return;
 				}
-	            FileParser fileParser = createFileParser(fileFullPath);
-	            try {
-	                System.out.println("parsing " + fileFullPath 
-	                		+ "...");		
-	                fileParser.parse();
-	            } catch (IOException e) {
-	                e.printStackTrace();
-	            }	
+				if (isPhase2Files(fileFullPath)) {
+					
+				}else {
+					parseFile(fileFullPath);
+				}
 			}
     		
     	});
     	fileTransversal.extensionFilter(this.fileSuffixes());
 		fileTransversal.travers(this.inputSrcPath);
+		for (String f:phase2Files) {
+			parseFile(f);
+		}
         System.out.println("all files procceed successfully...");		
 
 	}
     
 
+	protected void parseFile(String fileFullPath) {
+        FileParser fileParser = createFileParser(fileFullPath);
+        try {
+            System.out.println("parsing " + fileFullPath 
+            		+ "...");		
+            fileParser.parse();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }	
+	}
+	
+	protected boolean isPhase2Files(String fileFullPath) {
+		return false;
+	}
+	
 	public List<String> includePaths() {
 		ArrayList<String> r = new ArrayList<String>();
 		for (String path:includeDirs) {

947ce7014b7ab9e716a925ba6253c58b2a5e9aeb
@@ -49,6 +49,7 @@ public abstract class Entity {
 	private Set<Entity> children = new HashSet<>();
     ArrayList<Relation> relations = new ArrayList<>();
 	private Entity actualReferTo = null;
+	private boolean inScope = true;
 
 	public Entity() {};
     public Entity(GenericName rawName, Entity parent, Integer id) {
@@ -230,5 +231,11 @@ public abstract class Entity {
 			return false;
 		return true;
 	}
+	public void setInScope(boolean value) {
+		this.inScope  = value;
+	}
+	public boolean inScope() {
+		return inScope;
+	}
 	
 }

377ef8bb91c46220aad62e34bb76bc19b47da9f2
@@ -59,6 +59,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
         	for (Relation relation:entity.getRelations()) {
         		Entity relatedEntity = relation.getEntity();
         		if (relatedEntity==null) continue;
+        		if (!relatedEntity.inScope()) continue;
         		if (relatedEntity instanceof CandidateTypes) {
         			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
         			for (TypeEntity candidateType:candidateTypes) {

ad3304fccba6662eb9a8fd3d3d428f95305d530a
@@ -59,7 +59,6 @@ public class FileDependencyGenerator extends DependencyGenerator{
         	for (Relation relation:entity.getRelations()) {
         		Entity relatedEntity = relation.getEntity();
         		if (relatedEntity==null) continue;
-        		if (!relatedEntity.inScope()) continue;
         		if (relatedEntity instanceof CandidateTypes) {
         			List<TypeEntity> candidateTypes = ((CandidateTypes)relatedEntity).getCandidateTypes();
         			for (TypeEntity candidateType:candidateTypes) {
@@ -89,6 +88,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
 		Entity ancestor = entity.getAncestorOfType(FileEntity.class);
 		if (ancestor==null)
 			return -1;
+		if (!ancestor.inScope()) return -1;
 		return ancestor.getId();
 	}
 

4795536acf50163115018b25d37621a354588d94
@@ -66,6 +66,10 @@ public class Expression implements Serializable{
 	}
 
 	public void setType(TypeEntity type, Entity referredEntity, Inferer inferer) {
+		if (this.referredEntity==null && referredEntity!=null) {
+			this.referredEntity  = referredEntity;
+		}
+		
 		if (type instanceof CandidateTypes) {
 			return ;
 		}
@@ -80,11 +84,9 @@ public class Expression implements Serializable{
 			}
 			changedType = true;
 		}
-		if (this.referredEntity==null && referredEntity!=null) {
-			this.referredEntity  = referredEntity;
-		}
 		if (this.referredEntity==null)
 			this.referredEntity = this.type;
+
 		if (changedType)
 			deduceTheParentType(inferer);
 	}

ef273b33e595e038828d320bd8f38248be854e54
@@ -46,8 +46,9 @@ public class TypeEntity extends ContainerEntity {
 	public void inferLocalLevelEntities(Inferer inferer) {
 		inheritedTypes = new ArrayList<>();
 		identiferToEntities(inferer, this.inhertedTypeIdentifiers).forEach(item -> {
-			if (item instanceof TypeEntity) {
-				inheritedTypes.add((TypeEntity) item);
+			Entity typeItem = getTypeEntity(item);
+			if (typeItem !=null) {
+				inheritedTypes.add((TypeEntity) typeItem);
 			}else {
 				System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
 			}
@@ -57,8 +58,9 @@ public class TypeEntity extends ContainerEntity {
 		implementedTypes = new ArrayList<>();
 		identiferToEntities(inferer, this.implementedIdentifiers)
 				.forEach(item -> {
-					if (item instanceof TypeEntity) {
-						implementedTypes.add((TypeEntity) item);
+					Entity typeItem = getTypeEntity(item);
+					if (typeItem !=null) {
+						implementedTypes.add((TypeEntity) typeItem);
 					}else {
 						System.err.println(item.getRawName() + " expected a type, but actually it is "+ item.getClass().getSimpleName());
 					}
@@ -69,6 +71,13 @@ public class TypeEntity extends ContainerEntity {
 		super.inferLocalLevelEntities(inferer);
 	}
 
+	private Entity getTypeEntity(Entity item) {
+		if (item==null) return null;
+		if (item instanceof TypeEntity) return item;
+		if (item instanceof MultiDeclareEntities) return ((MultiDeclareEntities)item).getType();
+		if (item instanceof AliasEntity) return item.getType();
+		return null;
+	}
 	public void addImplements(GenericName typeName) {
 		if (typeName==null) {
 			return;

f6364da09d70d8ef4c1c35e9b7017ef47a19b98c
@@ -33,8 +33,18 @@ public class AliasTest extends CppParserTest{
 	}
 	
 	@Test
-	public void test_multi_declares_should_only_count_actual_referred() {
-		fail("to be implemented");
+	public void test_multi_declares_should_only_count_actual_referred() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/MultiDeclareRef.h",
+	    		"./src/test/resources/cpp-code-examples/MultiDeclareRef.cpp",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+        inferer.resolveAllBindings();
+        this.assertContainsRelation(repo.getEntity("bar"), DependencyType.CALL, "foo");
 	}
 	
 	@Test

818a9643005ff2b996f40eb6bf6c90c4a4a12c41
@@ -45,34 +45,43 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import depends.util.FileTraversal;
 import depends.util.FileUtil;
+
 abstract public class AbstractLangProcessor {
 	/**
 	 * The name of the lang
+	 * 
 	 * @return
 	 */
 	public abstract String supportedLanguage();
+
 	/**
 	 * The file suffixes in the lang
+	 * 
 	 * @return
 	 */
 	public abstract String[] fileSuffixes();
 
 	/**
-	 * Strategy of how to lookup  types and entities in the lang.
+	 * Strategy of how to lookup types and entities in the lang.
+	 * 
 	 * @return
 	 */
 	public abstract ImportLookupStrategy getImportLookupStrategy();
+
 	/**
-	 * The builtInType of the lang. 
+	 * The builtInType of the lang.
+	 * 
 	 * @return
 	 */
 	public abstract BuiltInType getBuiltInType();
+
 	/**
 	 * The language specific file parser
+	 * 
 	 * @param fileFullPath
 	 * @return
 	 */
-    protected abstract FileParser createFileParser(String fileFullPath);
+	protected abstract FileParser createFileParser(String fileFullPath);
 
 	public Inferer inferer;
 	protected EntityRepo entityRepo;
@@ -82,65 +91,70 @@ abstract public class AbstractLangProcessor {
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> unsolved;
 	private List<String> typeFilter;
+
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,getImportLookupStrategy(),getBuiltInType(),eagerExpressionResolve);
+		inferer = new Inferer(entityRepo, getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
 	}
-	
-    /**
-     * The process steps of build dependencies.
-     * Step 1: parse all files, add entities and expression into repositories
-     * Step 2: resolve bindings of files (if not resolved yet)
-     * Step 3: identify dependencies 
-     * @param includeDir 
-     * @param inputDir 
-     */
-	public void buildDependencies(String inputDir, String[] includeDir,List<String> typeFilter,boolean callAsImpl) {
+
+	/**
+	 * The process steps of build dependencies. Step 1: parse all files, add
+	 * entities and expression into repositories Step 2: resolve bindings of files
+	 * (if not resolved yet) Step 3: identify dependencies
+	 * 
+	 * @param includeDir
+	 * @param inputDir
+	 */
+	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
-        parseAllFiles();
-        markAllEntitiesScope();
-        resolveBindings(callAsImpl);
-        identifyDependencies();
+		parseAllFiles();
+		markAllEntitiesScope();
+		resolveBindings(callAsImpl);
+		identifyDependencies();
 	}
 
-
 	private void markAllEntitiesScope() {
-		entityRepo.getEntities().stream().forEach(entity->{
+		entityRepo.getEntities().stream().forEach(entity -> {
 			Entity file = entity.getAncestorOfType(FileEntity.class);
-			if (!file.getQualifiedName().startsWith(this.inputSrcPath)) {
-				entity.setInScope(false);
+			try {
+				if (!file.getQualifiedName().startsWith(this.inputSrcPath)) {
+					entity.setInScope(false);
+				}
+			} catch (Exception e) {
+
 			}
 		});
 	}
+
 	/**
 	 * 
-	 * @param callAsImpl 
+	 * @param callAsImpl
 	 * @return unsolved bindings
- 	 */
-    private void resolveBindings(boolean callAsImpl) {
+	 */
+	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-        this.unsolved =inferer.resolveAllBindings(callAsImpl);
-        if (getUnsolved().size()>0) {
-        	System.err.println("There are " + getUnsolved().size() + " items are unsolved." );
-        }
-        System.out.println("types and bindings resolved successfully...");
-    }
-    
-    private void identifyDependencies(){
-		System.out.println("dependencie data generating...");	
-        dependencyMatrix  = dependencyGenerator.build(entityRepo,typeFilter);
-        entityRepo = null;
-		System.out.println("reorder dependency matrix...");	
-        dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
-        System.out.println("dependencie data generating done successfully...");	 	
-    }
-
-    private final void parseAllFiles() {
-        System.out.println("start parsing files...");		
-        Set<String> phase2Files = new HashSet<>();
-    	FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor(){
+		this.unsolved = inferer.resolveAllBindings(callAsImpl);
+		if (getUnsolved().size() > 0) {
+			System.err.println("There are " + getUnsolved().size() + " items are unsolved.");
+		}
+		System.out.println("types and bindings resolved successfully...");
+	}
+
+	private void identifyDependencies() {
+		System.out.println("dependencie data generating...");
+		dependencyMatrix = dependencyGenerator.build(entityRepo, typeFilter);
+		entityRepo = null;
+		System.out.println("reorder dependency matrix...");
+		dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
+		System.out.println("dependencie data generating done successfully...");
+	}
+
+	private final void parseAllFiles() {
+		System.out.println("start parsing files...");
+		Set<String> phase2Files = new HashSet<>();
+		FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor() {
 			@Override
 			public void visit(File file) {
 				String fileFullPath = file.getAbsolutePath();
@@ -149,46 +163,44 @@ abstract public class AbstractLangProcessor {
 					return;
 				}
 				if (isPhase2Files(fileFullPath)) {
-					
-				}else {
+
+				} else {
 					parseFile(fileFullPath);
 				}
 			}
-    		
-    	});
-    	fileTransversal.extensionFilter(this.fileSuffixes());
+
+		});
+		fileTransversal.extensionFilter(this.fileSuffixes());
 		fileTransversal.travers(this.inputSrcPath);
-		for (String f:phase2Files) {
+		for (String f : phase2Files) {
 			parseFile(f);
 		}
-        System.out.println("all files procceed successfully...");		
+		System.out.println("all files procceed successfully...");
 
 	}
-    
 
 	protected void parseFile(String fileFullPath) {
-        FileParser fileParser = createFileParser(fileFullPath);
-        try {
-            System.out.println("parsing " + fileFullPath 
-            		+ "...");		
-            fileParser.parse();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }	
+		FileParser fileParser = createFileParser(fileFullPath);
+		try {
+			System.out.println("parsing " + fileFullPath + "...");
+			fileParser.parse();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
 	}
-	
+
 	protected boolean isPhase2Files(String fileFullPath) {
 		return false;
 	}
-	
+
 	public List<String> includePaths() {
 		ArrayList<String> r = new ArrayList<String>();
-		for (String path:includeDirs) {
+		for (String path : includeDirs) {
 			if (FileUtils.fileExists(path)) {
 				if (!r.contains(path))
 					r.add(path);
 			}
-			path = this.inputSrcPath +File.separator+path;
+			path = this.inputSrcPath + File.separator + path;
 			if (FileUtils.fileExists(path)) {
 				if (!r.contains(path))
 					r.add(path);
@@ -196,10 +208,11 @@ abstract public class AbstractLangProcessor {
 		}
 		return r;
 	}
-	
+
 	public DependencyMatrix getDependencies() {
 		return dependencyMatrix;
 	}
+
 	public EntityRepo getEntityRepo() {
 		return this.entityRepo;
 	}
@@ -207,7 +220,9 @@ abstract public class AbstractLangProcessor {
 	public void setDependencyGenerator(DependencyGenerator dependencyGenerator) {
 		this.dependencyGenerator = dependencyGenerator;
 	}
+
 	public abstract List<String> supportedRelations();
+
 	public Set<UnsolvedBindings> getUnsolved() {
 		return unsolved;
 	}

f96a8bfd551c8586e328ea00855389b525821749
@@ -42,6 +42,10 @@ public class DependencyType {
 	public static final String THROW = "Throw";
 	public static final String ANNOTATION = "Annotation";
 	public static final String MIXIN = "MixIn";
+	public static final String PomParent = "Parent";
+	public static final String PomPlugin = "Plugin";
+	public static final String PomDependency = "Dependency";
+	
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();
@@ -60,6 +64,9 @@ public class DependencyType {
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
 		depedencyTypes.add(MIXIN);
+		depedencyTypes.add(PomParent);
+		depedencyTypes.add(PomPlugin);
+		depedencyTypes.add(PomDependency);
 		return depedencyTypes;
 	}
 }

60e961d4b1f2cc6040a442a9503a9f4af7a8a335
@@ -0,0 +1,34 @@
+package depends.extractor.pom;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import depends.deptypes.DependencyType;
+
+public class DependencyTest extends MavenParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_extract_dep_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/to.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
+	}
+	
+	
+}
\ No newline at end of file

7be48f87c6c3298c6cb5bca15a6a56605fd8212b
@@ -30,5 +30,20 @@ public class DependencyTest extends MavenParserTest{
 	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
 	}
 	
+	@Test
+	public void should_extract_plugin_relation() throws IOException {
+	    String[] srcs = new String[] {
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/from.pom",
+	    		"./src/test/resources/maven-code-examples/dependencyRelation/plugin.pom",
+	    	    };
+	    
+	    for (String src:srcs) {
+		    PomFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings();
+	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.USE, "aplugins.aplugin_0.1_");
+	}
+	
 	
 }
\ No newline at end of file

6571df64e908777bd8949cd85afa4b0f5311b9a8
@@ -252,11 +252,13 @@ public class Expression implements Serializable{
 
 	private boolean validName(String name) {
 		if (name==null) return false;
-		if (name.equals("<Literal>")) return true;
-		if (name.equals("<Built-In>")) return true;
-		if (name.equals("<built-in>")) return true;
-		if (name.equals("built-in")) return true;
-		return name.matches("([a-zA-Z0-9_]|(\\.))*");
+		if (name.toLowerCase().equals("<literal>")) return true;
+		if (name.toLowerCase().equals("<built-in>")) return true;
+		boolean result = name.matches("([a-zA-Z0-9_]|(\\.)|(\\-))*");
+		if (result==false) {
+			System.err.println("expression name " + name);
+		}
+		return true;
 	}
 
 	public void setIdentifier(GenericName name) {

ff26192c2be15023d7081348a59f01833bf64f06
@@ -1,6 +1,8 @@
 package depends.extractor.pom;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
 
@@ -8,6 +10,8 @@ import org.junit.Before;
 import org.junit.Test;
 
 import depends.deptypes.DependencyType;
+import depends.entity.Entity;
+import depends.entity.MultiDeclareEntities;
 
 public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
     @Before
@@ -28,6 +32,7 @@ public class DependencyWithPropertiesOfParentTest extends MavenParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
+	    assertFalse(repo.getEntity("parent-group.a-parent_1.0_") instanceof MultiDeclareEntities);
 	    this.assertContainsRelation(repo.getEntity("testgroup.test_1.0_"), DependencyType.CONTAIN, "a-dep-group.a-artifact_0.2_");
 	}
 	

406b53d3840de487c2b4565bfc990212b46552af
@@ -0,0 +1,40 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.extractor.pom;
+
+import depends.entity.GenericName;
+
+public class PomCoords  {
+	public PomCoords() {
+	}
+
+	public String groupId;
+	public String artifactId;
+	public String version;
+	public String getPath() {
+		return groupId+"."+artifactId+"_" +version+"_" ;
+	}
+
+}

b11253d8af444193832a39661bb94f71bb57ca4f
@@ -24,7 +24,11 @@ SOFTWARE.
 
 package depends.extractor.pom;
 
+import java.io.File;
+import java.util.List;
+
 import depends.entity.GenericName;
+import depends.util.FileUtil;
 
 public class PomCoords  {
 	public PomCoords() {
@@ -36,5 +40,34 @@ public class PomCoords  {
 	public String getPath() {
 		return groupId+"."+artifactId+"_" +version+"_" ;
 	}
+	public void fillFromIfNull(PomParent pomParent) {
+		if (groupId==null) groupId = pomParent.groupId;
+		if (artifactId==null) artifactId = pomParent.artifactId;
+		if (version==null) version = pomParent.version;
+	}
+	public GenericName getGenericNamePath() {
+		return new GenericName(getPath());
+	}
+	public void sureFillVersion(List<String> includePaths) {
+		if (version!=null) return;
+		StringBuilder sb = new StringBuilder();
+		sb.append(this.groupId.replace(".", File.separator));
+		sb.append(File.separator);
+		sb.append(this.artifactId);
+		sb.append(File.separator);
+		
+		for (String includePath:includePaths) {
+			String path = includePath+File.separator+sb.toString();
+			if (FileUtil.existFile(path)) {
+				File f = new File(path);
+				String max = "";
+				for (String d:f.list()) {
+					if (d.compareTo(max)>0)
+						max = d;
+				}
+				version = max;
+			}
+		}
+	}
 
 }

70a678537832952f5bf42e6c44372a60e63821ab
@@ -34,22 +34,22 @@ public class PomCoords  {
 	public PomCoords() {
 	}
 
-	public String groupId;
-	public String artifactId;
-	public String version;
+	public String groupId = "";
+	public String artifactId = "";
+	public String version = "";
 	public String getPath() {
 		return groupId+"."+artifactId+"_" +version+"_" ;
 	}
 	public void fillFromIfNull(PomParent pomParent) {
-		if (groupId==null) groupId = pomParent.groupId;
-		if (artifactId==null) artifactId = pomParent.artifactId;
-		if (version==null) version = pomParent.version;
+		if (groupId=="") groupId = pomParent.groupId;
+		if (artifactId=="") artifactId = pomParent.artifactId;
+		if (version=="") version = pomParent.version;
 	}
 	public GenericName getGenericNamePath() {
 		return new GenericName(getPath());
 	}
 	public void sureFillVersion(List<String> includePaths) {
-		if (version!=null) return;
+		if (version!="") return;
 		StringBuilder sb = new StringBuilder();
 		sb.append(this.groupId.replace(".", File.separator));
 		sb.append(File.separator);

1dbf851df92f6e8022cc693b2f5948026c516fa7
@@ -255,9 +255,9 @@ public class Expression implements Serializable{
 		if (name.toLowerCase().equals("<literal>")) return true;
 		if (name.toLowerCase().equals("<built-in>")) return true;
 		boolean result = name.matches("([a-zA-Z0-9_]|(\\.)|(\\-))*");
-		if (result==false) {
-			System.err.println("expression name " + name);
-		}
+//		if (result==false) {
+//			System.err.println("expression name " + name);
+//		}
 		return true;
 	}
 

84d5c9beae5aacabc4f46f0a0163f984335b21ba
@@ -304,7 +304,9 @@ public abstract class HandlerContext {
 				container.cacheExpressions();
 			}
 		}
-		entityStack.pop();
+		//we never pop up the lastest one (FileEntity)
+		if (entityStack.size()>1)
+			entityStack.pop();
 	}
 	
 	private VarEntity getVar(ContainerEntity container, GenericName varName) {

271e68b9fcad9ff8cb867ab708b71fbe44928dea
@@ -6,6 +6,7 @@ import java.util.List;
 import org.eclipse.cdt.core.dom.ast.ASTVisitor;
 import org.eclipse.cdt.core.dom.ast.IASTDeclSpecifier;
 import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
+import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
 import org.eclipse.cdt.core.dom.ast.IASTName;
 import org.eclipse.cdt.core.dom.ast.IASTNode;
 import org.eclipse.cdt.core.dom.ast.IASTTypeId;
@@ -38,6 +39,8 @@ class TemplateParameterASTVisitor extends ASTVisitor{
 				} else if (argument instanceof IASTIdExpression){
 					String parameterName = ASTStringUtilExt.getName(((IASTIdExpression)argument).getName());
 					parameters.add(GenericName.build(parameterName));
+				} else if (argument instanceof IASTLiteralExpression){
+					parameters.add(GenericName.build("<Literal>"));
 				}else {
 					System.err.println ("TODO: unknown template arguments");
 				}

fd397a0f13a3c1627a0dcbd6099f66104dbf64be
@@ -186,6 +186,9 @@ abstract public class AbstractLangProcessor {
 			fileParser.parse();
 		} catch (IOException e) {
 			e.printStackTrace();
+		} catch (Exception e) {
+			System.err.println("error occoured during parse file " + fileFullPath);
+			e.printStackTrace();
 		}
 	}
 

0b82d62bc4ae4654adacde93509845d43bf5ae17
@@ -149,7 +149,7 @@ public class FileEntity extends TypeEntity {
 		this.cacheExpressions();
 		for (Entity child:containerEntity.getChildren()) {
 			if (child instanceof ContainerEntity) {
-				cacheChildExpressions((ContainerEntity)child);
+				((ContainerEntity)child).cacheExpressions();
 			}
 		}
 	}

0d2f9238499aaaff77c317200c54ce303dba8445
@@ -139,7 +139,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
-
+		if(expressionList.size()>10000) return;
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
 			if (expression.getType() != null)

b217ef7aaa6067b1ee40c9d34574875056bd682c
@@ -37,7 +37,7 @@ import depends.relations.ImportLookupStrategy;
 
 public class CppProcessor extends AbstractLangProcessor {
 	private static final String LANG = "cpp";
-	private static final String[] SUFFIX = new String[] { ".cpp", ".cc", ".c", ".h", ".hpp", ".hh", ".cxx", ".hxx" };
+	private static final String[] SUFFIX = new String[] { ".cpp", ".cc", ".c", ".c++", ".h", ".hpp", ".hh", ".cxx", ".hxx" };
 	PreprocessorHandler preprocessorHandler;
 
 	MacroRepo macroRepo = null;

b3123721086227b5c892a7c4ad0709c77b88d7be
@@ -29,6 +29,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -50,7 +51,10 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	private HashMap<Object, Expression> expressions;
+	WeakReference<HashMap<Object, Expression>> expressionWeakReference = new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
+	//private HashMap<Object, Expression> expressions;
+	
+	
 	private ArrayList<Expression> expressionList;
 	private Collection<GenericName> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
@@ -60,7 +64,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		functions = new ArrayList<>();
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
-		expressions = new HashMap<>();
 		expressionList = new ArrayList<>();
 	}
 
@@ -70,7 +73,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		functions = new ArrayList<>();
 		mixins = new ArrayList<>();
 		resolvedMixins = new ArrayList<>();
-		expressions = new HashMap<>();
 		expressionList = new ArrayList<>();
 	}
 
@@ -94,11 +96,13 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public HashMap<Object, Expression> expressions() {
-		return expressions;
+		HashMap<Object, Expression> r = expressionWeakReference.get();
+		if (r==null) return new HashMap<>();
+		return r;
 	}
 
 	public void addExpression(Object key, Expression expression) {
-		expressions.put(key, expression);
+		expressions().put(key, expression);
 		expressionList.add(expression);
 	}
 
@@ -181,13 +185,19 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
-		this.expressions = new HashMap<>();
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
 		cacheExpressionListToFile();
+		this.expressionList.clear();
+		this.expressionList=null;
 		this.expressionList = new ArrayList<>();
 	}
 
 	public void clearExpressions() {
-		this.expressions = new HashMap<>();
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
+		this.expressionList.clear();
+		this.expressionList=null;
 		this.expressionList = new ArrayList<>();
 	}
 	
@@ -236,7 +246,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public boolean containsExpression() {
-		return expressions.size() > 0;
+		return expressions().size() > 0;
 	}
 
 	public String dumpExpressions() {
@@ -358,10 +368,4 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	public Collection<ContainerEntity> getResolvedMixins() {
 		return resolvedMixins;
 	}
-
-
-
-
-
-
 }

8177ac46f304e681acd77cd5b787d4bbdb8717dc
@@ -86,7 +86,7 @@ abstract public class AbstractLangProcessor {
 	public Inferer inferer;
 	protected EntityRepo entityRepo;
 	DependencyMatrix dependencyMatrix;
-	private String inputSrcPath;
+	protected String inputSrcPath;
 	public String[] includeDirs;
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> unsolved;

757d605ac61d7e8cec2352eb42756b8af8de032d
@@ -51,51 +51,62 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	WeakReference<HashMap<Object, Expression>> expressionWeakReference = new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
-	//private HashMap<Object, Expression> expressions;
-	
-	
+	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
 	private ArrayList<Expression> expressionList;
 	private Collection<GenericName> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
 
+	private ArrayList<VarEntity> vars() {
+		if (vars==null)
+			vars = new ArrayList<>();
+		return this.vars;
+	}
+	
+	private Collection<GenericName> mixins() {
+		if (mixins==null)
+			mixins = new ArrayList<>();
+		return this.mixins;
+	}
+
+	private ArrayList<FunctionEntity> functions() {
+		if (functions==null)
+			functions = new ArrayList<>();
+		return this.functions;
+	}
+	
 	public ContainerEntity() {
-		vars = new ArrayList<>();
-		functions = new ArrayList<>();
-		mixins = new ArrayList<>();
-		resolvedMixins = new ArrayList<>();
-		expressionList = new ArrayList<>();
 	}
 
 	public ContainerEntity(GenericName rawName, Entity parent, Integer id) {
 		super(rawName, parent, id);
-		vars = new ArrayList<>();
-		functions = new ArrayList<>();
-		mixins = new ArrayList<>();
-		resolvedMixins = new ArrayList<>();
-		expressionList = new ArrayList<>();
 	}
 
 	public void addVar(VarEntity var) {
 		if (logger.isDebugEnabled()) {
 			logger.debug("var found: " + var.getRawName() + ":" + var.getRawType());
 		}
-		this.vars.add(var);
+		this.vars().add(var);
 	}
 
 	public ArrayList<VarEntity> getVars() {
-		return this.vars;
+		if (vars==null)
+			return new ArrayList<>();
+		return this.vars();
 	}
 
 	public void addFunction(FunctionEntity functionEntity) {
-		this.functions.add(functionEntity);
+		this.functions().add(functionEntity);
 	}
 
 	public ArrayList<FunctionEntity> getFunctions() {
+		if (functions==null)
+			return new ArrayList<>();
 		return this.functions;
 	}
 
 	public HashMap<Object, Expression> expressions() {
+		if (expressionWeakReference==null)
+			expressionWeakReference= new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
 		HashMap<Object, Expression> r = expressionWeakReference.get();
 		if (r==null) return new HashMap<>();
 		return r;
@@ -103,7 +114,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	public void addExpression(Object key, Expression expression) {
 		expressions().put(key, expression);
-		expressionList.add(expression);
+		expressionList().add(expression);
 	}
 
 	/**
@@ -112,19 +123,26 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 */
 	public void inferLocalLevelEntities(Inferer inferer) {
 		super.inferLocalLevelEntities(inferer);
-		for (VarEntity var : this.vars) {
+		for (VarEntity var : this.vars()) {
 			var.inferLocalLevelEntities(inferer);
 		}
-		for (FunctionEntity func : this.functions) {
+		for (FunctionEntity func : this.getFunctions()) {
 			func.inferLocalLevelEntities(inferer);
 		}
-		resolvedMixins = identiferToContainerEntity(inferer, mixins);
+		resolvedMixins = identiferToContainerEntity(inferer, getMixins());
 		if (inferer.isEagerExpressionResolve()) {
 			this.resolveExpressions(inferer);
 		}
 	}
 
+	private Collection<GenericName> getMixins() {
+		if (mixins==null)
+			return new ArrayList<>();
+		return mixins;
+	}
+
 	private Collection<ContainerEntity> identiferToContainerEntity(Inferer inferer, Collection<GenericName> identifiers) {
+		if (identifiers.size()==0) return null;
 		ArrayList<ContainerEntity> r = new ArrayList<>();
 		for (GenericName identifier : identifiers) {
 			Entity entity = inferer.resolveName(this, identifier, true);
@@ -143,6 +161,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	 * @param inferer
 	 */
 	public void resolveExpressions(Inferer inferer) {
+		if (expressionList==null) return;
 		if(expressionList.size()>10000) return;
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
@@ -185,6 +204,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
 		this.expressions().clear();
 		this.expressionWeakReference.clear();
 		cacheExpressionListToFile();
@@ -194,6 +215,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void clearExpressions() {
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
 		this.expressions().clear();
 		this.expressionWeakReference.clear();
 		this.expressionList.clear();
@@ -233,6 +256,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	public TypeEntity getLastExpressionType() {
+		if (expressionList==null) return null;
 		for (int i = this.expressionList.size() - 1; i >= 0; i--) {
 			Expression expr = this.expressionList.get(i);
 			if (expr.isStatement)
@@ -242,6 +266,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public List<Expression> expressionList() {
+		if (expressionList==null) 
+			expressionList = new ArrayList<>();
 		return expressionList;
 	}
 
@@ -250,6 +276,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public String dumpExpressions() {
+		if (expressionList==null) return "";
 		StringBuilder sb = new StringBuilder();
 		for (Expression exp : expressionList) {
 			sb.append(exp.toString()).append("\n");
@@ -362,10 +389,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void addMixin(GenericName moduleName) {
-		mixins.add(moduleName);
+		mixins().add(moduleName);
 	}
 
 	public Collection<ContainerEntity> getResolvedMixins() {
+		if (resolvedMixins==null) return new ArrayList<>();
 		return resolvedMixins;
 	}
 }

a3c2b61023b98080fe98c63e2af86332e49e771f
@@ -60,7 +60,7 @@ public class CppProcessor extends AbstractLangProcessor {
 	@Override
 	protected FileParser createFileParser(String fileFullPath) {
 		if (macroRepo == null) {
-			macroRepo = new MacroRepo();
+			macroRepo = new MacroFileRepo(entityRepo);
 			macroRepo.buildDefaultMap(super.includePaths());
 		}
 		if (preprocessorHandler==null) {

0b69920b98ab66961541e2b72fe100252b2ed520
@@ -78,7 +78,9 @@ public class DependsCommand {
 	private boolean callAsImpl = false;	
 	@Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
     private String[] typeFilter=new String[]{};
-    @Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
+	@Option(names = {"--external-deps"}, description = "Output external dependencies")
+	private boolean outputExternalDependencies = false;	
+	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
 	}
@@ -152,4 +154,7 @@ public class DependsCommand {
 	public boolean isCallAsImpl() {
 		return callAsImpl;
 	}
+	public boolean isOutputExternalDependencies() {
+		return outputExternalDependencies;
+	}
 }

9e4cf852447ec6ccae313633f2f6a5581c818879
@@ -53,6 +53,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	private ArrayList<FunctionEntity> functions;
 	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
 	private ArrayList<Expression> expressionList;
+	private int expressionCount = 0;
 	private Collection<GenericName> mixins;
 	private Collection<ContainerEntity> resolvedMixins;
 
@@ -225,6 +226,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 	
 	private void cacheExpressionListToFile() {
+		expressionCount = this.expressionList.size();
+		if (expressionCount ==0) return;
 		try {
 			FileOutputStream fileOut = new FileOutputStream(TemporaryFile.getInstance().exprPath(this.id));
 			ObjectOutputStream out = new ObjectOutputStream(fileOut);
@@ -238,6 +241,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	@SuppressWarnings("unchecked")
 	public void reloadExpression(EntityRepo repo) {
+		if (expressionCount ==0) return;
 		try
 	      {
 	         FileInputStream fileIn = new FileInputStream(TemporaryFile.getInstance().exprPath(this.id));

ac667382e1c7de19897e263e07f5130bf7babb7c
@@ -26,6 +26,7 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -41,6 +42,8 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
+	HashMap<Integer, HashSet<String>> includedFiles = new HashMap<>();
+
 	@Override
 	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
 		String importedString = fileEntity.importedSuffixMatch(name);
@@ -49,8 +52,8 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (r!=null) return r;
 		}
 		
-		HashSet<String> fileSet = new HashSet<>();
-		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
+		
+		HashSet<String> fileSet = findIncludedFiles(fileEntity, repo);
 		
 		for (String file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
@@ -70,6 +73,15 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
+	private HashSet<String> findIncludedFiles(FileEntity fileEntity, EntityRepo repo) {
+		HashSet<String> fileSet = this.includedFiles.get(fileEntity.getId());
+		if (fileSet!=null) return fileSet;
+		fileSet = new HashSet<>();
+		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
+		includedFiles.put(fileEntity.getId(),fileSet);
+		return fileSet;
+	}
+
 	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles, EntityRepo repo) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;

fdd899ac54368bb8e0edcf3e65855b12d8d82892
@@ -19,8 +19,8 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	private List<Entity> allEntitiesByOrder;
 
 	public InMemoryEntityRepo() {
-		allEntieisByName = new HashMap<>();
-		allEntitiesById = new HashMap<>();
+		allEntieisByName = new TreeMap<>();
+		allEntitiesById = new TreeMap<>();
 		allEntitiesByOrder = new LinkedList<>();
 	}
 

2d90871f912b249b9fa616cccfa2c76e54911a80
@@ -297,13 +297,6 @@ public abstract class HandlerContext {
 	
 	
 	public void exitLastedEntity() {
-		Entity e = entityStack.peek();
-		if (e instanceof ContainerEntity) {
-			ContainerEntity container = (ContainerEntity)e;
-			if (!inferer.isEagerExpressionResolve()) {
-				container.cacheExpressions();
-			}
-		}
 		//we never pop up the lastest one (FileEntity)
 		if (entityStack.size()>1)
 			entityStack.pop();

86c9b59cce7f1555ce2012fa711c011d9d2a3d10
@@ -26,7 +26,6 @@ package depends.extractor.cpp;
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -42,8 +41,6 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 
 public class CppImportLookupStrategy implements ImportLookupStrategy {
-	HashMap<Integer, HashSet<String>> includedFiles = new HashMap<>();
-
 	@Override
 	public Entity lookupImportedType(String name, FileEntity fileEntity, EntityRepo repo, Inferer inferer) {
 		String importedString = fileEntity.importedSuffixMatch(name);
@@ -52,8 +49,8 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (r!=null) return r;
 		}
 		
-		
-		HashSet<String> fileSet = findIncludedFiles(fileEntity, repo);
+		HashSet<String> fileSet = new HashSet<>();
+		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
 		
 		for (String file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
@@ -73,15 +70,6 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
-	private HashSet<String> findIncludedFiles(FileEntity fileEntity, EntityRepo repo) {
-		HashSet<String> fileSet = this.includedFiles.get(fileEntity.getId());
-		if (fileSet!=null) return fileSet;
-		fileSet = new HashSet<>();
-		foundIncludedFiles(fileSet, fileEntity.getImportedFiles(),repo);
-		includedFiles.put(fileEntity.getId(),fileSet);
-		return fileSet;
-	}
-
 	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles, EntityRepo repo) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;

f1dcc068bf118e3da747c9fa81dab838b0f95803
@@ -39,7 +39,8 @@ public class MultiDeclareEntities extends ContainerEntity {
 	List<ContainerEntity> entities = new ArrayList<>();
 	private boolean containsTypeEntity = false;
 	public MultiDeclareEntities(Entity entity, int id ) {
-		super(entity.getRawName(), entity.getParent(), id);
+		setQualifiedName(entity.getQualifiedName());
+		setRawName(entity.getRawName());
 		add(entity);
 	}
 

b48185e08400c5b39608b6118fdb7744d99cf8ee
@@ -91,6 +91,7 @@ abstract public class AbstractLangProcessor {
 	private DependencyGenerator dependencyGenerator;
 	private Set<UnsolvedBindings> potentialExternalDependencies;
 	private List<String> typeFilter;
+	private List<String> includePaths;
 
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
@@ -104,11 +105,13 @@ abstract public class AbstractLangProcessor {
 	 * 
 	 * @param includeDir
 	 * @param inputDir
+	 * @param b 
 	 */
-	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl) {
+	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl, boolean isCollectUnsolvedBindings) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
+		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
 		parseAllFiles();
 		markAllEntitiesScope();
 		resolveBindings(callAsImpl);
@@ -197,19 +200,28 @@ abstract public class AbstractLangProcessor {
 	}
 
 	public List<String> includePaths() {
-		ArrayList<String> r = new ArrayList<String>();
+		if (this.includePaths ==null) {
+			this.includePaths = buildIncludePath();
+		}
+		return includePaths;
+	}
+
+	private List<String> buildIncludePath() {
+		includePaths = new ArrayList<String>();
 		for (String path : includeDirs) {
 			if (FileUtils.fileExists(path)) {
-				if (!r.contains(path))
-					r.add(path);
+				path = FileUtil.uniqFilePath(path);
+				if (!includePaths.contains(path))
+					includePaths.add(path);
 			}
 			path = this.inputSrcPath + File.separator + path;
 			if (FileUtils.fileExists(path)) {
-				if (!r.contains(path))
-					r.add(path);
+				path = FileUtil.uniqFilePath(path);
+				if (!includePaths.contains(path))
+					includePaths.add(path);
 			}
 		}
-		return r;
+		return includePaths;
 	}
 
 	public DependencyMatrix getDependencies() {

cca69513864525be6168935c908e4c8e130b38c2
@@ -27,6 +27,7 @@ package depends.entity;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 
 import depends.relations.Inferer;
@@ -302,5 +303,18 @@ public class CandidateTypes extends TypeEntity {
 		System.err.println("error: getDisplayName should not been invoked");
 		return super.getDisplayName();
 	}
+	@Override
+	public Entity getByName(String name, HashSet<Entity> searched) {
+		Entity entity = super.getByName(name, searched);
+		if (entity!=null) return entity;
+		for (TypeEntity type:getCandidateTypes()) {
+			if (searched.contains(type)) continue;
+			Entity e = type.getByName(name, searched);
+			if (e !=null) return e;
+		}
+		return null;
+	}
+	
+	
  	
 }

f9df158464aa3deee528e6da9e7f218b1b05bc36
@@ -32,6 +32,8 @@ import java.util.List;
 import java.util.Set;
 
 import org.codehaus.plexus.util.FileUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import depends.entity.Entity;
 import depends.entity.FileEntity;
@@ -92,7 +94,8 @@ abstract public class AbstractLangProcessor {
 	private Set<UnsolvedBindings> potentialExternalDependencies;
 	private List<String> typeFilter;
 	private List<String> includePaths;
-
+	private static Logger logger = LoggerFactory.getLogger(AbstractLangProcessor.class);
+	
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
 		inferer = new Inferer(entityRepo, getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
@@ -138,6 +141,7 @@ abstract public class AbstractLangProcessor {
 	 */
 	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
+		logger.warn("debug: Resolve types and bindings of variables, methods and expressions....");
 		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
 		if (getExternalDependencies().size() > 0) {
 			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
@@ -152,6 +156,7 @@ abstract public class AbstractLangProcessor {
 		System.out.println("reorder dependency matrix...");
 		dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
 		System.out.println("dependencie data generating done successfully...");
+		logger.warn("debug: dependencie data generating done successfully...");
 	}
 
 	private final void parseAllFiles() {

4113fef975f81e65cc901ea58f49f977b52f7b2c
@@ -51,9 +51,9 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 			if (r!=null) return r;
 		}
 		
-		HashSet<String> fileSet = getIncludedFiles(fileEntity);
+		HashSet<Integer> fileSet = getIncludedFiles(fileEntity);
 		
-		for (String file:fileSet) {
+		for (Integer file:fileSet) {
 			Entity importedItem = repo.getEntity(file);
 			if (importedItem instanceof FileEntity) {
 				FileEntity importedFile = (FileEntity) repo.getEntity(file);
@@ -71,24 +71,24 @@ public class CppImportLookupStrategy implements ImportLookupStrategy {
 		return null;
 	}
 
-	private Map<Integer, HashSet<String> > includedFiles  = new HashMap<>();
-	private  HashSet<String> getIncludedFiles(FileEntity fileEntity) {
+	private Map<Integer, HashSet<Integer> > includedFiles  = new HashMap<>();
+	private  HashSet<Integer> getIncludedFiles(FileEntity fileEntity) {
 
 		if (includedFiles.containsKey(fileEntity.getId())) {
 				return includedFiles.get(fileEntity.getId());
 		}
-		HashSet<String> fileSet = new HashSet<>();
+		HashSet<Integer> fileSet = new HashSet<>();
 		foundIncludedFiles(fileSet, fileEntity.getImportedFiles());
 		includedFiles.put(fileEntity.getId(), fileSet);
 		return fileSet;
 	}
 
-	private void foundIncludedFiles(HashSet<String> fileSet, Collection<Entity> importedFiles) {
+	private void foundIncludedFiles(HashSet<Integer> fileSet, Collection<Entity> importedFiles) {
 		for (Entity file:importedFiles) {
 			if (file==null ) continue;
 			if (!(file instanceof FileEntity)) continue;
-			if (fileSet.contains(file.getRawName().uniqName())) continue;
-			fileSet.add(file.getRawName().uniqName());
+			if (fileSet.contains(file.getId())) continue;
+			fileSet.add(file.getId());
 			foundIncludedFiles(fileSet,((FileEntity)file).getImportedFiles());
 		}
 	}

353ef8bebfdf15e39d81c702dfce9eb886498769
@@ -51,7 +51,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
+	HashMap<Object, Expression> expressions;
 	private ArrayList<Expression> expressionList;
 	private int expressionCount = 0;
 	private Collection<GenericName> mixins;
@@ -106,11 +106,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public HashMap<Object, Expression> expressions() {
-		if (expressionWeakReference==null)
-			expressionWeakReference= new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
-		HashMap<Object, Expression> r = expressionWeakReference.get();
-		if (r==null) return new HashMap<>();
-		return r;
+		if (expressions==null) 
+			expressions= new HashMap<>();
+		return expressions;
 	}
 
 	public void addExpression(Object key, Expression expression) {
@@ -205,27 +203,18 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
-		if (expressionWeakReference==null) return;
-		if (expressionList==null) return;
-		this.expressions().clear();
-		this.expressionWeakReference.clear();
+		this.expressions=null;
 		cacheExpressionListToFile();
-		this.expressionList.clear();
 		this.expressionList=null;
-		this.expressionList = new ArrayList<>();
 	}
 
 	public void clearExpressions() {
-		if (expressionWeakReference==null) return;
-		if (expressionList==null) return;
-		this.expressions().clear();
-		this.expressionWeakReference.clear();
-		this.expressionList.clear();
+		this.expressions=null;
 		this.expressionList=null;
-		this.expressionList = new ArrayList<>();
 	}
 	
 	private void cacheExpressionListToFile() {
+		if(this.expressionList==null) return;
 		expressionCount = this.expressionList.size();
 		if (expressionCount ==0) return;
 		try {

c3cf8f5b11ec32748fdcb7453dfe32ef97cd4c2c
@@ -248,9 +248,12 @@ public abstract class Entity {
 			return false;
 		return true;
 	}
+	
 	public void setInScope(boolean value) {
 		this.inScope  = value;
+		children().forEach(child->child.setInScope(value));
 	}
+	
 	public boolean inScope() {
 		return inScope;
 	}

03cc80253f0f34d6829653116d6f6c05204021ea
@@ -51,7 +51,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 
 	private ArrayList<VarEntity> vars;
 	private ArrayList<FunctionEntity> functions;
-	HashMap<Object, Expression> expressions;
+	WeakReference<HashMap<Object, Expression>> expressionWeakReference;
 	private ArrayList<Expression> expressionList;
 	private int expressionCount = 0;
 	private Collection<GenericName> mixins;
@@ -106,9 +106,11 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public HashMap<Object, Expression> expressions() {
-		if (expressions==null) 
-			expressions= new HashMap<>();
-		return expressions;
+		if (expressionWeakReference==null)
+			expressionWeakReference= new WeakReference<HashMap<Object, Expression>>(new HashMap<>());
+		HashMap<Object, Expression> r = expressionWeakReference.get();
+		if (r==null) return new HashMap<>();
+		return r;
 	}
 
 	public void addExpression(Object key, Expression expression) {
@@ -203,18 +205,27 @@ public abstract class ContainerEntity extends DecoratedEntity {
 	}
 
 	public void cacheExpressions() {
-		this.expressions=null;
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
 		cacheExpressionListToFile();
+		this.expressionList.clear();
 		this.expressionList=null;
+		this.expressionList = new ArrayList<>();
 	}
 
 	public void clearExpressions() {
-		this.expressions=null;
+		if (expressionWeakReference==null) return;
+		if (expressionList==null) return;
+		this.expressions().clear();
+		this.expressionWeakReference.clear();
+		this.expressionList.clear();
 		this.expressionList=null;
+		this.expressionList = new ArrayList<>();
 	}
 	
 	private void cacheExpressionListToFile() {
-		if(this.expressionList==null) return;
 		expressionCount = this.expressionList.size();
 		if (expressionCount ==0) return;
 		try {

327f8cccd04bd195fe6a6abc437c2b35c41ba456
@@ -26,6 +26,7 @@ package depends.extractor;
 
 import java.io.File;
 import java.io.IOException;
+import java.lang.management.ManagementFactory;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -115,10 +116,20 @@ abstract public class AbstractLangProcessor {
 		this.includeDirs = includeDir;
 		this.typeFilter = typeFilter;
 		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
+		logger.info("Start parsing files...");
 		parseAllFiles();
 		markAllEntitiesScope();
+		if (logger.isInfoEnabled()) {
+			logger.info("Resolve types and bindings of variables, methods and expressions.... " + this.inputSrcPath);
+			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
+		}
 		resolveBindings(callAsImpl);
+		if (logger.isInfoEnabled()) {
+			System.gc();
+			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
+		}
 		identifyDependencies();
+		logger.info("Dependencie data generating done successfully...");
 	}
 
 	private void markAllEntitiesScope() {
@@ -141,7 +152,6 @@ abstract public class AbstractLangProcessor {
 	 */
 	private void resolveBindings(boolean callAsImpl) {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-		logger.warn("debug: Resolve types and bindings of variables, methods and expressions....");
 		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
 		if (getExternalDependencies().size() > 0) {
 			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
@@ -155,12 +165,11 @@ abstract public class AbstractLangProcessor {
 		entityRepo = null;
 		System.out.println("reorder dependency matrix...");
 		dependencyMatrix = new OrderedMatrixGenerator(dependencyMatrix).build();
-		System.out.println("dependencie data generating done successfully...");
-		logger.warn("debug: dependencie data generating done successfully...");
+		System.out.println("Dependencie data generating done successfully...");
 	}
 
 	private final void parseAllFiles() {
-		System.out.println("start parsing files...");
+		System.out.println("Start parsing files...");
 		Set<String> phase2Files = new HashSet<>();
 		FileTraversal fileTransversal = new FileTraversal(new FileTraversal.IFileVisitor() {
 			@Override

36ce0aa6a67d5d41772caf5bf076c107dc7ea9ba
@@ -203,6 +203,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			}
 		}
 	}
+	
+	public void cacheChildExpressions() {
+		cacheExpressions();
+		for (Entity child:getChildren()) {
+			if (child instanceof ContainerEntity) {
+				((ContainerEntity)child).cacheChildExpressions();
+			}
+		}
+	}
+
 
 	public void cacheExpressions() {
 		if (expressionWeakReference==null) return;

24ab7cccd7f90b2796bce39ab082d04f0bcf84e5
@@ -188,7 +188,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;
 				}
-				if (expression.isCall) {
+				if (expression.isCall()) {
 					FunctionEntity func = this.lookupFunctionInVisibleScope(expression.getIdentifier());
 					if (func != null) {
 						expression.setType(func.getType(), func, inferer);

d84bc1571b2d6c8b8665786b268e9c438254a613
@@ -59,8 +59,10 @@ public class ExpressionUsage {
 	public void foundExpression(IASTExpression ctx) {
 		Expression parent = findParentInStack(ctx);
 		//If parent already a call 
-		if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast)) {
-			return;
+		if (parent!=null ) {
+			if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast)) {
+				return;
+			}
 		}
 		/* create expression and link it with parent*/
 		Expression expression = new Expression(idGenerator.generateId());

23659135c34b9001b295def775ca28131d6a0944
@@ -40,6 +40,7 @@ public class DependencyType {
 	public static final String CREATE = "Create";
 	public static final String CAST = "Cast";
 	public static final String THROW = "Throw";
+	public static final String IMPLLINK = "ImplLink";
 	public static final String ANNOTATION = "Annotation";
 	public static final String MIXIN = "MixIn";
 	public static final String PomParent = "Parent";
@@ -64,6 +65,7 @@ public class DependencyType {
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
 		depedencyTypes.add(MIXIN);
+		depedencyTypes.add(IMPLLINK);
 		depedencyTypes.add(PomParent);
 		depedencyTypes.add(PomPlugin);
 		depedencyTypes.add(PomDependency);

731d2d7915c1cd8fa25f3744683167959fee21b1
@@ -74,8 +74,6 @@ public class DependsCommand {
 	private boolean detail = false;	
 	@Option(names = {"--auto-stub"},split=",", description = "create stub files for unsolved symbols (exprimental feature, only for java)")
 	private boolean autoStub = false;	
-	@Option(names = {"--call-as-impl"}, description = "(only for C/C++)convert the call relation to implementation instead of declaration")
-	private boolean callAsImpl = false;	
 	@Option(names = {"--type-filter"},split=",",  completionCandidates = DependsCommand.SupportedTypes.class, description = "only filter the listed dependency types[${COMPLETION-CANDIDATES}]")
     private String[] typeFilter=new String[]{};
 	@Option(names = {"--external-deps"}, description = "Output external dependencies")
@@ -151,9 +149,6 @@ public class DependsCommand {
 		}
 		return java.util.Arrays.asList(typeFilter);
 	}
-	public boolean isCallAsImpl() {
-		return callAsImpl;
-	}
 	public boolean isOutputExternalDependencies() {
 		return outputExternalDependencies;
 	}

b1bf37ebe644f4a625073ccf771a1417bdfd2805
@@ -85,10 +85,14 @@ public class Expression implements Serializable{
 		if (this.type==null && type!=null) {
 			this.type = type;
 			for (VarEntity var:deducedTypeVars) {
-				var.setType(this.type);
+				if (var!=null) {
+					var.setType(this.type);
+				}
 			}
 			for (FunctionEntity func:deducedTypeFunctions) {
-				func.addReturnType(this.type);
+				if (func!=null) {
+					func.addReturnType(this.type);
+				}
 			}
 			changedType = true;
 		}

8c02ab483a07fc0343f1359988fb2cdffa62481d
@@ -51,7 +51,7 @@ public abstract class Entity {
     ArrayList<Relation> relations;
 	private Entity actualReferTo = null;
 	private boolean inScope = true;
-	private HashMap<String, Entity> visibleNames = new HashMap<>();
+	protected HashMap<String, Entity> visibleNames = new HashMap<>();
 	public Entity() {};
     public Entity(GenericName rawName, Entity parent, Integer id) {
 		this.qualifiedName = null;

8fcd25200e5fdde5f09fd81f5aadd68c5bd16546
@@ -259,7 +259,7 @@ public abstract class HandlerContext {
 			container = currentFile();
 		}
 		
-		VarEntity var = getVar(container,GenericName.build(varName));
+		VarEntity var = getVarInLocalFile(container,GenericName.build(varName));
 		if (var!=null) return var;
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
 		container.addVar(var);
@@ -268,7 +268,20 @@ public abstract class HandlerContext {
 		return var;
 	}
 	
-
+	public VarEntity foundGlobalVarDefinition(ContainerEntity container,String varName) {
+		if (container==null) {
+			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
+			container = currentFile();
+		}
+		
+		VarEntity var = getVarInLocalFile(container,GenericName.build(varName));
+		if (var!=null) return var;
+		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
+		container.addVar(var);
+		var.setQualifiedName(var.getRawName().toString());
+		entityRepo.add(var);
+		return var;
+	}
 
 	public VarEntity foundVarDefinition(String varName, GenericName type, List<GenericName> typeArguments) {
 		VarEntity var = new VarEntity(GenericName.build(varName), type, lastContainer(), idGenerator.generateId());
@@ -303,9 +316,10 @@ public abstract class HandlerContext {
 			entityStack.pop();
 	}
 	
-	private VarEntity getVar(ContainerEntity container, GenericName varName) {
-		Entity entity = inferer.resolveName(container, varName, true); //TODO: should be check based on local/class/global
+	private VarEntity getVarInLocalFile(ContainerEntity container, GenericName varName) {
+		Entity entity = inferer.resolveName(container, varName, false); 
 		if (entity ==null ) return null;
+		if (!entity.getAncestorOfType(FileEntity.class).equals(currentFileEntity)) return null;
 		if (entity instanceof VarEntity) return (VarEntity)entity;
 		return null;
 	}

e2172ec78fc490f3d76b04559f7f219968a12e49
@@ -1,4 +1,4 @@
-package depends.extractor.python;
+package depends.extractor.python3;
 
 import java.util.List;
 

51debb5a1199aaabb5fd109bfc1d247e42f03027
@@ -1,28 +1,30 @@
-package depends.extractor.python3;
+package depends.extractor.python;
 
-import static depends.deptypes.DependencyType.*;
+import static depends.deptypes.DependencyType.ANNOTATION;
+import static depends.deptypes.DependencyType.CALL;
+import static depends.deptypes.DependencyType.CONTAIN;
+import static depends.deptypes.DependencyType.CREATE;
+import static depends.deptypes.DependencyType.IMPLLINK;
+import static depends.deptypes.DependencyType.IMPORT;
+import static depends.deptypes.DependencyType.INHERIT;
+import static depends.deptypes.DependencyType.PARAMETER;
+import static depends.deptypes.DependencyType.RETURN;
+import static depends.deptypes.DependencyType.SET;
+import static depends.deptypes.DependencyType.THROW;
+import static depends.deptypes.DependencyType.USE;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import depends.entity.repo.BuiltInType;
 import depends.extractor.AbstractLangProcessor;
-import depends.extractor.FileParser;
-import depends.extractor.ruby.IncludedFileLocator;
 import depends.relations.ImportLookupStrategy;
 
-public class PythonProcessor extends AbstractLangProcessor {
+public abstract class BasePythonProcessor extends AbstractLangProcessor{
 	private PythonImportLookupStrategy importedLookupStrategy;
 
-	public PythonProcessor() {
-		/* Because Python is dynamic languange, 
-		 * we eagerly resolve expression*/
-		super(true);
-	}
-
-	@Override
-	public String supportedLanguage() {
-		return "python3";
+	public BasePythonProcessor(boolean eagerExpressionResolve) {
+		super(eagerExpressionResolve);
 	}
 
 	@Override
@@ -41,12 +43,6 @@ public class PythonProcessor extends AbstractLangProcessor {
 	public BuiltInType getBuiltInType() {
 		return new PythonBuiltInType();
 	}
-	
-	@Override
-	protected FileParser createFileParser(String fileFullPath) {
-		IncludedFileLocator includeFileLocator = new IncludedFileLocator(super.includePaths());
-		return new PythonFileParser(fileFullPath,entityRepo,includeFileLocator,inferer,this);
-	}
 
 	@Override
 	public List<String> supportedRelations() {
@@ -71,5 +67,4 @@ public class PythonProcessor extends AbstractLangProcessor {
 		depedencyTypes.add(IMPLLINK);
 		return depedencyTypes;
 	}
-
 }

eac9dc83befbf79280f47caee604ffef16c9f60e
@@ -118,6 +118,9 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		expressionList().add(expression);
 	}
 
+	public boolean containsExpression(Object key) {
+		return 	expressions().containsKey(key);
+	}
 	/**
 	 * For all data in the class, infer their types. Should be override in
 	 * sub-classes
@@ -184,6 +187,17 @@ public abstract class ContainerEntity extends DecoratedEntity {
 			}
 			if (expression.getIdentifier() != null) {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
+				String composedName = expression.getIdentifier().toString();
+				Expression theExpr = expression;
+				if (entity.equals(Inferer.externalType)) {
+					while(theExpr.getParent()==null || !theExpr.isDot) {
+						theExpr = theExpr.getParent();
+						composedName = composedName + "." + theExpr.getIdentifier().toString();
+						entity = inferer.resolveName(this, GenericName.build(composedName), true);
+						if (entity!=null && !entity.equals(Inferer.externalType))
+							break;
+					}
+				}
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;
@@ -410,4 +424,6 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		if (resolvedMixins==null) return new ArrayList<>();
 		return resolvedMixins;
 	}
+
+
 }

94e17e471f95be840d54f9a2afcca564bcb8e45c
@@ -189,12 +189,12 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
-				if (entity.equals(Inferer.externalType)) {
-					while(theExpr.getParent()==null || !theExpr.isDot) {
+				if (Inferer.externalType.equals(entity)) {
+					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
 						theExpr = theExpr.getParent();
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
 						entity = inferer.resolveName(this, GenericName.build(composedName), true);
-						if (entity!=null && !entity.equals(Inferer.externalType))
+						if (entity!=null && !Inferer.externalType.equals(entity))
 							break;
 					}
 				}

ce4dfcf89ec34b0d1e60ca9965a7721f56f5260d
@@ -73,7 +73,6 @@ public class ExpressionUsage {
 		}
 		if (context.lastContainer().containsExpression(ctx)) return;
 		if (ctx.getParent() instanceof TrailerContext) return;
-		System.out.println("expr: "+ctx.getText() + " class:" + ctx.getClass().getSimpleName());
 		
 		Expression parent = findParentInStack(ctx);
 		Expression expression = parent;
@@ -122,7 +121,7 @@ public class ExpressionUsage {
 
 
 	private void makeSureVarExist(GenericName identifier) {
-		if (context.foundEntityWithName(identifier).equals(Inferer.externalType)) {
+		if (Inferer.externalType.equals(context.foundEntityWithName(identifier))) {
 			context.foundVarDefinition(context.lastContainer(), identifier.getName());
 		}
 	}

e504d18f1cb1d41e6f1f45efe88ea2c7a2fe56c9
@@ -10,7 +10,6 @@ import org.antlr.v4.runtime.ParserRuleContext;
 import depends.entity.ContainerEntity;
 import depends.entity.DecoratedEntity;
 import depends.entity.Entity;
-import depends.entity.Expression;
 import depends.entity.FileEntity;
 import depends.entity.FunctionEntity;
 import depends.entity.GenericName;
@@ -30,7 +29,6 @@ import depends.extractor.python.PythonParser.Def_parametersContext;
 import depends.extractor.python.PythonParser.Del_stmtContext;
 import depends.extractor.python.PythonParser.Dotted_as_nameContext;
 import depends.extractor.python.PythonParser.Dotted_nameContext;
-import depends.extractor.python.PythonParser.ExprContext;
 import depends.extractor.python.PythonParser.Expr_stmtContext;
 import depends.extractor.python.PythonParser.From_stmtContext;
 import depends.extractor.python.PythonParser.FuncdefContext;

c24f6b17802322567780d18437f5472833600077
@@ -1,190 +0,0 @@
-package depends.extractor.python.py3;
-
-import java.util.List;
-
-import org.antlr.v4.runtime.ParserRuleContext;
-
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.Expression;
-import depends.entity.FunctionEntity;
-import depends.entity.GenericName;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
-import depends.entity.repo.IdGenerator;
-import depends.extractor.python.PythonHandlerContext;
-import depends.extractor.python.Python3Parser.AtomContext;
-import depends.extractor.python.Python3Parser.Atom_exprContext;
-import depends.extractor.python.Python3Parser.Expr_stmtContext;
-import depends.extractor.python.Python3Parser.Raise_stmtContext;
-import depends.extractor.python.Python3Parser.Return_stmtContext;
-import depends.extractor.python.Python3Parser.SuiteContext;
-import depends.extractor.python.Python3Parser.TestContext;
-import depends.relations.Inferer;
-
-public class ExpressionUsage {
-	IdGenerator idGenerator;
-	Inferer inferer;
-	private PythonHandlerContext context;
-	private PythonParserHelper helper;
-
-	public ExpressionUsage(PythonHandlerContext context, IdGenerator idGenerator, PythonParserHelper helper,
-			Inferer inferer) {
-		this.context = context;
-		this.idGenerator = idGenerator;
-		this.inferer = inferer;
-		this.helper = helper;
-	}
-
-	public Expression foundExpression(ParserRuleContext ctx) {
-		if (!context.lastContainer().containsExpression()) {
-			if (!isStartOfContainerRule(ctx)) {
-				return null;
-			}
-		}
-		Expression expression = findExpression(ctx);
-		if (expression != null)
-			return expression;
-		Expression parent = findParentInStack(ctx);
-		/* create expression and link it with parent */
-		expression = new Expression(idGenerator.generateId());
-		expression.text = ctx.getText();
-		expression.setParent(parent);
-
-		context.lastContainer().addExpression(ctx, expression);
-		if (ctx instanceof AtomContext) {
-			AtomContext atom = (AtomContext) ctx;
-			if (atom.NUMBER() != null || atom.STRING() != null && atom.STRING().size() > 0) {
-				expression.setIdentifier("<literal>");
-				expression.setRawType(Inferer.buildInType.getQualifiedName());
-			} else if (atom.getText().equals("True") || atom.getText().equals("False")) {
-				expression.setIdentifier("<boolean>");
-				expression.setRawType(Inferer.buildInType.getQualifiedName());
-			} else if (atom.getText().equals("None")) {
-				expression.setIdentifier("<null>");
-				expression.setRawType(Inferer.buildInType.getQualifiedName());
-			} else if (atom.NAME() != null) {
-				expression.setIdentifier(atom.NAME().getText());
-			}
-		}
-
-		if (ctx instanceof Expr_stmtContext) {
-			Expr_stmtContext expr = ((Expr_stmtContext) ctx);
-			if ((expr.expr_stmt_rhs() != null) || (expr.augassign() != null) || (expr.annassign() != null)) {
-				expression.isSet = true;
-			}
-		} else if (ctx instanceof Atom_exprContext) {
-			Atom_exprContext expr = ((Atom_exprContext) ctx);
-			if (expr.func_call() != null) {
-				// TODO: should be refined later. Currently only a.b.c could be solved.
-				expression.setIdentifier(expr.atom_expr().getText());
-				String callPrefix = expr.atom_expr().getText();
-				// call with variables
-				if (callPrefix.contains(".")) {
-					int pos = callPrefix.lastIndexOf('.');
-					GenericName functionName = GenericName.build(callPrefix.substring(pos + 1));
-					GenericName preFix = GenericName.build(callPrefix.substring(0, pos));
-					Entity prefixEntity = context.foundEntityWithName(preFix);
-					if (prefixEntity instanceof VarEntity) {
-						((VarEntity) prefixEntity).addFunctionCall(functionName);
-						expression.setCall(true);
-					}
-				}
-				if (!expression.isCall()) {
-					Entity typeEntity = context.foundEntityWithName(expression.getIdentifier());
-					if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {
-						expression.isCreate = true;
-					} else {
-						expression.setCall(true);
-					}
-				}
-			} else if (expr.member_access() != null) {
-				expression.isDot = true;
-				expression.setIdentifier(expr.member_access().NAME().getText());
-			}
-			// TODO: member access in python should be handled seperately. they could be
-			// different types;
-		} else if (ctx instanceof Return_stmtContext) {
-			deduceReturnTypeInCaseOfReturn(ctx, expression);
-		} else if (ctx instanceof Raise_stmtContext) {
-			expression.isThrow = true;
-			expression.deriveTypeFromChild = true;
-		}
-		deduceVarTypeInCaseOfAssignment(ctx, expression);
-		return expression;
-	}
-
-	/**
-	 * To judge whether is an 'real' expression
-	 * 
-	 * @param ctx
-	 * @return
-	 */
-	private boolean isStartOfContainerRule(ParserRuleContext ctx) {
-		return ctx instanceof SuiteContext || ctx instanceof TestContext || ctx instanceof Expr_stmtContext;
-	}
-
-	/**
-	 * Auto deduce variable type from assignment. for example: c = C.new then c is
-	 * type of C
-	 * 
-	 * @param node
-	 * @param expression
-	 */
-	private void deduceVarTypeInCaseOfAssignment(ParserRuleContext node, Expression expression) {
-		ParserRuleContext parentNode = node.getParent();
-		if (parentNode instanceof Expr_stmtContext) {
-			Expr_stmtContext expr = (Expr_stmtContext) parentNode;
-			if (expr.expr_stmt_rhs() != null) {
-				ContainerEntity scope = helper.getScopeOfVar(expr, this.context);
-				if (scope == null)
-					return;
-				String varName = null;
-				// TODO: should handle list properly;
-				List<String> names = helper.getName(expr.testlist_star_expr());
-				if (names.size() == 1)
-					varName = names.get(0);
-				if (varName == null)
-					return;
-				VarEntity var = scope.lookupVarLocally(varName);
-				if (var != null) {
-					expression.addDeducedTypeVar(var);
-				}
-			}
-		}
-	}
-
-	private void deduceReturnTypeInCaseOfReturn(ParserRuleContext ctx, Expression expression) {
-		FunctionEntity currentFunction = context.currentFunction();
-		if (currentFunction == null)
-			return;
-		if (ctx instanceof Return_stmtContext) {
-			expression.addDeducedTypeFunction(currentFunction);
-		}
-	}
-
-	private Expression findParentInStack(ParserRuleContext ctx) {
-		if (ctx == null)
-			return null;
-		if (ctx.getParent() == null)
-			return null;
-		if (context.lastContainer() == null) {
-			return null;
-		}
-		if (context.lastContainer().expressions().containsKey(ctx.getParent()))
-			return context.lastContainer().expressions().get(ctx.getParent());
-		return findParentInStack(ctx.getParent());
-	}
-
-	private Expression findExpression(ParserRuleContext ctx) {
-		if (ctx == null)
-			return null;
-		if (ctx.getParent() == null)
-			return null;
-		if (context.lastContainer() == null) {
-			return null;
-		}
-		return context.lastContainer().expressions().get(ctx);
-	}
-
-}

25621c7d3bae58acff680df84e531342298af290
@@ -7,7 +7,6 @@ import org.junit.Test;
 
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
-import depends.extractor.python.py3.Python3FileParser;
 import depends.extractor.python.union.PythonFileParser;
 
 public class PythonGlobalVarTest extends PythonParserTest {

f7bf745c444f56faa5c735f25e4dfa35e6f454c6
@@ -192,6 +192,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				if (Inferer.externalType.equals(entity)) {
 					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
 						theExpr = theExpr.getParent();
+						if (theExpr.getIdentifier()==null) break;
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
 						entity = inferer.resolveName(this, GenericName.build(composedName), true);
 						if (entity!=null && !Inferer.externalType.equals(entity))

aa5645c0ccabb49690ceefd560a28febf0f39879
@@ -1,9 +1,90 @@
 package depends.extractor.python;
 
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import depends.entity.FileEntity;
+import depends.entity.FunctionCall;
+import depends.entity.FunctionEntity;
+import depends.entity.GenericName;
+import depends.entity.TypeEntity;
 import depends.entity.repo.BuiltInType;
+import depends.relations.FunctionMatcher;
 
 public class PythonBuiltInType extends BuiltInType {
 
+	public static String[] BUILT_IN_FUNCTIONS = { "abs", "delattr", "hash", "memoryview", "set", "all", "dict", "help",
+			"min", "setattr", "any", "dir", "hex", "next", "slice", "exit", "ascii", "divmod", "id", "object", "sorted",
+			"bin", "enumerate", "input", "oct", "staticmethod", "bool", "eval", "int", "open", "str", "breakpoint",
+			"exec", "isinstance", "ord", "sum", "bytearray", "filter", "issubclass", "pow", "super", "bytes", "float",
+			"iter", "print", "tuple", "callable", "format", "len", "property", "type", "chr", "frozenset", "list",
+			"range", "vars", "classmethod", "getattr", "locals", "repr", "zip", "compile", "globals", "map", "reversed",
+			"__import__", "complex", "hasattr", "max", "round" };
+
+	/**
+	 * methods of built-in String
+	 */
+	public static String[] BUILT_IN_STRING_METHODS = { "capitalize", "center", "casefold", "count", "endswith",
+			"expandtabs", "encode", "find", "format", "index", "isalnum", "isalpha", "isdecimal", "isdigit",
+			"isidentifier", "islower", "isnumeric", "isprintable", "isspace", "istitle", "isupper", "join", "ljust",
+			"rjust", "lower", "upper", "swapcase", "lstrip", "rstrip", "strip", "partition", "maketrans", "rpartition",
+			"translate", "replace", "rfind", "rindex", "split", "rsplit", "splitlines", "startswith", "title", "zfill",
+			"format_map" };
+
+	/**
+	 * methods of built-in List
+	 */
+	public static String[] BUILT_IN_LIST_METHODS = { "index", "append", "extend", "insert", "remove", "count", "pop",
+			"reverse", "sort", "copy", "clear" };
+
+	/**
+	 * methods of built-in Tuple
+	 */
+	public static String[] BUILT_IN_TUPLE_METHODS = { "index", "count" };
+
+	/**
+	 * methods of built-in Dict
+	 */
+	public static String[] BUILT_IN_DICT_METHODS = { "clear", "copy", "fromkeys", "get", "items", "keys", "popitem",
+			"setdefault", "pop", "values", "update", };
+
+	/**
+	 * methods of built-in Set
+	 */
+	public static String[] BUILT_IN_SET_METHODS = { "remove", "add", "copy", "clear", "difference", "difference_update",
+			"discard", "intersection", "intersection_update", "isdisjoint", "issubset", "pop", "symmetric_difference",
+			"symmetric_difference_update", "union", "update" };
+
+	/**
+	 * methods of built-in File
+	 */
+	public static String[] BUILT_IN_FILE_METHOD = { "close", "flush", "fileno", "isatty", "next", "read", "readline",
+			"readlines", "seek", "tell", "truncate", "write", "writelines" };
+	
+	List<TypeEntity> buildInTypes = new ArrayList<>();
+	
+
+	
+	public PythonBuiltInType() {
+		addBuildInType(BUILT_IN_FILE_METHOD);
+		addBuildInType(BUILT_IN_SET_METHODS);
+		addBuildInType(BUILT_IN_DICT_METHODS);
+		addBuildInType(BUILT_IN_TUPLE_METHODS);
+		addBuildInType(BUILT_IN_LIST_METHODS);
+		addBuildInType(BUILT_IN_STRING_METHODS);
+	}
+	
+	private void addBuildInType(String[] methods) {
+		TypeEntity type  = new TypeEntity();
+		for (String method:methods) {
+			FunctionEntity func = new FunctionEntity(GenericName.build(method),type,-1,GenericName.build(""));
+			type.addFunction(func);
+		}
+		buildInTypes.add(type);
+	}
+
 	@Override
 	public String[] getBuiltInMethods() {
 		// TODO Auto-generated method stub
@@ -21,5 +102,17 @@ public class PythonBuiltInType extends BuiltInType {
 		// TODO Auto-generated method stub
 		return null;
 	}
+	
+	
+	@Override
+	public  boolean isBuildInTypeMethods(List<FunctionCall> functionCalls) {
+		for (TypeEntity type:buildInTypes) {
+			FunctionMatcher functionMatcher = new FunctionMatcher(type.getFunctions());
+			if (functionMatcher.containsAll(functionCalls)) {
+				return true;
+			}
+		}
+		return false;
+	}
 
 }

d6a63dd737fca5ed5dc9b981ae1b48572726cf76
@@ -171,6 +171,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 						}
 					}
 				}
+				if (FileUtil.existFile(fullName+File.separator + "__init__.py")) {
+					fullName = fullName+File.separator +"__init__.py";
+				}
 			} else {
 				visitIncludedFile(fullName);
 			}

111602a07eff0a56d928a74b606a5742d5a9af18
@@ -127,7 +127,7 @@ public class ExpressionUsage {
 	}
 
 	private boolean isValidIdentifier(GenericName identifier) {
-		Pattern p = Pattern.compile("[a-z_][a-z0-9_]*");
+		Pattern p = Pattern.compile("[a-zA-Z_][a-zA-Z0-9_]*");
 		Matcher m = p.matcher(identifier.getName());
 		return m.find();
 	}

6db3940df1f48a50892d659696d613a7d3763ea0
@@ -82,8 +82,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 			if (dotted_as_name.name()!=null) {
 				aliasName = dotted_as_name.name().getText();
 			}
-			String fullName = foundImportedModuleOrPackage(0,moduleName);
-			if (fullName!=null) {
+			List<String> fullNames = foundImportedModuleOrPackage(0,moduleName);
+			 
+			for (String fullName:fullNames) {
 				context.foundNewImport(new NameAliasImport(fullName, entityRepo.getEntity(fullName), aliasName));
 			}
 		}
@@ -97,16 +98,13 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		int prefixDotCount = getDotCounter(ctx);
 
-		String fullName = foundImportedModuleOrPackage(prefixDotCount, moduleName);
-		if (fullName != null) {
+		 List<String> fullNames = foundImportedModuleOrPackage(prefixDotCount, moduleName);
+		for (String fullName:fullNames) {
 			if (ctx.import_as_names() == null) {// import *
 				ContainerEntity moduleEntity = (ContainerEntity) (entityRepo.getEntity(fullName));
 				if (moduleEntity != null) {
-					for (FunctionEntity func : moduleEntity.getFunctions()) {
-						context.foundNewImport(new NameAliasImport(fullName, func, func.getRawName().uniqName()));
-					}
-					for (VarEntity var : moduleEntity.getVars()) {
-						context.foundNewImport(new NameAliasImport(fullName, var, var.getRawName().uniqName()));
+					for (Entity child:moduleEntity.getChildren()) {
+						context.foundNewImport(new NameAliasImport(fullName, child, child.getRawName().uniqName()));
 					}
 					if (moduleEntity instanceof PackageEntity) {
 						for (Entity file : moduleEntity.getChildren()) {
@@ -114,6 +112,10 @@ public class PythonCodeListener extends PythonParserBaseListener{
 							context.foundNewImport(new NameAliasImport(file.getRawName().uniqName(), file, fileName));
 						}
 					}
+					if (moduleEntity instanceof FileEntity) {
+						String fileName = moduleEntity.getRawName().uniqName().substring(fullName.length());
+						context.foundNewImport(new NameAliasImport(moduleEntity.getRawName().uniqName(), moduleEntity, fileName));
+					}
 				}
 			} else {
 				for (Import_as_nameContext item : ctx.import_as_names().import_as_name()) {
@@ -141,7 +143,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		return total;
 	}
-	private String foundImportedModuleOrPackage(int prefixDotCount, String originalName) {
+	private List<String> foundImportedModuleOrPackage(int prefixDotCount, String originalName) {
 		String dir = FileUtil.getLocatedDir(context.currentFile().getRawName().uniqName());
 		String preFix = "";
 		for (int i = 0; i < prefixDotCount - 1; i++) {
@@ -171,14 +173,17 @@ public class PythonCodeListener extends PythonParserBaseListener{
 						}
 					}
 				}
-				if (FileUtil.existFile(fullName+File.separator + "__init__.py")) {
-					fullName = fullName+File.separator +"__init__.py";
-				}
 			} else {
 				visitIncludedFile(fullName);
 			}
 		}
-		return fullName;
+		ArrayList<String> r = new ArrayList<>();
+		if (fullName==null) return r;
+		r.add(fullName);
+		if (FileUtil.existFile(fullName+File.separator + "__init__.py")) {
+			r.add( fullName+File.separator +"__init__.py");
+		}
+		return r;
 	}
 
 	private void visitIncludedFile(String fullName) {

bd85ee5b8f053acc98d47772a628169e2826dcf2
@@ -41,6 +41,7 @@ import depends.extractor.python.PythonParser.Return_stmtContext;
 import depends.extractor.python.PythonParser.Yield_stmtContext;
 import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.ruby.IncludedFileLocator;
+import depends.importtypes.FileImport;
 import depends.relations.Inferer;
 import depends.util.FileUtil;
 
@@ -85,6 +86,9 @@ public class PythonCodeListener extends PythonParserBaseListener{
 			List<String> fullNames = foundImportedModuleOrPackage(0,moduleName);
 			 
 			for (String fullName:fullNames) {
+				if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
+					context.foundNewImport(new FileImport(fullName));
+				}
 				context.foundNewImport(new NameAliasImport(fullName, entityRepo.getEntity(fullName), aliasName));
 			}
 		}
@@ -100,6 +104,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 
 		 List<String> fullNames = foundImportedModuleOrPackage(prefixDotCount, moduleName);
 		for (String fullName:fullNames) {
+
 			if (ctx.import_as_names() == null) {// import *
 				ContainerEntity moduleEntity = (ContainerEntity) (entityRepo.getEntity(fullName));
 				if (moduleEntity != null) {
@@ -123,6 +128,15 @@ public class PythonCodeListener extends PythonParserBaseListener{
 					String alias = name;
 					if (item.name().size() > 1)
 						alias = item.name(1).getText();
+					if (FileUtil.isDirectory(fullName)) {
+						String fileName = fullName + File.separator + name + ".py";
+						if (FileUtil.existFile(fileName) && !(FileUtil.isDirectory(fileName))) {
+							context.foundNewImport(new FileImport(fileName));
+						}
+					}
+					if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
+						context.foundNewImport(new FileImport(fullName));
+					}
 					Entity itemEntity = inferer.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
 					if (itemEntity != null)
 						context.foundNewImport(new NameAliasImport(itemEntity.getQualifiedName(), itemEntity, alias));

d8ce71ac612c191c9873616f114bde4e6eb65676
@@ -90,7 +90,7 @@ public class VarEntity extends ContainerEntity {
 	}
 
 	public void fillCandidateTypes(Inferer inferer) {
-		if (type!=null) return ; //it is a strong type lang, do not need deduce candidate types
+		if (type!=null && !(type instanceof CandidateTypes)) return ; //it is a strong type lang, do not need deduce candidate types
 		if (functionCalls==null) return;
 		if (functionCalls.size()==0) return; //no information avaliable for type deduction
 		if (this.rawType==null) {

49853810888a31a9875c3468cbb8349a9acd7b43
@@ -189,16 +189,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
-				if (Inferer.externalType.equals(entity)) {
-					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
-						theExpr = theExpr.getParent();
-						if (theExpr.getIdentifier()==null) break;
-						composedName = composedName + "." + theExpr.getIdentifier().toString();
-						entity = inferer.resolveName(this, GenericName.build(composedName), true);
-						if (entity!=null && !Inferer.externalType.equals(entity))
-							break;
-					}
-				}
+
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;

e662d5c286f501528291567d30409219a749b38c
@@ -189,7 +189,16 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;
-
+				if (entity==null) {
+					while(theExpr.getParent()!=null && theExpr.getParent().isDot) {
+						theExpr = theExpr.getParent();
+						if (theExpr.getIdentifier()==null) break;
+						composedName = composedName + "." + theExpr.getIdentifier().toString();
+						entity = inferer.resolveName(this, GenericName.build(composedName), true);
+						if (entity!=null && !Inferer.externalType.equals(entity))
+							break;
+					}
+				}
 				if (entity != null) {
 					expression.setType(entity.getType(), entity, inferer);
 					continue;

6617b2a77d05c8b9d48b723b3fe825e5deb56562
@@ -195,7 +195,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 						if (theExpr.getIdentifier()==null) break;
 						composedName = composedName + "." + theExpr.getIdentifier().toString();
 						entity = inferer.resolveName(this, GenericName.build(composedName), true);
-						if (entity!=null && !Inferer.externalType.equals(entity))
+						if (entity!=null)
 							break;
 					}
 				}

e3de22671c616d9a860d4d68414fc9a15b9e0906
@@ -6,6 +6,7 @@ import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 
+import depends.deptypes.DependencyType;
 import depends.extractor.cpp.cdt.CdtCppFileParser;
 
 public class ContainRelationTest extends CppParserTest{
@@ -55,7 +56,7 @@ public class ContainRelationTest extends CppParserTest{
 		    parser.parse();
 	    }
 	    inferer.resolveAllBindings();
-        assertEquals(2,repo.getEntity("UnderTest").getRelations().size());
+	    this.assertContainsRelation(repo.getEntity("UnderTest"), DependencyType.CONTAIN, "Member");
 	}
 	
 	

a778caf06c8c15c134f22780a1cfc25a6e135b2c
@@ -167,11 +167,6 @@ public class CandidateTypes extends TypeEntity {
 		super.resolveExpressions(inferer);
 	}
 
-	@Override
-	public TypeEntity getLastExpressionType() {
-		System.err.println("error: getLastExpressionType should not been invoked");
-		return super.getLastExpressionType();
-	}
 
 	@Override
 	public void addMixin(GenericName moduleName) {

54eb077aa9029c8f7f796f40f5ef938c993009f1
@@ -78,6 +78,8 @@ public class DependsCommand {
     private String[] typeFilter=new String[]{};
 	@Option(names = {"--external-deps"}, description = "Output external dependencies")
 	private boolean outputExternalDependencies = false;	
+	@Option(names = {"--duck-typing-deduce"}, description = "Deduce implicit variable types")
+	private boolean duckTypingDeduce = true;	
 	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
@@ -152,4 +154,8 @@ public class DependsCommand {
 	public boolean isOutputExternalDependencies() {
 		return outputExternalDependencies;
 	}
+	
+	public boolean isDuckTypingDeduce() {
+		return this.duckTypingDeduce;
+	}
 }

e58135b89f09d83d669d0926c80eca84d027fbc0
@@ -176,9 +176,6 @@ public class Expression implements Serializable{
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {
 			if (parent.isCall()) {
-				if (parent.getIdentifier().getName().equals("C")) {
-					System.out.println("hh");
-				}
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 				if (funcs!=null) {
 					Entity func = funcs.get(0);

5b800185d7d2460da094640c66198cb100ceba46
@@ -27,6 +27,7 @@ package depends.entity;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.stream.Collectors;
 
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
@@ -178,18 +179,21 @@ public class Expression implements Serializable{
 			if (parent.isCall()) {
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
 				if (funcs!=null) {
-					Entity func = funcs.get(0);
-					if (funcs.size()>1) {
-						MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
-						inferer.getRepo().add(m);
-						for (int i=1;i<funcs.size();i++) {
-							m.add(funcs.get(i));
+					//funcs = funcs.stream().filter(item->!(item instanceof MultiDeclareEntities)).collect(Collectors.toList());
+					if (funcs.size()>0) {
+						Entity func = funcs.get(0);
+						if (funcs.size()>1) {
+							MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
+							inferer.getRepo().add(m);
+							for (int i=1;i<funcs.size();i++) {
+								m.add(funcs.get(i));
+							}
+							parent.setType(func.getType(), m,inferer);
+							parent.setReferredEntity(m);
+						}else {
+							parent.setType(func.getType(), func,inferer);
+							parent.setReferredEntity(func);
 						}
-						parent.setType(func.getType(), m,inferer);
-						parent.setReferredEntity(m);
-					}else {
-						parent.setType(func.getType(), func,inferer);
-						parent.setReferredEntity(func);
 					}
 				}
 			}else {
@@ -202,7 +206,9 @@ public class Expression implements Serializable{
 					if (funcs!=null) {
 						Entity func = funcs.get(0);
 						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, -1);
+							MultiDeclareEntities m = new MultiDeclareEntities(func, inferer.getRepo().generateId());
+							inferer.getRepo().add(m);
+
 							for (int i=1;i<funcs.size();i++) {
 								m.add(funcs.get(i));
 							}
@@ -229,8 +235,9 @@ public class Expression implements Serializable{
 
 	private void setReferredEntity(Entity referredEntity) {
 		this.referredEntity = referredEntity;
-		if (this.referredEntity!=null)
+		if (this.referredEntity!=null) {
 			this.referredEntityId = referredEntity.getId();
+		}
 	}
 
 	public void addDeducedTypeVar(VarEntity var) {

a00a168fc7c1852dd729c9869bdf8e60e6259234
@@ -26,7 +26,9 @@ package depends.entity;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import depends.relations.Inferer;
 
@@ -171,6 +173,20 @@ public class AliasEntity extends Entity {
 	public void setReferToEntity(Entity referToEntity) {
 		this.referToEntity = referToEntity;
 	}
+	public Entity getReferToEntityTillNoAlias() {
+		Set<Entity> searched = new HashSet<>();
+		int i=0;
+		Entity current = this;
+		while(i<100) { //maximum 100 levels
+			if (searched.contains(current)) return current; //with a loop
+			if (!(current instanceof AliasEntity)) return current;
+			searched.add(current);
+			current = ((AliasEntity)current).getReferToEntity();
+			if (current ==null) return this;
+			i++;
+		}
+		return current;
+	}
 	
 
 }

ca8e0b048569fadcb8e4d3aed08b5922f1e1c7f2
@@ -36,6 +36,7 @@ public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
 	private GenericName originName;
 	private List<Entity> referPath = new ArrayList<>();
+	private boolean deepResolve = false;
 	public AliasEntity() {
 		
 	}
@@ -173,20 +174,34 @@ public class AliasEntity extends Entity {
 	public void setReferToEntity(Entity referToEntity) {
 		this.referToEntity = referToEntity;
 	}
-	public Entity getReferToEntityTillNoAlias() {
+	public Entity deepResolve() {
+		if (!deepResolve) return this;
 		Set<Entity> searched = new HashSet<>();
 		int i=0;
 		Entity current = this;
 		while(i<100) { //maximum 100 levels
-			if (searched.contains(current)) return current; //with a loop
+			if (searched.contains(current)) return current; //avoid a loop
 			if (!(current instanceof AliasEntity)) return current;
+			
 			searched.add(current);
+			Entity originalFile = current.getAncestorOfType(FileEntity.class);
 			current = ((AliasEntity)current).getReferToEntity();
+			
 			if (current ==null) return this;
+			//if already out of current file, return current
+			if (!current.getAncestorOfType(FileEntity.class).equals(originalFile)) {
+				return current;
+			}
 			i++;
 		}
 		return current;
 	}
+	public boolean isDeepResolve() {
+		return deepResolve;
+	}
+	public void setDeepResolve(boolean deepResolve) {
+		this.deepResolve = deepResolve;
+	}
 	
 
 }

2ca9e1d9c9f0319ab864d166753bdb913e847cd8
@@ -179,6 +179,8 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		
 		if (expressionList==null) return;
 		if(expressionList.size()>10000) return;
+		
+		
 		for (Expression expression : expressionList) {
 			// 1. if expression's type existed, break;
 			if (expression.getType() != null)
@@ -198,6 +200,13 @@ public abstract class ContainerEntity extends DecoratedEntity {
 				}
 			}
 			if (expression.getIdentifier() != null) {
+
+//				if (this.getAncestorOfType(FileEntity.class).getRawName().contains("/examples/usersession/server.py") &&
+//						expression.getIdentifier().contains("config")) {
+//					System.out.print("dd");
+//				}
+				
+				
 				Entity entity = inferer.resolveName(this, expression.getIdentifier(), true);
 				String composedName = expression.getIdentifier().toString();
 				Expression theExpr = expression;

ae520072222fef1d0fcb05033fadc0e852d8c30d
@@ -40,7 +40,7 @@ import org.slf4j.LoggerFactory;
 
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
-import depends.util.TemporaryFile;
+import multilang.depends.util.file.TemporaryFile;
 
 /**
  * ContainerEntity for example file, class, method, etc. they could contain

5dd681fdea3e82cbb649ad6e4762ab71e73a2053
@@ -23,16 +23,7 @@ SOFTWARE.
 */
 
 package depends.extractor.cpp.cdt;
-import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;
-import org.eclipse.cdt.core.dom.ast.IASTCastExpression;
-import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
-import org.eclipse.cdt.core.dom.ast.IASTExpression;
-import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;
-import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
-import org.eclipse.cdt.core.dom.ast.IASTNode;
-import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;
-import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;
+import org.eclipse.cdt.core.dom.ast.*;
 import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;
 
 import depends.entity.Expression;
@@ -75,7 +66,6 @@ public class ExpressionUsage {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);
 			return;
 		}
-		
 		expression.setSet(isSet(ctx));
 		expression.setCall((ctx instanceof IASTFunctionCallExpression)?true:false);
 		expression.setLogic(isLogic(ctx));
@@ -108,15 +98,16 @@ public class ExpressionUsage {
 			expression.disableDriveTypeFromChild();
 
 		}
-		if (expression.isDot()) {
-			IASTExpression op2 = ((IASTBinaryExpression)ctx).getOperand2();
-			if (op2 instanceof IASTIdExpression)
-				expression.setIdentifier(ASTStringUtilExt.getName(((IASTIdExpression)op2).getName()));
-			else if (op2 instanceof IASTLiteralExpression)
-				expression.setIdentifier(ASTStringUtilExt.getName((IASTLiteralExpression)op2));
-			else if (op2 instanceof IASTFunctionCallExpression)
-				expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression)op2));
-			return;
+		if (expression.isDot() ) {
+			if (ctx instanceof  IASTBinaryExpression) {
+				IASTExpression op2 = ((IASTBinaryExpression) ctx).getOperand2();
+				if (op2 instanceof IASTIdExpression)
+					expression.setIdentifier(ASTStringUtilExt.getName(((IASTIdExpression) op2).getName()));
+				else if (op2 instanceof IASTLiteralExpression)
+					expression.setIdentifier(ASTStringUtilExt.getName((IASTLiteralExpression) op2));
+				else if (op2 instanceof IASTFunctionCallExpression)
+					expression.setIdentifier(getMethodCallIdentifier((IASTFunctionCallExpression) op2));
+			}
 		}		
 	}
 
@@ -149,6 +140,10 @@ public class ExpressionUsage {
 		if (f instanceof IASTIdExpression) {
 			return GenericName.build(ASTStringUtilExt.getName(((IASTIdExpression)f).getName()));
 		}
+		if (f instanceof  IASTFieldReference){
+			IASTFieldReference func = (IASTFieldReference) f;
+			return GenericName.build(ASTStringUtilExt.getName(func.getFieldName()));
+		}
 		return null;
 	}
 
@@ -158,6 +153,12 @@ public class ExpressionUsage {
 			if (op==IASTBinaryExpression.op_pmdot ||
 					op==IASTBinaryExpression.op_pmarrow	) return true;
 		}
+		if (ctx instanceof  IASTFunctionCallExpression){
+			if (ctx.getChildren().length>0){
+				if (ctx.getChildren()[0] instanceof IASTFieldReference)
+					return true;
+			}
+		}
 		return false;
 	}
 	

97edd75c00417bc6f661d7b91fd9a4032295cf4a
@@ -49,30 +49,28 @@ public class ExpressionUsage {
 	
 	public void foundExpression(IASTExpression ctx) {
 		Expression parent = findParentInStack(ctx);
-		//If parent already a call 
-		if (parent!=null ) {
-			if (ctx instanceof IASTIdExpression && (parent.isCall() || parent.isCast())) {
-				return;
-			}
+		Expression expression = null;
+		if (parent!=null && ctx.getParent()!=null && (ctx.getParent().getChildren().length==1)){
+			expression = parent;
+		}else {
+			/* create expression and link it with parent*/
+			expression = new Expression(idGenerator.generateId());
+			expression.setText(ctx.getRawSignature());
+			context.lastContainer().addExpression(ctx, expression);
+			expression.setParent(parent);
 		}
-		/* create expression and link it with parent*/
-		Expression expression = new Expression(idGenerator.generateId());
-		expression.setText( ctx.getRawSignature());
-		context.lastContainer().addExpression(ctx,expression);
-		expression.setParent(parent);
-	
 		
 		if (isTerminalExpression(ctx)) {
 			tryFillExpressionTypeAndIdentifier(ctx,expression);
 			return;
 		}
-		expression.setSet(isSet(ctx));
-		expression.setCall((ctx instanceof IASTFunctionCallExpression)?true:false);
-		expression.setLogic(isLogic(ctx));
+		expression.setSet(expression.isSet() || isSet(ctx));
+		expression.setCall(expression.isCall() || (ctx instanceof IASTFunctionCallExpression)?true:false);
+		expression.setLogic(expression.isLogic() || isLogic(ctx));
 		if (ctx instanceof ICPPASTNewExpression){
 			expression.setCreate(true);;
 		}		
-		expression.setDot(isDot(ctx));
+		expression.setDot(expression.isDot() || isDot(ctx));
 
 		/**
  *    | expression bop='.'

98bf537cced18c2409a2a807d30470997be2a523
@@ -0,0 +1,47 @@
+package depends.extractor.cpp;
+
+import depends.entity.Entity;
+import depends.entity.FunctionEntityImpl;
+import depends.entity.FunctionEntityProto;
+import depends.relations.Relation;
+import multilang.depends.util.file.FileUtil;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
+
+public class RelationInSameFileTest extends CppParserTest{
+    @Before
+    public void setUp() {
+    	super.init();
+    }
+	
+	@Test
+	public void should_convert_call_relation_to_impl() throws IOException {
+		String[] srcs = new String[] {
+	    		"./src/test/resources/cpp-code-examples/relation_in_samefile/A.c",
+				"./src/test/resources/cpp-code-examples/relation_in_samefile/B.c"
+	    	    };
+	    
+	    for (String src:srcs) {
+		    CppFileParser parser = createParser(src);
+		    parser.parse();
+	    }
+	    inferer.resolveAllBindings(true,null);
+	    Entity bar = repo.getEntity(FileUtil.uniqFilePath(srcs[0]));
+	    int matchCount = 0;
+	    for (Relation relation:bar.getRelations()) {
+	    	if (relation.getEntity() instanceof FunctionEntityProto) {
+	    		matchCount++;
+	    	}
+	    	if (relation.getEntity() instanceof FunctionEntityImpl) {
+	    		matchCount++;
+	    	}
+	    }
+	    assertEquals(2, matchCount);
+	}
+	
+
+}

e8f45fc3c5da985fd82175687b6e9faffb6fadf2
@@ -24,16 +24,11 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Set;
-
-
 import depends.relations.Inferer;
 import depends.relations.Relation;
 
+import java.util.*;
+
 /**
  * Entity is the root of all entities, including file, package, module, 
  * class, method/function etc.
@@ -52,6 +47,7 @@ public abstract class Entity {
 	private Entity actualReferTo = null;
 	private boolean inScope = true;
 	protected HashMap<String, Entity> visibleNames = new HashMap<>();
+	private Location location = new Location();
 	public Entity() {};
     public Entity(GenericName rawName, Entity parent, Integer id) {
 		this.qualifiedName = null;
@@ -263,5 +259,16 @@ public abstract class Entity {
 		searched.add(this);
 		return visibleNames.get(name);
 	}
-	
+
+	public Integer getLine() {
+		return location.getLine();
+	}
+
+	public void setLine(int lineNumber) {
+		this.location.setLine(lineNumber);
+	}
+
+	public Location getLocation() {
+		return this.location;
+	}
 }

af9d8bc51ca3f187e0866baad28ded0c3d4b122f
@@ -24,23 +24,16 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import depends.entity.repo.EntityRepo;
 import depends.relations.Inferer;
+import depends.relations.Relation;
 import multilang.depends.util.file.TemporaryFile;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.lang.ref.WeakReference;
+import java.util.*;
 
 /**
  * ContainerEntity for example file, class, method, etc. they could contain
@@ -271,6 +264,7 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		this.expressionList.clear();
 		this.expressionList=null;
 		this.expressionList = new ArrayList<>();
+		this.expressionUseList = null;
 	}
 	
 	private void cacheExpressionListToFile() {
@@ -447,5 +441,35 @@ public abstract class ContainerEntity extends DecoratedEntity {
 		return resolvedMixins;
 	}
 
+	HashMap<String,Set<Expression>> expressionUseList = null;
+	public void addRelation(Expression expression, Relation relation) {
+		String key = relation.getEntity().qualifiedName+relation.getType();
+		if (this.expressionUseList==null)
+			expressionUseList = new HashMap<>();
+		if (expressionUseList.containsKey(key)){
+			Set<Expression> expressions = expressionUseList.get(key);
+			for (Expression expr:expressions){
+				if (linkedExpr(expr,expression)) return;
+			}
+		}else{
+			expressionUseList.put(key,new HashSet<>());
+		}
+
+		expressionUseList.get(key).add(expression);
+		super.addRelation(relation);
+	}
 
+	private boolean linkedExpr(Expression a, Expression b) {
+		Expression parent = a.getParent();
+		while(parent!=null){
+			if (parent==b) return true;
+			parent = parent.getParent();
+		}
+		parent = b.getParent();
+		while(parent!=null){
+			if (parent==a) return true;
+			parent = parent.getParent();
+		}
+		return  false;
+	}
 }

1e1fd70dfc0a05b97d5a41ea1dc407868397d722
@@ -1,14 +1,14 @@
 package depends.extractor.cpp;
 
-import java.util.HashMap;
-import java.util.Map;
-
-import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
-
 import depends.entity.repo.EntityRepo;
 import net.sf.ehcache.Cache;
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Element;
+import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
+import org.eclipse.cdt.core.dom.ast.IMacroBinding;
+
+import java.util.HashMap;
+import java.util.Map;
 
 public class MacroEhcacheRepo extends MacroRepo {
 	private EntityRepo entityRepo;
@@ -44,7 +44,7 @@ public class MacroEhcacheRepo extends MacroRepo {
 		Map<String, String> macros = get(fileFullPath);
 		macros.putAll(macroMap);
 		for (IASTPreprocessorMacroDefinition def : macroDefinitions) {
-			macros.put(def.getName().toString(), new String(def.getExpansion()));
+			macros.put(((IMacroBinding)def.getName().resolveBinding()).toString(), new String(def.getExpansion()));
 		}
 		Element cacheElement = new Element(buildKey(fileId), macros);
 		cache.put(cacheElement);

02e3a87f3d519ae49a7eceaa2c102040028a4905
@@ -0,0 +1,132 @@
+package depends.extractor.golang;
+
+import org.antlr.v4.runtime.*;
+
+import java.util.List;
+
+/**
+ * All parser methods that used in grammar (p, prev, notLineTerminator, etc.)
+ * should start with lower case char similar to parser rules.
+ */
+public abstract class GoParserBase extends Parser
+{
+    protected GoParserBase(TokenStream input) {
+        super(input);
+    }
+
+    /**
+     * Returns {@code true} iff on the current index of the parser's
+     * token stream a token exists on the {@code HIDDEN} channel which
+     * either is a line terminator, or is a multi line comment that
+     * contains a line terminator.
+     *
+     * @return {@code true} iff on the current index of the parser's
+     * token stream a token exists on the {@code HIDDEN} channel which
+     * either is a line terminator, or is a multi line comment that
+     * contains a line terminator.
+     */
+    protected boolean lineTerminatorAhead() {
+        // Get the token ahead of the current index.
+        int possibleIndexEosToken = this.getCurrentToken().getTokenIndex() - 1;
+
+        if (possibleIndexEosToken == -1)
+        {
+            return true;
+        }
+
+        Token ahead = _input.get(possibleIndexEosToken);
+        if (ahead.getChannel() != Lexer.HIDDEN) {
+            // We're only interested in tokens on the HIDDEN channel.
+            return false;
+        }
+
+        if (ahead.getType() == GoLexer.TERMINATOR) {
+            // There is definitely a line terminator ahead.
+            return true;
+        }
+
+        if (ahead.getType() == GoLexer.WS) {
+            // Get the token ahead of the current whitespaces.
+            possibleIndexEosToken = this.getCurrentToken().getTokenIndex() - 2;
+            ahead = _input.get(possibleIndexEosToken);
+        }
+
+        // Get the token's text and type.
+        String text = ahead.getText();
+        int type = ahead.getType();
+
+        // Check if the token is, or contains a line terminator.
+        return (type == GoLexer.COMMENT && (text.contains("\r") || text.contains("\n"))) ||
+                (type == GoLexer.TERMINATOR);
+    }
+
+     /**
+     * Returns {@code true} if no line terminator exists between the specified
+     * token offset and the prior one on the {@code HIDDEN} channel.
+     *
+     * @return {@code true} if no line terminator exists between the specified
+     * token offset and the prior one on the {@code HIDDEN} channel.
+     */
+    protected boolean noTerminatorBetween(int tokenOffset) {
+        BufferedTokenStream stream = (BufferedTokenStream)_input;
+        List<Token> tokens = stream.getHiddenTokensToLeft(stream.LT(tokenOffset).getTokenIndex());
+        
+        if (tokens == null) {
+            return true;
+        }
+
+        for (Token token : tokens) {
+            if (token.getText().contains("\n"))
+                return false;
+        }
+
+        return true;
+    }
+
+     /**
+     * Returns {@code true} if no line terminator exists after any encounterd
+     * parameters beyond the specified token offset and the next on the
+     * {@code HIDDEN} channel.
+     *
+     * @return {@code true} if no line terminator exists after any encounterd
+     * parameters beyond the specified token offset and the next on the
+     * {@code HIDDEN} channel.
+     */
+    protected boolean noTerminatorAfterParams(int tokenOffset) {
+        BufferedTokenStream stream = (BufferedTokenStream)_input;
+        int leftParams = 1;
+        int rightParams = 0;
+        int valueType;
+
+        if (stream.LT(tokenOffset).getType() == GoLexer.L_PAREN) {
+            // Scan past parameters
+            while (leftParams != rightParams) {
+                tokenOffset++;
+                valueType = stream.LT(tokenOffset).getType();
+
+                if (valueType == GoLexer.L_PAREN){
+                    leftParams++;
+                }
+                else if (valueType == GoLexer.R_PAREN) {
+                    rightParams++;
+                }
+            }
+
+            tokenOffset++;
+            return noTerminatorBetween(tokenOffset);
+        }
+
+        return true;
+    }
+
+    protected boolean checkPreviousTokenText(String text)
+    {
+        BufferedTokenStream stream = (BufferedTokenStream)_input;
+        String prevTokenText = stream.LT(1).getText();
+        
+        if (prevTokenText == null)
+            return false;
+        
+        return prevTokenText.equals(text);
+    }
+}

9188affd5288882270795e341e9ef9a4979f03f3
@@ -24,25 +24,17 @@ SOFTWARE.
 
 package depends.extractor;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Stack;
-import java.util.stream.Collectors;
-
-import depends.entity.AliasEntity;
-import depends.entity.ContainerEntity;
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.FunctionEntity;
-import depends.entity.PackageEntity;
-import depends.entity.GenericName;
-import depends.entity.TypeEntity;
-import depends.entity.VarEntity;
+import depends.entity.*;
 import depends.entity.repo.EntityRepo;
 import depends.entity.repo.IdGenerator;
 import depends.importtypes.Import;
 import depends.relations.Inferer;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Stack;
+import java.util.stream.Collectors;
+
 public abstract class HandlerContext {
 	protected EntityRepo entityRepo;
 	protected IdGenerator idGenerator;
@@ -307,9 +299,9 @@ public abstract class HandlerContext {
 		return varEntity;
 	}
 
-	public void foundEnumConstDefinition(String varName) {
+	public VarEntity foundEnumConstDefinition(String varName) {
 		GenericName type = lastContainer().getRawName();
-		foundVarDefinition(varName,type,new ArrayList<>());
+		return foundVarDefinition(varName,type,new ArrayList<>());
 	}
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();

190b575301a535680fb631f4af6d01dc47ce94a9
@@ -29,7 +29,6 @@ public class ExpressionUsage {
 	 * Auto deduce variable type from assignment. for example: c = new C() then c is
 	 * type of C
 	 * 
-	 * @param node
 	 */
 	private void deduceVarTypeInCaseOfAssignment(Expr_stmtContext expr, Expression expression) {
 		List<String> names = getName(expr.testlist_star_expr());
@@ -66,6 +65,7 @@ public class ExpressionUsage {
 		}else {
 			/* create expression and link it with parent*/
 			expression = new Expression(idGenerator.generateId());
+			expression.setLine(ctx.getStart().getLine());
 
 			expression.setText(ctx.getText());
 			context.lastContainer().addExpression(ctx,expression);
@@ -79,7 +79,7 @@ public class ExpressionUsage {
 				expression.setSet(true);
 				expression.setIdentifier(exprAssign.testlist_star_expr().getText());
 				if (isValidIdentifier(expression.getIdentifier())) {
-					makeSureVarExist(expression.getIdentifier());
+					makeSureVarExist(expression.getIdentifier(), ctx);
 				}
 				deduceVarTypeInCaseOfAssignment((Expr_stmtContext)ctx,expression);
 			}
@@ -104,9 +104,11 @@ public class ExpressionUsage {
 	}
 
 
-	private void makeSureVarExist(GenericName identifier) {
+	private void makeSureVarExist(GenericName identifier, ParserRuleContext ctx) {
 		if (null==context.foundEntityWithName(identifier)) {
-			context.foundVarDefinition(context.lastContainer(), identifier.getName());
+			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName());
+			var.setLine(ctx.getStart().getLine());
+
 		}
 	}
 
@@ -124,6 +126,7 @@ public class ExpressionUsage {
 		if (exprCtx.atom()!=null) {
 			//atom
 			Expression atomExpr = new Expression(idGenerator.generateId());
+			atomExpr.setLine(exprCtx.atom().getStart().getLine());
 			atomExpr.setParent(expression);
 			atomExpr.setText(exprCtx.atom().getText());
 			atomExpr.setIdentifier(exprCtx.atom().getText());
@@ -136,6 +139,7 @@ public class ExpressionUsage {
 				for (TrailerContext trailer:exprCtx.trailer()) {
 					if (trailer.name()!=null) {
 						Expression trailerExpr = new Expression(idGenerator.generateId());
+						trailerExpr.setLine(trailer.getStart().getLine());
 						trailerExpr.setText(trailer.getText());
 						context.lastContainer().addExpression(trailer,trailerExpr);
 						trailerExpr.setParent(expression);
@@ -145,7 +149,7 @@ public class ExpressionUsage {
 						trailerExpr.setIdentifier(trailer.name().getText());
 						if (trailer.arguments()!=null) {
 							if (trailer.arguments().OPEN_PAREN()!=null) {
-								foundCallStyleExpressionWithDot(trailerExpr,lastExpression.getIdentifier());
+								foundCallStyleExpressionWithDot(trailerExpr,lastExpression.getIdentifier(), trailer);
 							}else {
 								//subscript list, do nothing
 							}
@@ -156,7 +160,7 @@ public class ExpressionUsage {
 						//direct call, or direct data access
 						if (trailer.arguments()!=null) {
 							if (trailer.arguments().OPEN_PAREN()!=null) {
-								foundCallStyleExpressionWithoutDot(lastExpression);
+								foundCallStyleExpressionWithoutDot(lastExpression, trailer.arguments());
 							}else {
 								//subscript list, do nothing
 							}
@@ -194,7 +198,7 @@ public class ExpressionUsage {
 
 
 
-	private void foundCallStyleExpressionWithDot(Expression theExpression, GenericName varName) {
+	private void foundCallStyleExpressionWithDot(Expression theExpression, GenericName varName, ParserRuleContext ctx) {
 		GenericName funcName = theExpression.getIdentifier();
 		Entity prefixEntity = context.foundEntityWithName(varName);
 		if (prefixEntity instanceof VarEntity) {
@@ -212,7 +216,7 @@ public class ExpressionUsage {
 
 
 
-	private void foundCallStyleExpressionWithoutDot(Expression theExpression) {
+	private void foundCallStyleExpressionWithoutDot(Expression theExpression, ParserRuleContext ctx) {
 		GenericName funcName = theExpression.getIdentifier();
 		Entity typeEntity = context.foundEntityWithName(funcName);
 		if (typeEntity instanceof TypeEntity && typeEntity.getId() > 0) {

3daeed23bc01306f5ec1ad860d0c1d564c2d949d
@@ -1,13 +1,12 @@
 package depends.extractor.python;
 
-import java.io.IOException;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import depends.deptypes.DependencyType;
 import depends.entity.Entity;
 import depends.extractor.python.union.PythonFileParser;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
 
 public class PythonGlobalVarTest extends PythonParserTest {
     @Before
@@ -28,7 +27,7 @@ public class PythonGlobalVarTest extends PythonParserTest {
 	    }
 	    inferer.resolveAllBindings(true,null);
         Entity foo = repo.getEntity(withPackageName(srcs[0],"foo"));
-        this.assertContainsRelation(foo, DependencyType.IMPLLINK, "global_var");
+        this.assertContainsRelation(foo, DependencyType.USE, "global_var");
 	}
 	
 

36174edb716bdf9b12181f883ed8dbdf80aba4ae
@@ -61,22 +61,24 @@ public abstract class HandlerContext {
 		entityRepo.addFile(this.currentFile());
 	}
 
-	public TypeEntity foundNewType(GenericName name) {
+	public TypeEntity foundNewType(GenericName name, Integer startLine) {
 		TypeEntity currentTypeEntity = new TypeEntity(name, this.latestValidContainer(),
 				idGenerator.generateId());
-			pushToStack(currentTypeEntity);
-			addToRepo(currentTypeEntity);
-		 	currentFileEntity.addType(currentTypeEntity);
-			return currentTypeEntity;		
+		currentTypeEntity.setLine(startLine);
+		pushToStack(currentTypeEntity);
+		addToRepo(currentTypeEntity);
+		currentFileEntity.addType(currentTypeEntity);
+		return currentTypeEntity;
 	}
 	
 	/**
 	 * Tell the context object that a new type founded.
 	 * @param name
+	 * @param startLine
 	 * @return
 	 */
-	public TypeEntity foundNewType(String name) {
-		return foundNewType(GenericName.build(name));
+	public TypeEntity foundNewType(String name, Integer startLine) {
+		return foundNewType(GenericName.build(name),startLine);
 	}
 
 	public AliasEntity foundNewAlias(String aliasName, String originalName) {
@@ -105,9 +107,10 @@ public abstract class HandlerContext {
 	 * @param throwedType - if no throwed type information avaliable, keep it as empty list;  
 	 * @return the new function enity
 	 */
-	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType) {
+	public FunctionEntity foundMethodDeclarator(String methodName, String returnType, List<String> throwedType, Integer startLine) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
 				idGenerator.generateId(),GenericName.build(returnType));
+		functionEntity.setLine(startLine);
 		addToRepo(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
@@ -115,19 +118,10 @@ public abstract class HandlerContext {
 		return functionEntity;
 	}
 	
-	public FunctionEntity foundMethodDeclarator(String methodName, GenericName returnType, List<String> throwedType) {
-		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
-				idGenerator.generateId(),returnType);
-		addToRepo(functionEntity);
-		this.typeOrFileContainer().addFunction(functionEntity);
-		pushToStack(functionEntity);
-		functionEntity.addThrowTypes(throwedType.stream().map(item->GenericName.build(item)).collect(Collectors.toList()));
-		return functionEntity;
-	}
-	
-	public FunctionEntity foundMethodDeclarator(String methodName) {
+	public FunctionEntity foundMethodDeclarator(String methodName, Integer startLine) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), this.latestValidContainer(),
 				idGenerator.generateId(),null);
+		functionEntity.setLine(startLine);
 		addToRepo(functionEntity);
 		this.typeOrFileContainer().addFunction(functionEntity);
 		pushToStack(functionEntity);
@@ -135,9 +129,10 @@ public abstract class HandlerContext {
 	}
 
 	
-	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName) {
+	public FunctionEntity foundMethodDeclarator(ContainerEntity containerEntity, String methodName, Integer startLine) {
 		FunctionEntity functionEntity = new FunctionEntity(GenericName.build(methodName), containerEntity,
 				idGenerator.generateId(),null);
+		functionEntity.setLine(startLine);
 		addToRepo(functionEntity);
 		containerEntity.addFunction(functionEntity);
 		pushToStack(functionEntity);
@@ -215,10 +210,6 @@ public abstract class HandlerContext {
 		return null;
 	}
 
-	public void foundAnnotation(String name) {
-		lastContainer().addAnnotation(GenericName.build(name));
-	}
-
 	public void foundImplements(GenericName typeName) {
 		currentType().addImplements(typeName);
 	}
@@ -250,11 +241,11 @@ public abstract class HandlerContext {
 	}
 
 
-	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericName> typeArguments) {
-		return varNames.stream().map(item->foundVarDefinition(item,GenericName.build(type),typeArguments)).collect(Collectors.toList());
+	public List<VarEntity> foundVarDefinitions(List<String> varNames, String type, List<GenericName> typeArguments, Integer line) {
+		return varNames.stream().map(item->foundVarDefinition(item,GenericName.build(type),typeArguments,line)).collect(Collectors.toList());
 	}
 	
-	public VarEntity foundVarDefinition(ContainerEntity container,String varName) {
+	public VarEntity foundVarDefinition(ContainerEntity container,String varName,Integer line) {
 		if (container==null) {
 			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
 			container = currentFile();
@@ -263,13 +254,14 @@ public abstract class HandlerContext {
 		VarEntity var = getVarInLocalFile(container,GenericName.build(varName));
 		if (var!=null) return var;
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
+		var.setLine(line);
 		container.addVar(var);
 		addToRepo(var);
 
 		return var;
 	}
 	
-	public VarEntity foundGlobalVarDefinition(ContainerEntity container,String varName) {
+	public VarEntity foundGlobalVarDefinition(ContainerEntity container,String varName,Integer line) {
 		if (container==null) {
 			System.out.println("fallback to file container for var " + varName + " in file "+ currentFile().getRawName());
 			container = currentFile();
@@ -279,13 +271,15 @@ public abstract class HandlerContext {
 		if (var!=null) return var;
 		var = new VarEntity(GenericName.build(varName), null, container, idGenerator.generateId());
 		container.addVar(var);
+		var.setLine(line);
 		var.setQualifiedName(var.getRawName().toString());
 		addToRepo(var);
 		return var;
 	}
 
-	public VarEntity foundVarDefinition(String varName, GenericName type, List<GenericName> typeArguments) {
+	public VarEntity foundVarDefinition(String varName, GenericName type, List<GenericName> typeArguments,Integer line) {
 		VarEntity var = new VarEntity(GenericName.build(varName), type, lastContainer(), idGenerator.generateId());
+		var.setLine(line);
 		var.addTypeParameter(typeArguments);
 		lastContainer().addVar(var);	
 		addToRepo(var);
@@ -299,9 +293,9 @@ public abstract class HandlerContext {
 		return varEntity;
 	}
 
-	public VarEntity foundEnumConstDefinition(String varName) {
+	public VarEntity foundEnumConstDefinition(String varName,Integer line) {
 		GenericName type = lastContainer().getRawName();
-		return foundVarDefinition(varName,type,new ArrayList<>());
+		return foundVarDefinition(varName,type,new ArrayList<>(),line);
 	}
 	
 	protected Stack<Entity> entityStack = new Stack<Entity>();

a41d0bc65bcb34a4b37983e789d2c0f4b4b5df99
@@ -0,0 +1,50 @@
+/*
+MIT License
+
+Copyright (c) 2018-2019 Gang ZHANG
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+package depends.extractor.golang;
+
+import depends.entity.repo.BuiltInType;
+
+public class GoBuiltInType extends BuiltInType{
+
+	public GoBuiltInType() {
+        super.createBuiltInTypes();
+	}
+	@Override
+	public String[] getBuiltInTypeStr() {
+		return new String[]{
+				"<Built-in>"
+		};
+	}
+	@Override
+	public String[] getBuiltInPrefixStr() {
+		return new String[]{
+		};
+	}
+	@Override
+	public String[] getBuiltInMethods() {
+		return new String[]{};
+	}
+	
+}

adf1da4360a6e7455af8519c6aa6e7a7bb181740
@@ -26,25 +26,39 @@ package depends.extractor.golang;
 
 import depends.entity.repo.BuiltInType;
 
-public class GoBuiltInType extends BuiltInType{
+public class GoBuiltInType extends BuiltInType {
 
-	public GoBuiltInType() {
+    public GoBuiltInType() {
         super.createBuiltInTypes();
-	}
-	@Override
-	public String[] getBuiltInTypeStr() {
-		return new String[]{
-				"<Built-in>"
-		};
-	}
-	@Override
-	public String[] getBuiltInPrefixStr() {
-		return new String[]{
-		};
-	}
-	@Override
-	public String[] getBuiltInMethods() {
-		return new String[]{};
-	}
-	
+    }
+
+    @Override
+    public String[] getBuiltInTypeStr() {
+        return new String[]{
+                "<Built-in>",
+                "break", "default", "func", "interface",
+				"select", "case", "defer", "go", "map", "struct", "chan",
+				"else", "goto", "package", "switch", "const", "fallthrough",
+				"if", "range", "type", "continue", "for", "import", "return",
+				"var", "append", "bool", "byte", "cap", "close", "complex",
+				"complex64", "complex128", "uint16", "copy", "false", "float32",
+				"float64", "imag", "int", "int8", "int16", "uint32", "int32",
+				"int64", "iota", "len", "make", "new", "nil", "panic", "uint64",
+				"print", "println", "real", "recover", "string", "true", "uint",
+				"uint8", "uintptr",
+				"_"
+        };
+    }
+
+    @Override
+    public String[] getBuiltInPrefixStr() {
+        return new String[]{
+        };
+    }
+
+    @Override
+    public String[] getBuiltInMethods() {
+        return new String[]{};
+    }
+
 }

8c054fdbe92f063713b04ce0954d26b316f0c7d5
@@ -326,4 +326,6 @@ public abstract class HandlerContext {
 	public void addToRepo(Entity entity) {
 		entityRepo.add(entity);
 	}
+
+
 }
\ No newline at end of file

78158583dd7d0c06ea2e285667406038ea11f662
@@ -91,6 +91,7 @@ public class FileDependencyGenerator extends DependencyGenerator{
 	}
 
 	private DependencyDetail rewriteDetail(DependencyDetail detail) {
+		if (detail==null) return null;
 		String srcFile = filenameWritter.reWrite(detail.getSrc().getFile());
 		String dstFile = filenameWritter.reWrite(detail.getDest().getFile());
 		return new DependencyDetail(

b80c11205bc98f5370756dc346842a09d509eb32
@@ -92,8 +92,11 @@ public class FileDependencyGenerator extends DependencyGenerator{
 
 	private DependencyDetail rewriteDetail(DependencyDetail detail) {
 		if (detail==null) return null;
-		String srcFile = filenameWritter.reWrite(detail.getSrc().getFile());
-		String dstFile = filenameWritter.reWrite(detail.getDest().getFile());
+		String srcFile = filenameWritter.reWrite(
+				stripper.stripFilename(detail.getSrc().getFile())
+				);
+		String dstFile = filenameWritter.reWrite(
+				stripper.stripFilename(detail.getDest().getFile()));
 		return new DependencyDetail(
 				new LocationInfo(detail.getSrc().getObject(),
 						srcFile, detail.getSrc().getLineNumber())

e5cb76afa0a102a92fa6b5b0bccd1805a556b7fb
@@ -62,7 +62,7 @@ public class DependsCommand {
 	@Option(names = {"--strip-paths"}, split=",", description =  "The path(s) to be stripped. if -s enabled, the path(s) start after <src>. "
 			+ "Otherwise, the path(s) should be valid.")
 	private String[] strippedPaths = new String[]{};
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,L#(the level of folder. e.g. L1=1st level folder)]")
+	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,structure,L#(the level of folder. e.g. L1=1st level folder)]")
     private String granularity="file";
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
     private String namePathPattern="";

5ddfc9e8ec6791a95895138f084e042cd116ff8b
@@ -24,18 +24,6 @@ SOFTWARE.
 
 package depends.extractor;
 
-import java.io.File;
-import java.io.IOException;
-import java.lang.management.ManagementFactory;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.codehaus.plexus.util.FileUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.repo.BuiltInType;
@@ -48,8 +36,20 @@ import depends.relations.ImportLookupStrategy;
 import depends.relations.Inferer;
 import multilang.depends.util.file.FileTraversal;
 import multilang.depends.util.file.FileUtil;
+import org.codehaus.plexus.util.FileUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 
 abstract public class AbstractLangProcessor {
+
 	/**
 	 * The name of the lang
 	 * 
@@ -99,7 +99,7 @@ abstract public class AbstractLangProcessor {
 	
 	public AbstractLangProcessor(boolean eagerExpressionResolve) {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo, getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
+		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
 	}
 
 	/**
@@ -109,8 +109,6 @@ abstract public class AbstractLangProcessor {
 	 * 
 	 * @param includeDir
 	 * @param inputDir
-	 * @param b 
-	 * @param b 
 	 */
 	public void buildDependencies(String inputDir, String[] includeDir, List<String> typeFilter, boolean callAsImpl, boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
 		this.inputSrcPath = inputDir;

220968985bfca03ce90ccc2f148dc7a6a14c452a
@@ -97,9 +97,9 @@ abstract public class AbstractLangProcessor {
 	private List<String> includePaths;
 	private static Logger logger = LoggerFactory.getLogger(AbstractLangProcessor.class);
 	
-	public AbstractLangProcessor(boolean eagerExpressionResolve) {
+	public AbstractLangProcessor() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType(), eagerExpressionResolve);
+		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType());
 	}
 
 	/**
@@ -260,4 +260,7 @@ abstract public class AbstractLangProcessor {
 		return relation;
 	}
 
+	public boolean isEagerExpressionResolve(){
+		return false;
+	}
 }

2fbd504d61455e28fb36cde50ad689d81ae69b79
@@ -24,13 +24,13 @@ SOFTWARE.
 
 package depends.entity.repo;
 
-import java.util.Collection;
-import java.util.Iterator;
-
 import depends.entity.Entity;
 import depends.entity.FileEntity;
 import depends.entity.GenericName;
 
+import java.util.Collection;
+import java.util.Iterator;
+
 public interface EntityRepo extends IdGenerator {
 	public static final String GLOBAL_SCOPE_NAME = "::GLOBAL::";
 
@@ -52,6 +52,5 @@ public interface EntityRepo extends IdGenerator {
 
 	void addFile(FileEntity currentFileEntity);
 
-
-
+    void clear();
 }

f0094bc3f455f2ff782fe2ba8fe6476cb5afd387
@@ -81,7 +81,7 @@ abstract public class AbstractLangProcessor {
 	 * @param fileFullPath
 	 * @return
 	 */
-	protected abstract FileParser createFileParser(String fileFullPath);
+	public abstract FileParser createFileParser(String fileFullPath);
 
 	public Inferer inferer;
 	protected EntityRepo entityRepo;
@@ -93,7 +93,6 @@ abstract public class AbstractLangProcessor {
 	
 	public AbstractLangProcessor() {
 		entityRepo = new InMemoryEntityRepo();
-		inferer = new Inferer(entityRepo,  getImportLookupStrategy(), getBuiltInType());
 	}
 
 	/**
@@ -103,13 +102,13 @@ abstract public class AbstractLangProcessor {
 	 *
 	 * @param inputDir
 	 * @param includeDir
+	 * @param inferer
 	 * @return
 	 */
-	public EntityRepo buildDependencies(String inputDir, String[] includeDir, boolean callAsImpl, boolean isCollectUnsolvedBindings, boolean isDuckTypingDeduce) {
+	public EntityRepo buildDependencies(String inputDir, String[] includeDir, Inferer inferer) {
 		this.inputSrcPath = inputDir;
 		this.includeDirs = includeDir;
-		this.inferer.setCollectUnsolvedBindings(isCollectUnsolvedBindings);
-		this.inferer.setDuckTypingDeduce(isDuckTypingDeduce);
+		this.inferer = inferer;
 		logger.info("Start parsing files...");
 		parseAllFiles();
 		markAllEntitiesScope();
@@ -117,7 +116,7 @@ abstract public class AbstractLangProcessor {
 			logger.info("Resolve types and bindings of variables, methods and expressions.... " + this.inputSrcPath);
 			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
 		}
-		resolveBindings(callAsImpl);
+		resolveBindings();
 		if (logger.isInfoEnabled()) {
 			System.gc();
 			logger.info("Heap Information: " + ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
@@ -143,9 +142,9 @@ abstract public class AbstractLangProcessor {
 	 * @param callAsImpl
 	 * @return unsolved bindings
 	 */
-	public void resolveBindings(boolean callAsImpl) {
+	public void resolveBindings() {
 		System.out.println("Resolve types and bindings of variables, methods and expressions....");
-		this.potentialExternalDependencies = inferer.resolveAllBindings(callAsImpl,this);
+		this.potentialExternalDependencies = inferer.resolveAllBindings(this);
 		if (getExternalDependencies().size() > 0) {
 			System.out.println("There are " + getExternalDependencies().size() + " items are potential external dependencies.");
 		}

3768f51d89efb4dba59690e7476e379357790554
@@ -166,14 +166,14 @@ public class Expression implements Serializable{
 		if (parent.deduceTypeBasedId!=this.id) return;
 		
 		//if child is a built-in/external type, then parent must also a built-in/external type
-		if (this.type.equals(Inferer.buildInType)) {
-			parent.setType(Inferer.buildInType,Inferer.buildInType,inferer);
+		if (this.type.equals(TypeEntity.buildInType)) {
+			parent.setType(TypeEntity.buildInType,TypeEntity.buildInType,inferer);
 			return;
 		}
 		
 		/* if it is a logic expression, the return type/type is boolean. */
 		if (parent.isLogic) {
-			parent.setType(Inferer.buildInType,null,inferer);
+			parent.setType(TypeEntity.buildInType,null,inferer);
 		}
 		/* if it is a.b, and we already get a's type, b's type could be identified easily  */
 		else if (parent.isDot) {

18a7c2b851ce53c4052d10ce4bbe3b3fafec27b1
@@ -24,13 +24,9 @@ SOFTWARE.
 
 package depends.entity;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import depends.relations.IBindingResolver;
 
-import depends.relations.Inferer;
+import java.util.*;
 
 public class AliasEntity extends Entity {
 	private Entity referToEntity = new EmptyTypeEntity();
@@ -45,9 +41,9 @@ public class AliasEntity extends Entity {
 		this.originName = originTypeName;
 	}
 
-	public void inferLocalLevelEntities(Inferer inferer) {
+	public void inferLocalLevelEntities(IBindingResolver bindingResolver) {
 		if (!(referToEntity instanceof EmptyTypeEntity)) return;
-		Entity entity = inferer.resolveName(this, originName, true);
+		Entity entity = bindingResolver.resolveName(this, originName, true);
 		while(entity instanceof AliasEntity) {
 			AliasEntity aliasEntity = (AliasEntity)entity;
 			if (this.referPath.contains(aliasEntity)) {
@@ -55,7 +51,7 @@ public class AliasEntity extends Entity {
 				break;
 			}
 			this.referPath.add(aliasEntity);
-			entity = inferer.resolveName(aliasEntity, aliasEntity.originName,true);
+			entity = bindingResolver.resolveName(aliasEntity, aliasEntity.originName,true);
 			if (entity==null) break;
 			if (entity.equals(this)) {
 				entity = null;

2f0724800b1a1808db7ad18db917480eeea8fe81
@@ -213,7 +213,7 @@ public class BindingResolver implements IBindingResolver{
 			return precendenceEntity;
 		}
 		if (nameIndex == -1) {
-			System.err.println("error");
+			System.err.println("No expected symbols: names"+Arrays.toString(names) +", index=" + nameIndex);
 			return null;
 		}
 		//If it is not an entity with types (not a type, var, function), fall back to itself

1016ff9298216859922a8e055c425d0b789d9ef3
@@ -33,15 +33,12 @@ import depends.relations.ImportLookupStrategy;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 
 import static depends.deptypes.DependencyType.*;
 
 public class RubyProcessor extends AbstractLangProcessor implements ParserCreator{
     private static final String LANG = "ruby";
     private static final String[] SUFFIX = new String[] {".rb"};
-	private ExecutorService executor;
 
 	@Override
 	public String supportedLanguage() {
@@ -56,15 +53,7 @@ public class RubyProcessor extends AbstractLangProcessor implements ParserCreato
 
 	@Override
 	public FileParser createFileParser(String fileFullPath) {
-		executor = Executors.newSingleThreadExecutor();
-		return new JRubyFileParser(fileFullPath,entityRepo,executor,new IncludedFileLocator(super.includePaths()), bindingResolver,this);
-	}
-
-
-	@Override
-	protected void finalize() throws Throwable {
-		this.executor.shutdown();
-		super.finalize();
+		return new JRubyFileParser(fileFullPath,entityRepo,new IncludedFileLocator(super.includePaths()), bindingResolver,this);
 	}
 
 	@Override

b6feb8187235f09f1e9347e55de613ec5ba5c52a
@@ -28,12 +28,8 @@ import depends.entity.repo.BuiltInType;
 
 public class CppBuiltInType extends BuiltInType {
 
-	public CppBuiltInType() {
-		super.createBuiltInTypes();
-	}
-
 	@Override
-	public String[] getBuiltInTypeStr() {
+	protected String[] getBuiltInTypeName() {
 		return new String[] { "alignas", "alignof", "asm", "auto", "bool", "break", "case", "catch", "char",
 				"char16_t", "char32_t", "class", "const", "constexpr", "const_cast", "continue", "decltype",
 				"default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
@@ -64,12 +60,7 @@ public class CppBuiltInType extends BuiltInType {
 	}
 
 	@Override
-	public String[] getBuiltInPrefixStr() {
+	protected String[] getBuiltInTypePrefix() {
 		return new String[] {"__"};
 	}
-	@Override
-	public String[] getBuiltInMethods() {
-		return new String[]{};
-	}
-
 }
\ No newline at end of file

aaa26dab1acc77b60ee66459259a230fb59b79eb
@@ -6,7 +6,7 @@ import depends.extractor.python.NameAliasImport;
 import depends.extractor.python.PythonHandlerContext;
 import depends.extractor.python.PythonParser.*;
 import depends.extractor.python.PythonParserBaseListener;
-import depends.extractor.ruby.IncludedFileLocator;
+import depends.extractor.IncludedFileLocator;
 import depends.importtypes.FileImport;
 import depends.relations.IBindingResolver;
 import multilang.depends.util.file.FileUtil;

b4f94214f3a342026dceda416f1f82d84938a1e7
@@ -81,7 +81,7 @@ abstract public class AbstractLangProcessor {
 	 * @param fileFullPath
 	 * @return
 	 */
-	public abstract FileParser createFileParser(String fileFullPath);
+	public abstract FileParser createFileParser();
 
 	public IBindingResolver bindingResolver;
 	protected EntityRepo entityRepo;
@@ -182,10 +182,10 @@ abstract public class AbstractLangProcessor {
 	}
 
 	protected void parseFile(String fileFullPath) {
-		FileParser fileParser = createFileParser(fileFullPath);
+		FileParser fileParser = createFileParser();
 		try {
 			System.out.println("parsing " + fileFullPath + "...");
-			fileParser.parse();
+			fileParser.parse(FileUtil.uniqFilePath(fileFullPath));
 		} catch (IOException e) {
 			e.printStackTrace();
 		} catch (Exception e) {

4286870bf9580fb659721a3d06a6197f730a9761
@@ -50,7 +50,9 @@ public interface EntityRepo extends IdGenerator {
 
 	Iterator<Entity> sortedFileIterator();
 
-	void addFile(FileEntity currentFileEntity);
-
     void clear();
+
+	FileEntity getFileEntity(String fileFullPath);
+
+	void completeFile(String fileFullPath);
 }

c1c275b9688258eac09c28091e7961252d9ae96c
@@ -126,7 +126,10 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 	@Override
 	public void completeFile(String fileFullPath) {
 		FileEntity fileEntity = getFileEntity(fileFullPath);
-		fileEntity.cacheAllExpressions();
-		allFileEntitiesByOrder.add(fileEntity);
+		// in case of parse error(throw exception), the file entity may not exists
+		if (fileEntity!=null) {
+			fileEntity.cacheAllExpressions();
+			allFileEntitiesByOrder.add(fileEntity);
+		}
 	}
 }

75f07ae8c185ee0e89f6defaa16f80f7bcd930e3
@@ -66,7 +66,7 @@ public class JRubyFileParser extends FileParser {
 			JRubyVisitor parser = new JRubyVisitor(fileFullPath, entityRepo, includesFileLocator, bindingResolver,parserCreator);
 			node.accept(parser);
 		}catch(SyntaxException e) {
-			System.out.println("parsing error in "+fileFullPath + "(" + e.getMessage() +")");
+			System.out.println("parsing error in "+e.getPosition()  + "(" + e.getMessage() + ")");
 		}catch (Exception e){
 			e.printStackTrace();
 		}

7dfb555a4175123524018333f8da81e64d558fa3
@@ -59,7 +59,7 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitModuleNode(ModuleNode node) {
 		String name = helper.getName(node.getCPath());
-		context.foundNamespace(name,node.getPosition().getStartLine());
+		context.foundNamespace(name,node.getPosition().getStartLine()+1);
 		super.visitModuleNode(node);
 		context.exitLastedEntity();
 		return null;
@@ -67,7 +67,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitClassNode(ClassNode node) {
-		TypeEntity type = context.foundNewType(helper.getName(node.getCPath()),node.getPosition().getStartLine());
+		TypeEntity type = context.foundNewType(helper.getName(node.getCPath()),node.getPosition().getStartLine()+1);
 		Node superNode = node.getSuper();
 		
 		if (superNode instanceof ConstNode ||
@@ -96,7 +96,7 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitFCallNode(FCallNode node) {
 		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
-		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine()+1);
 		return super.visitFCallNode(node);
 	}
 
@@ -121,7 +121,7 @@ public class JRubyVisitor extends NoopVisitor {
 		String fname = helper.getName(node);
 		Collection<String> params = getParams(node);
 		addCallToReceiverVar(node, fname);
-		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine()+1);
 		return super.visitCallNode(node);
 	}
 
@@ -142,7 +142,7 @@ public class JRubyVisitor extends NoopVisitor {
 	public Object visitUnaryCallNode(UnaryCallNode node) {
 		String fname = helper.getName(node);
 		Collection<String> params = new ArrayList<>();
-		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine());
+		context.processSpecialFuncCall(fname, params, node.getPosition().getStartLine()+1);
 		return super.visitUnaryCallNode(node);
 	}
 
@@ -156,8 +156,8 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDefnNode(DefnNode node) {
-		FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine());
-		method.setLine(node.getPosition().getStartLine());
+		FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine()+1);
+		method.setLine(node.getPosition().getStartLine()+1);
 
 		super.visitDefnNode(node);
 		context.exitLastedEntity();
@@ -174,8 +174,8 @@ public class JRubyVisitor extends NoopVisitor {
 			String className = ((INameNode) varNode).getName();
 			Entity entity = context.foundEntityWithName(GenericName.build(className));
 			if (entity != null && entity instanceof ContainerEntity) {
-				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) entity), node.getName(),node.getPosition().getStartLine());
-				method.setLine(node.getPosition().getStartLine());
+				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) entity), node.getName(),node.getPosition().getStartLine()+1);
+				method.setLine(node.getPosition().getStartLine()+1);
 				handled = true;
 			}
 
@@ -183,16 +183,16 @@ public class JRubyVisitor extends NoopVisitor {
 			String varName = ((INameNode) varNode).getName();
 			Entity var = context.foundEntityWithName(GenericName.build(varName));
 			if (var != null && var instanceof ContainerEntity) {
-				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) var), node.getName(),node.getPosition().getStartLine());
-				method.setLine(node.getPosition().getStartLine());
+				FunctionEntity method = context.foundMethodDeclarator(((ContainerEntity) var), node.getName(),node.getPosition().getStartLine()+1);
+				method.setLine(node.getPosition().getStartLine()+1);
 				handled = true;
 			}
 		} 
 
 		if (!handled) {
 			// fallback to add it to last container
-			FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine());
-			method.setLine(node.getPosition().getStartLine());
+			FunctionEntity method = context.foundMethodDeclarator(node.getName(),node.getPosition().getStartLine()+1);
+			method.setLine(node.getPosition().getStartLine()+1);
 		}
 		super.visitDefsNode(node);
 		context.exitLastedEntity();
@@ -201,31 +201,31 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitGlobalVarNode(GlobalVarNode node) {
-		context.foundVarDefinition(context.globalScope(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.globalScope(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitGlobalVarNode(node);
 	}
 
 	@Override
 	public Object visitInstVarNode(InstVarNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitInstVarNode(node);
 	}
 
 	@Override
 	public Object visitClassVarAsgnNode(ClassVarAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitClassVarAsgnNode(node);
 	}
 
 	@Override
 	public Object visitClassVarDeclNode(ClassVarDeclNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitClassVarDeclNode(node);
 	}
 
 	@Override
 	public Object visitClassVarNode(ClassVarNode node) {
-		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.currentType(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitClassVarNode(node);
 	}
 
@@ -236,25 +236,26 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitDVarNode(DVarNode node) {
-		context.foundVarDefinition(context.lastContainer(), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(context.lastContainer(), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitDVarNode(node);
 	}
 
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
+		expressionUsage.foundExpression(node.getValue());
 		return super.visitDAsgnNode(node);
 	}
 
 	@Override
 	public Object visitGlobalAsgnNode(GlobalAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitGlobalAsgnNode(node);
 	}
 
 	@Override
 	public Object visitInstAsgnNode(InstAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitInstAsgnNode(node);
 	}
 
@@ -267,7 +268,7 @@ public class JRubyVisitor extends NoopVisitor {
 
 	@Override
 	public Object visitLocalAsgnNode(LocalAsgnNode node) {
-		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine());
+		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
 		return super.visitLocalAsgnNode(node);
 	}
 

8e144f23fa61ee9e6853a3dbc979d774b1da01b9
@@ -138,8 +138,6 @@ abstract public class AbstractLangProcessor {
 	}
 
 	/**
-	 * 
-	 * @param callAsImpl
 	 * @return unsolved bindings
 	 */
 	public void resolveBindings() {
@@ -233,7 +231,18 @@ abstract public class AbstractLangProcessor {
 		return relation;
 	}
 
+	/**
+	 * Whether to resolve expression immediately during parse
+	 * @return
+	 */
 	public boolean isEagerExpressionResolve(){
 		return false;
 	}
+
+	/**
+	 * Call as Impl:
+	 *     implicit call (for example polymorphic in cpp)
+	 * @return
+	 */
+	public boolean supportCallAsImpl(){return false;};
 }

42dbac90d8498e69245b6571a8077601008a7310
@@ -70,6 +70,7 @@ public class FunctionDependencyGenerator extends DependencyGenerator {
 		String name = stripper.stripFilename(file.getRawName().uniqName());
 		name = filenameWritter.reWrite(name);
 		String functionName = EntityNameBuilder.build(entity);
+		functionName = stripper.stripFilename(functionName);
 		name = name + "("+functionName+")";
 		return name;
 	}

37e47836910002a4e254fb5f7a5a9e85d3d202ad
@@ -46,7 +46,8 @@ public class DependencyType {
 	public static final String PomParent = "Parent";
 	public static final String PomPlugin = "Plugin";
 	public static final String PomDependency = "Dependency";
-	
+
+	public static final String DuckTypingLabel = "(duck)";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();

0be07f93f6c83785fbc25be0b7e4ce97d16c89db
@@ -11,8 +11,7 @@ import org.junit.Test;
 
 import java.io.IOException;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	@Before
@@ -98,6 +97,22 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
 	}
 
+	@Test
+	public void test_expression_count_should_be_only_1() throws IOException {
+		String[] srcs = new String[] {
+				"./src/test/resources/python-code-examples/deducetype_parameter.py",
+		};
+
+		for (String src:srcs) {
+			FileParser parser = createFileParser();
+			parser.parse(src);
+		}
+		resolveAllBindings();
+		String name = withPackageName(srcs[0],"test_expression");
+		FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
+		assertNotNull(function);
+	}
+
 
 }
 

dbabb7e459681d357fa489658976420065cf5989
@@ -113,8 +113,12 @@ public class Expression implements Serializable{
 		}
 		
 		//referer referredEntity -- TODO:maybe not require
-		if (this.referredEntityId!=null && this.referredEntity==null)
+		if (this.referredEntityId!=null && this.referredEntity==null) {
 			this.referredEntity = repo.getEntity(this.referredEntityId);
+			if (this.referredEntity ==null){
+				System.err.println("unexpected: referred Entity is null" + this.referredEntityId + this.text+this.id);
+			}
+		}
 	}
 	
 	/**

d003ee4afa4123608df5fcb19954254a89ec4920
@@ -182,24 +182,7 @@ public class Expression implements Serializable{
 		else if (parent.isDot) {
 			if (parent.isCall()) {
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-				if (funcs!=null) {
-					//funcs = funcs.stream().filter(item->!(item instanceof MultiDeclareEntities)).collect(Collectors.toList());
-					if (funcs.size()>0) {
-						Entity func = funcs.get(0);
-						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
-							bindingResolver.getRepo().add(m);
-							for (int i=1;i<funcs.size();i++) {
-								m.add(funcs.get(i));
-							}
-							parent.setType(func.getType(), m, bindingResolver);
-							parent.setReferredEntity(m);
-						}else {
-							parent.setType(func.getType(), func, bindingResolver);
-							parent.setReferredEntity(func);
-						}
-					}
-				}
+				setReferredFunctions(bindingResolver, parent, funcs);
 			}else {
 				Entity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
@@ -207,22 +190,7 @@ public class Expression implements Serializable{
 					parent.setReferredEntity(var);
 				}else {
 					List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-					if (funcs!=null) {
-						Entity func = funcs.get(0);
-						if (funcs.size()>1) {
-							MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
-							bindingResolver.getRepo().add(m);
-
-							for (int i=1;i<funcs.size();i++) {
-								m.add(funcs.get(i));
-							}
-							parent.setType(func.getType(), m, bindingResolver);
-							parent.setReferredEntity(m);
-						}else {
-							parent.setType(func.getType(), func, bindingResolver);
-							parent.setReferredEntity(func);
-						}
-					}
+					setReferredFunctions(bindingResolver,parent,funcs);
 				}
 			}
 			if (parent.getType()==null) {
@@ -237,6 +205,23 @@ public class Expression implements Serializable{
 			parent.setReferredEntity(parent.type);
 	}
 
+	private void setReferredFunctions(IBindingResolver bindingResolver, Expression expr, List<Entity> funcs) {
+		if (funcs ==null ||funcs.size()==0) return;
+		Entity func = funcs.get(0);
+		if (funcs.size()==1){
+			expr.setType(func.getType(), func, bindingResolver);
+			expr.setReferredEntity(func);
+			return;
+		}
+		MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
+		bindingResolver.getRepo().add(m);
+		for (int i = 1; i< funcs.size(); i++) {
+			m.add(funcs.get(i));
+		}
+		expr.setType(func.getType(), m, bindingResolver);
+		expr.setReferredEntity(m);
+	}
+
 	private void setReferredEntity(Entity referredEntity) {
 		this.referredEntity = referredEntity;
 		if (this.referredEntity!=null) {

f114c9c371062b1aebc55861844ba9d3770dda7d
@@ -1,9 +1,6 @@
 package depends.entity.repo;
 
-import depends.entity.Entity;
-import depends.entity.FileEntity;
-import depends.entity.GenericName;
-import depends.entity.MultiDeclareEntities;
+import depends.entity.*;
 import multilang.depends.util.file.FileUtil;
 
 import java.util.*;
@@ -39,6 +36,7 @@ public class InMemoryEntityRepo extends SimpleIdGenerator implements EntityRepo
 		allEntieisByName = new TreeMap<>();
 		allEntitiesById = new TreeMap<>();
 		allFileEntitiesByOrder = new LinkedList<>();
+		add(TypeEntity.buildInType);
 	}
 
 	@Override

55854a2a5c80130035a17e3c864ae2c058aebfff
@@ -47,7 +47,7 @@ public class DependencyType {
 	public static final String PomPlugin = "Plugin";
 	public static final String PomDependency = "Dependency";
 
-	public static final String DuckTypingLabel = "(duck)";
+	public static final String POSSIBLE_DEP = "(possible)";
 
 	public static ArrayList<String> allDependencies() {
 		ArrayList<String> depedencyTypes = new ArrayList<String>();

dc6e7fdf8b2ba8b380dfc6e6ac3ddf0c0a2b999c
@@ -5,11 +5,14 @@ import depends.entity.FunctionEntity;
 import depends.entity.TypeEntity;
 import depends.entity.VarEntity;
 import depends.extractor.FileParser;
+import edu.emory.mathcs.backport.java.util.Arrays;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
+import java.util.List;
+import java.util.stream.Collectors;
 
 import static org.junit.Assert.*;
 
@@ -110,8 +113,9 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 		resolveAllBindings();
 		String name = withPackageName(srcs[0],"test_expression");
 		FunctionEntity function = (FunctionEntity)( entityRepo.getEntity(name));
-		for (int r= 2;r<4;r++)
-			assertTrue(function.getRelations().get(r).possible());
+		List<Boolean> result = function.getRelations().stream().map(r -> r.possible()).collect(Collectors.toList());
+		List<Boolean> expected = Arrays.asList(new Boolean[]{false,false,true,true,true,false, false, true, true,false});
+		assertArrayEquals(expected.toArray(),result.toArray());
 	}
 
 

40399d6885d0fb7e96f778976a8a32bf5e6041b0
@@ -123,9 +123,15 @@ public class Expression implements Serializable{
 	
 	/**
 	 * Set type of the expression
-	 * @param type
-	 * @param referredEntity
-	 * @param bindingResolver
+	 *      if it is already has type, it will skip
+	 *      if it is already referered entity, it will skip
+	 *      if the type changed, parent expression will be re-caculated
+	 * For dynamic type language, return type or parameters, variables may depends on the expression type,
+	 *      so once we get the type of expression, we will assign type to them.
+	 *
+	 * @param type  the type of the expression
+	 * @param referredEntity the entity of the expression point to, which is used to calculate dependency relation
+	 * @param bindingResolver a parameter which will be passed to deduced parent type
 	 */
 	public void setType(TypeEntity type, Entity referredEntity, IBindingResolver bindingResolver) {
 		if (this.getReferredEntity()==null && referredEntity!=null) {
@@ -135,6 +141,7 @@ public class Expression implements Serializable{
 		boolean changedType = false;
 		if (this.type==null && type!=null) {
 			this.type = type;
+			changedType = true;
 			for (VarEntity var:deducedTypeVars) {
 				if (var!=null) {
 					var.setType(this.type);
@@ -145,7 +152,6 @@ public class Expression implements Serializable{
 					func.addReturnType(this.type);
 				}
 			}
-			changedType = true;
 		}
 		if (this.referredEntity==null)
 			this.setReferredEntity(this.type);
@@ -157,6 +163,7 @@ public class Expression implements Serializable{
 
 	/**
 	 * deduce type of parent based on child's type
+	 *
 	 * @param bindingResolver
 	 */
 	private void deduceTheParentType(IBindingResolver bindingResolver) {
@@ -182,7 +189,7 @@ public class Expression implements Serializable{
 		else if (parent.isDot) {
 			if (parent.isCall()) {
 				List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-				setReferredFunctions(bindingResolver, parent, funcs);
+				parent.setReferredFunctions(bindingResolver, funcs);
 			}else {
 				Entity var = this.getType().lookupVarInVisibleScope(parent.identifier);
 				if (var!=null) {
@@ -190,7 +197,7 @@ public class Expression implements Serializable{
 					parent.setReferredEntity(var);
 				}else {
 					List<Entity> funcs = this.getType().lookupFunctionInVisibleScope(parent.identifier);
-					setReferredFunctions(bindingResolver,parent,funcs);
+					parent.setReferredFunctions(bindingResolver,funcs);
 				}
 			}
 			if (parent.getType()==null) {
@@ -205,12 +212,22 @@ public class Expression implements Serializable{
 			parent.setReferredEntity(parent.type);
 	}
 
-	private void setReferredFunctions(IBindingResolver bindingResolver, Expression expr, List<Entity> funcs) {
+	/**
+	 * set expr's referred entity to functions
+	 *    why do not use 'setReferredEntity' directly?
+	 *    in case of multiple functions, we should first construct a multi-declare entities object,
+	 *    than set the type to multi-declare entity, for future resolver,
+	 *    for example in duck typing case:
+	 *        conn.send().foo, if conn is mutiple type (A, B), send should be search in both A and B
+	 * @param bindingResolver
+	 * @param funcs
+	 */
+	private void setReferredFunctions(IBindingResolver bindingResolver, List<Entity> funcs) {
 		if (funcs ==null ||funcs.size()==0) return;
 		Entity func = funcs.get(0);
 		if (funcs.size()==1){
-			expr.setType(func.getType(), func, bindingResolver);
-			expr.setReferredEntity(func);
+			setType(func.getType(), func, bindingResolver);
+			setReferredEntity(func);
 			return;
 		}
 		MultiDeclareEntities m = new MultiDeclareEntities(func, bindingResolver.getRepo().generateId());
@@ -218,8 +235,8 @@ public class Expression implements Serializable{
 		for (int i = 1; i< funcs.size(); i++) {
 			m.add(funcs.get(i));
 		}
-		expr.setType(func.getType(), m, bindingResolver);
-		expr.setReferredEntity(m);
+		setType(func.getType(), m, bindingResolver);
+		setReferredEntity(m);
 	}
 
 	private void setReferredEntity(Entity referredEntity) {
@@ -229,11 +246,19 @@ public class Expression implements Serializable{
 		}
 	}
 
+	/**
+	 * remember the vars depends on the expression type
+	 * @param var
+	 */
 	public void addDeducedTypeVar(VarEntity var) {
 		this.deducedTypeVars.add(var);
 		this.deducedTypeVarsId.add(var.getId());
 	}
 
+	/**
+	 * remember the functions depends on the expression type
+	 * @param var
+	 */
 	public void addDeducedTypeFunction(FunctionEntity function) {
 		this.deducedTypeFunctions.add(function);
 		this.deducedTypeFunctionsId.add(function.id);

80cc02fe91c389d6a798e1a72bda6c1e8d67d518
@@ -40,7 +40,7 @@ public class DependencyType {
 	public static final String CREATE = "Create";
 	public static final String CAST = "Cast";
 	public static final String THROW = "Throw";
-	public static final String IMPLLINK = "ImplLink";
+	public static final String LINK = "Link";
 	public static final String ANNOTATION = "Annotation";
 	public static final String MIXIN = "MixIn";
 	public static final String PomParent = "Parent";
@@ -66,7 +66,7 @@ public class DependencyType {
 		depedencyTypes.add(THROW);
 		depedencyTypes.add(ANNOTATION);
 		depedencyTypes.add(MIXIN);
-		depedencyTypes.add(IMPLLINK);
+		depedencyTypes.add(LINK);
 		depedencyTypes.add(PomParent);
 		depedencyTypes.add(PomPlugin);
 		depedencyTypes.add(PomDependency);

877c1ac1d363deffd6ba74c2d6b1e53226ce114b
@@ -7,7 +7,6 @@ import depends.entity.VarEntity;
 import depends.extractor.FileParser;
 import edu.emory.mathcs.backport.java.util.Arrays;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -81,7 +80,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	}
 	
 	
-	@Ignore
+	@Test
 	public void test_deduce_type_of_non_param_var() throws IOException {
 		String[] srcs = new String[] {
 	    		"./src/test/resources/python-code-examples/deducetype_nonparam.py",
@@ -97,7 +96,7 @@ public class PythonParameterTypeDedudceTest extends PythonParserTest {
 	    VarEntity var = function.lookupVarLocally("t2");
 	    TypeEntity type = var.getType();
 	    assertTrue(type instanceof CandidateTypes);
-	    assertEquals(2,((CandidateTypes)type).getCandidateTypes().size());
+	    assertEquals(1,((CandidateTypes)type).getCandidateTypes().size());
 	}
 
 	@Test

27f1206a1aab12fc321a4993bc6b199789f767d5
@@ -24,15 +24,15 @@ SOFTWARE.
 
 package depends;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import depends.deptypes.DependencyType;
 import depends.extractor.LangProcessorRegistration;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
+import java.util.ArrayList;
+import java.util.List;
+
 @Command(name = "depends")
 public class DependsCommand {
 	public static class SupportedLangs extends ArrayList<String> {
@@ -62,8 +62,8 @@ public class DependsCommand {
 	@Option(names = {"--strip-paths"}, split=",", description =  "The path(s) to be stripped. if -s enabled, the path(s) start after <src>. "
 			+ "Otherwise, the path(s) should be valid.")
 	private String[] strippedPaths = new String[]{};
-	@Option(names = {"-g", "--granularity"},  description = "Granularity of dependency.[file(default),method,structure,L#(the level of folder. e.g. L1=1st level folder)]")
-    private String granularity="file";
+	@Option(names = {"-g", "--granularity"}, split=",",  description = "Granularity of dependency.[file(default),method,structure]")
+    private String[] granularity=new String[]{"file"};
 	@Option(names = {"-p", "--namepattern"},  description = "The name path pattern.[dot(.), unix(/) or windows(\\)")
     private String namePathPattern="";
 	@Option(names = {"-i","--includes"},split=",", description = "The files of searching path")
@@ -120,7 +120,7 @@ public class DependsCommand {
 	public boolean isHelp() {
 		return help;
 	}
-    public String getGranularity() {
+    public String[] getGranularity() {
 		return granularity;
 	}
 	public String getNamePathPattern() {

a7f33f2d1f2eeb5ce8b968d2dce95eca534acb38
@@ -79,7 +79,9 @@ public class DependsCommand {
 	@Option(names = {"--external-deps"}, description = "Output external dependencies")
 	private boolean outputExternalDependencies = false;	
 	@Option(names = {"--duck-typing-deduce"}, description = "Deduce implicit variable types")
-	private boolean duckTypingDeduce = true;	
+	private boolean duckTypingDeduce = true;
+	@Option(names = {"--output-self-deps"}, description = "Output self dependencies")
+	private boolean outputSelfDependencies = false;
 	@Option(names = {"-h","--help"}, usageHelp = true, description = "display this help and exit")
     boolean help;
 	public DependsCommand() {
@@ -154,7 +156,9 @@ public class DependsCommand {
 	public boolean isOutputExternalDependencies() {
 		return outputExternalDependencies;
 	}
-	
+	public boolean isOutputSelfDependencies() {
+		return outputSelfDependencies;
+	}
 	public boolean isDuckTypingDeduce() {
 		return this.duckTypingDeduce;
 	}

c09675c980b1e0fe17feb6ec379151ce0d3e0433
@@ -243,7 +243,7 @@ public class JRubyVisitor extends NoopVisitor {
 	@Override
 	public Object visitDAsgnNode(DAsgnNode node) {
 		context.foundVarDefinition(helper.getScopeOfVar(node,context), node.getName(),node.getPosition().getStartLine()+1);
-		expressionUsage.foundExpression(node.getValue());
+		expressionUsage.foundExpression(node);
 		return super.visitDAsgnNode(node);
 	}
 

910f31e4f279f89f9e62d90e5ea98ceaa6eb50c4
@@ -145,7 +145,7 @@ public abstract class Entity {
 		deduceQualifiedName();
 	}
 	
-	public final String getQualifiedName() {
+	public String getQualifiedName() {
 		return qualifiedName;
 	}
 

982b1e2859f7082793495a6d0550e3115faaa28e
@@ -50,6 +50,15 @@ public class ExpressionUsage {
 			return names;
 	}
 
+	private List<String> getName(List<Testlist_star_exprContext> testlist_star_expr) {
+		List<String> names = new ArrayList<>();
+		for (Testlist_star_exprContext expr:testlist_star_expr){
+			expr.accept(new NameCollector(names));
+		}
+		return names;
+	}
+
+
 	public void foundExpression(ParserRuleContext ctx) {
 		if (!isStartOfContainerRule(ctx)) {
 			return ;
@@ -79,7 +88,9 @@ public class ExpressionUsage {
 				expression.setSet(true);
 				expression.setIdentifier(exprAssign.testlist_star_expr().getText());
 				if (isValidIdentifier(expression.getIdentifier())) {
-					makeSureVarExist(expression.getIdentifier(), ctx);
+					if (!isAlias(exprAssign)){
+						makeSureVarExist(expression.getIdentifier(), ctx);
+					}
 				}
 				deduceVarTypeInCaseOfAssignment((Expr_stmtContext)ctx,expression);
 			}
@@ -96,6 +107,22 @@ public class ExpressionUsage {
 		
 	}
 
+	private boolean isAlias(Expr_stmtContext exprAssign) {
+		String theName = exprAssign.testlist_star_expr().getText();
+
+		List<String> assignNames = this.getName(exprAssign.assign_part().testlist_star_expr());
+		if (assignNames.size()==0) return false;
+		String assignName = assignNames.get(0);
+		Entity type = bindingResolver.resolveName(context.lastContainer(), GenericName.build(assignName),true);
+		if (type==null)
+			return false;
+		if (!(type instanceof TypeEntity))
+			return false;
+		context.foundNewAlias(theName,assignName);
+		return true;
+	}
+
+
 	private void deduceReturnTypeInCaseOfReturn(Return_stmtContext ctx, Expression expression) {
 		FunctionEntity currentFunction = context.currentFunction();
 		if (currentFunction == null)
@@ -106,9 +133,8 @@ public class ExpressionUsage {
 
 	private void makeSureVarExist(GenericName identifier, ParserRuleContext ctx) {
 		if (null==context.foundEntityWithName(identifier)) {
-			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName(),ctx.getStart().getLine());
+			VarEntity var = context.foundVarDefinition(context.lastContainer(), identifier.getName(), ctx.getStart().getLine());
 			var.setLine(ctx.getStart().getLine());
-
 		}
 	}
 

9e012e4d0c41e28be14a2c0be87993b28a1f68fa
@@ -5,10 +5,12 @@ import depends.entity.repo.IdGenerator;
 import depends.extractor.HandlerContext;
 import depends.extractor.python.PythonHandlerContext;
 import depends.extractor.python.PythonParser.*;
+import depends.extractor.python.PythonParserBaseListener;
 import depends.extractor.python.PythonParserBaseVisitor;
 import depends.relations.IBindingResolver;
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.RuleContext;
+import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -108,6 +110,10 @@ public class ExpressionUsage {
 	}
 
 	private boolean isAlias(Expr_stmtContext exprAssign) {
+		//if contain arguments, like a = A(), it must be a variable
+		if (containArguments(exprAssign)){
+			return false;
+		}
 		String theName = exprAssign.testlist_star_expr().getText();
 
 		List<String> assignNames = this.getName(exprAssign.assign_part().testlist_star_expr());
@@ -122,6 +128,19 @@ public class ExpressionUsage {
 		return true;
 	}
 
+	private boolean containArguments(Expr_stmtContext expr) {
+		final boolean[] containsArgument = {false};
+		PythonParserBaseListener visitor = new PythonParserBaseListener() {
+			@Override
+			public void enterArguments(ArgumentsContext ctx) {
+				containsArgument[0] = true;
+				super.enterArguments(ctx);
+			}
+		};
+		ParseTreeWalker walker = new ParseTreeWalker();
+		walker.walk(visitor,expr);
+		return containsArgument[0];
+	}
 
 	private void deduceReturnTypeInCaseOfReturn(Return_stmtContext ctx, Expression expression) {
 		FunctionEntity currentFunction = context.currentFunction();

66db5d509e4dd337cf89b65a079009fb8ffe2349
@@ -251,8 +251,14 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		List<String> result = new ArrayList<>();
 		for (Def_parametersContext params:def_parameters) {
 			for (Def_parameterContext param:params.def_parameter()) {
-				String p = getName( param.named_parameter().name());
-				result.add(p);
+				if (!(param.named_parameter()==null)){
+					String p = getName( param.named_parameter().name());
+					result.add(p);
+				}
+				else{
+					// STAR, we ignore it
+					//    refer to definition: def_parameter:named_parameter (ASSIGN test)? | STAR
+				}
 			}
 		
 		}

6bd17bb8eaabfe6e1a18cd3fc41d463f85a13d1d
@@ -115,10 +115,9 @@ public class ExpressionUsage {
 			return false;
 		}
 		String theName = exprAssign.testlist_star_expr().getText();
-
 		List<String> assignNames = this.getName(exprAssign.assign_part().testlist_star_expr());
 		if (assignNames.size()==0) return false;
-		String assignName = assignNames.get(0);
+		String assignName = namesToDot(assignNames);
 		Entity type = bindingResolver.resolveName(context.lastContainer(), GenericName.build(assignName),true);
 		if (type==null)
 			return false;
@@ -128,6 +127,17 @@ public class ExpressionUsage {
 		return true;
 	}
 
+	private String namesToDot(List<String> assignNames) {
+		StringBuilder sb = new StringBuilder();
+		for (String s:assignNames){
+			if (sb.length()>0){
+				sb.append(".");
+			}
+			sb.append(s);
+		}
+		return sb.toString();
+	}
+
 	private boolean containArguments(Expr_stmtContext expr) {
 		final boolean[] containsArgument = {false};
 		PythonParserBaseListener visitor = new PythonParserBaseListener() {
@@ -335,9 +345,8 @@ class NameCollector extends PythonParserBaseVisitor<Void>{
 		this.names = names;
 	}
 	@Override
-	public Void visitAtom(AtomContext ctx) {
-		if (ctx.name()!=null)
-			names.add(ctx.name().getText());
-		return super.visitAtom(ctx);
+	public Void visitName(NameContext ctx) {
+			names.add(ctx.getText());
+		return super.visitName(ctx);
 	}
 }
\ No newline at end of file

2c272809aea906584d6dd3e1165895bcea631002
@@ -40,7 +40,6 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		this.includeFileLocator = includeFileLocator;
 		this.bindingResolver = bindingResolver;
 		this.pythonProcessor = pythonProcessor;
-
 		String dir = FileUtil.uniqFilePath(FileUtil.getLocatedDir(fileFullPath));
 		if (entityRepo.getEntity(dir) == null) {
 			PackageEntity pacakgeEntity = new PackageEntity(dir, entityRepo.generateId());
@@ -67,7 +66,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 			if (dotted_as_name.name()!=null) {
 				aliasName = dotted_as_name.name().getText();
 			}
-			List<String> fullNames = foundImportedModuleOrPackage(0,moduleName);
+			List<String> fullNames = sureImportedModulesParsed(0,moduleName,null);
 			 
 			for (String fullName:fullNames) {
 				if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
@@ -80,15 +79,15 @@ public class PythonCodeListener extends PythonParserBaseListener{
 	}
 	@Override
 	public void enterFrom_stmt(From_stmtContext ctx) {
-		String moduleName = null;
+		String fromName = null;
 		if (ctx.dotted_name() != null) {
-			moduleName = ctx.dotted_name().getText();
+			fromName = ctx.dotted_name().getText();
 		}
 		int prefixDotCount = getDotCounter(ctx);
+		List<String> moduleNames = getModuleNames(ctx.import_as_names());
+		List<String> fullNames = sureImportedModulesParsed(prefixDotCount, fromName,moduleNames);
 
-		 List<String> fullNames = foundImportedModuleOrPackage(prefixDotCount, moduleName);
 		for (String fullName:fullNames) {
-
 			if (ctx.import_as_names() == null) {// import *
 				ContainerEntity moduleEntity = (ContainerEntity) (entityRepo.getEntity(fullName));
 				if (moduleEntity != null) {
@@ -124,8 +123,7 @@ public class PythonCodeListener extends PythonParserBaseListener{
 						if (FileUtil.existFile(fileName) && !(FileUtil.isDirectory(fileName))) {
 							context.foundNewImport(new FileImport(fileName));
 						}
-					}
-					if (FileUtil.existFile(fullName) && !(FileUtil.isDirectory(fullName))) {
+					}else if (FileUtil.existFile(fullName)) {
 						context.foundNewImport(new FileImport(fullName));
 					}
 					Entity itemEntity = bindingResolver.resolveName(entityRepo.getEntity(fullName), GenericName.build(name), true);
@@ -138,8 +136,18 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		super.enterFrom_stmt(ctx);
 	}
-	
-	
+
+	private List<String> getModuleNames(Import_as_namesContext import_as_names) {
+		List<String> names = new ArrayList<>();
+		if (import_as_names==null)
+			return names;
+		for (Import_as_nameContext item : import_as_names.import_as_name()) {
+			String name = item.name(0).getText();
+			names.add(name);
+		}
+		return names;
+	}
+
 	private int getDotCounter(From_stmtContext ctx) {
 		int total = 0;
 		if (ctx.DOT()!=null){
@@ -150,54 +158,82 @@ public class PythonCodeListener extends PythonParserBaseListener{
 		}
 		return total;
 	}
-	private List<String> foundImportedModuleOrPackage(int prefixDotCount, String originalName) {
+
+
+	private List<String> sureImportedModulesParsed(int prefixDotCount, String fromName, List<String> moduleNames) {
+		ArrayList<String> visitedFiles = new ArrayList<>();
+
+		/*  compute prefix path */
 		String dir = FileUtil.getLocatedDir(context.currentFile().getRawName().uniqName());
 		String preFix = "";
 		for (int i = 0; i < prefixDotCount - 1; i++) {
 			preFix = preFix + ".." + File.separator;
 		}
 		dir = dir + File.separator + preFix;
-		String fullName = null;
-		if (originalName != null) {
-			String importedName = originalName.replace(".", File.separator);
-			fullName = includeFileLocator.uniqFileName(dir, importedName);
-			if (fullName == null) {
-				fullName = includeFileLocator.uniqFileName(dir, importedName + ".py");
+
+		/* compute importedName */
+		String importedName = "";
+		if (fromName!=null) {
+			importedName = fromName.replace(".", File.separator);
+		}
+
+		/* search importedName from all included paths */
+		String uniqFrom = includeFileLocator.uniqFileName(dir, importedName);
+		if (uniqFrom==null)
+			uniqFrom = includeFileLocator.uniqFileName(dir,importedName+".py");
+		if (uniqFrom==null){ //cannot find the path
+			return visitedFiles;
+		}
+		if (uniqFrom.endsWith(".py")){
+			return visitIncludedFile(uniqFrom);
+		}
+		if (moduleNames!=null && moduleNames.size()>0){
+			for (String moduleName:moduleNames){
+				String fileName = uniqFrom + File.separator + moduleName;
+				if (!FileUtil.existFile(fileName)){
+					fileName +=".py";
+				}else if (FileUtil.isDirectory(fileName)){
+					fileName += File.separator + PythonBuiltInType.PACKAGE_PY_NAME;
+				}
+
+				List<String> files = visitIncludedFile(fileName);
+				visitedFiles.addAll(files);
 			}
-		} else {
-			fullName = FileUtil.uniqFilePath(dir);
+		}else{
+			return visitIncludedFile(uniqFrom);
 		}
-		if (fullName != null) {
-			if (FileUtil.isDirectory(fullName)) {
-				if (!FileUtil.uniqFilePath(fullName).equals(FileUtil.uniqFilePath(dir))) {
-					File d = new File(fullName);
-					File[] files = d.listFiles();
-					for (File file : files) {
-						if (!file.isDirectory()) {
-							if (file.getAbsolutePath().endsWith(".py")) {
-								visitIncludedFile(FileUtil.uniqFilePath(file.getAbsolutePath()));
-							}
-						}
+		return visitedFiles;
+	}
+
+	private List<String> visitIncludedFile(String fullName) {
+		List<String> visitedFiles = new ArrayList<>();
+		if (FileUtil.isDirectory(fullName)){
+			File d = new File(fullName);
+			File[] files = d.listFiles();
+			for (File file : files) {
+				if (!file.isDirectory()) {
+					if (file.getAbsolutePath().endsWith(".py")) {
+						String fileName = FileUtil.uniqFilePath(file.getAbsolutePath());
+						visitIncludedFile(fileName);
+						visitedFiles.add(fileName);
 					}
 				}
-			} else {
-				visitIncludedFile(fullName);
 			}
+			if (FileUtil.existFile(fullName+File.separator + PythonBuiltInType.PACKAGE_PY_NAME)) {
+				visitedFiles.add( fullName+File.separator +PythonBuiltInType.PACKAGE_PY_NAME);
+			}
+		}else{
+			invokeParser(fullName);
+			visitedFiles.add(fullName);
 		}
-		ArrayList<String> r = new ArrayList<>();
-		if (fullName==null) return r;
-		r.add(fullName);
-		if (FileUtil.existFile(fullName+File.separator + PythonBuiltInType.PACKAGE_PY_NAME)) {
-			r.add( fullName+File.separator +PythonBuiltInType.PACKAGE_PY_NAME);
-		}
-		return r;
+		return visitedFiles;
 	}
 
-	private void visitIncludedFile(String fullName) {
+	private void invokeParser(String fileName){
 		PythonFileParser importedParser = new PythonFileParser(entityRepo, includeFileLocator, bindingResolver,
 				pythonProcessor);
 		try {
-			importedParser.parse(fullName);
+			importedParser.parse(fileName);
 		} catch (IOException e) {
 			e.printStackTrace();
 		}

c3874e4b7098fafb8759abe335fd166868d674fa
@@ -79,7 +79,7 @@ public class RelationCounter {
 			if (var.getType()!=null)
 				entity.addRelation(buildRelation(entity,DependencyType.CONTAIN,var.getType(),var.getLocation()));
 			for (Entity type:var.getResolvedTypeParameters()) {
-				var.addRelation(buildRelation(var, DependencyType.PARAMETER,type,type.getLocation()));
+				var.addRelation(buildRelation(var, DependencyType.PARAMETER,type));
 			}
 		}
 		for (Entity type:entity.getResolvedAnnotations()) {

